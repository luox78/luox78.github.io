<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>luox78</title>
  
  <subtitle>Daily Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luox78.github.io/"/>
  <updated>2018-01-02T13:30:10.817Z</updated>
  <id>https://luox78.github.io/</id>
  
  <author>
    <name>luox78</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步基础</title>
    <link href="https://luox78.github.io/2018/01/02/CS_Thread02/"/>
    <id>https://luox78.github.io/2018/01/02/CS_Thread02/</id>
    <published>2018-01-02T13:19:59.458Z</published>
    <updated>2018-01-02T13:30:10.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1同步概要"><a href="#1同步概要" class="headerlink" title="1同步概要"></a>1同步概要</h2><p>在<a href="https://blog.gkarch.com/threading/part1.html" target="_blank" rel="noopener">第 1 部分：基础知识</a>中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。</p><p>下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。</p><p>同步构造可以分为以下四类：</p><ul><li><p>简单的阻塞方法</p><p>这些方法会使当前线程等待另一个线程结束或是自己等待一段时间。<code>Sleep</code>、<code>Join</code>与<code>Task.Wait</code>都是简单的阻塞方法。</p></li><li><p>锁构造</p><p>锁构造能够限制每次可以执行某些动作或是执行某段代码的线程数量。排它锁构造是最常见的，它每次只允许一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。标准的排它锁构造是<a href="https://blog.gkarch.com/threading/part2.html#locking" target="_blank" rel="noopener"><code>lock</code></a>（<code>Monitor.Enter</code>/<code>Monitor.Exit</code>）、<a href="https://blog.gkarch.com/threading/part2.html#mutex" target="_blank" rel="noopener"><code>Mutex</code></a>与 <a href="https://blog.gkarch.com/threading/part5.html#spinlock-and-spinwait" target="_blank" rel="noopener"><code>SpinLock</code></a>。非排它锁构造是<a href="https://blog.gkarch.com/threading/part2.html#semaphore" target="_blank" rel="noopener"><code>Semaphore</code></a>、<a href="https://blog.gkarch.com/threading/part2.html#semaphore" target="_blank" rel="noopener"><code>SemaphoreSlim</code></a>以及<a href="https://blog.gkarch.com/threading/part4.html#reader-writer-locks" target="_blank" rel="noopener">读写锁</a>。</p></li><li><p>信号构造</p><p>信号构造可以使一个线程暂停，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：<a href="https://blog.gkarch.com/threading/part2.html#signaling-with-event-wait-handles" target="_blank" rel="noopener">事件等待句柄（event wait handle ）</a>和<code>Monitor</code>类的<a href="https://blog.gkarch.com/threading/part4.html#signaling-with-wait-and-pulse" target="_blank" rel="noopener"><code>Wait</code> / <code>Pluse</code></a>方法。Framework 4.0 加入了<a href="https://blog.gkarch.com/threading/part2.html#countdownevent" target="_blank" rel="noopener"><code>CountdownEvent</code></a>与<a href="https://blog.gkarch.com/threading/part4.html#the-barrier-class" target="_blank" rel="noopener"><code>Barrier</code></a>类。</p></li><li><p>非阻塞同步构造</p><p>非阻塞同步构造通过调用处理器指令来保护对公共字段的访问。CLR 与 C# 提供了下列非阻塞构造：<a href="https://blog.gkarch.com/threading/part4.html#memory-barriers-and-volatility" target="_blank" rel="noopener"><code>Thread.MemoryBarrier</code> 、<code>Thread.VolatileRead</code>、<code>Thread.VolatileWrite</code></a>、<a href="https://blog.gkarch.com/threading/part4.html#the-volatile-keyword" target="_blank" rel="noopener"><code>volatile</code></a>关键字以及<a href="https://blog.gkarch.com/threading/part4.html#interlocked" target="_blank" rel="noopener"><code>Interlocked</code></a>类。</p></li></ul><p>阻塞这个概念对于前三类来说都非常重要，接下来我们简要的剖析下它。</p><h3 id="1-1阻塞"><a href="#1-1阻塞" class="headerlink" title="1.1阻塞"></a>1.1阻塞</h3><p>当线程的执行由于某些原因被暂停，比如调用<code>Sleep</code>等待一段时间，或者通过<code>Join</code>或<code>EndInvoke</code>方法等待其它线程结束时，则认为此线程被阻塞（blocked）。被阻塞的线程会立即出让（yields）其处理器时间片，之后不再消耗处理器时间，直到阻塞条件被满足。可以通过线程的<a href="https://blog.gkarch.com/threading/part2.html#threadstate" target="_blank" rel="noopener"><code>ThreadState</code></a>属性来检查一个线程是否被阻塞：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span><span class="keyword">blocked </span>= (someThread.ThreadState &amp; ThreadState.<span class="keyword">WaitSleepJoin) </span>!= <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>（上面例子中线程状态可能在进行状态判断和依据状态进行操作之间发生改变，因此这段代码仅可用于调试诊断的场景。）</p><p>当一个线程被阻塞或是解除阻塞时，操作系统会进行上下文切换（context switch），这会带来几微秒的额外时间开销。</p><p>阻塞会在以下 4 种情况下解除（电源按钮可不能算<code>╮(╯▽╰)╭</code>）：</p><ul><li>阻塞条件被满足</li><li>操作超时（如果指定了超时时间）</li><li>通过<a href="https://blog.gkarch.com/threading/part3.html#interrupt" target="_blank" rel="noopener"><code>Thread.Interrupt</code></a>中断</li><li>通过<a href="https://blog.gkarch.com/threading/part3.html#abort" target="_blank" rel="noopener"><code>Thread.Abort</code></a>中止</li></ul><p>通过<a href="https://blog.gkarch.com/threading/part4.html#suspend-and-resume" target="_blank" rel="noopener"><code>Suspend</code></a>方法（已过时，不应该再使用）暂停线程的执行不被认为是阻塞。</p><h3 id="1-2阻塞-vs-自旋"><a href="#1-2阻塞-vs-自旋" class="headerlink" title="1.2阻塞 vs 自旋"></a>1.2阻塞 vs 自旋</h3><p>有时线程必须暂停，直到特定条件被满足。<a href="https://blog.gkarch.com/threading/part2.html#signaling-with-event-wait-handles" target="_blank" rel="noopener">信号构造</a>和<a href="https://blog.gkarch.com/threading/part2.html#locking" target="_blank" rel="noopener">锁构造</a>可以通过在条件被满足前<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>线程来实现。但是还有一种更为简单的方法：线程可以通过自旋（spinning）来等待条件被满足。例如：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(!proceed)</span>;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="keyword">while</span> <span class="comment">(DateTime.Now &lt; nextStartTime)</span>;</span><br></pre></td></tr></table></figure><p>一般来说，这会非常浪费处理器时间：因为对 CLR 和操作系统来说，这个线程正在执行重要的计算，就给它分配了相应的资源。</p><p>有时会组合使用阻塞与自旋：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(!proceed)</span> Thread.Sleep <span class="comment">(10)</span>;</span><br></pre></td></tr></table></figure><p>尽管并不优雅，但是这比仅使用自旋更高效（一般来说）。然而这样也可能会出现问题，这是由<code>proceed</code>标识上的并发问题引起的。正确的使用和<a href="https://blog.gkarch.com/threading/part2.html#locking" target="_blank" rel="noopener">锁构造</a>和<a href="https://blog.gkarch.com/threading/part2.html#signaling-with-event-wait-handles" target="_blank" rel="noopener">信号构造</a>可以避免这个问题。</p><p>自旋在等待的条件很快（大致几微秒）就能被满足的情况下更高效，因为它避免了上下文切换带来的额外开销。.NET Framework 提供了专门的方法和类型来辅助实现自旋，在<a href="https://blog.gkarch.com/threading/part5.html#spinlock-and-spinwait" target="_blank" rel="noopener">第 5 部分</a>会讲到。</p><h3 id="1-3线程状态"><a href="#1-3线程状态" class="headerlink" title="1.3线程状态"></a>1.3线程状态</h3><p>可以通过线程的<code>ThreadState</code>属性来查询线程状态，它会返回一个<code>ThreadState</code>类型的按位方式组合的枚举值，其中包含了三“层”信息。然而大多数值都是冗余的、无用的或者过时不建议使用的。下图是其中一“层”信息：</p><p><a href="https://blog.gkarch.com/img/threading/ThreadState.png" target="_blank" rel="noopener"><img src="https://blog.gkarch.com/img/threading/ThreadState.png" alt="ThreadState"></a></p><p>下面的代码可以提取线程状态中最有用的 4 个值: <code>Unstarted</code>、<code>Running</code>、<code>WaitSleepJoin</code>和<code>Stopped</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadState <span class="title">SimpleThreadState</span> <span class="params">(ThreadState ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ts &amp; (ThreadState.Unstarted |</span><br><span class="line">               ThreadState.WaitSleepJoin |</span><br><span class="line">               ThreadState.Stopped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadState</code>属性在进行调试诊断时有用，但不适合用来进行同步，因为线程状态可能在判断状态和依据状态进行操作之间发生改变。</p><h2 id="2锁"><a href="#2锁" class="headerlink" title="2锁"></a>2锁</h2><p>排它锁用于确保同一时间只允许一个线程执行指定的代码段。主要的两个排它锁构造是<code>lock</code>和<code>Mutex</code>（互斥体）。其中<code>lock</code>更快，使用也更方便。而<code>Mutex</code>的优势是它可以跨进程的使用。</p><p>在这一节里，我们从介绍<code>lock</code>构造开始，然后介绍<a href="https://blog.gkarch.com/threading/part2.html#mutex" target="_blank" rel="noopener"><code>Mutex</code></a>和<a href="https://blog.gkarch.com/threading/part2.html#semaphore" target="_blank" rel="noopener">信号量（semaphore）</a>（用于非排它场景）。稍后在第 4 部分会介绍<a href="https://blog.gkarch.com/threading/part4.html#reader-writer-locks" target="_blank" rel="noopener">读写锁（reader / writer lock）</a>。</p><p>Framework 4.0 加入了<a href="https://blog.gkarch.com/threading/part5.html#spinlock-and-spinwait" target="_blank" rel="noopener"><code>SpinLock</code></a>结构体，可以用于高并发场景。</p><p>让我们从下边这个类开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafe</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _val1 = <span class="number">1</span>, _val2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_val2 != <span class="number">0</span>) Console.WriteLine (_val1 / _val2);</span><br><span class="line">    _val2 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类不是线程安全的：如果<code>Go</code>方法同时被两个线程调用，可能会产生除数为零错误，因为可能在一个线程刚好执行完<code>if</code>的判断语句但还没执行<code>Console.WriteLine</code>语句时，<code>_val2</code>就被另一个线程设置为零。</p><p>下边使用<code>lock</code>解决这个问题：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _val1, _val2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_locker)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_val2 != <span class="number">0</span>) Console.WriteLine (_val1 / _val2);</span><br><span class="line">      _val2 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一时间只有一个线程可以锁定同步对象（这里指<code>_locker</code>），并且其它竞争锁的线程会被<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>，直到锁被释放。如果有多个线程在竞争锁，它们会在一个“就绪队列（ready queue）”中排队，并且遵循先到先得的规则（需要说明的是，Windows 系统和 CLR 的差别可能导致这个队列在有时会不遵循这个规则）。因为一个线程的访问不能与另一个线程相重叠，排它锁有时也被这样描述：它强制对锁保护的内容进行顺序（serialized）访问。在这个例子中，我们保护的是<code>Go</code>方法的内部逻辑，还有<code>_val1</code>与<code>_val2</code>字段。</p><p>在竞争锁时被阻塞的线程，它的<a href="https://blog.gkarch.com/threading/part2.html#threadstate" target="_blank" rel="noopener">线程状态</a>是<code>WaitSleepJoin</code>。在<a href="https://blog.gkarch.com/threading/part3.html#interrupt-and-abort" target="_blank" rel="noopener">中断与中止</a>中，我们会描述如何通过其它线程强制释放被阻塞的线程，这是一种可以用于结束线程的重型技术（译者注：这里指它们应该被作为在没有其它更为优雅的办法时的最后手段）。</p><h4 id="锁构造比较"><a href="#锁构造比较" class="headerlink" title="锁构造比较"></a>锁构造比较</h4><table><thead><tr><th>构造</th><th>用途</th><th>跨进程</th><th>开销*</th></tr></thead><tbody><tr><td><a href="https://blog.gkarch.com/threading/part2.html#locking" target="_blank" rel="noopener">lock</a>（<code>Monitor.Enter</code>/<code>Monitor.Exit</code>）</td><td>确保同一时间只有一个线程可以访问资源或代码</td><td>-</td><td>20ns</td></tr><tr><td><a href="https://blog.gkarch.com/threading/part2.html#mutex" target="_blank" rel="noopener">Mutex</a></td><td>**</td><td>1000ns</td><td></td></tr><tr><td><a href="https://blog.gkarch.com/threading/part2.html#semaphore" target="_blank" rel="noopener">SemaphoreSlim</a>（Framework 4.0 中加入）</td><td>确保只有不超过指定数量的线程可以并发访问资源或代码</td><td>-</td><td>200ns</td></tr><tr><td><a href="https://blog.gkarch.com/threading/part2.html#semaphore" target="_blank" rel="noopener">Semaphore</a></td><td>**</td><td>1000ns</td><td></td></tr><tr><td><a href="https://blog.gkarch.com/threading/part4.html#reader-writer-locks" target="_blank" rel="noopener">ReaderWriterLockSlim</a>（Framework 3.5 中加入）</td><td>允许多个读线程和一个写线程共存</td><td>-</td><td>40ns</td></tr><tr><td><a href="https://blog.gkarch.com/threading/part4.html#reader-writer-locks" target="_blank" rel="noopener">ReaderWriterLock</a>（已过时）</td><td>-</td><td>100ns</td></tr></tbody></table><p>* 时间代表在同一线程上一次进行加锁和释放锁（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。</p><h3 id="2-1Monitor-Enter-与-Monitor-Exit"><a href="#2-1Monitor-Enter-与-Monitor-Exit" class="headerlink" title="2.1Monitor.Enter 与 Monitor.Exit"></a>2.1Monitor.Enter 与 Monitor.Exit</h3><p>C# 的<code>lock</code>语句是一个语法糖，它其实就是使用了<code>try / finally</code>来调用<code>Monitor.Enter</code>与<code>Monitor.Exit</code>方法。下面是在之前示例中的<code>Go</code>方法内部所发生的事情（简化的版本）：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Monitor.Enter (<span class="variable">_locker</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_val2</span> != <span class="number">0</span>) Console.WriteLine (<span class="variable">_val1</span> / <span class="variable">_val2</span>);</span><br><span class="line">  <span class="variable">_val2</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">finally &#123; Monitor.<span class="keyword">Exit</span> (<span class="variable">_locker</span>); &#125;</span><br></pre></td></tr></table></figure><p>如果在同一个对象上没有先调用<code>Monitor.Enter</code>就调用<code>Monitor.Exit</code>会抛出一个异常。</p><h4 id="lockTaken-重载"><a href="#lockTaken-重载" class="headerlink" title="lockTaken 重载"></a>lockTaken 重载</h4><p>刚刚所描述的就是 C# 1.0、2.0 和 3.0 的编译器翻译<code>lock</code>语句产生的代码。</p><p>然而它有一个潜在的缺陷。考虑这样的情况：在<code>Monitor.Enter</code>的实现内部或者在<code>Monitor.Enter</code>与<code>try</code>中间有异常被抛出（可能是因为在线程上调用了<a href="https://blog.gkarch.com/threading/part3.html#abort" target="_blank" rel="noopener"><code>Abort</code></a>，或者有<code>OutOfMemoryException</code>异常被抛出），这时不一定能够获得锁。如果获得了锁，那么该锁就不会被释放，因为不可能执行到<code>try / finally</code>内，这会导致锁泄漏。</p><p>为了避免这种危险，CLR 4.0 的设计者为<code>Monitor.Enter</code>添加了下面的重载：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Enter</span> (<span class="params"><span class="keyword">object</span> obj, <span class="keyword">ref</span> <span class="keyword">bool</span> lockTaken</span>)</span>;</span><br></pre></td></tr></table></figure><p>当（且仅当）<code>Enter</code>方法抛出异常，锁没有能够获得时，<code>lockTaken</code>为<code>false</code>。</p><p>下边是正确的使用方式（这就是 C# 4.0 对于<code>lock</code>语句的翻译）：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  Monitor.Enter (_locker, <span class="keyword">ref</span> lockTaken);</span><br><span class="line">  <span class="comment">// 你的代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; <span class="keyword">if</span> (lockTaken) Monitor.Exit (_locker); &#125;</span><br></pre></td></tr></table></figure><h4 id="TryEnter"><a href="#TryEnter" class="headerlink" title="TryEnter"></a>TryEnter</h4><p><code>Monitor</code>还提供了一个<code>TryEnter</code>方法，允许以毫秒或是<code>TimeSpan</code>方式指定超时时间。如果获得了锁，该方法会返回<code>true</code>，而如果由于超时没有获得锁，则会返回<code>false</code>。<code>TryEnter</code>也可以以无参数的形式进行调用，这是对锁进行“测试”，如果不能立即获得锁就会立即返回<code>false</code>。</p><p>类似于<code>Enter</code>方法，该方法在 CLR 4.0 中也被重载来接受<code>lockTaken</code>参数。</p><h3 id="2-2选择同步对象"><a href="#2-2选择同步对象" class="headerlink" title="2.2选择同步对象"></a>2.2选择同步对象</h3><p>对所有参与同步的线程可见的任何对象都可以被当作同步对象使用，但有一个硬性规定：同步对象必须为引用类型。同步对象一般是私有的（因为这有助于封装锁逻辑），并且一般是一个实例或静态字段。同步对象也可以就是其要保护的对象，如下面例子中的<code>_list</code>字段：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span><br><span class="line">&#123;</span><br><span class="line">  List &lt;<span class="keyword">string</span>&gt; _list = <span class="keyword">new</span> List &lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_list)</span><br><span class="line">    &#123;</span><br><span class="line">      _list.Add (<span class="string">"Item 1"</span>);</span><br><span class="line">      <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>一个只被用来加锁的字段（例如前面例子中的<code>_locker</code>）可以精确控制锁的作用域与粒度。对象自己（<code>this</code>），甚至是其类型都可以被当作同步对象来使用：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> (<span class="keyword">this</span>) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="keyword">lock</span> (<span class="keyword">typeof</span> (Widget)) &#123; ... &#125;    <span class="comment">// 保护对静态资源的访问</span></span><br></pre></td></tr></table></figure><p>这种方式的缺点在于并没有对锁逻辑进行封装，从而很难避免<a href="https://blog.gkarch.com/threading/part2.html#deadlocks" target="_blank" rel="noopener">死锁</a>与过多的<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>。同时类型上的锁也可能会跨越应用程序域（application domain）边界（在同一进程内）。</p><p>你也可以在被 lambda 表达式或匿名方法所捕获的局部变量上加锁。</p><p>锁在任何情况下都不会限制对同步对象本身的访问。换句话说，<code>x.ToString()</code>不会因为其它线程调用<code>lock(x)</code>而阻塞，两个线程都要调用<code>lock(x)</code>才能使阻塞发生。</p><h3 id="2-3何时加锁"><a href="#2-3何时加锁" class="headerlink" title="2.3何时加锁"></a>2.3何时加锁</h3><p>简单的原则是，需要在访问任意可写的共享字段（any writable shared field）时加锁。即使是最简单的操作，例如对一个字段的赋值操作，都必须考虑同步。在下面的类中，<code>Increment</code>与<code>Assign</code>方法都不是线程安全的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafe</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _x;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Increment</span><span class="params">()</span> </span>&#123; _x++; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Assign</span><span class="params">()</span>    </span>&#123; _x = <span class="number">123</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是线程安全的版本：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _x;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Increment</span>(<span class="params"></span>) </span>&#123; <span class="keyword">lock</span> (_locker) _x++; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Assign</span>(<span class="params"></span>)    </span>&#123; <span class="keyword">lock</span> (_locker) _x = <span class="number">123</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://blog.gkarch.com/threading/part4.html#nonblocking-synchronization" target="_blank" rel="noopener">非阻塞同步（nonblocking synchronization）</a>中，我们会解释这种需求是如何产生的，以及在这些场景下内存屏障（memory barrier，内存栅栏，内存栅障）和<a href="https://blog.gkarch.com/threading/part4.html#interlocked" target="_blank" rel="noopener"><code>Interlocked</code></a>类如何提供替代方法进行锁定。</p><h3 id="2-4锁与原子性"><a href="#2-4锁与原子性" class="headerlink" title="2.4锁与原子性"></a>2.4锁与原子性</h3><p>如果一组变量总是在相同的锁内进行读写，就可以称为原子的（atomically）读写。假定字段<code>x</code>与<code>y</code>总是在对<code>locker</code>对象的<code>lock</code>内进行读取与赋值：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock <span class="comment">(locker)</span> &#123; <span class="keyword">if</span> <span class="comment">(x != 0)</span> y /= x; &#125;</span><br></pre></td></tr></table></figure><p>可以说<code>x</code>和<code>y</code>是被原子的访问的，因为上面的代码块无法被其它的线程分割或抢占。如果被其它线程分割或抢占，<code>x</code>和<code>y</code>就可能被别的线程修改导致计算结果无效。而现在 <code>x</code>和<code>y</code>总是在相同的排它锁中进行访问，因此不会出现除数为零的错误。</p><p>在<code>lock</code>锁内抛出异常将打破锁的原子性，考虑如下代码：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">decimal <span class="variable">_savingsBalance</span>, <span class="variable">_checkBalance</span>;</span><br><span class="line"></span><br><span class="line">void Transfer (decimal amount)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">lock</span> (<span class="variable">_locker</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="variable">_savingsBalance</span> += amount;</span><br><span class="line">    <span class="variable">_checkBalance</span> -= amount + GetBankFee();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>GetBankFee()</code>方法内抛出异常，银行可能就要损失钱财了。在这个例子中，我们可以通过更早的调用<code>GetBankFee()</code>来避免这个问题。对于更复杂情况，解决方案是在<code>catch</code>或<code>finally</code>中实现“回滚（rollback）”逻辑。</p><p>指令原子性是一个相似但不同的概念： 如果一条指令可以在 CPU 上不可分割地执行，那么它就是原子的。（见<a href="https://blog.gkarch.com/threading/part4.html#nonblocking-synchronization" target="_blank" rel="noopener">非阻塞同步</a>）</p><h3 id="2-5嵌套锁"><a href="#2-5嵌套锁" class="headerlink" title="2.5嵌套锁"></a>2.5嵌套锁</h3><p>线程可以用嵌套（重入）的方式重对相同的对象进行加锁：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> (locker)</span><br><span class="line">  <span class="keyword">lock</span> (locker)</span><br><span class="line">    <span class="keyword">lock</span> (locker)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Monitor</span>.<span class="keyword">Enter</span> (locker); <span class="keyword">Monitor</span>.<span class="keyword">Enter</span> (locker);  <span class="keyword">Monitor</span>.<span class="keyword">Enter</span> (locker);</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">Monitor</span>.<span class="keyword">Exit</span> (locker);  <span class="keyword">Monitor</span>.<span class="keyword">Exit</span> (locker);   <span class="keyword">Monitor</span>.<span class="keyword">Exit</span> (locker);</span><br></pre></td></tr></table></figure><p>在这样的场景中，只有当最外层的<code>lock</code>语句退出或是执行了匹配数目的<code>Monitor.Exit</code>语句时，对象才会被解锁。</p><p>嵌套锁可以用于在锁中调用另一个方法（也使用了同一对象来锁定）：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">lock</span> (_locker)</span><br><span class="line">  &#123;</span><br><span class="line">     AnotherMethod();</span><br><span class="line">     <span class="comment">//  这里依然拥有锁，因为锁是可重入的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AnotherMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">lock</span> (_locker) &#123; Console.WriteLine (<span class="string">"Another method"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程只会在第一个（最外层）<code>lock</code>处<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>。</p><h3 id="2-6死锁"><a href="#2-6死锁" class="headerlink" title="2.6死锁"></a>2.6死锁</h3><p>当两个线程等待的资源都被对方占用时，它们都无法执行，这就产生了死锁。演示死锁最简单的方法就是使用两个锁：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> locker1 = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"><span class="keyword">object</span> locker2 = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread (() =&gt; &#123;</span><br><span class="line">                    <span class="keyword">lock</span> (locker1)</span><br><span class="line">                    &#123;</span><br><span class="line">                      Thread.Sleep (<span class="number">1000</span>);</span><br><span class="line">                      <span class="keyword">lock</span> (locker2);      <span class="comment">// 死锁</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;).Start();</span><br><span class="line"><span class="keyword">lock</span> (locker2)</span><br><span class="line">&#123;</span><br><span class="line">  Thread.Sleep (<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">lock</span> (locker1);                          <span class="comment">// 死锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更复杂的死锁链可能由三个或更多的线程创建。</p><p>在标准环境下，CLR 不会像<code>SQL Server</code>一样自动检测和解决死锁。除非你指定了锁定的超时时间，否则死锁会造成参与的线程无限<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>。（在SQL CLR 集成宿主环境中，死锁能够被自动检测，并在其中一个线程上抛出可捕获的异常。）</p><p>死锁是多线程中最难解决的问题之一，尤其是在有很多关联对象的时候。这个困难在根本上在于无法确定调用方（caller）已经拥有了哪些锁。</p><p>你可能会锁定类<code>x</code>中的私有字段<code>a</code>，而并不知道调用方（或者调用方的调用方）已经锁住了类<code>y</code>中的字段<code>b</code>。同时，另一个线程正在执行顺序相反的操作，这样就创建了死锁。讽刺的是，这个问题会由于（良好的）面向对象的设计模式而加剧，因为这类模式建立的调用链直到运行时才能确定。</p><p>流行的建议：“以一致的顺序对对象加锁以避免死锁”，尽管它对于我们最初的例子有帮助，但是很难应用到刚才所描述的场景。更好的策略是：如果发现在锁区域中的对其它类的方法调用最终会引用回当前对象，就应该小心，同时考虑是否真的需要对其它类的方法调用加锁（往往是需要的，但是有时也会有其它选择）。更多的依靠<a href="https://blog.gkarch.com/threading/part5.html#plinq" target="_blank" rel="noopener">声明方式（declarative）</a>与<a href="https://blog.gkarch.com/threading/part5.html#the-parallel-class" target="_blank" rel="noopener">数据并行（data parallelism）</a>、<a href="https://blog.gkarch.com/threading/part2.html#immutable-objects" target="_blank" rel="noopener">不可变类型（immutable types）</a>与<a href="https://blog.gkarch.com/threading/part4.html#nonblocking-synchronization" target="_blank" rel="noopener">非阻塞同步构造（ nonblocking synchronization constructs）</a>，可以减少对锁的需要。</p><p>有另一种思路来帮助理解这个问题：当你在拥有锁的情况下访问其它类的代码，对于锁的封装就存在潜在的泄露。这不是 CLR 或 .NET Framework 的问题，而是因为锁本身的局限性。锁的问题在许多研究项目中被分析，包括软件事务内存（Software Transactional Memory）。</p><p>另一个死锁的场景是：如果已拥有一个锁，在调用<code>Dispatcher.Invoke</code>（在 WPF 程序中）或是<code>Control.Invoke</code>（在 Windows Forms 程序中）时，如果 UI 恰好要运行等待同一个锁的另一个方法，就会在这里发生死锁。这通常可以通过调用<code>BeginInvoke</code>而不是<code>Invoke</code>来简单的修复。或者，可以在调用<code>Invoke</code>之前释放锁，但是如果是调用方获得的锁，那么这种方法可能并不会起作用。我们在<a href="https://blog.gkarch.com/threading/part2.html#rich-client-applications-and-thread-affinity" target="_blank" rel="noopener">富客户端应用与线程亲和</a>中来解释<code>Invoke</code>和<code>BeginInvoke</code>。</p><h3 id="2-7性能"><a href="#2-7性能" class="headerlink" title="2.7性能"></a>2.7性能</h3><p>锁是非常快的，在一个 2010 时代的计算机上，没有竞争的情况下获取并释放锁一般只需 20 纳秒。如果存在竞争，产生的上下文切换会把开销增加到微秒的级别，并且线程被重新调度前可能还会等待更久的时间。如果需要锁定的时间很短，那么可以使用<a href="https://blog.gkarch.com/threading/part5.html#spinlock-and-spinwait" target="_blank" rel="noopener">自旋锁（<code>SpinLock</code>）</a>来避免上下文切换的开销。</p><p>如果获取锁后保持的时间太长而不释放，就会降低并发度，同时也会加大<a href="https://blog.gkarch.com/threading/part2.html#deadlocks" target="_blank" rel="noopener">死锁</a>的风险。</p><h3 id="2-8互斥体（Mutex）"><a href="#2-8互斥体（Mutex）" class="headerlink" title="2.8互斥体（Mutex）"></a>2.8互斥体（Mutex）</h3><p>互斥体类似于 C# 的<code>lock</code>，不同在于它是可以跨越多个进程工作。换句话说，<code>Mutex</code>可以是机器范围（computer-wide）的，也可以是程序范围（application-wide）的。</p><p>没有竞争的情况下，获取并释放<code>Mutex</code>需要几微秒的时间，大约比<code>lock</code>慢 50 倍。</p><p>使用<code>Mutex</code>类时，可以调用<code>WaitOne</code>方法来加锁，调用<code>ReleaseMutex</code>方法来解锁。关闭或销毁<code>Mutex</code>会自动释放锁。与<code>lock</code>语句一样，<code>Mutex</code>只能被获得该锁的线程释放。</p><p>跨进程<code>Mutex</code>的一种常见的应用就是确保只运行一个程序实例。下面演示了这是如何实现的：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">OneAtATimePlease</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// 命名的 Mutex 是机器范围的，它的名称需要是唯一的</span></span><br><span class="line">    <span class="comment">// 比如使用公司名+程序名，或者也可以用 URL</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> mutex = <span class="keyword">new</span> Mutex (<span class="literal">false</span>, <span class="string">"oreilly.com OneAtATimeDemo"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 可能其它程序实例正在关闭，所以可以等待几秒来让其它实例完成关闭</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!mutex.WaitOne (TimeSpan.FromSeconds (<span class="number">3</span>), <span class="literal">false</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        Console.WriteLine (<span class="string">"Another app instance is running. Bye!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      RunProgram();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunProgram</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">"Running. Press Enter to exit"</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在终端服务（Terminal Services）下运行，机器范围的<code>Mutex</code>默认仅对于运行在相同终端服务器会话的应用程序可见。要使其对所有终端服务器会话可见，需要在其名字前加上<code>Global\</code>。</p><h3 id="2-9信号量（Semaphore）"><a href="#2-9信号量（Semaphore）" class="headerlink" title="2.9信号量（Semaphore）"></a>2.9信号量（Semaphore）</h3><p>信号量类似于一个夜总会：它具有一定的容量，并且有保安把守。一旦满员，就不允许其他人进入，这些人将在外面排队。当有一个人离开时，排在最前头的人便可以进入。这种构造最少需要两个参数：夜总会中当前的空位数以及夜总会的总容量。</p><p>容量为 1 的信号量与<code>Mutex</code>和<code>lock</code>类似，所不同的是信号量没有“所有者”，它是线程无关（thread-agnostic）的。任何线程都可以在调用<code>Semaphore</code>上的<code>Release</code>方法，而对于<code>Mutex</code>和<code>lock</code>，只有获得锁的线程才可以释放。</p><p><code>SemaphoreSlim</code>是 Framework 4.0 加入的轻量级的信号量，功能与<code>Semaphore</code>相似，不同之处是它对于<a href="https://blog.gkarch.com/threading/part5.html" target="_blank" rel="noopener">并行编程</a>的低延迟需求做了优化。在传统的多线程方式中也有用，因为它支持在等待时指定<a href="https://blog.gkarch.com/threading/part3.html#cancellation-tokens" target="_blank" rel="noopener">取消标记 （cancellation token）</a>。但它不能跨进程使用。</p><p>在<code>Semaphore</code>上调用<code>WaitOne</code>或<code>Release</code>会产生大概 1 微秒的开销，而<code>SemaphoreSlim</code>产生的开销约是其四分之一。</p><p>信号量在有限并发的需求中有用，它可以阻止过多的线程同时执行特定的代码段。在下面的例子中，五个线程尝试进入一个只允许三个线程进入的夜总会：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TheClub</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> SemaphoreSlim _sem = <span class="keyword">new</span> SemaphoreSlim (<span class="number">3</span>);    <span class="comment">// 容量为 3</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="keyword">new</span> Thread (Enter).Start (i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Enter</span> (<span class="params"><span class="keyword">object</span> id</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.WriteLine (id + <span class="string">" wants to enter"</span>);</span><br><span class="line">    _sem.Wait();</span><br><span class="line">    Console.WriteLine (id + <span class="string">" is in!"</span>);           <span class="comment">// 同时只能有</span></span><br><span class="line">    Thread.Sleep (<span class="number">1000</span> * (<span class="keyword">int</span>) id);               <span class="comment">// 3个线程</span></span><br><span class="line">    Console.WriteLine (id + <span class="string">" is leaving"</span>);       <span class="comment">// 执行这里</span></span><br><span class="line">    _sem.Release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>wants <span class="keyword">to</span> enter</span><br><span class="line"><span class="symbol">1 </span>is in!</span><br><span class="line"><span class="symbol">2 </span>wants <span class="keyword">to</span> enter</span><br><span class="line"><span class="symbol">2 </span>is in!</span><br><span class="line"><span class="symbol">3 </span>wants <span class="keyword">to</span> enter</span><br><span class="line"><span class="symbol">3 </span>is in!</span><br><span class="line"><span class="symbol">4 </span>wants <span class="keyword">to</span> enter</span><br><span class="line"><span class="symbol">5 </span>wants <span class="keyword">to</span> enter</span><br><span class="line"><span class="symbol">1 </span>is leaving</span><br><span class="line"><span class="symbol">4 </span>is in!</span><br><span class="line"><span class="symbol">2 </span>is leaving</span><br><span class="line"><span class="symbol">5 </span>is in!</span><br></pre></td></tr></table></figure><p>如果<code>Sleep</code>语句被替换为密集的磁盘 I/O 操作，由于<code>Semaphore</code>限制了过多的并发硬盘活动，就可能改善整体性能。</p><p>类似于<code>Mutex</code>，命名的<code>Semaphore</code>也可以跨进程使用。</p><h2 id="3线程安全"><a href="#3线程安全" class="headerlink" title="3线程安全"></a>3线程安全</h2><p>说一个程序或方法是线程安全（ thread-safe）的，是指它在任意的多线程场景中都不存在不确定性。线程安全主要是通过锁以及减少线程交互来实现。</p><p>一般的类型很少有完全线程安全的，原因如下：</p><ul><li>完全线程安全的开发负担很重，特别是如果一个类型有很多字段的情况（在任意多线程并发的情况下每个字段都有交互的潜在可能）。</li><li>线程安全可能会损失性能（某种程度上，无论类型是否实际被用于多线程都会增加损耗）。</li><li>线程安全的类型并不能确保使用该类型的程序也是线程安全的，为了实现程序线程安全所涉及的工作经常会使得类型线程安全成为多余。</li></ul><p>因此线程安全通常只会在需要时再实现，只为了处理特定的多线程场景。</p><p>然而，有些方法可以用来“作弊” ，使庞大和复杂的类在多线程环境中安全运行。一种方法是牺牲粒度，将大段代码甚至是访问的整个对象封装在一个<a href="https://blog.gkarch.com/threading/part2.html#locking" target="_blank" rel="noopener">排它锁</a>内，从而保证在高层上能进行顺序访问。事实上，如果我们希望在多线程环境中使用线程不安全的第三方代码（或大多数 Framework 的类型）时，这种策略是十分有用的。它仅仅是简单的使用了相同的排它锁，来保护对非线程安全对象上所有属性、方法和字段的访问。这种解决方案适用于对象的方法都能够快速执行的场景（否则会导致大量的<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>）。</p><p>除基本类型外，很少有 .NET Framework 的类型能在比并发读取更高的需求下保证其实例成员是线程安全的。实现线程安全的责任就落在了开发人员身上，一般就是使用排它锁。（命名空间<code>System.Collections.Concurrent</code>中的类型是个例外，它们是线程安全的数据结构。）</p><p>另一种“作弊”的方法是通过最小化共享数据来减少线程交互。这是一种优秀的方法，隐式的用于“ 无状态（stateless）”的中间层程序和网页服务器中。由于多个客户端请求可以同时到达，服务端方法就必须是线程安全的。无状态设计（因可伸缩性（scalability）好而流行）在本质上限制了交互的可能性，因为类并不需要持久化请求之间的数据。线程交互仅限于静态字段，比如在内存中缓存通用数据，或者提供认证和审计这样的基础服务时需要考虑。</p><p>实现线程安全的最后一种方式是使用<a href="https://blog.gkarch.com/threading/part2.html#synchronization-contexts" target="_blank" rel="noopener">自动锁机制（automatic locking regime）</a>。如果<a href="https://blog.gkarch.com/threading/part2.html#synchronization-contexts" target="_blank" rel="noopener">继承 <code>ContextBoundObject</code> 类并使用 <code>Synchronization</code> 特性</a>，.NET Framework 就可以实现这种机制。当该对象上的方法或属性被调用时，一个对象范围（object-wide）的锁就会自动作用于整个方法或属性的调用。尽管这样降低了实现线程安全的负担，但是也有它的问题：它很可能造成<a href="https://blog.gkarch.com/threading/part2.html#deadlocks" target="_blank" rel="noopener">死锁</a>、降低并发度并引起并非有意的重入。正是由于这些原因，手动加锁通常是更好的选择（直到有更好用的自动锁机制出现）。</p><h3 id="3-1线程安全与-NET-Framework-类型"><a href="#3-1线程安全与-NET-Framework-类型" class="headerlink" title="3.1线程安全与 .NET Framework 类型"></a>3.1线程安全与 .NET Framework 类型</h3><p>锁可以用来将线程不安全的代码转换为线程安全的代码。.NET Framework 就是一个好例子：几乎所有的非基本类型的实例成员都不是线程安全的（对于比只读访问更高的需求），然而如果对指定对象的所有访问都通过<a href="https://blog.gkarch.com/threading/part2.html#locking" target="_blank" rel="noopener">锁</a>进行保护，它们就可以被用于多线程代码中。例如，两个线程同时向同一个<code>List</code>中添加对象，然后枚举它：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> List &lt;<span class="keyword">string</span>&gt; _list = <span class="keyword">new</span> List &lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (AddItem).Start();</span><br><span class="line">    <span class="keyword">new</span> Thread (AddItem).Start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddItem</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_list) _list.Add (<span class="string">"Item "</span> + _list.Count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span>[] items;</span><br><span class="line">    <span class="keyword">lock</span> (_list) items = _list.ToArray();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">string</span> s <span class="keyword">in</span> items) Console.WriteLine (s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>_list</code>对象本身来加锁。如果有两个关联的<code>List</code>，就需要选择一个公共对象来加锁（可以使用其中一个<code>List</code>对象，然而更好的方式是使用一个独立的字段）。</p><p>枚举 .NET 的集合也不是线程安全的，因为如果在枚举的过程中集合被修改则会抛出异常。在这个例子中，我们并没有将整个枚举过程加锁，而是首先将其中的对象复制到一个数组中。如果我们要进行的枚举可能很耗时，那么可以通过上述方式避免过长时间锁定。（另一种解决方案是使用<a href="https://blog.gkarch.com/threading/part4.html#reader-writer-locks" target="_blank" rel="noopener">读写锁（reader / writer lock）</a>）</p><h4 id="对线程安全的对象加锁"><a href="#对线程安全的对象加锁" class="headerlink" title="对线程安全的对象加锁"></a>对线程安全的对象加锁</h4><p>有时也需要对线程安全的对象加锁，为了举例说明，假设 Framework 的<code>List</code>类是线程安全的，我们要给它添加一个条目：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_list.Contains (<span class="keyword">new</span><span class="type">Item</span>)) _list.Add (<span class="keyword">new</span><span class="type">Item</span>);</span><br></pre></td></tr></table></figure><p>无论<code>List</code>本身是否线程安全，上面的语句都不是线程安全的！为了防止<code>if</code>条件判断执行后，在实际添加条目之前，被其它线程抢占修改了<code>_list</code>，整个<code>if</code>所包含的代码都需要封装在一个锁中。并且在所有要修改<code>_list</code>的地方都要使用这个锁。例如，下面的语句也需要封装在相同的锁中：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_list.Clear()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这也是为了确保了它不会在前面语句的执行过程中抢先执行。换句话说，我们不得不像对于非线程安全的集合一样锁定线程安全的集合（这使得对于<code>List</code>类是线程安全的假设变得多余）。</p><p>在高并发的环境下，对集合的访问加锁可能会产生大量<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>，为此 Framework 4.0 提供了<a href="https://blog.gkarch.com/threading/part5.html#concurrent-collections" target="_blank" rel="noopener">线程安全的队列、栈和字典</a>。</p><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>将对对象的访问封装在一个自定义锁中的方式，只有当所有参与并发的线程都知道并使用这个锁时才能起作用。然而如果需要加锁的逻辑有更大范围那就不是这么简单了。最糟糕的情况就是<code>public</code>类型中的静态成员。比如，我们假设<code>DateTime</code>结构体上的静态属性<code>DateTime.Now</code>不是线程安全的，即两个并发线程调用会导致错误的输出或是异常。使用外部加锁进行修正的唯一方法就是在调用<code>DateTime.Now</code>之前对类型本身加锁：<code>lock(typeof(DateTime))</code>。这仅适用于所有的程序员都接受这样做（这不太可能）。此外，对类型加锁也有其自身的问题。</p><p>因此，<code>DateTime</code>结构体的静态成员都经过细致的处理，来保证它是线程安全的。这在 .NET Framework 中是一个通用模式：静态成员是线程安全的，而实例成员则不是。编写类型让别人使用时，遵守这种模式就不会令别人感到困惑和遇到难以解决的线程安全问题。换句话说，保证静态成员的线程安全，就不会妨碍你的类型的使用者实现线程安全。</p><p>静态方法的线程安全是必须由明确的编码实现的，不是说把方法写成静态的就能自动实现线程安全！</p><h4 id="只读线程安全"><a href="#只读线程安全" class="headerlink" title="只读线程安全"></a>只读线程安全</h4><p>使类型对于并发只读访问是线程安全的会很有益，这意味着使用者可以避免使用排它锁。许多 .NET Framework 类型都遵循这一原则：例如集合对于并发读是线程安全的。</p><p>自己遵循这一愿则也很简单：如果我们希望一个类型对于并发只读访问是线程安全的，那么不要在使用者期望是只读的方法内修改字段（也不要加锁后修改）。例如，在集合的<code>ToArray()</code>方法的实现中，也许会从压紧（compacting）集合的内部结构开始。然而，这会导致使用者认为是只读的操作并非线程安全。</p><p>只读线程安全也是枚举器与可枚举类型分离的原因之一：两个线程可以在一个集合上同时进行枚举，因为它们会分别获得单独的枚举器。</p><p>如果缺乏文档，在认为一个方法是只读前一定要谨慎。一个很好的例子是<code>Random</code>类：当调用<code>Random.Next()</code>时，它会更新私有的种子（seed）值。因此，或者对<code>Random</code>类的使用加锁，或者每个线程使用单独的实例。</p><h3 id="3-2应用服务器中的线程安全"><a href="#3-2应用服务器中的线程安全" class="headerlink" title="3.2应用服务器中的线程安全"></a>3.2应用服务器中的线程安全</h3><p>应用服务器需要使用多线程来处理多个客户端的同时请求。WCF、ASP.NET 以及 Web Services 应用都是隐式多线程的。使用 TCP 或 HTTP 之类网络通道的远程（Remoting）服务应用程序也是如此。这意味着服务端编程必须考虑线程安全，考虑在处理客户端请求的线程间是否存在交互的可能。幸运的是，这种交互的可能性不大，一般服务端类要不然是无状态的（无字段），要不然就有为每个客户端或每个请求创建单独对象实例的激活模型。交互通常仅在静态字段上出现，有时是用于在内存中缓存数据库数据来提高性能。</p><p>例如，有一个查询数据库的<code>RetrieveUser</code>方法：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">User</span> <span class="title">是一个自定义类型，包含用户数据的字段</span></span><br><span class="line"><span class="title">internal</span> <span class="keyword">User</span> <span class="title">RetrieveUser</span> (int id) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>如果对这个方法的调用很频繁，可以通过在一个静态<code>Dictionary</code>中缓存查询结果来提高性能。下边是一个考虑了线程安全的方案：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UserCache</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> Dictionary &lt;<span class="keyword">int</span>, User&gt; _users = <span class="keyword">new</span> Dictionary &lt;<span class="keyword">int</span>, User&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> User <span class="title">GetUser</span> (<span class="params"><span class="keyword">int</span> id</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    User u = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lock</span> (_users)</span><br><span class="line">      <span class="keyword">if</span> (_users.TryGetValue (id, <span class="keyword">out</span> u))</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line"></span><br><span class="line">    u = RetrieveUser (id);   <span class="comment">// 从数据库获取数据</span></span><br><span class="line">    <span class="keyword">lock</span> (_users) _users [id] = u;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至少必须要在读取和更新字典时加锁来保证线程安全。在这个例子中，在加锁的便捷和性能之间进行了平衡。我们的设计略有一些效率问题：如果两个线程同时使用未缓存过数据的<code>id</code>调用这个方法，<code>RetrieveUser</code>就可能被调用两次，并且其中一次对字典的更新是不必要的。对整个方法加锁可以避免这一问题，但会导致更糟的效率：整个缓存在调用<code>RetrieveUser</code>的期间都会被加锁，在这段时间内，其它需要这样获取用户信息的线程都会被<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>。</p><h3 id="3-3富客户端应用与线程亲和"><a href="#3-3富客户端应用与线程亲和" class="headerlink" title="3.3富客户端应用与线程亲和"></a>3.3富客户端应用与线程亲和</h3><p>（译者注：这里的 <em>thread affinity</em> 译为线程亲和，是指 UI 控件与线程的一种“绑定”关系，而不是通常理解中的线程与 CPU 核心的绑定关系。）</p><p>WPF 与 Windows Forms 库都遵循基于线程亲和的模型。尽管它们有各自的实现，但是原理非常相似。</p><p>富客户端的构成主要基于<code>DependencyObject</code>（WPF 中）或是<code>Control</code>（Windows Forms 中）。这些对象具有线程亲和性（thread affinity），意思是只有创建它们的线程才能访问其成员。违反这一原则会引起不可预料的行为，或是抛出异常。</p><p>这样的好处是访问 UI 对象时并不需要加锁。而坏处是，如果希望调用在另一线程 Y 上创建的对象 X 的成员，就必须将请求封送（marshal）到线程 Y 。通过下列方法显式实现：</p><ul><li>WPF 中：在其<code>Dispatcher</code>对象上调用<code>Invoke</code>或<code>BeginInvoke</code>。</li><li>Windows Forms 中：调用<code>Control</code>对象上的<code>Invoke</code>或<code>BeginInvoke</code>。</li></ul><p><code>Invoke</code>和<code>BeginInvoke</code>都接受一个委托，代表我们希望在目标控件上运行的的方法。<code>Invoke</code>是同步工作的：调用方在封送的委托执行完成前会被<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>；<code>BeginInvoke</code>是异步工作的：调用方立即返回，封送请求被加入队列（使用与处理键盘、鼠标、定时器事件相同的消息队列）。</p><p>假定窗体包含一个名为<code>txtMessage</code>的文本框，我们希望使用一个工作线程更新其内容，下面是 WPF 的示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MyWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line">    <span class="keyword">new</span> Thread (Work).Start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Work</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread.Sleep (<span class="number">5000</span>);           <span class="comment">// 模拟耗时任务</span></span><br><span class="line">    UpdateMessage (<span class="string">"The answer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">UpdateMessage</span> (<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Action action = () =&gt; txtMessage.Text = message;</span><br><span class="line">    Dispatcher.Invoke (action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Windows Forms 的代码类似，所不同的是我们调用<code>Form</code>的<code>Invoke</code>方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> UpdateMessage (<span class="built_in">string</span> message)</span><br><span class="line">&#123;</span><br><span class="line">  Action action = <span class="function"><span class="params">()</span> =&gt;</span> txtMessage.Text = message;</span><br><span class="line">  <span class="keyword">this</span>.Invoke (action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Framework 提供了两个构造来简化这个过程：</p><ul><li><a href="https://blog.gkarch.com/threading/part3.html#backgroundworker" target="_blank" rel="noopener"><code>BackgroundWorker</code></a></li><li><a href="https://blog.gkarch.com/threading/part5.html#continuations" target="_blank" rel="noopener">任务延续（Task continuations）</a></li></ul><h4 id="工作线程-vs-UI-线程"><a href="#工作线程-vs-UI-线程" class="headerlink" title="工作线程 vs UI 线程"></a>工作线程 vs UI 线程</h4><p>我们可以认为富客户端应用程序中有两种不同的线程类别：UI 线程和工作线程。UI 线程创建（并“占有”） UI 元素，工作线程则不会；工作线程通常执行长时间任务，例如获取数据。</p><p>大多数的富客户端应用只有一个 UI 线程（它也是应用程序的主线程），它再去根据需要创建工作线程，可以直接创建或者使用<a href="https://blog.gkarch.com/threading/part3.html#backgroundworker" target="_blank" rel="noopener"><code>BackgroundWorker</code></a>。这些工作线程可以将代码封送回主 UI 线程来更新控件或报告工作进度。</p><p>那么，应用程序何时会需要多个 UI 线程呢？主要的应用场景是：如果应用具有多个顶级窗口，每个顶级窗口都是被称为单文档界面（Single Document Interface，SDI）的程序，例如 Microsoft Word。每个 SDI 窗口通常会在任务栏上显示为独立的应用程序，并且与其它的 SDI 窗口在功能上基本隔离。通过为每一个这样的窗口设置独立的 UI 线程，可以使应用程序有更好的响应。</p><h3 id="3-4不可变对象"><a href="#3-4不可变对象" class="headerlink" title="3.4不可变对象"></a>3.4不可变对象</h3><p>不可变对象的状态不能被修改，无论通过外部还是内部。不可变对象的字段通常被声明为只读的，并且在构造过程中就会被初始化好。</p><p>不变性（immutability ）是函数式编程的一个标志：不是修改对象，而是使用不同的属性创建一个新的对象。LINQ 就遵循这种模式。不变性在多线程中也很有价值，它可以通过消除（或是最小化）写入的可能来避免共享可写状态的问题。</p><p>使用不可变对象的一个模式是：封装一组相关的字段来最小化锁定的时长。下面的例子中，假设有两个字段：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int _percentComplete<span class="comment">;</span></span><br><span class="line">string _statusMessage<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>我们希望对其进行原子的读 / 写操作。除了加<a href="https://blog.gkarch.com/threading/part2.html#locking" target="_blank" rel="noopener">锁</a>之外，也可以定义如下的不可变类：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ProgressStatus</span>    <span class="comment">// 代表某活动进度</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">int</span> PercentComplete;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">string</span> StatusMessage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个类可能还有其它很多字段...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProgressStatus</span> (<span class="params"><span class="keyword">int</span> percentComplete, <span class="keyword">string</span> statusMessage</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    PercentComplete = percentComplete;</span><br><span class="line">    StatusMessage = statusMessage;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以定义一个该类型的字段，以及一个用于加锁的对象：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readonly object _statusLocker = new object();</span><br><span class="line"><span class="keyword">Progress</span>Status _status;</span><br></pre></td></tr></table></figure><p>现在，我们就可以读 / 写该类型的值，而仅需要为一次赋值加锁：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="keyword">new</span> ProgressStatus (<span class="number">50</span>, <span class="string">"Working on it"</span>);</span><br><span class="line"><span class="comment">// 想象一下我们曾经在这要处理多少个字段 ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">lock</span> (_statusLocker) _status = status;    <span class="comment">// 非常短暂的锁</span></span><br></pre></td></tr></table></figure><p>要读取该对象，首先获取该对象的一个副本（在锁内），然后就可以读取其值而不需要继续占有锁：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Progress</span>Status statusCopy;</span><br><span class="line">lock (_locker ProgressStatus) statusCopy = _status;   // 也是一个短暂的锁</span><br><span class="line">int pc = statusCopy.PercentComplete;</span><br><span class="line">string msg = statusCopy.StatusMessage;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>（译者注：上面代码有误，<code>lock</code>中应该是<code>_statusLocker</code>。这里的<code>statusCopy</code>也不是真正的副本，而仅仅相当于<code>_status</code>的别名，这么做是为了通过刷新处理器缓存，获取<code>_status</code>当前的一致状态。）</p><p>技术上讲，最后两行代码的线程安全，是因为之前的<code>lock</code>进行了隐式的<a href="https://blog.gkarch.com/threading/part4.html#memory-barriers-and-volatility" target="_blank" rel="noopener">内存屏障（memory barrier）</a>。</p><p>需要注意的是，这种无锁（译者注：这里不是说完全没有用到锁，而是指锁非常短暂）的方法可以避免一组相关字段出现不一致的情况。但它无法阻止后续的操作修改数据，因此，通常需要使用锁。在第 5 部分中，将会看到使用不变性来简化多线程的更多示例，包括<a href="https://blog.gkarch.com/threading/part5.html#plinq" target="_blank" rel="noopener">PLINQ</a>。</p><p>可以根据先前的值安全的创建一个新的<code>ProgressStatus</code>对象（例如：在其上可以“增加”<code>PercentComplete</code>的值），而仅需锁定一行代码。实际上不使用锁都可以，我们可以显式使用内存屏障、<code>Interlocked.CompareExchange</code>还有自旋等待。这种高级技术将在稍后的<a href="https://blog.gkarch.com/threading/part5.html#spinlock-and-spinwait" target="_blank" rel="noopener">并行编程</a>中讲解。</p><h2 id="4使用事件等待句柄进行信号同步"><a href="#4使用事件等待句柄进行信号同步" class="headerlink" title="4使用事件等待句柄进行信号同步"></a>4使用事件等待句柄进行信号同步</h2><p>（译者注：<em>signal / signalling</em> 直译是信号 / 发信号，一般在通讯领域用于控制的信号称为信令，但是计算机领域一般还是称之为信号。这里的 signaling 指使用信号进行线程同步，翻译成信号或者信号同步。）</p><p>事件等待句柄（event wait handle）用于信号同步。信号同步就是一个线程进行等待，直到它收到其它线程的通知的过程。事件等待句柄是最简单的信号构造，与 C# 的事件（译者注：指基于<code>event</code>关键字的事件模式）无关。它们有三个成员：<a href="https://blog.gkarch.com/threading/part2.html#autoresetevent" target="_blank" rel="noopener"><code>AutoResetEvent</code></a>、<a href="https://blog.gkarch.com/threading/part2.html#manualresetevent" target="_blank" rel="noopener"><code>ManualResetEvent</code></a>以及<a href="https://blog.gkarch.com/threading/part2.html#countdownevent" target="_blank" rel="noopener"><code>CountdownEvent</code></a>( Framework 4.0 中加入)。前两个的功能基本都是在它们的基类<code>EventWaitHandle</code>上实现的。</p><h4 id="信号构造比较"><a href="#信号构造比较" class="headerlink" title="信号构造比较"></a>信号构造比较</h4><table><thead><tr><th>构造</th><th>用途</th><th>跨进程</th><th>开销*</th></tr></thead><tbody><tr><td><a href="https://blog.gkarch.com/threading/part2.html#autoresetevent" target="_blank" rel="noopener">AutoResetEvent</a></td><td>使线程在收到其它线程信号时解除阻塞一次</td><td>**</td><td>1000ns</td></tr><tr><td><a href="https://blog.gkarch.com/threading/part2.html#manualresetevent" target="_blank" rel="noopener">ManualResetEvent</a></td><td>使线程在收到其它线程信号时解除阻塞，并且不继续阻塞直到被复位</td><td>**</td><td>1000ns</td></tr><tr><td><a href="https://blog.gkarch.com/threading/part2.html#manualresetevent" target="_blank" rel="noopener">ManualResetEventSlim</a>（Framework 4.0 中加入）</td><td>-</td><td>40ns</td><td></td></tr><tr><td><a href="https://blog.gkarch.com/threading/part2.html#countdownevent" target="_blank" rel="noopener">CountdownEvent</a>（Framework 4.0 中加入）</td><td>使线程在收到预定数量的信号时解除阻塞</td><td>-</td><td>40ns</td></tr><tr><td><a href="https://blog.gkarch.com/threading/part4.html#the-barrier-class" target="_blank" rel="noopener">Barrier</a>（Framework 4.0 中加入）</td><td>实现线程执行屏障</td><td>-</td><td>80ns</td></tr><tr><td><a href="https://blog.gkarch.com/threading/part4.html#signaling-with-wait-and-pulse" target="_blank" rel="noopener">Wait 和 Pulse</a></td><td>使线程阻塞，直到自定义条件被满足</td><td>-</td><td>120ns每个<code>Pulse</code></td></tr></tbody></table><p>* 时间代表在同一线程上进行发信号并等待（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。</p><h3 id="4-1AutoResetEvent"><a href="#4-1AutoResetEvent" class="headerlink" title="4.1AutoResetEvent"></a>4.1AutoResetEvent</h3><p><code>AutoResetEvent</code>就像验票闸机：插入一张票，就只允许一个人通过。类名字里的 “ auto “ 是指打开的闸门可以自动关闭，或着说在有人通过后 “reset （复位）”。在闸机处调用<code>WaitOne</code>方法（等待这 “one（一个）” 闸机打开），线程就会进入等待或者说<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>。票的插入则通过调用<code>Set</code>方法。如果有多个线程调用<code>WaitOne</code>，便会在闸机前排队（与锁同样，由于操作系统的差异，这个等待队列的先入先出顺序有时可能被破坏）。票可以来自任意线程，换句话说，任何能够访问这个<code>AutoResetEvent</code>对象的（非阻塞）线程都可以调用<code>Set</code>方法来放行一个被阻塞的线程。</p><p>有两种方式可以创建<code>AutoResetEvent</code>对象，第一种是通过构造方法：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> auto = <span class="keyword">new</span> <span class="type">AutoResetEvent</span> (<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>（如果传递<code>ture</code>给构造方法则相当于在创建后立即调用<code>Set</code>方法。）</p><p>第二种方式是像下边的代码这样创建<code>AutoResetEvent</code>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> auto = <span class="keyword">new</span> <span class="type">EventWaitHandle</span> (<span class="literal">false</span>, EventResetMode.AutoReset);</span><br></pre></td></tr></table></figure><p>在接下来的例子中，一个线程开始等待直到收到另一个线程的信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicWaitHandle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">static</span> EventWaitHandle _waitHandle = <span class="keyword">new</span> AutoResetEvent (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (Waiter).Start();</span><br><span class="line">    Thread.Sleep (<span class="number">1000</span>);                  <span class="comment">// 暂停 1 秒</span></span><br><span class="line">    _waitHandle.Set();                    <span class="comment">// 唤醒 Waiter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Waiter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">"Waiting..."</span>);</span><br><span class="line">    _waitHandle.WaitOne();                <span class="comment">// 等待通知</span></span><br><span class="line">    Console.WriteLine (<span class="string">"Notified"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Waiting</span></span>... (pause) Notified.</span><br></pre></td></tr></table></figure><p><a href="https://blog.gkarch.com/img/threading/EventWaitHandle.png" target="_blank" rel="noopener"><img src="https://blog.gkarch.com/img/threading/EventWaitHandle.png" alt="使用事件等待句柄进行信号同步"></a></p><p>如果在没有线程等待的时候调用<code>Set</code>，该事件等待句柄会保持“打开”状态直到有线程调用<code>WaitOne</code>。这个行为可以帮助避免一个前往闸机的线程和一个正在插入票的线程之间的配合问题（“糟糕，票早插入了 1 微秒，真不幸，你要永远等下去了！”）。然而，在一个没有任何线程在等待的闸机上反复调用<code>Set</code>并不会允许一堆线程通过：仅仅允许下一个通过，多出来的票被“浪费”了。</p><p>在<code>AutoResetEvent</code>上调用<code>Reset</code>可以关闭闸机（应该是开启状态的），这个调用不会等待或<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>。</p><p><code>WaitOne</code>接受一个可选的<code>timeout</code>参数，如果等待不是由于收到了信号，而是超时结束则返回<code>false</code>。</p><p>调用<code>WaitOne</code>并给定一个为 0 的超时时间，可以用来测试等待句柄是否是“打开”的，并且不会阻塞调用方。但是要记住，如果<code>AutoResetEvent</code>是打开的则会复位（关闭）它。</p><h4 id="销毁等待句柄"><a href="#销毁等待句柄" class="headerlink" title="销毁等待句柄"></a>销毁等待句柄</h4><p>（译者注：这里把 dispose 翻译为销毁。）</p><p>一旦等待句柄使用完成，可以调用它的<code>Close</code>方法来释放操作系统资源。或者，也可以简单地丢弃所有对等待句柄的引用，让垃圾回收器在稍后处理它（等待句柄实现了销毁模式，会在析构方法中调用<code>Close</code>）。这是少数几个能被接受的（有争论）依赖这种备用机制的场景之一，因为等待句柄对操作系统而言是轻量级资源（<a href="https://blog.gkarch.com/threading/part1.html#asynchronous-delegates" target="_blank" rel="noopener">异步委托（asynchronous delegates）</a>就是这样来释放其<code>IAsyncResult</code>的等待句柄的 ）。</p><p>等待句柄在应用程序域被卸载时会自动地释放。</p><h4 id="双向信号"><a href="#双向信号" class="headerlink" title="双向信号"></a>双向信号</h4><p>我们设定一种场景：主线程需要连续向工作线程发 3 次信号。如果主线程只是在等待句柄上快速的多次调用<code>Set</code>，第 2 个和第 3 个信号可能会丢失，这是由于工作线程可能要花时间去处理每个信号。</p><p>解决方案是：主线程需要在发信号前等待工作线程就绪。这可以再用一个<code>AutoResetEvent</code>做到，例如：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class TwoWaySignaling</span><br><span class="line">&#123;</span><br><span class="line">  static EventWaitHandle <span class="variable">_ready</span> = new AutoResetEvent (<span class="literal">false</span>);</span><br><span class="line">  static EventWaitHandle <span class="variable">_go</span> = new AutoResetEvent (<span class="literal">false</span>);</span><br><span class="line">  static readonly object <span class="variable">_locker</span> = new object();</span><br><span class="line">  static string <span class="variable">_message</span>;</span><br><span class="line"></span><br><span class="line">  static void Main()</span><br><span class="line">  &#123;</span><br><span class="line">    new Thread (Work).Start();</span><br><span class="line"></span><br><span class="line">    <span class="variable">_ready</span>.WaitOne();                  <span class="comment">// 首先等待工作线程就绪</span></span><br><span class="line">    <span class="built_in">lock</span> (<span class="variable">_locker</span>) <span class="variable">_message</span> = <span class="string">"ooo"</span>;</span><br><span class="line">    <span class="variable">_go</span>.<span class="built_in">Set</span>();                         <span class="comment">// 通知工作线程执行</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">_ready</span>.WaitOne();</span><br><span class="line">    <span class="built_in">lock</span> (<span class="variable">_locker</span>) <span class="variable">_message</span> = <span class="string">"ahhh"</span>;  <span class="comment">// 给工作线程其它信息</span></span><br><span class="line">    <span class="variable">_go</span>.<span class="built_in">Set</span>();</span><br><span class="line">    <span class="variable">_ready</span>.WaitOne();</span><br><span class="line">    <span class="built_in">lock</span> (<span class="variable">_locker</span>) <span class="variable">_message</span> = null;    <span class="comment">// 发信号通知工作线程退出</span></span><br><span class="line">    <span class="variable">_go</span>.<span class="built_in">Set</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void Work()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">_ready</span>.<span class="built_in">Set</span>();                          <span class="comment">// 表示我们准备好了</span></span><br><span class="line">      <span class="variable">_go</span>.WaitOne();                         <span class="comment">// 等待开始</span></span><br><span class="line">      <span class="built_in">lock</span> (<span class="variable">_locker</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_message</span> == null) return;        <span class="comment">// 优雅地退出</span></span><br><span class="line">        Console.WriteLine (<span class="variable">_message</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ooo</span></span><br><span class="line"><span class="attribute">ahhh</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.gkarch.com/img/threading/TwoWaySignaling.png" target="_blank" rel="noopener"><img src="https://blog.gkarch.com/img/threading/TwoWaySignaling.png" alt="双向信号"></a></p><p>这里我们使用了一个为<code>null</code>的消息来指示工作线程结束。对于无限运行（译者注：指类似这里的<code>while (true)</code>方式无限循环）的线程，退出机制是非常重要的！</p><h4 id="生产者-消费者队列"><a href="#生产者-消费者队列" class="headerlink" title="生产者 / 消费者队列"></a>生产者 / 消费者队列</h4><p>生产者 / 消费者队列是一个在多线程中常见的需求，它是这样工作的：</p><ul><li>建立一个队列，用于描述需要执行的工作项，或需要处理的数据。</li><li>当有任务需要执行时，把它加入队列中，这样调用方就可以继续处理其它事情。</li><li>一个或多个工作线程在后台工作，它们从队列中取出工作项并执行。</li></ul><p>这种模型的好处是，可以精确控制工作线程的数量，使你能够限制 CPU 和其它资源的消耗。比如，如果任务执行密集的磁盘 I/O 操作，可以仅使用一个工作线程来执行工作，这样能够避免操作系统和其它应用出现饥饿。其它类型的应用也许就可以使用 20 个工作线程。也可以在队列生命周期内动态添加和移除工作线程。CLR 的线程池本身就是一种生产者 / 消费者队列。</p><p>生产者 / 消费者队列一般只是存放需要任务处理的数据项，例如数据项可能是文件名，而任务是加密这些文件。</p><p>下边的例子，使用一个<code>AutoResetEvent</code>发信号给工作线程，工作线程在所有任务都已完成时（或者说队列为空时）会处于等待状态。通过加入<code>null</code>任务来通知工作线程结束：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProducerConsumerQueue</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">  EventWaitHandle _wh = <span class="keyword">new</span> AutoResetEvent (<span class="literal">false</span>);</span><br><span class="line">  Thread _worker;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="keyword">object</span> _locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">  Queue&lt;<span class="keyword">string</span>&gt; _tasks = <span class="keyword">new</span> Queue&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProducerConsumerQueue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    _worker = <span class="keyword">new</span> Thread (Work);</span><br><span class="line">    _worker.Start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnqueueTask</span> (<span class="params"><span class="keyword">string</span> task</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_locker) _tasks.Enqueue (task);</span><br><span class="line">    _wh.Set();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    EnqueueTask (<span class="literal">null</span>);     <span class="comment">// 通知消费者退出</span></span><br><span class="line">    _worker.Join();         <span class="comment">// 等待消费者线程完成执行</span></span><br><span class="line">    _wh.Close();            <span class="comment">// 释放所有系统资源</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Work</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">string</span> task = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">lock</span> (_locker)</span><br><span class="line">        <span class="keyword">if</span> (_tasks.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          task = _tasks.Dequeue();</span><br><span class="line">          <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (task != <span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        Console.WriteLine (<span class="string">"Performing task: "</span> + task);</span><br><span class="line">        Thread.Sleep (<span class="number">1000</span>);  <span class="comment">// 模拟执行工作...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        _wh.WaitOne();         <span class="comment">// 没有任务了，等待信号</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为保证线程安全，我们使用了一个锁来保护对<code>Queue&lt;string&gt;</code>的访问。在<code>Dispose</code>方法中，我们也显式关闭了等待句柄，因为在程序生命周期中，有可能会创建和销毁许多这个类的实例。</p><p>下边是测试这个队列的主方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> (ProducerConsumerQueue q = <span class="keyword">new</span> ProducerConsumerQueue())</span><br><span class="line">  &#123;</span><br><span class="line">    q.EnqueueTask (<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) q.EnqueueTask (<span class="string">"Say "</span> + i);</span><br><span class="line">    q.EnqueueTask (<span class="string">"Goodbye!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 using 语句结束时会调用 q 的 Dispose 方法</span></span><br><span class="line">  <span class="comment">// 该方法向队列中插入一个 null 的任务，并等待消费者完成退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Performing <span class="keyword">task</span>: Hello</span><br><span class="line">Performing <span class="keyword">task</span>: Say <span class="number">1</span></span><br><span class="line">Performing <span class="keyword">task</span>: Say <span class="number">2</span></span><br><span class="line">Performing <span class="keyword">task</span>: Say <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Performing <span class="keyword">task</span>: Say <span class="number">9</span></span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure><p>Framework 4.0 提供了一个新的类型<a href="https://blog.gkarch.com/threading/part5.html#blockingcollectiont" target="_blank" rel="noopener"><code>BlockingCollection</code></a>，它实现了生产者 / 消费者队列的功能。</p><p>前面我们自己写的生产者 / 消费者队列还是有价值的，它不仅仅为了举例说明<code>AutoResetEvent</code>和<a href="https://blog.gkarch.com/threading/part2.html#thread-safety" target="_blank" rel="noopener">线程安全</a>，也是更多其它复杂构造的基础。例如，如果想要实现有界阻塞队列（bounded blocking queue）（可以限制队列中任务的个数），并且希望支持取消（和移除）队列中工作项，我们的代码就是一个很好的起点。之后在讨论<a href="https://blog.gkarch.com/threading/part4.html#producer-consumer-queue" target="_blank" rel="noopener"><code>Wait</code> 和 <code>Pulse</code></a>时会让这个的生产者 / 消费者队列的例子更进一步。</p><h3 id="4-2ManualResetEvent"><a href="#4-2ManualResetEvent" class="headerlink" title="4.2ManualResetEvent"></a>4.2ManualResetEvent</h3><p><code>ManualResetEvent</code>就像一个普通的门。调用<code>Set</code>方法打开门，允许任意数量的线程调用<code>WaitOne</code>方法来通过。调用<code>Reset</code>方法关闭门。如果线程在一个关闭的门上调用<code>WaitOne</code>方法将会被<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>，当门下次打开时，会被立即放行。除这些不同以外，<code>ManualResetEvent</code>就和<code>AutoResetEvent</code>差不多了。</p><p>与<code>AutoResetEvent</code>类似，可以使用两种方式构造<code>ManualResetEvent</code>:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> manual1 = <span class="keyword">new</span> <span class="type">ManualResetEvent</span> (<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> manual2 = <span class="keyword">new</span> <span class="type">EventWaitHandle</span> (<span class="literal">false</span>, EventResetMode.ManualReset);</span><br></pre></td></tr></table></figure><p>从 Framework 4.0 开始，提供了另一个版本的<code>ManualResetEvent</code>，名为<code>ManualResetEventSlim</code>。后者为短等待时间做了优化，它提供了进行一定次数迭代<a href="https://blog.gkarch.com/threading/part2.html#blocking-versus-spinning" target="_blank" rel="noopener">自旋</a>的能力，也实现了一种更有效的管理机制，允许通过<a href="https://blog.gkarch.com/threading/part3.html#cancellation-tokens" target="_blank" rel="noopener"><code>CancellationToken</code></a>取消<code>Wait</code>等待。但它不能用于跨进程的信号同步。<code>ManualResetEventSlim</code>不是<code>WaitHandle</code>的子类，但它提供一个<code>WaitHandle</code>的属性，会返回一个基于<code>WaitHandle</code>的对象（使用它的性能和一般的等待句柄相同）。</p><h4 id="信号构造与性能"><a href="#信号构造与性能" class="headerlink" title="信号构造与性能"></a>信号构造与性能</h4><p>对于<code>AutoResetEvent</code>和<code>ManualResetEvent</code>，使用它们等待或者发信号需要大概 1 微秒时间（假设没有阻塞）。</p><p><code>ManualResetEventSlim</code>和<a href="https://blog.gkarch.com/threading/part2.html#countdownevent" target="_blank" rel="noopener"><code>CountdownEvent</code></a>在等待时间很短的情况下可以比上面两个快 50 倍。这是因为它们不依赖操作系统，并能择机使用<a href="https://blog.gkarch.com/threading/part5.html#spinlock-and-spinwait" target="_blank" rel="noopener">自旋构造</a>。</p><p>然而大多数情况下，信号构造自身的开销并不会造成瓶颈，所以很少需要去考虑。高度并发的场景是个例外，我们将在<a href="https://blog.gkarch.com/threading/part5.html" target="_blank" rel="noopener">第 5 部分</a>进行讨论。</p><p><code>ManualResetEvent</code>在需要让一个线程解除其它多个线程的阻塞时有用。如果是相反的需求，可以使用<code>CountdownEvent</code>。</p><h3 id="4-3CountdownEvent"><a href="#4-3CountdownEvent" class="headerlink" title="4.3CountdownEvent"></a>4.3CountdownEvent</h3><p><code>CountdownEvent</code> 可以让你等待 1 个以上的线程。这个类型是 Framework 4.0 加入的，并且是一个高效的纯托管实现。</p><p>如果在使用较早版本的 .NET Framework，也不是没有办法。稍后我们会介绍如何使用<a href="https://blog.gkarch.com/threading/part4.html#writing-a-countdownevent" target="_blank" rel="noopener"><code>Wait</code> 和 <code>Pulse</code></a>来实现<code>CountdownEvent</code>。</p><p>使用<code>CountdownEvent</code>时，需要指定一个计数器数值，也就是你希望等待的线程数量：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countdown = <span class="keyword">new</span> <span class="type">CountdownEvent</span> (<span class="number">3</span>);  <span class="comment">// 初始计数为 3</span></span><br></pre></td></tr></table></figure><p>调用<code>Signal</code>方法会将计数减 1，调用<code>Wait</code>会<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>直到计数为 0。例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> CountdownEvent _countdown = <span class="keyword">new</span> CountdownEvent (<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread (SaySomething).Start (<span class="string">"I am thread 1"</span>);</span><br><span class="line">  <span class="keyword">new</span> Thread (SaySomething).Start (<span class="string">"I am thread 2"</span>);</span><br><span class="line">  <span class="keyword">new</span> Thread (SaySomething).Start (<span class="string">"I am thread 3"</span>);</span><br><span class="line"></span><br><span class="line">  _countdown.Wait();   <span class="comment">// 阻塞直到收到 3 次信号</span></span><br><span class="line">  Console.WriteLine (<span class="string">"All threads have finished speaking!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaySomething</span> (<span class="params"><span class="keyword">object</span> thing</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Thread.Sleep (<span class="number">1000</span>);</span><br><span class="line">  Console.WriteLine (thing);</span><br><span class="line">  _countdown.Signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时通过使用结构化并行（structured parallelism）构造会比<code>CountdownEvent</code>更容易解决问题。我们将在第 5 部分来说明（<a href="https://blog.gkarch.com/threading/part5.html#plinq" target="_blank" rel="noopener">PLINQ</a> 和 <a href="https://blog.gkarch.com/threading/part5.html#the-parallel-class" target="_blank" rel="noopener"><code>Parallel</code></a>类）。</p><p>调用<code>AddCount</code>，可以增加<code>CountdownEvent</code>的计数。然而，如果计数已经为 0，就会抛出一个异常：是无法通过调用<code>AddCount</code>来复位（unsignal）的。为避免异常，可以用<code>TryAddCount</code>替代，它在当前计数为 0 时会返回<code>false</code>。</p><p>想要复位，可以调用<code>Reset</code>：把构造复位到初始状态，计数恢复原值。</p><p>像<code>ManualResetEventSlim</code>一样，<code>CountdownEvent</code>也提供<code>WaitHandle</code>属性，可以在其它类或方法希望得到一个基于<code>WaitHandle</code>的对象时使用。</p><h3 id="4-4创建跨进程的-EventWaitHandle"><a href="#4-4创建跨进程的-EventWaitHandle" class="headerlink" title="4.4创建跨进程的 EventWaitHandle"></a>4.4创建跨进程的 EventWaitHandle</h3><p><code>EventWaitHandle</code>的构造方法允许以命名的方式进行创建，这样它就可以跨进程使用。名称就是一个字符串，可以随意起名，但是注意不要和别人的命名冲突！如果名字在计算机上已存在，你就会获取一个它对应的<code>EventWaitHandle</code>的引用，否则操作系统会创建一个新的。例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventWaitHandle wh = <span class="keyword">new</span> <span class="type">EventWaitHandle</span> (<span class="literal">false</span>, EventResetMode.AutoReset,</span><br><span class="line">    <span class="string">"MyCompany.MyApp.SomeName"</span>);</span><br></pre></td></tr></table></figure><p>如果两个应用程序分别执行这个代码，它们就可以进行信号同步：这个等待句柄可以在跨这两个进程内的所有线程中使用。</p><h3 id="4-5等待句柄和线程池"><a href="#4-5等待句柄和线程池" class="headerlink" title="4.5等待句柄和线程池"></a>4.5等待句柄和线程池</h3><p>如果你的应用有很多线程，这些线程大部分时间都在阻塞，那么可以通过调用<code>ThreadPool.RegisterWaitForSingleObject</code>来减少资源消耗。这个方法接受一个委托，它会在向等待句柄发信号时执行。当处于等待状态时，它不会浪费线程资源：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ManualResetEvent _starter = <span class="keyword">new</span> ManualResetEvent (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject</span><br><span class="line">                             (_starter, Go, <span class="string">"Some Data"</span>, <span class="number">-1</span>, <span class="literal">true</span>);</span><br><span class="line">  Thread.Sleep (<span class="number">5000</span>);</span><br><span class="line">  Console.WriteLine (<span class="string">"Signaling worker..."</span>);</span><br><span class="line">  _starter.Set();</span><br><span class="line">  Console.ReadLine();</span><br><span class="line">  reg.Unregister (_starter);    <span class="comment">// 完成后的清理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span> (<span class="params"><span class="keyword">object</span> data, <span class="keyword">bool</span> timedOut</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Console.WriteLine (<span class="string">"Started - "</span> + data);</span><br><span class="line">  <span class="comment">// 执行任务 ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">5</span> second <span class="keyword">delay</span>)</span><br><span class="line">Signaling worker...</span><br><span class="line">Started - <span class="keyword">Some</span> Data</span><br></pre></td></tr></table></figure><p>当向等待句柄发信号时（或者已超时），委托会在一个线程池线程运行。</p><p>除等待句柄和委托外，<code>RegisterWaitForSingleObject</code>还接受一个“黑盒”对象，它会被传递给委托的目标方法（像<code>ParameterizedThreadStart</code>一样）；还有一个以毫秒为单位的超时时间（-1 代表没有超时时间）；和一个布尔值用来设置请求是一次性的还是可重复的。</p><p><code>RegisterWaitForSingleObject</code>在需要处理很多并发请求的应用服务器中非常有用。假如你需要在<a href="https://blog.gkarch.com/threading/part2.html#manualresetevent" target="_blank" rel="noopener"><code>ManualResetEvent</code></a>上阻塞，调用<code>WaitOne</code>就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppServerMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _wh.WaitOne();</span><br><span class="line">  <span class="comment">// ... 继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 100 个客户端调用这个方法，就会有 100 个服务端线程被浪费在阻塞上。把<code>_wh.WaitOne</code>换成<code>RegisterWaitForSingleObject</code>可以让方法立即返回，就不会浪费线程资源：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AppServerMethod</span><br><span class="line">&#123;</span><br><span class="line">  RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject</span><br><span class="line">   (_wh, Resume, <span class="literal">null</span>, <span class="number">-1</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Resume</span> (<span class="params"><span class="keyword">object</span> data, <span class="keyword">bool</span> timedOut</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... 继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递给<code>Resume</code>的<code>data</code>对象可以用来传递和暂存一些瞬态数据。</p><h3 id="4-6WaitAny、WaitAll-和-SignalAndWait"><a href="#4-6WaitAny、WaitAll-和-SignalAndWait" class="headerlink" title="4.6WaitAny、WaitAll 和 SignalAndWait"></a>4.6WaitAny、WaitAll 和 SignalAndWait</h3><p>除了<code>Set</code>、<code>WaitOne</code>和<code>Reset</code>方法外，在<code>WaitHandle</code>类上还有一些静态方法用来解决更复杂的同步问题。</p><p><code>WaitAny</code>、<code>WaitAll</code>和<code>SignalAndWait</code>方法可以向多个等待句柄发信号和进行等待操作。等待句柄可以是不同的类型（包括<a href="https://blog.gkarch.com/threading/part2.html#mutex" target="_blank" rel="noopener"><code>Mutex</code></a>和<a href="https://blog.gkarch.com/threading/part2.html#semaphore" target="_blank" rel="noopener"><code>Semaphore</code></a>，因为它们都派生自抽象类<code>WaitHandle</code>）。对于<a href="https://blog.gkarch.com/threading/part2.html#manualresetevent" target="_blank" rel="noopener"><code>ManualResetEventSlim</code></a>和<a href="https://blog.gkarch.com/threading/part2.html#countdownevent" target="_blank" rel="noopener"><code>CountdownEvent</code></a>，也可以通过它们的<code>WaitHandle</code>属性来让这些方法使用。</p><p><code>WaitAll</code>和<code>SignalAndWait</code>与旧有的 COM 架构有古怪的联系：这些方法要求调用方必须在多线程套间（multithreaded apartment）中，这个模式最不适合交互操作。比如 WPF 或 Windows 应用程序的主线程就不能在这种模式下操作剪贴板。我们稍后会讨论到它们的替代方案。</p><p><code>WaitHandle.WaitAny</code>等待一组等待句柄中任意一个，<br><code>WaitHandle.WaitAll</code>等待给定的所有等待句柄。这个等待是原子的，就是说如果在等待两个<code>AutoResetEvent</code>：</p><ul><li><code>WaitAny</code>当任意一个事件处于“打开”状态时就能结束等待。</li><li><code>WaitAll</code>当两个事件同时处于“打开”状态时才能结束等待。</li></ul><p>（译者注：见前文，<code>AutoResetEvent</code>在被<code>Set</code>时，如果没有线程在等待，会保持“打开”状态，直到有线程等待它，会放行一个线程，并“关闭”或者说“复位”。这里用<code>WaitAny</code>等待两个<code>AutoResetEvent</code>，那么它只会触发其中一个的复位，另一个如果也被<code>Set</code>，会继续保持“打开”；而如果是<code>WaitAll</code>，则必须两个都处于“打开”状态才能结束等待，同时触发两个事件的复位。）</p><p><code>SignalAndWait</code>会调用一个<code>WaitHandle</code>的<code>Set</code>方法，然后调用另一个<code>WaitHandle</code>的<code>WaitOne</code>方法。在向第一个句柄发信号后，会（让当前线程）跳到第二个句柄的等待队列的最前位置。你可以把它看作是“交换”两个信号，在一对<code>EventWaitHandle</code>上调用这个方法来设定两个线程的会合点（rendezvous），或者说是让它们在某一个时间点“相遇”。不管是<code>AutoResetEvent</code>还是<code>ManualResetEvent</code>都可以用来实现这个技巧。第一个线程执行：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WaitHandle.SignalAndWait </span>(wh1, wh2)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>而第二个线程相反：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WaitHandle.SignalAndWait </span>(wh2, wh1)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="WaitAll-和-SignalAndWait-的替代方案"><a href="#WaitAll-和-SignalAndWait-的替代方案" class="headerlink" title="WaitAll 和 SignalAndWait 的替代方案"></a>WaitAll 和 SignalAndWait 的替代方案</h4><p><code>WaitAll</code>和<code>SignalAndWait</code>不能运行在单线程套间（single-threaded apartment）中。幸运的是，还有替代方案。对于<code>SignalAndWait</code>，其实很少需要它的插队机制：例如在上边的会合例子中，如果等待句柄完全只是为了会合使用，那么就可以在第一个句柄上调用<code>Set</code>，然后在第二个句柄上调用<code>WaitOne</code>。在<a href="https://blog.gkarch.com/threading/part4.html#the-barrier-class" target="_blank" rel="noopener">Barrier</a>类中，我们将探索实现线程会合的另外一个方法。</p><p>对于<code>WaitAll</code>，有时可以使用<a href="https://blog.gkarch.com/threading/part5.html#parallel-invoke" target="_blank" rel="noopener"><code>Parallel</code> 类的 <code>Invoke</code> 方法</a>来替代，这个我们将在第 5 部分讨论。（我们也会讨论<a href="https://blog.gkarch.com/threading/part5.html#task-parallelism" target="_blank" rel="noopener"><code>Task</code></a>和<a href="https://blog.gkarch.com/threading/part5.html#continuations" target="_blank" rel="noopener">任务延续（continuations）</a>，以及如何使用<code>TaskFactory</code>的<a href="https://blog.gkarch.com/threading/part5.html#continuations-with-multiple-antecedents" target="_blank" rel="noopener"><code>ContinueWhenAny</code></a>作为<code>WaitAny</code>的替代。）</p><p>对于其它情况，答案是使用底层的方法来解决所有信号同步问题：见<a href="https://blog.gkarch.com/threading/part4.html#signaling-with-wait-and-pulse" target="_blank" rel="noopener"><code>Wait</code> 和 <code>Pulse</code></a>。</p><h2 id="5同步上下文"><a href="#5同步上下文" class="headerlink" title="5同步上下文"></a>5同步上下文</h2><p>（译者注：这里的同步上下文（synchronization context）并不是指<code>System.Threading.SynchronizationContext</code>类。而是指 CLR 的自动锁机制中的同步域或者说加锁的范围。）</p><p>对于<a href="https://blog.gkarch.com/threading/part2.html#locking" target="_blank" rel="noopener">手动锁定</a>，另一种实现方案是使用声明方式（declaratively）来锁定。通过从<code>ContextBoundObject</code>类派生并添加<code>Synchronization</code>特性，可以指示 CLR 自动加锁。例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Contexts;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Synchronization</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutoLock</span> : <span class="title">ContextBoundObject</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.Write (<span class="string">"Start..."</span>);</span><br><span class="line">    Thread.Sleep (<span class="number">1000</span>);           <span class="comment">// 这里我们无法抢占</span></span><br><span class="line">    Console.WriteLine (<span class="string">"end"</span>);     <span class="comment">// 感谢自动锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    AutoLock safeInstance = <span class="keyword">new</span> AutoLock();</span><br><span class="line">    <span class="keyword">new</span> Thread (safeInstance.Demo).Start();</span><br><span class="line">    <span class="keyword">new</span> Thread (safeInstance.Demo).Start();</span><br><span class="line">    safeInstance.Demo();                        <span class="comment">//并发调用 Demo 3 次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Start</span></span>... end</span><br><span class="line"><span class="function"><span class="title">Start</span></span>... end</span><br><span class="line"><span class="function"><span class="title">Start</span></span>... end</span><br></pre></td></tr></table></figure><p>CLR 确保了同一时刻只有一个线程可以执行 <code>safeInstance</code>中的代码。它通过创建了一个同步对象，并在每次调用<code>safeInstance</code>的方法和属性时进行锁定来实现。锁的作用范围，在这里是指<code>safeInstance</code>对象，被称为同步上下文（synchronization context）。</p><p>那么，它是如何工作的呢？一个线索是<code>Synchronization</code>特性的命名空间：<code>System.Runtime.Remoting.Contexts</code>。<code>ContextBoundObject</code>可以被认为是一个“远程（remote）”对象，这意味着所有方法的调用都是会被拦截。为了实现这种拦截，当我们实例化<code>AutoLock</code>时，CLR 自动返回了一个具有相同方法和属性的<code>AutoLock</code>的代理对象，它扮演着中间人角色。自动锁定就是在中间人上进行的。总的来说，这种拦截会在每次方法调用时增加大概 1 微秒的开销。</p><p>自动同步不能用于保护静态成员，也不能用于非派生自 <code>ContextBoundObject</code>的类。（例如：Windows Forms 窗体）</p><p>锁在内部以相同的方式运作，可以期待下面的例子与之前的有一样的结果：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Synchronization</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AutoLock</span> : <span class="title">ContextBoundObject</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.Write (<span class="string">"Start..."</span>);</span><br><span class="line">    Thread.Sleep (<span class="number">1000</span>);</span><br><span class="line">    Console.WriteLine (<span class="string">"end"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (Demo).Start();</span><br><span class="line">    <span class="keyword">new</span> Thread (Demo).Start();</span><br><span class="line">    <span class="keyword">new</span> Thread (Demo).Start();</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> AutoLock().Test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（注意我们偷偷加了<code>Console.ReadLine</code>语句。）因为这个类的对象在同一时间只有一个线程可以执行代码，三个新线程将<a href="https://blog.gkarch.com/threading/part2.html#blocking" target="_blank" rel="noopener">阻塞</a>在<code>Demo</code>方法处，直到<code>Test</code> 方法完成，也就是要等待<code>ReadLine</code>完成。因此只有在按了回车键之后，才会得到和之前一样的结果。这种线程安全的重型武器足以阻碍所有类内部的多线程！</p><p>此外，我们仍未解决之前描述的一个问题：如果<code>AutoLock</code>是一个集合类，如果在其它类中执行下面的代码，那么仍然需要加锁：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (<span class="selector-tag">safeInstance</span><span class="selector-class">.Count</span> &gt; 0) <span class="selector-tag">safeInstance</span><span class="selector-class">.RemoveAt</span> (0);</span><br></pre></td></tr></table></figure><p>除非执行这段代码的类本身也是一个同步的<code>ContextBoundObject</code>！</p><p>同步上下文的作用域可以扩展到超过单一对象的范围。默认情况下，如果一个同步对象在另一个类中被实例化，它们会共享同一个同步上下文（换言之，就是一个巨大的锁！）。这个行为可以通过在<code>Synchronization</code>特性构造方法中使用一个整型标识来改变，可以使用下列<code>SynchronizationAttribute</code>类中定义的常量之一：</p><table><thead><tr><th>常量</th><th>作用</th></tr></thead><tbody><tr><td>NOT_SUPPORTED</td><td>相当于不使用<code>Synchronized</code>特性</td></tr><tr><td>SUPPORTED</td><td>如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则保持非同步状态</td></tr><tr><td>REQUIRED（默认值）</td><td>如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则创建新的同步上下文</td></tr><tr><td>REQUIRES_NEW</td><td>始终创建新的同步上下文</td></tr></tbody></table><p>所以如果<code>SynchronizedA</code>在<code>SynchronizedB</code>中被实例化，而<code>SynchronizedB</code>使用下面这种声明的话，它们就有各自的同步上下文：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Synchronization (SynchronizationAttribute.REQUIRES_NEW)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SynchronizedB</span> : <span class="title">ContextBoundObject</span> &#123; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>越大的同步上下文越容易管理，但是并发的可能性就越低。另一方面，分离的同步上下文则容易造成<a href="https://blog.gkarch.com/threading/part2.html#deadlocks" target="_blank" rel="noopener">死锁</a>，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Synchronization</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Deadlock</span> : <span class="title">ContextBoundObject</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> Deadlock Other;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123; Thread.Sleep (<span class="number">1000</span>); Other.Hello(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Hello</span>(<span class="params"></span>)       </span>&#123; Console.WriteLine (<span class="string">"hello"</span>);        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Deadlock dead1 = <span class="keyword">new</span> Deadlock();</span><br><span class="line">    Deadlock dead2 = <span class="keyword">new</span> Deadlock();</span><br><span class="line">    dead1.Other = dead2;</span><br><span class="line">    dead2.Other = dead1;</span><br><span class="line">    <span class="keyword">new</span> Thread (dead1.Demo).Start();</span><br><span class="line">    dead2.Demo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为两个<code>Deadlock</code>的实例都是在<code>Test</code>中创建的，而<code>Test</code>是非同步类，所以这两个实例会拥有它自己的同步上下文，因此有它自己的锁。当它们互相调用的时候，用不了多久就会死锁（确切的说是一秒！）。如果<code>Deadlock</code>和 <code>Test</code>是由不同的开发团队写的，这个问题会藏的很深。别指望负责<code>Test</code>的团队能意识到他们犯了什么错，更别指望能知道如何解决了。而对于显式的加锁，死锁的原因通常更容易被发现。</p><h3 id="5-1重入"><a href="#5-1重入" class="headerlink" title="5.1重入"></a>5.1重入</h3><p>（译者注：在单线程场景下，方法没有退出前自身再被调用也是重入，比如显式的递归调用，或者隐式的通过消息队列机制等等，这种重入和作者讨论的多线程场景下的重入并不是完全相同的概念。）</p><p>线程安全方法有时也被称为可重入的（reentrant），因为它可能在执行中途被抢占，然后在另外的线程再被调用也不会有问题。在一般意义上，线程安全和可重入是同义词或者是密切相关的。</p><p>然而，在自动锁机制下，重入有另一个更危险的潜在问题。如果<code>Synchronization</code>特性的<code>reentrant</code>参数为<code>true</code>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">Synchronization</span>(<span class="name">true</span>)]</span><br></pre></td></tr></table></figure><p>那么在执行离开上下文时，同步上下文的锁会被临时释放。在之前的例子中，这可以防止死锁的发生，当然是符合我们期望的。但是，一个副作用是，在过渡期间，任何线程都可以自由的调用原对象上的任何方法（重新进入（re-entering）同步上下文），这会导致多线程编程异常复杂，应该极力避免它。这就是可重入的问题。</p><p>因为<code>[Synchronization(true)]</code>作用于类上，就导致了类中所有会离开同步上下文的方法调用都会带来可重入的副作用问题。</p><p>虽然可重入可能是危险的，但有些时候几乎没有其它选择。例如，在一个同步类内部实现了多线程，方法是通过委托把逻辑交给运行在其它同步上下文中的工作线程。如果没有重入，那么工作线程就可能会导致彼此之间或是原线程的阻塞。</p><p>这凸显了自动同步的一个基本缺点：范围过大的锁定作用域将制造出巨大的麻烦：死锁、可重入以及降低并发度。这使得手动锁定在任何场景都显得更为合适，而并不仅仅只在简单的场景下。</p><blockquote><p>原文：<a href="http://www.albahari.com/threading/part2.aspx" target="_blank" rel="noopener">http://www.albahari.com/threading/part2.aspx</a><br>翻译：<a href="https://blog.gkarch.com/threading/part2.html" target="_blank" rel="noopener">https://blog.gkarch.com/threading/part2.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1同步概要&quot;&gt;&lt;a href=&quot;#1同步概要&quot; class=&quot;headerlink&quot; title=&quot;1同步概要&quot;&gt;&lt;/a&gt;1同步概要&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://blog.gkarch.com/threading/part1.html&quot; ta
      
    
    </summary>
    
      <category term="C#" scheme="https://luox78.github.io/categories/C/"/>
    
    
      <category term="thread" scheme="https://luox78.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>初识JavaScript03</title>
    <link href="https://luox78.github.io/2017/12/31/JavaScript03/"/>
    <id>https://luox78.github.io/2017/12/31/JavaScript03/</id>
    <published>2017-12-31T11:50:33.903Z</published>
    <updated>2018-01-02T12:02:22.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h2><blockquote><p>js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3></blockquote><a id="more"></a><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">var arr = new Array(<span class="number">3</span>);</span><br><span class="line">   arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">   alert(arr);<span class="comment">//0,1,2</span></span><br><span class="line">   arr[<span class="number">3</span>] = <span class="number">3</span>;<span class="comment">//0,1,2,3</span></span><br><span class="line">   alert(arr);</span><br><span class="line">   <span class="comment">//2</span></span><br><span class="line">   for(var i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">     arr[i]=i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3</span></span><br><span class="line">   var arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">"string"</span>];</span><br><span class="line">   var arr=new Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">"string"</span>);</span><br></pre></td></tr></table></figure><h3 id="Json-键值对"><a href="#Json-键值对" class="headerlink" title="Json(键值对)"></a>Json(键值对)</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> arr=&#123;<span class="string">"gender"</span>:<span class="string">"male"</span>,<span class="string">"name"</span>:<span class="string">"luox78"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">var</span> <span class="built_in">key</span> <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  alert(<span class="built_in">key</span>+arr[<span class="built_in">key</span>]);</span><br><span class="line">  //取值的另一种方式 arr.<span class="built_in">key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><blockquote><p>相当于C#拓展方法</p><p>注意：不能跨script标签使用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简易的邮箱判断</span></span><br><span class="line"><span class="built_in">String</span>.prototype.checkEmail=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(<span class="string">"@"</span>)&gt;<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"111@163.com"</span>;</span><br><span class="line">alert(str.checkEmail());<span class="comment">//true;</span></span><br></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><blockquote><p>DOM document object model</p></blockquote><h3 id="为什么要有dom"><a href="#为什么要有dom" class="headerlink" title="为什么要有dom"></a>为什么要有dom</h3><p>为了更方便的操作html。DOM就是把Html页面模拟成一个对象，就像<code>XDocument</code>一样，把Xml模拟成了一个对象，提供了操作各个节点的方法，直接调用就可以了。</p><p><a href="https://luox78.github.io/images/javascript/3.png"><img src="https://luox78.github.io/images/javascript/3.png" alt="dom"></a></p><h3 id="window，document对象"><a href="#window，document对象" class="headerlink" title="window，document对象"></a>window，document对象</h3><blockquote><p> <code>window</code>代表浏览器整个窗口，<code>alert</code>等操作只能用<code>window</code>操作(<code>window</code>可以省略)</p><p> <code>document</code>代表整个页面，只能操作页面元素 ，及内置方法</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">var</span> n=<span class="number">90</span>;</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="built_in">window</span>.n);<span class="comment">//90</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).id;</span><br></pre></td></tr></table></figure><p>但通过window获取元素时会碰到一个问题，就是元素嵌套必须一层一层访问，如访问form中的button<code>window.form1.btn.id</code>，此时应该使用<code>document</code>对象简化操作,<code>document.getElementById(&#39;btn&#39;).id</code></p><hr><h4 id="document演示"><a href="#document演示" class="headerlink" title="document演示"></a>document演示</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当click时先弹出body area 然后才是html body 涉及事件冒泡</span></span><br><span class="line"><span class="built_in">document</span>.body.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"body area"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"html area"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="window常见方法"><a href="#window常见方法" class="headerlink" title="window常见方法"></a>window常见方法</h4><ul><li><p><code>window.alert(&#39;大家好!&#39;);</code>//弹出警告对话框</p></li><li><p><code>window.confirm(&#39;确定要删除吗？&#39;);</code>//确定、取消对话框，返回true或false;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"> <span class="built_in">document</span>.getElementById(<span class="string">"btn3"</span>).onclick= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">window</span>.confirm(<span class="string">"Are you sure to delete?"</span>)) &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"delete success"</span>);</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"delete failed"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>window.navigate(url);</code>//将网页重新导航到url,只支持IE、Opera11.6,建议使用<code>window.location.href=&#39;url&#39;;</code>//支持大多数浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">window</span>.navigate(<span class="string">"https://luox78.github.io"</span>);</span><br><span class="line">   &#125;<span class="comment">//基本上都不行</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">window</span>.location.href = <span class="string">"https://luox78.github.io"</span>;</span><br><span class="line">   &#125;<span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure></li><li><p><code>window.setInterval(function,delay)</code>每个delay ms执行一次</p><p><code>setTimeout(function,delay)</code>只会执行一次，<code>clearTimeout(setId)</code>是为了清理占用的内存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//botton value自增例子</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).value);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> setId = setInterval(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).value = num++;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        1);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).onclick= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        clearInterval(setId);<span class="comment">//计时器一旦被销毁不能再创建</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><blockquote><p>跟C#中事件，委托差不多</p></blockquote><p><strong>注意点：</strong></p><ul><li>事件=函数名，等于给事件赋值不会调用</li><li>事件=函数名（），会执行一次函数，这种赋值其实并不正确，事件应该不能等于函数返回值</li></ul><p><code>&lt;body&gt;</code>中</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&lt;body&gt;</span></span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"btn"</span>/&gt;</span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"button"</span> onclick=<span class="string">"f1();"</span> /&gt;</span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"button"</span> onclick=f1 /&gt;</span><br><span class="line">    &lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"btn2"</span> value=<span class="string">"change method"</span>/&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>onclick=f1;</code>的意思就是说<code>onclick</code>触发的方法就是f1.</p><p><code>onclick=“f1()”</code>的意思就是说<code>onclick</code><strong>触发的方法里调用了f1  </strong></p></blockquote><p><code>&lt;script&gt;</code>中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"f1"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"f3"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).onclick = f1;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"btn2"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).onclick = f3;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"change completed"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="body、document对象的事件"><a href="#body、document对象的事件" class="headerlink" title="body、document对象的事件"></a>body、document对象的事件</h4><ul><li><p><code>window.onload</code></p><ul><li>网页加载完毕时触发，浏览器是一边下载文档、一边解析执行，可能会出现JavaScript执行时需要操作某个元素，这个元素还没有加载，如果这样就要把操作的代码放到body的<code>onload</code>事件中，或者可以把JavaScript放到元素之后。元素的<code>onload</code>事件是元素自己加载完毕时触发，body onload才是全部加载完成<ul><li><code>window.控件Id</code>（不建议使用),<code>document.getElementById(“控件Id”);</code>(推荐)</li></ul></li></ul></li><li><p><code>onunload</code>（页面卸载后触发）</p><p>网页关闭（或者离开）后触发。//刷新页面的时候、关闭选项卡的时候（多个选项卡）</p></li><li><p><code>onbeforeunload</code>（页面卸载前触发）</p><p>在网页准备关闭（或者离开）前触发。//注意浏览器缓存</p><p><code>&lt;bodyonbeforeunload=“return ‘真的要放弃发帖退出吗?’; ”&gt;</code>。显示的文字随浏览器版本而有差异。// =“window.event.returnValue=‘’只兼容IE</p></li><li><p>除了属性之外，当然还有通用的HTML元素的事件：<code>onclick</code>（单击）、<code>ondblclick</code>（双击）、<code>onkeydown</code>（按键按下）、<code>onkeypress</code>（点击按键）、<code>onkeyup</code>（按键释放）、<code>onmousedown</code>（鼠标按下）、<code>onmousemove</code>（鼠标移动）、<code>onmouseout</code>（鼠标离开元素范围）、<code>onmouseover</code>（鼠标移动到元素范围）、<code>onmouseup</code>（鼠标按键释放）、<code>oncontextmenu</code>（在浏览器中单击鼠标右键显示”右键菜单”时触发）等。</p></li></ul><hr><h4 id="window对象事件-属性"><a href="#window对象事件-属性" class="headerlink" title="window对象事件,属性"></a>window对象事件,属性</h4><ul><li><p><code>window.location</code></p><ul><li><code>window.location.href=‘’;</code>//重新导航到新页面,可以取值，也可以赋值。</li><li><code>window.location.reload();</code>//刷新当前页</li></ul></li><li><p><code>window.event</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"dv"</span>).onmousedown= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">window</span>.event.shiftKey) &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"you have pressed the shift"</span>);</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"only mouse click"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>clientX、clientY</code>发生事件时鼠标在客户区域的坐标(指显示html区域)；</p><p><code>screenX、screenY</code>发生事件时鼠标在屏幕上的坐标；</p><p><code>offsetX、offsetY</code>发生事件时鼠标相对于事件源（比如点击按钮时触发<code>onclick</code>）的坐标。当页面中有&lt;!DOCTYPE（文档定义）时，对<code>offsetX</code>和<code>offsetY</code>单击时的解析不同(使用<code>onmousedown</code>的时候与<code>onclick</code>测试结果不同)（单击按钮中文字的时候。）</p></li><li><p><code>(window.event.returnValue)returnValue</code>属性，如果将<code>returnValue</code>设置为false，就会取消默认事件的处理。在超链接的<code>onclick</code>里面禁止访问<code>href</code>的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。(<code>onsubmit=&quot;window.event.returnValue=false;&quot;</code>)</p><p>•<code>window.event.returnValue</code>不兼容火狐浏览器</p><p>•<code>FireFox:e. preventDefault();</code>取消事件的默认动作。</p><p>•直接写<code>return false;</code>IE、FF、Chrome都可以。</p></li><li><p><code>window.event.button</code>，发生事件时鼠标按键，IE:1为左键，2为右键，4中滑轮,3左右键同时按下//要测试<code>event.button</code>的值的时候，请在<code>onmousedown</code>事件中测试</p></li><li><p>​</p></li></ul></li><li><p><code>window.screen</code>对象，获取屏幕的信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(screen.width);</span><br><span class="line">        alert(screen.height);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>clipboardData</code> 对象，对粘贴板的操作</p><ul><li><p><code>onpaste,oncopy</code>事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.oncopy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"forbid copy"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.onpaste= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"forbid paste"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>window.clipboardData.getData``window.clipboardData.setData</code>已弃用，新的粘贴复制方法下面介绍</p><p>​</p></li></ul></li></ul><h2 id="js实现各种复制到剪贴板的方法"><a href="#js实现各种复制到剪贴板的方法" class="headerlink" title="js实现各种复制到剪贴板的方法"></a>js实现各种复制到剪贴板的方法</h2><p><strong>一、实现点击按钮，复制文本框中的的内容</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">copyUrl2</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> Url2 = <span class="built_in">document</span>.getElementById(<span class="string">"biao1"</span>);</span></span><br><span class="line"><span class="actionscript">        Url2.select(); <span class="comment">// 选择对象</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.execCommand(<span class="string">"Copy"</span>); <span class="comment">// 执行浏览器复制命令</span></span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"已复制好，可贴粘。"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>二、点击文本框时，复制文本框里面的内容</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">"oCopy(this)"</span> <span class="attr">value</span>=<span class="string">"你好.要copy的内容!"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">oCopy</span><span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">        obj.select();</span></span><br><span class="line"><span class="undefined">        js = obj.createTextRange();</span></span><br><span class="line"><span class="actionscript">        js.execCommand(<span class="string">"Copy"</span>)</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"复制成功!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>三、复制文本框或者隐藏域中的内容</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">CopyUrl</span><span class="params">(target)</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">        target.value = myimg.value;</span></span><br><span class="line"><span class="undefined">        target.select();</span></span><br><span class="line"><span class="undefined">        js = myimg.createTextRange();</span></span><br><span class="line"><span class="actionscript">        js.execCommand(<span class="string">"Copy"</span>);</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"复制成功!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">AddImg</span><span class="params">(target)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        target.value = <span class="string">"[IMG]"</span> + myimg.value + <span class="string">"[/ img]"</span>;</span></span><br><span class="line"><span class="undefined">        target.select();</span></span><br><span class="line"><span class="undefined">        js = target.createTextRange();</span></span><br><span class="line"><span class="actionscript">        js.execCommand(<span class="string">"Copy"</span>);</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"复制成功!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>四、复制 span 标记中的内容</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">copyText</span><span class="params">(obj)</span></span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> rng = <span class="built_in">document</span>.body.createTextRange();</span></span><br><span class="line"><span class="undefined">        rng.moveToElementText(obj);</span></span><br><span class="line"><span class="undefined">        rng.scrollIntoView();</span></span><br><span class="line"><span class="undefined">        rng.select();</span></span><br><span class="line"><span class="actionscript">        rng.execCommand(<span class="string">"Copy"</span>);</span></span><br><span class="line"><span class="actionscript">        rng.collapse(<span class="literal">false</span>);</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"复制成功!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Array对象&quot;&gt;&lt;a href=&quot;#Array对象&quot; class=&quot;headerlink&quot; title=&quot;Array对象&quot;&gt;&lt;/a&gt;Array对象&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组&lt;/p&gt;
&lt;h3 id=&quot;赋值&quot;&gt;&lt;a href=&quot;#赋值&quot; class=&quot;headerlink&quot; title=&quot;赋值&quot;&gt;&lt;/a&gt;赋值&lt;/h3&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://luox78.github.io/categories/JavaScript/"/>
    
    
      <category term="jsfoundation" scheme="https://luox78.github.io/tags/jsfoundation/"/>
    
  </entry>
  
  <entry>
    <title>初识JavaScript02</title>
    <link href="https://luox78.github.io/2017/12/28/JavaScript02/"/>
    <id>https://luox78.github.io/2017/12/28/JavaScript02/</id>
    <published>2017-12-28T13:39:52.479Z</published>
    <updated>2017-12-31T14:26:24.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js中的事件"><a href="#js中的事件" class="headerlink" title="js中的事件"></a>js中的事件</h2><p>1 通过调用方法名或在“”内部写<br>2 通过id，使用<code>document.getElementById</code>实现事件</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"show time"</span> <span class="attr">onclick</span>=<span class="string">"alert(new Date().toLocaleString());"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn2"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"show time"</span> <span class="attr">onclick</span>=<span class="string">"f1();"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn3"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"show time"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">onclick</span>=<span class="string">"alert(new Date().toLocaleString());"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"alert(new Date().toLocaleString());"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">onclick</span>=<span class="string">"alert(new Date().toLocaleString());"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"alert(new Date().toLocaleString());"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(new Date().toLocaleString());"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//alert(new Date().toLocaleString());</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString());</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'btn3'</span>).onclick = <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString());</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//script 写在上面要加一个窗体以加载事件以防止报错</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'btn3'</span>).onclick = <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString());</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="js调试"><a href="#js调试" class="headerlink" title="js调试"></a>js调试</h2><p>1 直接在vs中点调试，下断点<br><a href="https://luox78.github.io/images/javascript/1.png"><img src="https://luox78.github.io/images/javascript/1.png" alt="调试"></a><br>2 直接在浏览器中调试，按f12-调试<br><a href="https://luox78.github.io/images/javascript/2.png"><img src="https://luox78.github.io/images/javascript/2.png" alt="调试"></a></p><h2 id="js中的函数"><a href="#js中的函数" class="headerlink" title="js中的函数"></a>js中的函数</h2><p>1 JavaScript中声明函数的方式：（无需声明返回值类型）</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">i1, i2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> i1 + i2;  <span class="comment">//如果不写return返回的是undefined</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> add(<span class="built_in">int</span> i1,<span class="built_in">int</span> i2)<span class="comment">//C#写法</span></span><br></pre></td></tr></table></figure><p>2 不需要声明返回值类型、参数类型。函数定义以function开头。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var r = <span class="keyword">add</span><span class="bash">(1, 2);</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">alert(r);</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">r = add(<span class="string">"你好"</span>, <span class="string">"tom"</span>);</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">alert(r);</span></span><br></pre></td></tr></table></figure><p>3 JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。</p><p>4 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectAll、focus等函数名不要用。//不要与系统函数重名。(在单击事件中调用自己定义的focus方法，有问题。与系统的focus()方法重名了)</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1 js方法小写开头</p><p>2 js中定义名字的方法没有返回值接受到的是undefined</p><p>3 js不支持方法重载，只认最后一个</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">add</span>(n1,n2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">n1</span> + n2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title">add</span>(n1, n2, n3) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">n1</span> + n2 + n3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alert(add(<span class="number">1</span>, <span class="number">2</span>));//NaN,此时调用的三个参数的add，n3位undefined，导致最后结果为NaN</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">add</span>(n1, n2, n3) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="type">n1</span> + n2 + n3;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">function</span> <span class="title">add</span>(n1, n2) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="type">n1</span> + n2;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   alert(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));//<span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>通过<code>arguments</code>实现传入多个值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alert(add(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>));<span class="comment">//60</span></span><br></pre></td></tr></table></figure></p></blockquote><p>4 return写成<code>return {Name:’yzk’,Age:18};</code>而不要写成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">return</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">Name</span>:’yzk’,</span><br><span class="line">Age:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是js会在语句末尾自动增加”分号”，如果将大括号另起一行，则return语句后自动增加“分号”后，返回值就变成了undefined了。</p><p>5 </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = <span class="number">10</span>;</span><br><span class="line">function <span class="keyword">add</span><span class="bash">(n) &#123; n = n + 1; <span class="built_in">return</span> n &#125;</span></span><br><span class="line"><span class="bash">alert(add(x));//4 js搜索的是整个页面的方法，当出现重名的方法，js会使用最后一个（一般是同一个script标签中，涉及加载问题）</span></span><br><span class="line"><span class="bash"><span class="keyword">function</span> add(n) &#123; n = n + 3; <span class="built_in">return</span> n; &#125;</span></span><br><span class="line"><span class="bash">alert(add(x));//4</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><blockquote><p>为了解决方法名冲突（主要是导入文件）</p></blockquote><p>1 写法一</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js为动态类型，只有运行时才知道方法有没有返回值，所以f此时代表的是方法</span></span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> n = f(<span class="number">10</span>);</span><br><span class="line">    alert(n);<span class="comment">//11</span></span><br></pre></td></tr></table></figure><p>2 写法二</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟第一种一个意思，没有接受方法而已</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>3 写法三</p><p>创建一个方法对象，参数传入：方法的参数和方法体，浏览器解析成正常方法所以效率低，不推荐</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"return m+n"</span>)</span></span>;</span><br><span class="line">alert(m(<span class="number">10</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure><h2 id="js的闭包"><a href="#js的闭包" class="headerlink" title="js的闭包"></a>js的闭包</h2><blockquote><p>定义：在一定函数里面再定义一个函数，•内部函数函数能访问外部函数作用域范围内的变量，这时这个内部函数就叫做闭包。</p><p>无论这个内部函数在哪里被调用都能访问的到外部函数作用域中的那些变量。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          alert(n);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> f2();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> res = f1();</span><br><span class="line">  res();</span><br></pre></td></tr></table></figure></p></blockquote><p>闭包的目的：</p><p>​    * 通过闭包实现访问闭包外方法的局部变量（解决在匿名函数中调用局部变量相关的问题）</p><p>​    *  这样使得局部变量一直保存在内存中，模拟面向对象</p><p>闭包如何实现的：</p><p>​    *  通过作用域链（使用变量先搜索自己作用域里面的数，没有再往上搜索）<br>​    </p><h2 id="闭包模拟面向对象"><a href="#闭包模拟面向对象" class="headerlink" title="闭包模拟面向对象"></a>闭包模拟面向对象</h2><blockquote><p>闭包获取数据会长时间占用内存，尽量减少使用<br>js中利用函数可以模拟面向对象<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//类名首字母大写以示区分</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> per=<span class="keyword">new</span> Person();</span></span><br><span class="line"><span class="actionscript">    per.name=<span class="string">"luox78"</span>;</span></span><br><span class="line"><span class="undefined">    per.age=18;</span></span><br><span class="line"><span class="actionscript">    per.say=<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"hello"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    alert(per.name);</span></span><br><span class="line"><span class="undefined">    per.say();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.name=name;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="string">"luo78"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//访问里面变量的两种方法</span></span></span><br><span class="line"><span class="undefined">   alert(per.name);</span></span><br><span class="line"><span class="actionscript">   alert(per[<span class="string">"name"</span>]);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="js里面string的常用方法"><a href="#js里面string的常用方法" class="headerlink" title="js里面string的常用方法"></a>js里面string的常用方法</h2><p><code>length</code> 返回字符串长度<br><code>charAt(index)</code> 返回index位置的字符<br><code>split(&quot;分隔符&quot;,limit)</code> 多个分隔符使用正则表达式，limit代表返回个数<br>js中数组可以直接显示，中间是逗号隔开<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">str</span> = <span class="string">"1|2|3|4#6"</span>;</span><br><span class="line">alert(<span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">"|"</span>));<span class="comment">//1,2,3,4</span></span><br><span class="line"><span class="comment">//js中split使用正则，且使用直接//转义特殊字符</span></span><br><span class="line">alert(<span class="built_in">str</span>.<span class="built_in">split</span>(\☆|#\));</span><br></pre></td></tr></table></figure></p><p><code>substr(startindex,len)</code> 返回截取start位置后len长度的字符串<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str=<span class="string">"luox78"</span><span class="comment">;</span></span><br><span class="line">alert(<span class="name">str</span>.substr(<span class="number">2</span>))<span class="comment">;//ox78</span></span><br><span class="line">alert(<span class="name">str</span>.substr(<span class="number">2</span>,<span class="number">2</span>))<span class="comment">;//ox</span></span><br></pre></td></tr></table></figure></p><p><code>substring(startindex,stopindex)</code>  返回截取start位置到stop位置的字符串<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="name">str</span>.substring(<span class="number">0</span>,<span class="number">3</span>))<span class="comment">;//luo</span></span><br></pre></td></tr></table></figure></p><p><code>toUpperCase() toLowerCase()</code> 返回大写，小写<br><code>match() replace() search()</code> 后面dom部分涉及<br><code>indexOf(&quot;str&quot;,position)</code> 返回str的索引位置， str指想找的字符串，position指想找的第几个</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js中的事件&quot;&gt;&lt;a href=&quot;#js中的事件&quot; class=&quot;headerlink&quot; title=&quot;js中的事件&quot;&gt;&lt;/a&gt;js中的事件&lt;/h2&gt;&lt;p&gt;1 通过调用方法名或在“”内部写&lt;br&gt;2 通过id，使用&lt;code&gt;document.getElementById&lt;/code&gt;实现事件&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://luox78.github.io/categories/JavaScript/"/>
    
    
      <category term="jsfoundation" scheme="https://luox78.github.io/tags/jsfoundation/"/>
    
  </entry>
  
  <entry>
    <title>C#中的多线程 - 01基础知识</title>
    <link href="https://luox78.github.io/2017/12/28/CS_Thread01/"/>
    <id>https://luox78.github.io/2017/12/28/CS_Thread01/</id>
    <published>2017-12-28T12:50:03.698Z</published>
    <updated>2017-12-31T12:44:41.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1简介及概念"><a href="#1简介及概念" class="headerlink" title="1简介及概念"></a>1简介及概念</h2><p>C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。</p><p>一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：</p><a id="more"></a><blockquote><p>所有示例都假定已经引用了以下命名空间：</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread (WriteY);  <span class="comment">// 创建新线程</span></span><br><span class="line">    t.Start();                       <span class="comment">// 启动新线程，执行WriteY()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时，在主线程做其它事情</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) Console.Write (<span class="string">"x"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) Console.Write (<span class="string">"y"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyy</span><br><span class="line">yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>主线程创建了一个新线程<code>t</code>来不断打印字母 “ y “，与此同时，主线程在不停打印字母 “ x “。</p><p><a href="https://luox78.github.io/images/threading/NewThread.png"><img src="https://luox78.github.io/images/threading/NewThread.png" alt="启动新线程"></a></p><p>线程一旦启动，线程的<code>IsAlive</code>属性值就会为<code>true</code>，直到线程结束。当传递给<code>Thread</code>的构造方法的委托执行完成时，线程就会结束。一旦结束，该线程不能再重新启动。</p><p>CLR 为每个线程分配各自独立的栈空间，因此局部变量是独立的。在下面的例子中，我们定义一个拥有局部变量的方法，然后在主线程和新创建的线程中同时执行该方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread (Go).Start();      <span class="comment">// 在新线程执行Go()</span></span><br><span class="line">  Go();                         <span class="comment">// 在主线程执行Go()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 定义和使用局部变量 - 'cycles'</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> cycles = <span class="number">0</span>; cycles &lt; <span class="number">5</span>; cycles++) Console.Write (<span class="string">'?'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>??????????</code></p><p>变量<code>cycles</code>的副本是分别在各自的栈中创建的，因此才会输出 10 个问号。</p><p>线程可以通过对同一对象的引用来共享数据。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">bool</span> done;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ThreadTest tt = <span class="keyword">new</span> ThreadTest();   <span class="comment">// 创建一个公共的实例</span></span><br><span class="line">    <span class="keyword">new</span> Thread (tt.Go).Start();</span><br><span class="line">    tt.Go();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意： Go现在是一个实例方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!done) &#123; done = <span class="literal">true</span>; Console.WriteLine (<span class="string">"Done"</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于两个线程是调用了同一个的<code>ThreadTest</code>实例上的<code>Go()</code>，它们共享了<code>done</code>字段，因此输出结果是一次 “ Done “，而不是两次。</p><p>输出结果：<code>Done</code></p><p>静态字段提供了另一种在线程间共享数据的方式，以下是一个静态的<code>done</code>字段的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> done;    <span class="comment">// 静态字段在所有线程中共享</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (Go).Start();</span><br><span class="line">    Go();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123; done = <span class="literal">true</span>; Console.WriteLine (<span class="string">"Done"</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个例子引出了一个关键概念[线程安全（thread safety）]。上述两个例子的输出实际上是不确定的：” Done “ 有可能会被打印两次。如果在<code>Go</code>方法里调换指令的顺序，” Done “ 被打印两次的几率会大幅提高：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Go()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">done</span>) &#123; Console.WriteLine (<span class="string">"Done"</span>); <span class="keyword">done</span> = <span class="keyword">true</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Done</span><br><span class="line">Done   (很可能!)</span><br></pre></td></tr></table></figure><p>这个问题是因为一个线程对<code>if</code>中的语句估值的时候，另一个线程正在执行<code>WriteLine</code>语句，这时<code>done</code>还没有被设置为<code>true</code>。</p><p>修复这个问题需要在读写公共字段时，获得一个[排它锁（互斥锁，exclusive lock ）]。C# 提供了[lock]来达到这个目的：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> done;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (Go).Start();</span><br><span class="line">    Go();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (locker)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123; Console.WriteLine (<span class="string">"Done"</span>); done = <span class="literal">true</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当两个线程同时争夺一个锁的时候（例子中的<code>locker</code>），一个线程等待，或者说[阻塞]，直到锁变为可用。这样就确保了在同一时刻只有一个线程能进入临界区（critical section，不允许并发执行的代码），所以 “ Done “ 只被打印了一次。像这种用来避免在多线程下的不确定性的方式被称为[线程安全（thread-safe）]。</p><p>在线程间共享数据是造成多线程复杂、难以定位的错误的主要原因。尽管这通常是必须的，但应该尽可能保持简单。</p><p>一个线程被阻塞时，不会消耗 CPU 资源。</p><h3 id="1-1Join-和-Sleep"><a href="#1-1Join-和-Sleep" class="headerlink" title="1.1Join 和 Sleep"></a>1.1Join 和 Sleep</h3><p>可以通过调用<code>Join</code>方法来等待另一个线程结束，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread (Go);</span><br><span class="line">  t.Start();</span><br><span class="line">  t.<span class="keyword">Join</span>();</span><br><span class="line">  Console.<span class="keyword">WriteLine</span> (<span class="string">"Thread t has ended!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Go()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) Console.<span class="keyword">Write</span> (<span class="string">"y"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 “ y “ 1,000 次之后，紧接着会输出 “ Thread t has ended! “。当调用<code>Join</code>时可以使用一个超时参数，以毫秒或是<code>TimeSpan</code>形式。如果线程正常结束则返回<code>true</code>，如果超时则返回<code>false</code>。</p><p><code>Thread.Sleep</code>会将当前的线程阻塞一段时间：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="built-in">Sleep</span> (TimeSpan.FromHours (<span class="number">1</span>));  <span class="comment">// 阻塞 1小时</span></span><br><span class="line">Thread.<span class="built-in">Sleep</span> (<span class="number">500</span>);                     <span class="comment">// 阻塞 500 毫秒</span></span><br></pre></td></tr></table></figure><p>当使用<code>Sleep</code>或<code>Join</code>等待时，线程是[阻塞（blocked）]状态，因此不会消耗 CPU 资源。</p><p><code>Thread.Sleep(0)</code>会立即释放当前的时间片，将 CPU 资源出让给其它线程。Framework 4.0 新的<code>Thread.Yield()</code>方法与其相同，除了它只会出让给运行在相同处理器核心上的其它线程。</p><p><code>Sleep(0)</code>和<code>Yield</code>在调整代码性能时偶尔有用，它也是一个很好的诊断工具，可以用于找出[线程安全（thread safety）]的问题。如果在你代码的任意位置插入<code>Thread.Yield()</code>会影响到程序，基本可以确定存在 bug。</p><h3 id="1-2线程是如何工作的"><a href="#1-2线程是如何工作的" class="headerlink" title="1.2线程是如何工作的"></a>1.2线程是如何工作的</h3><p>线程在内部由一个线程调度器（thread scheduler）管理，一般 CLR 会把这个任务交给操作系统完成。线程调度器确保所有活动的线程能够分配到适当的执行时间，并且保证那些处于等待或阻塞状态（例如，等待排它锁或者用户输入）的线程不消耗CPU时间。</p><p>在单核计算机上，线程调度器会进行时间切片（time-slicing），快速的在活动线程中切换执行。在 Windows 操作系统上，一个时间片通常在十几毫秒（译者注：默认 15.625ms），远大于 CPU 在线程间进行上下文切换的开销（通常在几微秒区间）。</p><p>在多核计算机上，多线程的实现是混合了时间切片和真实的并发，不同的线程同时运行在不同的 CPU 核心上。几乎可以肯定仍然会使用到时间切片，因为操作系统除了要调度其它的应用，还需要调度自身的线程。</p><p>线程的执行由于外部因素（比如时间切片）被中断称为被抢占（preempted）。在大多数情况下，线程无法控制其在何时及在什么代码处被抢占。</p><h3 id="1-3线程-vs-进程"><a href="#1-3线程-vs-进程" class="headerlink" title="1.3线程 vs 进程"></a>1.3线程 vs 进程</h3><p>好比多个进程并行在计算机上执行，多个线程是在一个进程中并行执行。进程是完全隔离的，而线程是在一定程度上隔离。一般的，线程与运行在相同程序中的其它线程共享堆内存。这就是线程为何有用的部分原因，一个线程可以在后台获取数据，而另一个线程可以同时显示已获取到的数据。</p><h3 id="1-4线程的使用与误用"><a href="#1-4线程的使用与误用" class="headerlink" title="1.4线程的使用与误用"></a>1.4线程的使用与误用</h3><p>多线程有许多用处，下面是通常的应用场景：</p><ul><li><p>维持用户界面的响应</p><p>使用工作线程并行运行时间消耗大的任务，这样主UI线程就仍然可以响应键盘、鼠标的事件。</p></li><li><p>有效利用 CPU</p><p>多线程在一个线程等待其它计算机或硬件设备响应时非常有用。当一个线程在执行任务时被阻塞，其它线程就可以利用这个空闲出来的CPU核心。</p></li><li><p>并行计算</p><p>在多核心或多处理器的计算机上，计算密集型的代码如果通过分治策略（divide-and-conquer，见[第 5 部分]）将工作量分摊到多个线程，就可以提高计算速度。</p></li><li><p>推测执行（speculative execution）</p><p>在多核心的计算机上，有时可以通过推测之后需要被执行的工作，提前执行它们来提高性能。[LINQPad**]就使用了这个技术来加速新查询的创建。另一种方式就是可以多线程并行运行解决相同问题的不同算法，因为预先不知道哪个算法更好，这样做就可以尽早获得结果。</p></li><li><p>允许同时处理请求</p><p>在服务端，客户端请求可能同时到达，因此需要并行处理（如果你使用 ASP.NET、WCF、Web Services 或者 Remoting，.NET Framework 会自动创建线程）。这在客户端同样有用，例如处理 P2P 网络连接，或是处理来自用户的多个请求。</p></li></ul><p>如果使用了 ASP.NET 和 WCF 之类的技术，可能[不会注意到多线程被使用]，除非是访问共享数据时（比如通过静态字段共享数据）。如果没有正确的[加锁]，就[可能产生线程安全问题]。</p><p>多线程同样也会带来缺点，最大的问题是它提高了程序的复杂度。使用多个线程本身并不复杂，复杂的是线程间的交互（一般是通过共享数据）。无论线程间的交互是否有意为之，都会带来较长的开发周期，以及带来间歇的、难以重现的 bug。因此，最好保证线程间的交互尽量少，并坚持简单和已被证明的多线程交互设计。这篇文章主要就是关于如何处理这种复杂的问题，如果能够移除线程间交互，那会轻松许多。</p><p>一个好的策略是把多线程逻辑使用可重用的类封装，以便于独立的检验和测试。.NET Framework 提供了许多高层的线程构造，之后会讲到。</p><p>当频繁地调度和切换线程时（并且如果活动线程数量大于 CPU 核心数），多线程会增加资源和 CPU 的开销，线程的创建和销毁也会增加开销。多线程并不总是能提升程序的运行速度，如果使用不当，反而可能降低速度。 例如，当需要进行大量的磁盘 I/O 时，几个工作线程顺序执行可能会比 10 个线程同时执行要快。（在[使用 <code>Wait</code> 和 <code>Pulse</code> 进行同步]中，将会描述如何实现 [生产者 / 消费者队列]，它提供了上述功能。）</p><h2 id="2创建和启动线程"><a href="#2创建和启动线程" class="headerlink" title="2创建和启动线程"></a>2创建和启动线程</h2><p>像我们在简介中看到的那样，使用<code>Thread</code>类的构造方法来创建线程，通过传递<code>ThreadStart</code>委托来指明线程从哪里开始运行，下面是<code>ThreadStart</code>委托的定义：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ThreadStart</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure><p>调用<code>Start</code>方法后，线程开始执行，直到它所执行的方法返回后，线程终止。下面这个例子使用完整的 C# 语法创建<code>TheadStart</code>委托：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread (<span class="keyword">new</span> ThreadStart (Go));</span><br><span class="line">    t.Start();   <span class="comment">// 在新线程运行 GO()</span></span><br><span class="line">    Go();        <span class="comment">// 同时在主线程运行 GO()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">"hello!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，线程<code>t</code>执行<code>Go()</code>方法，几乎同时主线程也执行<code>Go()</code>方法，结果将打印两个 hello。</p><p>线程也可以使用更简洁的语法创建，使用方法组（method group），让 C# 编译器推断<code>ThreadStart</code>委托类型：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span> t = <span class="literal">new</span> <span class="keyword">Thread</span> (Go);    <span class="comment">// 无需显式使用 ThreadStart</span></span><br></pre></td></tr></table></figure><p>另一个快捷的方式是使用 lambda 表达式或者匿名方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread ( <span class="function"><span class="params">()</span> =&gt;</span> Console.WriteLine (<span class="string">"Hello!"</span>) );</span><br><span class="line">  t.Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1向线程传递数据"><a href="#2-1向线程传递数据" class="headerlink" title="2.1向线程传递数据"></a>2.1向线程传递数据</h3><p>向一个线程的目标方法传递参数最简单的方式是使用 lambda 表达式调用目标方法，在表达式内指定参数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread ( () =&gt; Print (<span class="string">"Hello from t!"</span>) );</span><br><span class="line">  t.Start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span> <span class="params">(<span class="built_in">string</span> message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Console.WriteLine (message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方式，可以向方法传递任意数量的参数。甚至可以将整个实现封装为一个多语句的 lambda 表达式：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread (<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine (<span class="string">"I'm running on another thread!"</span>);</span><br><span class="line">  Console.WriteLine (<span class="string">"This is so easy!"</span>);</span><br><span class="line">&#125;).Start();</span><br></pre></td></tr></table></figure><p>在 C# 2.0 中，也可以很容易的使用匿名方法来进行相同的操作：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">new</span> <span class="keyword">Thread</span> (delegate()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="params">...</span></span><br><span class="line">&#125;).Start();</span><br></pre></td></tr></table></figure><p>另一个方法是向<code>Thread</code>的<code>Start</code>方法传递参数：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread (Print);</span><br><span class="line">  t.Start (<span class="string">"Hello from t!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span> (<span class="params"><span class="keyword">object</span> messageObj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">string</span> message = (<span class="keyword">string</span>) messageObj;    <span class="comment">// 需要强制类型转换</span></span><br><span class="line">  Console.WriteLine (message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样是因为<code>Thread</code>的构造方法通过重载来接受两个委托中的任意一个：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ThreadStart</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ParameterizedThreadStart</span> (<span class="params"><span class="keyword">object</span> obj</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>ParameterizedThreadStart</code>的限制是它只接受一个参数。并且由于它是<code>object</code>类型，通常需要类型转换。</p><h4 id="Lambda-表达式与被捕获变量"><a href="#Lambda-表达式与被捕获变量" class="headerlink" title="Lambda 表达式与被捕获变量"></a>Lambda 表达式与被捕获变量</h4><p>如我们所见，lambda 表达式是向线程传递数据的最强大的方法。然而必须小心，不要在启动线程之后误修改被捕获变量（captured variables）。例如，考虑下面的例子：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++)</span></span><br><span class="line">  new Thread (() =&gt; Console.Write (<span class="name">i</span>)).Start()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>输出结果是不确定的！可能是这样<code>0223557799</code>。</p><p>问题在于变量<code>i</code>在整个循环中指向相同的内存地址。所以，每一个线程在调用<code>Console.Write</code>时，都在使用这个值在运行时会被改变的变量！</p><p>类似的问题在[C# 4.0 in a Nutshell**]的第 8 章的 “Captured Variables” 有描述。这个问题与多线程没什么关系，而是和 C# 的捕获变量的规则有关（在<code>for</code>和<code>foreach</code>的场景下有时不是很理想）。</p><p>解决方法就是使用临时变量，如下所示：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">  int temp = i<span class="comment">;</span></span><br><span class="line">  new Thread (() =&gt; Console.Write (<span class="name">temp</span>)).Start()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>temp</code>对于每一个循环迭代是局部的。所以，每一个线程会捕获一个不同的内存地址，从而不会产生问题。我们可以使用更为简单的代码来演示前面的问题：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string text = <span class="string">"t1"</span><span class="comment">;</span></span><br><span class="line">Thread <span class="built_in">t1</span> = new Thread ( () =&gt; Console.WriteLine (text) )<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">"t2"</span><span class="comment">;</span></span><br><span class="line">Thread <span class="built_in">t2</span> = new Thread ( () =&gt; Console.WriteLine (text) )<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">t1</span>.Start()<span class="comment">;</span></span><br><span class="line"><span class="built_in">t2</span>.Start()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>因为两个lambda表达式捕获了相同的<code>text</code>变量，<code>t2</code>会被打印两次：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t2</span></span><br><span class="line"><span class="built_in">t2</span></span><br></pre></td></tr></table></figure><h3 id="2-2线程命名"><a href="#2-2线程命名" class="headerlink" title="2.2线程命名"></a>2.2线程命名</h3><p>每一个线程都有一个 Name 属性，我们可以设置它以便于调试。这在 Visual Studio 中非常有用，因为线程的名字会显示在线程窗口（Threads Window）与调试位置（Debug Location）工具栏上。线程的名字只能设置一次，以后尝试修改会抛出异常。</p><p>静态的<code>Thread.CurrentThread</code>属性会返回当前执行的线程。在下面的例子中，我们设置主线程的名字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadNaming</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread.CurrentThread.Name = <span class="string">"main"</span>;</span><br><span class="line">    Thread worker = <span class="keyword">new</span> Thread (Go);</span><br><span class="line">    worker.Name = <span class="string">"worker"</span>;</span><br><span class="line">    worker.Start();</span><br><span class="line">    Go();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">"Hello from "</span> + Thread.CurrentThread.Name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3前台与后台线程"><a href="#2-3前台与后台线程" class="headerlink" title="2.3前台与后台线程"></a>2.3前台与后台线程</h3><p>默认情况下，显式创建的线程都是前台线程（foreground threads）。只要有一个前台线程在运行，程序就可以保持存活，而后台线程（background threads）并不能保持程序存活。当一个程序中所有前台线程停止运行时，仍在运行的所有后台线程会被强制终止。</p><p>线程的前台/后台状态与它的优先级和执行时间的分配无关。</p><p>可以通过线程的<code>IsBackground</code>属性来查询或修改线程的前后台状态。如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> <span class="params">(<span class="built_in">string</span>[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread worker = <span class="keyword">new</span> Thread ( () =&gt; Console.ReadLine() );</span><br><span class="line">    <span class="keyword">if</span> (args.Length &gt; <span class="number">0</span>) worker.IsBackground = <span class="literal">true</span>;</span><br><span class="line">    worker.Start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个程序以无参数的形式运行，工作线程会默认为前台，并在<code>ReadLine</code>时等待用户输入回车。此时主线程退出，但是程序仍然在运行，因为有一个前台线程依然存活。</p><p>相反，如果给<code>Main()</code>传递了参数，工作线程设置为后台状态，当主线程结束时，程序几乎立即退出（终止<code>ReadLine</code>需要一咪咪时间）。</p><p>当进程以这种方式结束时，后台线程执行栈中所有<code>finally</code>块就会被避开。如果程序依赖<code>finally</code>（或是<code>using</code>）块来执行清理工作，例如释放资源或是删除临时文件，就可能会产生问题。为了避免这种问题，在退出程序时可以显式的等待这些后台线程结束。有两种方法可以实现：</p><ul><li>如果是自己创建的线程，在线程上调用[<code>Join</code>](方法。</li><li>如果是使用[线程池线程]，使用[事件等待句柄]。</li></ul><p>在任一种情况下，都应指定一个超时时间，从而可以放弃由于某种原因而无法正常结束的线程。这是后备的退出策略：我们希望程序最后可以关闭，而不是让用户去开任务管理器<code>(╯-_-)╯╧══╧</code></p><p>如果用户使用任务管理器强行终止了 .NET 进程，所有线程都会被当作后台线程一般丢弃。这是通过观察得出的结论，并不是通过文档，而且可能会因为 CLR 和操作系统的版本不同而有不同的行为。</p><p>前台线程不需要这种处理，但是必须小心避免会使线程无法结束的 bug。程序无法正常退出的一个很有可能的原因就是仍有前台线程存在。</p><h3 id="2-4线程优先级"><a href="#2-4线程优先级" class="headerlink" title="2.4线程优先级"></a>2.4线程优先级</h3><p>线程的<code>Priority</code>属性决定了相对于操作系统中的其它活动线程，它可以获得多少执行时间。线程优先级的取值如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThreadPriority</span> &#123; <span class="title">Lowest</span>, <span class="title">BelowNormal</span>, <span class="title">Normal</span>, <span class="title">AboveNormal</span>, <span class="title">Highest</span> &#125;</span></span><br></pre></td></tr></table></figure><p>只有当多个线程同时活动时，线程优先级才有意义。</p><blockquote><p>在提升线程优先级前请三思，这可能会导致其它线程的资源饥饿（resource starvation，译者注：指没有分配到足够的CPU时间来运行）等问题。</p></blockquote><p>提升线程的优先级是无法使其能够处理实时任务的，因为它还受到程序进程优先级的影响。要进行实时任务，必须同时使用<code>System.Diagnostics</code>中的<code>Process</code>类来提升进程的优先级（记得这不是我告诉你的）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="built_in">Process</span> p = <span class="built_in">Process</span>.GetCurrentProcess())</span><br><span class="line">  p.PriorityClass = ProcessPriorityClass.High;</span><br></pre></td></tr></table></figure><p><code>ProcessPriorityClass.High</code>实际上就是一个略低于最高优先级<code>Realtime</code>的级别。将一个进程的优先级设置为<code>Realtime</code>是通知操作系统，我们绝不希望该进程将 CPU 时间出让给其它进程。如果你的程序误入一个无限循环，会发现甚至是操作系统也被锁住了，就只好去按电源按钮了<code>o(&gt;_&lt;)o</code>　正是由于这一原因，High 通常是实时程序的最好选择。</p><p>如果实时程序拥有用户界面，提升进程的优先级会导致大量的 CPU 时间被用于屏幕更新，这会降低整台机器的速度（特别是当 UI 很复杂时）。降低主线程的优先级，并提升进程的优先级可以保证需要进行实时任务的工作线程不会被屏幕重绘所抢占。但是这依然没有解决其它程序的CPU时间饥饿的问题，因为操作系统依然为这个进程分配了大量 CPU 资源。</p><p>理想的解决方案是分离 UI 线程和实时工作线程，使用两个进程分别运行。这样就可以分别设置各自的进程优先级，彼此之间通过 Remoting 或是内存映射文件进行通信。内存映射文件十分适用于这一任务，在<a href="http://www.albahari.com/nutshell/" target="_blank" rel="noopener">C# 4.0 in a Nutshell**</a>的第 14 和 25 章会讲到。</p><p>即使是提升了进程优先级，托管环境在处理强实时需求时仍然有限制。除了自动垃圾回收带来的延迟，操作系统也不能够完全满足实时任务的需要，即便是非托管的程序也是如此。最好的解决办法还是使用独立的硬件或者专门的实时平台。</p><h3 id="2-5异常处理"><a href="#2-5异常处理" class="headerlink" title="2.5异常处理"></a>2.5异常处理</h3><p>当线程开始运行后，其创建代码所在的<code>try / catch / finally</code>块与该线程不再有任何关系。考虑下面的程序：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (Go).Start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 永远执行不到这里</span></span><br><span class="line">    Console.WriteLine (<span class="string">"Exception!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">null</span>; &#125;   <span class="comment">// 产生 NullReferenceException 异常</span></span><br></pre></td></tr></table></figure><blockquote><p>这个例子中的<code>try / catch</code>语句是无效的，而新创建的线程将会遇到一个未处理的<code>NullReferenceException</code>。因为主线程直接跳过catch。</p></blockquote><p>修改方法是将异常处理移到<code>Go</code>方法中：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">new</span> Thread (Go).Start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Go()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">null</span>;    <span class="comment">// 异常会在下面被捕获</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 一般会记录异常， 和/或通知其它线程我们遇到问题了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生产环境的程序中，所有线程的入口方法处都应该有一个异常处理器，就如同在主线程所做的那样（一般可能是在执行栈上靠近入口的地方）。未处理的异常会使得整个程序停止运行，弹出一个难看的对话框。</p><p>在写异常处理块的时候，最好不要忽略错误。一般应该记录异常详细信息，然后可以弹出一个对话框让用户可以选择是否自动把这些信息提交到你的服务器。最后应该关闭程序，因为很可能错误已经破坏的程序的状态。然而这么做会导致用户丢失当前的工作，比如打开的文档。</p><p>WPF 和 Windows Forms 应用中的“全局”异常处理事件（<code>Application.DispatcherUnhandledException</code>和<code>Application.ThreadException</code>）只会在主UI线程有未处理的异常时触发。对于工作线程上的异常仍然需要手动处理。</p><p><code>AppDomain.CurrentDomain.UnhandledException</code>会对所有未处理的异常触发，但是它不提供阻止程序退出的办法。</p><p>然而在某些情况下，可以不必处理工作线程上的异常，因为 .NET Framework 会为你处理。这些会在接下来的内容中讲到：</p><ul><li>[异步委托]</li><li>[<code>BackgroundWorker</code>]</li><li>[任务并行库（TPL）]</li></ul><h2 id="3线程池"><a href="#3线程池" class="headerlink" title="3线程池"></a>3线程池</h2><blockquote><p>当启动一个线程时，会有几百毫秒的时间花费在准备一些额外的资源上，例如一个新的私有局部变量栈这样的事情。每个线程会占用（默认情况下）1MB 内存。线程池（thread pool）可以通过共享与回收线程来减轻这些开销，允许多线程应用在很小的粒度上而没有性能损失。在多核心处理器以分治（divide-and-conquer）的风格执行计算密集代码时将会十分有用。</p></blockquote><p>线程池会限制其同时运行的工作线程总数。太多的活动线程会加重操作系统的管理负担，也会降低 CPU 缓存的效果。一旦达到数量限制，任务就会进行排队，等待一个任务完成后才会启动另一个。这使得程序任意并发成为可能，例如 web 服务器。（异步方法模式（asynchronous method pattern）是进一步高效利用线程池的高级技术，我们在<a href="http://www.albahari.com/nutshell/" target="_blank" rel="noopener">C# 4.0 in a Nutshell**</a>的 23 章来讲）。</p><p>有多种方法可以使用线程池：</p><ul><li>通过[任务并行库（TPL）]（Framework 4.0 中加入）</li><li>调用[<code>ThreadPool.QueueUserWorkItem</code>]</li><li>通过[异步委托]</li><li>通过[<code>BackgroundWorker</code>]</li></ul><p>以下构造会间接使用线程池：</p><ul><li>WCF、Remoting、ASP.NET 和 ASMX 网络服务应用</li><li>[<code>System.Timers.Timer</code>]和 [<code>System.Threading.Timer</code>]</li><li>.NET Framework 中名字以 <em>Async</em> 结尾的方法，例如<code>WebClient</code>上的方法（使用[基于事件的异步模式，EAP]），和大部分<code>BeginXXX</code>方法（异步编程模型模式，APM）</li><li>PLINQ</li></ul><p>任务并行库（Task Parallel Library，TPL）与 PLINQ 足够强大并面向高层，即使使用线程池并不重要，也应该使用它们来辅助多线程。我们会在[第 5 部分]中进行更详细的讨论。现在，简单看一下如何使用[<code>Task</code>]类作为在线程池线程上运行委托的简单方法。</p><p>在使用线程池线程时有几点需要小心：</p><ul><li>无法设置线程池线程的<code>Name</code>属性，这会令调试更为困难（当然，调试时也可以在 Visual Studio 的线程窗口中给线程附加备注）。</li><li>线程池线程永远是[后台线程]（一般不是问题）。</li><li>[阻塞]线程池线程可能会在程序早期带来额外的延迟，除非调用了<code>ThreadPool.SetMinThreads</code>（见[优化线程池]）。</li></ul><p>可以改变线程池线程的[优先级]，当它用完后返回线程池时会被恢复到默认状态。</p><p>可以通过<code>Thread.CurrentThread.IsThreadPoolThread</code>属性来查询当前是否运行在线程池线程上。</p><h3 id="3-1通过-TPL-使用线程池"><a href="#3-1通过-TPL-使用线程池" class="headerlink" title="3.1通过 TPL 使用线程池"></a>3.1通过 TPL 使用线程池</h3><p>可以很容易的使用<em>任务并行库</em>（Task Parallel Library，TPL）中的[<code>Task</code>]类来使用线程池。</p><blockquote><p><code>Task</code>类在 Framework 4.0 时被加入：如果你熟悉旧式的构造，可以将非泛型的<code>Task</code>类看作[<code>ThreadPool.QueueUserWorkItem</code>]的替代，而泛型的<code>Task&lt;TResult&gt;</code>看作[异步委托]的替代。比起旧式的构造，新式的构造会更快速，更方便，并且更灵活。</p></blockquote><p>要使用非泛型的<code>Task</code>类，调用<code>Task.Factory.StartNew</code>，并传递目标方法的委托：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span>    <span class="comment">// Task 类在 System.Threading.Tasks 命名空间中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Task.Factory.StartNew (Go);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Console.WriteLine (<span class="string">"Hello from the thread pool!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Task.Factory.StartNew</code>返回一个<code>Task</code>对象，可以用来监视任务，例如通过调用<code>Wait</code>)方法来等待其结束。</p><p>当调用<code>Task</code>的[<code>Wait</code>方法]时，所有未处理的异常会在宿主线程被重新抛出。（如果不调用<code>Wait</code>而是丢弃不管，未处理的异常会[像普通的线程那样]结束程序。（译者注：在 .NET 4.5 中，为了支持基于<code>async / await</code>的异步模式，<code>Task</code>中这种“未观察”的异常默认会被忽略，而不会导致程序结束。</p><p>泛型的<code>Task&lt;TResult&gt;</code>类是非泛型<code>Task</code>的子类。它可以使你在其完成执行后得到一个返回值。在下面的例子中，我们使用<code>Task&lt;TResult&gt;</code>来下载一个网页：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 启动 task：</span></span><br><span class="line">  Task&lt;<span class="built_in">string</span>&gt; task = Task.Factory.StartNew&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">    ( <span class="function"><span class="params">()</span> =&gt;</span> DownloadString (<span class="string">"http://www.gkarch.com"</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行其它工作，它会和 task 并行执行：</span></span><br><span class="line">  RunSomeOtherMethod();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 Result 属性获取返回值：</span></span><br><span class="line">  <span class="comment">// 如果仍在执行中, 当前进程会阻塞等待直到 task 结束：</span></span><br><span class="line">  <span class="built_in">string</span> result = task.Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">string</span> DownloadString (<span class="built_in">string</span> uri)</span><br><span class="line">&#123;</span><br><span class="line">  using (<span class="keyword">var</span> wc = <span class="keyword">new</span> System.Net.WebClient())</span><br><span class="line">    <span class="keyword">return</span> wc.DownloadString (uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这里的<code>&lt;string&gt;</code> 类型参数是为了示例的清晰，它可以被省略，让编译器推断。）</p><p>查询task的<code>Result</code>属性时，未处理的异常会被封装在[<code>AggregateException</code>]中自动重新抛出。然而，如果没有查询<code>Result</code>属性（并且也没有调用<code>Wait</code>），未处理的异常会令程序结束。</p><p>TPL 具有更多的特性，非常适合于利用多核处理器。关于 TPL 的讨论我们在[第 5 部分]中继续。</p><h3 id="3-2不通过-TPL-使用线程池"><a href="#3-2不通过-TPL-使用线程池" class="headerlink" title="3.2不通过 TPL 使用线程池"></a>3.2不通过 TPL 使用线程池</h3><p>如果是使用 .NET Framework 4.0 以前的版本，则不能使用任务并行库。你必须通过一种旧的构造使用线程池：<code>ThreadPool.QueueUserWorkItem</code>与异步委托。这两者之间的不同在于异步委托可以让你从线程中返回数据，同时异步委托还可以将异常封送回调用方。</p><h4 id="QueueUserWorkItem"><a href="#QueueUserWorkItem" class="headerlink" title="QueueUserWorkItem"></a>QueueUserWorkItem</h4><p>要使用<code>QueueUserWorkItem</code>，仅需要使用希望在线程池线程上运行的委托来调用该方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ThreadPool.QueueUserWorkItem (Go);</span><br><span class="line">  ThreadPool.QueueUserWorkItem (Go, <span class="number">123</span>);</span><br><span class="line">  Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span> (<span class="params"><span class="keyword">object</span> data</span>)   <span class="comment">// 第一次调用时 data 为 null</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Console.WriteLine (<span class="string">"Hello from the thread pool! "</span> + data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello <span class="built_in">from</span> <span class="keyword">the</span> thread pool!</span><br><span class="line">Hello <span class="built_in">from</span> <span class="keyword">the</span> thread pool! <span class="number">123</span></span><br></pre></td></tr></table></figure><p>目标方法<code>Go</code>，必须接受单一一个<code>object</code>参数（来满足<code>WaitCallback</code>委托）。这提供了一种向方法传递数据的便捷方式，就像<code>ParameterizedThreadStart</code>一样。与<code>Task</code>不同，<code>QueueUserWorkItem</code>并不会返回一个对象来帮助我们在后续管理其执行。并且，你必须在目标代码中显式处理异常，未处理的异常会[令程序结束]</p><h4 id="异步委托"><a href="#异步委托" class="headerlink" title="异步委托"></a>异步委托</h4><p><code>ThreadPool.QueueUserWorkItem</code>并没有提供在线程执行结束之后从线程中返回值的简单机制。异步委托调用（asynchronous delegate invocations ）解决了这一问题，可以允许双向传递任意数量的参数。而且，异步委托上的未处理异常可以方便的原线程上重新抛出（更确切的说，在调用<code>EndInvoke</code>的线程上），所以它们不需要显式处理。</p><p>不要混淆异步委托和异步方法（asynchronous methods ，以 <em>Begin</em> 或 <em>End</em> 开始的方法，比如<code>File.BeginRead</code>/<code>File.EndRead</code>）。异步方法表面上看使用了相似的方式，但是其实是为了解决更困难的问题。我们在<a href="http://www.albahari.com/nutshell/" target="_blank" rel="noopener">C# 4.0 in a Nutshell**</a>的第 23 章中描述。</p><p>下面是如何通过异步委托启动一个工作线程：</p><ol><li><p>创建目标方法的委托（通常是一个<code>Func</code>类型的委托）。</p></li><li><p>在该委托上调用<code>BeginInvoke</code>，保存其<code>IAsyncResult</code>类型的返回值。</p><p><code>BeginInvokde</code>会立即返回。当线程池线程正在工作时，你可以执行其它的动作。</p></li><li><p>当需要结果时，在委托上调用<code>EndInvoke</code>，传递所保存的<code>IAsyncResult</code>对象。</p></li></ol><p>接下来的例子中，我们使用异步委托调用来和主线程中并行运行一个返回字行串长度的简单方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; method = Work;</span><br><span class="line">  IAsyncResult cookie = method.BeginInvoke (<span class="string">"test"</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 这里可以并行执行其它任务</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">int</span> result = method.EndInvoke (cookie);</span><br><span class="line">  Console.WriteLine (<span class="string">"String length is: "</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Work</span> (<span class="params"><span class="keyword">string</span> s</span>) </span>&#123; <span class="keyword">return</span> s.Length; &#125;</span><br></pre></td></tr></table></figure><p><code>EndInvoke</code>会做三件事：</p><ol><li>如果异步委托还没有结束，它会等待异步委托完成执行。</li><li>它会接收返回值（也包括<code>ref</code>和<code>out</code>方式的参数）。</li><li>它会向调用线程抛出未处理的异常。</li></ol><blockquote><p>如果使用异步委托调用的方法没有返回值，技术上你仍然需要调用<code>EndInvoke</code>。在实践中，这里存在争论，因为不调用<code>EndInvoke</code>也不会有什么损失。然而如果你选择不调用它，就需要考虑目标方法中的异常处理来避免错误无法察觉。</p><p>（译者注：<a href="https://msdn.microsoft.com/zh-cn/library/2e08f6yc.aspx" target="_blank" rel="noopener">MSDN文档**</a>中明确写了 “无论您使用何种方法，都要调用 <strong>EndInvoke</strong> 来完成异步调用。”，所以最好不要偷懒。）</p></blockquote><p>当调用<code>BeginInvoke</code>时也可以指定一个回调委托。这是一个在完成时会被自动调用的、接受<code>IAsyncResult</code>对象的方法。这样可以在后面的代码中“忘记”异步委托，但是需要在回调方法里做点其它工作：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; method = Work;</span><br><span class="line">  method.BeginInvoke (<span class="string">"test"</span>, Done, method);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Work</span> (<span class="params"><span class="keyword">string</span> s</span>) </span>&#123; <span class="keyword">return</span> s.Length; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Done</span> (<span class="params">IAsyncResult cookie</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = (Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;) cookie.AsyncState;</span><br><span class="line">  <span class="keyword">int</span> result = target.EndInvoke (cookie);</span><br><span class="line">  Console.WriteLine (<span class="string">"String length is: "</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeginInvoke</code>的最后一个参数是一个用户状态对象，用于设置<code>IAsyncResult</code>的<code>AsyncState</code>属性。它可以是需要的任何东西，在这个例子中，我们用它向回调方法传递<code>method</code>委托，这样才能够在它上面调用<code>EndInvoke</code>。</p><h3 id="3-3优化线程池"><a href="#3-3优化线程池" class="headerlink" title="3.3优化线程池"></a>3.3优化线程池</h3><p>线程池初始时其池内只有一个线程。随着任务的分配，线程池管理器就会向池内“注入”新线程来满足工作负荷的需要，直到最大数量的限制。在足够的非活动时间之后，线程池管理器在认为“回收”一些线程能够带来更好的吞吐量时进行线程回收。</p><p>可以通过调用<code>ThreadPool.SetMaxThreads</code>方法来设置线程池可以创建的线程上限；默认如下：</p><ul><li>Framework 4.0，32位环境下：1023</li><li>Framework 4.0，64位环境下：32768</li><li>Framework 3.5：每个核心 250</li><li>Framework 2.0：每个核心 25</li></ul><p>（这些数字可能根据硬件和操作系统不同而有差异。）数量这么多是因为要确定[阻塞]（等待一些条件，比如远程计算机的相应）的线程的条件是否被满足。</p><p>也可以通过<code>ThreadPool.SetMinThreads</code>设置线程数量下限。下限的作用比较奇妙：它是一种高级的优化技术，用来指示线程池管理器在达到下限之前不要延迟线程的分配。当存在[阻塞]线程时，提高下限可以改善程序并发性。</p><p>默认下限数量是 CPU 核心数，也就是能充分利用 CPU 的最小数值。在服务器环境下（比如 IIS 中的 ASP.NET），下限数量一般要高的多，差不多 50 或者更高。</p><h4 id="最小线程数量是如何起作用的？"><a href="#最小线程数量是如何起作用的？" class="headerlink" title="最小线程数量是如何起作用的？"></a>最小线程数量是如何起作用的？</h4><blockquote><p><strong>将线程池的最小线程数设置为 <em>x</em> 并不是立即创建至少 <em>x</em> 个线程，而是线程会根据需要来创建。这个数值是指示线程池管理器当需要的时候，立即 创建 <em>x</em> 个线程</strong>。那么问题是为什么线程池在其它情况下会延迟创建线程？</p></blockquote><p>答案是为了防止短生命周期的任务导致线程数量短暂高峰，使程序的内存足迹（memory footprint）快速膨胀。为了描述这个问题，考虑在一个 4 核的计算机上运行一个客户端程序，它一次发起了 40 个任务请求。如果每个任务都是一个 10ms 的计算，假设它们平均分配在 4 个核心上，总共的开销就是 100ms 多。理想情况下，我们希望这 40 个任务运行在 <em>4</em> 个线程上：</p><ul><li>如果线程数量更少，就无法充分利用 4 个核心。</li><li>如果线程数量更多，会浪费内存和 CPU 时间去创建不必要的线程。</li></ul><p>线程池就是以这种方式工作的。让线程数量和 CPU 核心数量匹配，就能够既保持小的内存足迹，又不损失性能。当然这也需要线程都能被充分使用（在这个例子中满足该条件）。</p><p>但是，现在来假设任务不是进行 10ms 的计算，而是请求互联网，使用半秒钟等待响应，此时本地 CPU 是空闲状态。线程池管理器的线程经济策略（译者注：指上面说的线程数量匹配核心数）这时就不灵了，应该创建更多的线程，让所有的请求同时进行。</p><p>幸运的是，线程池管理器还有一个后备方案。如果在半秒内没有能够响应请求队列，就会再创建一个新的线程，以此类推，直到线程数量上限。</p><p><strong>半秒的等待时间是一把双刃剑。一方面它意味着一次性的短暂任务不会使程序快速消耗不必要的40MB（或者更多）的内存。另一方面，在线程池线程被阻塞时，比如在请求数据库或者调用<code>WebClient.DownloadFile</code>，就进行不必要的等待。</strong>因为这种原因，你可以通过调用<code>SetMinThreads</code>来让线程池管理器在分配最初的 <em>x</em> 个线程时不要等待，例如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.SetMinThreads (<span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>（第二个参数是表示多少个线程分配给 I/O 完成端口（I/O completion ports，IOCP），来被APM使用，这会在<a href="http://www.albahari.com/nutshell/" target="_blank" rel="noopener">C# 4.0 in a Nutshell**</a> 的第 23 章描述。）</p><p>最小线程数量的默认值是 CPU 核心数。</p><blockquote><p>总结：面对长时间等待的线程，因为这些线程只占时间，并不需要cpu计算，所以线程池管理器之前的平分策略就出现了问题，由此引入半秒等待机制，一旦此线程运行时间超过半秒就直接开启新的线程给新任务。但半秒等待机制还是存在利弊，利是防止很多线程的同时开启一下子占用大量内存，弊是必须等待半秒线程管理器才会开启新线程导致时间浪费，此时设置最小线程数量显得尤为重要，可以有效的防止等待，也不会占用很多内存（根据你自己的设置）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1简介及概念&quot;&gt;&lt;a href=&quot;#1简介及概念&quot; class=&quot;headerlink&quot; title=&quot;1简介及概念&quot;&gt;&lt;/a&gt;1简介及概念&lt;/h2&gt;&lt;p&gt;C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。&lt;/p&gt;
&lt;p&gt;一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：&lt;/p&gt;
    
    </summary>
    
      <category term="C#" scheme="https://luox78.github.io/categories/C/"/>
    
    
      <category term="thread" scheme="https://luox78.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>初识JavaScript01</title>
    <link href="https://luox78.github.io/2017/12/27/JavaScript01/"/>
    <id>https://luox78.github.io/2017/12/27/JavaScript01/</id>
    <published>2017-12-27T12:55:09.751Z</published>
    <updated>2018-01-01T11:38:56.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js作用域"><a href="#js作用域" class="headerlink" title="js作用域"></a>js作用域</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="actionscript">    &#125;               <span class="comment">//js没有块级作用域</span></span></span><br><span class="line"><span class="actionscript">    alert(i);       <span class="comment">//10</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">(parameters)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> n = <span class="number">1</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//因为页面一开始加载并不会执行f1方法</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//alert(n); undefined</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>默认如果直接在script标签中定义变量，则属于“全局作用域范围”(全局执行环境)，即属于window对象。<br>1 . 全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源<br>2 . 一个页面中的多个script标签中的变量可以互相访问。<br>3 . JS有垃圾回收机制，会定时对可释放资源的变量回收。将变量设置为null则表示可以被回收了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">name</span><span class="params">(parameters)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> i = <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined">        i++;</span></span><br><span class="line"><span class="undefined">        alert(i);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//方法无返回值，会返回undefined</span></span></span><br><span class="line"><span class="undefined">    alert(name());</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> i = <span class="number">1</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源</span></span></span><br><span class="line"><span class="actionscript">    alert(i);<span class="comment">//1</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法内部不使用var定义的变量相当于全局变量<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">(parameters)</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">        i = 100;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//var i = 100;</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    f1();</span></span><br><span class="line"><span class="actionscript">    alert(i);<span class="comment">//100</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//alert(i);使用未定义</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>js中switch中的判断是严格判断就是全等于（===）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> i = <span class="number">90</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">switch</span> (i) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="number">90</span>:</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"number"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">"90"</span>:</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"string"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">default</span>:</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="js类型转换"><a href="#js类型转换" class="headerlink" title="js类型转换"></a>js类型转换</h3><p>注意点：<br>    1 Number（）将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN<br>    2 String（）转换不成功返回undefined， toString（）报错<br>    3 Boolean（）转换当为0或为空（值为空或者null）时返回false，其余返回true<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">parseInt</span>(<span class="string">"90"</span>));              <span class="comment">//90</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">parseInt</span>(<span class="string">"90aaaaaaaaaa"</span>));    <span class="comment">//90</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">parseInt</span>(<span class="string">"aaaaaa"</span>));          <span class="comment">//NaN</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">parseInt</span>(<span class="number">111</span>, <span class="number">2</span>));            <span class="comment">//代表给定一个二进制的数111输出十进制</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">parseFloat</span>(<span class="number">10.111</span>));          <span class="comment">//10.111</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">Number</span>(<span class="string">"40addd"</span>));            <span class="comment">//将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//alert(isNaN("aaa"));              //true</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> str;</span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">String</span>(str));                 <span class="comment">//undefined</span></span></span><br><span class="line"><span class="actionscript">    alert(str.toString());              <span class="comment">//报错</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//boolean</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="string">""</span>); <span class="comment">//false - 空字符串</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">"hello"</span>); <span class="comment">//true - 非空字符串</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="number">50</span>); <span class="comment">//true - 非零数字</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">//false – null</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="number">0</span>); <span class="comment">//false - 零</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="keyword">new</span> object()); <span class="comment">//true - 对象 </span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;js作用域&quot;&gt;&lt;a href=&quot;#js作用域&quot; class=&quot;headerlink&quot; title=&quot;js作用域&quot;&gt;&lt;/a&gt;js作用域&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;    &amp;#125;               &lt;span class=&quot;comment&quot;&gt;//js没有块级作用域&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;    alert(i);       &lt;span class=&quot;comment&quot;&gt;//10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(parameters)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//因为页面一开始加载并不会执行f1方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;actionscript&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//alert(n); undefined&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://luox78.github.io/categories/JavaScript/"/>
    
    
      <category term="jsfoundation" scheme="https://luox78.github.io/tags/jsfoundation/"/>
    
  </entry>
  
  <entry>
    <title>LINQ</title>
    <link href="https://luox78.github.io/2017/12/26/Ten_LINQ_Myth/"/>
    <id>https://luox78.github.io/2017/12/26/Ten_LINQ_Myth/</id>
    <published>2017-12-26T14:34:53.555Z</published>
    <updated>2018-01-01T11:38:28.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-All-LINQ-queries-must-start-with-the-‘var’-keyword-In-fact-the-very-purpose-of-the-‘var’-keyword-is-to-start-a-LINQ-query"><a href="#1-All-LINQ-queries-must-start-with-the-‘var’-keyword-In-fact-the-very-purpose-of-the-‘var’-keyword-is-to-start-a-LINQ-query" class="headerlink" title="1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!"></a>1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] people = <span class="keyword">new</span> [] &#123; <span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> filteredPeople = people.Where (<span class="function"><span class="params">p</span> =&gt;</span> p.Length &gt; <span class="number">3</span>); </span><br><span class="line"><span class="comment">//is precisely equivalent to:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] people = <span class="keyword">new</span> [] &#123; <span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; filteredPeople = people.Where (<span class="function"><span class="params">p</span> =&gt;</span> p.Length &gt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-All-LINQ-queries-must-use-query-syntax"><a href="#2-All-LINQ-queries-must-use-query-syntax" class="headerlink" title="2 All LINQ queries must use query syntax."></a>2 All LINQ queries must use query syntax.</h2><ul><li><p><strong>lambda syntax</strong> </p></li><li><p><strong>query syntax</strong> </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Here's an <span class="built_in">example</span> of <span class="built_in">lambda</span> syntax:</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] people = <span class="built_in">new</span> [] &#123; <span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span> &#125;;</span><br><span class="line"><span class="built_in">var</span> filteredPeople = people.Where (p =&gt; p.Length &gt; <span class="number">3</span>); </span><br><span class="line">Here's the same thing expressed <span class="keyword">in</span> query syntax:</span><br><span class="line"></span><br><span class="line">//<span class="built_in">string</span>[] people = <span class="built_in">new</span> [] &#123; <span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span> &#125;;</span><br><span class="line"><span class="built_in">var</span> filteredPeople = from p <span class="keyword">in</span> people where p.Length &gt; <span class="number">3</span> select p;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-To-retrieve-all-customers-from-the-customer-table-you-must-perform-a-query-similar-to-the-following"><a href="#3-To-retrieve-all-customers-from-the-customer-table-you-must-perform-a-query-similar-to-the-following" class="headerlink" title="3 To retrieve all customers from the customer table, you must perform a query similar to the following:"></a>3 To retrieve all customers from the customer table, you must perform a query similar to the following:</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">The expression:</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> c <span class="keyword">in</span> db.Customers select c </span><br><span class="line">is a frivolous query! You can simply go:</span><br><span class="line"></span><br><span class="line">db.Customers</span><br><span class="line">Similarly, the following LINQ <span class="keyword">to</span> XML query:</span><br><span class="line"></span><br><span class="line">var xe = <span class="keyword">from</span> e <span class="keyword">in</span> myXDocument.Descendants (<span class="string">"phone"</span>) select e;</span><br><span class="line">can be simplified <span class="keyword">to</span>:</span><br><span class="line"></span><br><span class="line">var xe = myXDocument.Descendants (<span class="string">"phone"</span>);</span><br><span class="line"><span class="keyword">And</span> this:</span><br><span class="line"></span><br><span class="line">Customer<span class="built_in"> customer </span>= (<span class="keyword">from</span> c <span class="keyword">in</span> db.Customers where c.ID == 123 select c)</span><br><span class="line">                    .Single();</span><br><span class="line">can be simplified <span class="keyword">to</span>:</span><br><span class="line"></span><br><span class="line">Customer<span class="built_in"> customer </span>= db.Customers.Single (c =&gt; c.ID == 123);</span><br></pre></td></tr></table></figure><h2 id="4-A-LINQ-to-SQL-or-EF-query-will-be-executed-in-one-round-trip-only-if-the-query-was-built-in-a-single-step"><a href="#4-A-LINQ-to-SQL-or-EF-query-will-be-executed-in-one-round-trip-only-if-the-query-was-built-in-a-single-step" class="headerlink" title="4 A LINQ to SQL or EF query will be executed in one round-trip only if the query was built in a single step."></a>4 A LINQ to SQL or EF query will be executed in one round-trip only if the query was built in a single step.</h2><p>LINQ follows a lazy evaluation model, which means queries execute not when constructed, but when enumerated. This means you can build up a query in as many steps as you like, and it won’t actually hit the server until you eventually start consuming the results.</p><p>For instance, the following query retrieves the names of all customers whose name starts with the letter ‘A’, and who have made at least two purchases. We build this query in three steps:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">query</span> = <span class="keyword">db</span>.Customers.Where (c =&gt; c.Name.StartsWith (<span class="string">"A"</span>));</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.Where (c =&gt; c.Purchases.<span class="keyword">Count</span>() &gt;= 2);</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">query</span>.Select (c =&gt; c.Name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (string name <span class="keyword">in</span> result)   <span class="comment">// Only now is the query executed!</span></span><br><span class="line">   Console.WriteLine (name);</span><br></pre></td></tr></table></figure></p><h2 id="5-Because-SQL-emits-flat-result-sets-LINQ-queries-must-be-structured-to-emit-flat-result-sets-too"><a href="#5-Because-SQL-emits-flat-result-sets-LINQ-queries-must-be-structured-to-emit-flat-result-sets-too" class="headerlink" title="5 Because SQL emits flat result sets, LINQ queries must be structured to emit flat result sets, too."></a>5 Because SQL emits flat result sets, LINQ queries must be structured to emit flat result sets, too.</h2><p>For example, if you want to retrieve the names of customers in the state of WA along with all their purchases, you can simply do the following:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from c <span class="keyword">in</span> db.Customers</span><br><span class="line">where c<span class="selector-class">.State</span> == <span class="string">"WA"</span></span><br><span class="line">select new</span><br><span class="line">&#123;</span><br><span class="line">   c<span class="selector-class">.Name</span>,</span><br><span class="line">   c<span class="selector-class">.Purchases</span>    <span class="comment">// An EntitySet (collection)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The hierarchical result from this query is much easier to work with than a flat result set!</p><p>We can achieve the same result without association properties as follows:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from c <span class="keyword">in</span> db.Customers</span><br><span class="line">where c<span class="selector-class">.State</span> == <span class="string">"WA"</span></span><br><span class="line">select new</span><br><span class="line">&#123;</span><br><span class="line">   c<span class="selector-class">.Name</span>,</span><br><span class="line">   Purchases = db<span class="selector-class">.Purchases</span><span class="selector-class">.Where</span> (<span class="selector-tag">p</span> =&gt; <span class="selector-tag">p</span><span class="selector-class">.CustomerID</span> == c.ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-All-LINQ-queries-must-start-with-the-‘var’-keyword-In-fact-the-very-purpose-of-the-‘var’-keyword-is-to-start-a-LINQ-query&quot;&gt;&lt;a href=&quot;#1-All-LINQ-queries-must-start-with-the-‘var’-keyword-In-fact-the-very-purpose-of-the-‘var’-keyword-is-to-start-a-LINQ-query&quot; class=&quot;headerlink&quot; title=&quot;1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!&quot;&gt;&lt;/a&gt;1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!&lt;/h2&gt;&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;[] people = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; [] &amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;Tom&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Dick&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Harry&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; filteredPeople = people.Where (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;p&lt;/span&gt; =&amp;gt;&lt;/span&gt; p.Length &amp;gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//is precisely equivalent to:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;[] people = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; [] &amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;Tom&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Dick&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Harry&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IEnumerable&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt; filteredPeople = people.Where (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;p&lt;/span&gt; =&amp;gt;&lt;/span&gt; p.Length &amp;gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="C#" scheme="https://luox78.github.io/categories/C/"/>
    
    
      <category term="LINQ" scheme="https://luox78.github.io/tags/LINQ/"/>
    
  </entry>
  
  <entry>
    <title>C#6 特性</title>
    <link href="https://luox78.github.io/2017/12/26/CS6/"/>
    <id>https://luox78.github.io/2017/12/26/CS6/</id>
    <published>2017-12-26T12:27:56.003Z</published>
    <updated>2018-01-01T11:37:40.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Name = &quot;Jack&quot;; </span><br><span class="line">var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="空操作符"><a href="#空操作符" class="headerlink" title="空操作符 ( ?. )"></a>空操作符 ( ?. )</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span> &amp;&amp; user.<span class="keyword">Project</span> != <span class="keyword">null</span> &amp;&amp; user.<span class="keyword">Project</span>.Tasks != <span class="keyword">null</span> &amp;&amp; user.<span class="keyword">Project</span>.Tasks.<span class="keyword">Count</span> &gt; <span class="number">0</span>) </span><br><span class="line">&#123; </span><br><span class="line">   Console.<span class="keyword">WriteLine</span>(user.<span class="keyword">Project</span>.Tasks.First().Name); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//现在</span></span><br><span class="line">Console.<span class="keyword">WriteLine</span>(user?.<span class="keyword">Project</span>?.Tasks?.First()?.Name);</span><br></pre></td></tr></table></figure><blockquote><p>注意： 上面的代码虽然可以让我们少些很多代码，而且也减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常，那么使用这个特性反而隐藏了Bug </p></blockquote><h2 id="NameOf"><a href="#NameOf" class="headerlink" title="NameOf"></a>NameOf</h2><p>利用nameof减少手写带来的错误</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">"nameof(Person)"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式方法体"><a href="#表达式方法体" class="headerlink" title="表达式方法体"></a>表达式方法体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">SayHello</span><span class="params">()</span> </span>=&gt; <span class="string">"Hello World"</span>;</span><br></pre></td></tr></table></figure><h2 id="自动属性初始化器"><a href="#自动属性初始化器" class="headerlink" title="自动属性初始化器"></a>自动属性初始化器</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        Age = <span class="number">100</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//现在</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//同时增加了只读属性初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; &#125; = <span class="number">100</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Index-初始化器"><a href="#Index-初始化器" class="headerlink" title="Index 初始化器"></a>Index 初始化器</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; </span><br><span class="line">       &#123; </span><br><span class="line">           [<span class="meta">1</span>] = <span class="string">"Jack"</span>, </span><br><span class="line">           [<span class="meta">2</span>] = <span class="string">"Alex"</span>, </span><br><span class="line">           [<span class="meta">3</span>] = <span class="string">"Eric"</span>, </span><br><span class="line">           [<span class="meta">4</span>] = <span class="string">"Jo"</span> </span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure><h2 id="using-静态类的方法可以使用-static-using"><a href="#using-静态类的方法可以使用-static-using" class="headerlink" title="using 静态类的方法可以使用 static using"></a>using 静态类的方法可以使用 static using</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Math; </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharp6NewFeatures</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">class</span> <span class="title">Program</span> </span><br><span class="line">  &#123; </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span></span><br><span class="line"><span class="function">     </span>&#123; </span><br><span class="line">        Console.WriteLine(Log10(<span class="number">5</span>)+PI); </span><br><span class="line">     &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串拼接&quot;&gt;&lt;a href=&quot;#字符串拼接&quot; class=&quot;headerlink&quot; title=&quot;字符串拼接&quot;&gt;&lt;/a&gt;字符串拼接&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var Name = &amp;quot;Jack&amp;quot;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var results = $&amp;quot;Hello &amp;#123;Name&amp;#125;&amp;quot;; ## 空操作符&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="C#" scheme="https://luox78.github.io/categories/C/"/>
    
    
      <category term="C#特性" scheme="https://luox78.github.io/tags/C-%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>C#7 特性</title>
    <link href="https://luox78.github.io/2017/12/26/CS7/"/>
    <id>https://luox78.github.io/2017/12/26/CS7/</id>
    <published>2017-12-25T16:01:58.230Z</published>
    <updated>2017-12-27T15:15:16.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地方法（Local-functions）"><a href="#本地方法（Local-functions）" class="headerlink" title="本地方法（Local functions）"></a>本地方法（Local functions）</h2><p><strong>有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为</strong></p><p><strong>（local function）：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci(int x) </span><br><span class="line">&#123; </span><br><span class="line">    if (x &lt; 0) throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x)); </span><br><span class="line">    return Fib(x).current; </span><br><span class="line"> </span><br><span class="line">(int current, int previous) Fib(int i) </span><br><span class="line">    &#123; </span><br><span class="line">        if (i == 0) return (1, 0); </span><br><span class="line">        var (p, pp) = Fib(i - 1); </span><br><span class="line">        return (p + pp, p); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="元组（Tuples）"><a href="#元组（Tuples）" class="headerlink" title="元组（Tuples）"></a>元组（Tuples）</h2><p>我们经常希望能从一个方法中返回一个以上的结果。旧版本的 C#中的选项远远达不到令人满意的程度： </p><ol><li>Out 参数： 使用起来很笨拙（哪怕你使用了上面所述的改进），并且无法在 async 方法中使用。 </li><li>System.Tuple&lt;…&gt; 返回类型： 用起来很啰嗦，并且需要分配一个元组对象。 </li><li>自定义每个方法的传输类型： 需要用一大堆代码来实现一个类，而目的仅仅是临时打包几个变量。 </li><li>通过动态类型返回匿名类： 性能有瓶颈，且没有静态类型检查。 </li></ol><p>为了在这方面做得更好，C# 7.0 加入了元组类型（tuple types）和元组字面量（tupleliterals）： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(string, string, string) LookupName(long id) // 元组返回类型 </span><br><span class="line">&#123; </span><br><span class="line">     // 从数据储存中取出第一个、中间和最后一个数据 </span><br><span class="line">    return (first, middle, last); // 元组字面量 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法现在会很有效率地返回三个字符串，包装成一个元组值中的元素。 </p><p>方法的调用者将会收到一个元组，并可以分别访问各个元素： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var names = LookupName(id); </span><br><span class="line"></span><br><span class="line">WriteLine($&quot;found &#123;names.Item1&#125;&#123;names.Item3&#125;.&quot;);</span><br></pre></td></tr></table></figure><p>Item1等是元组元素的默认名称，并且总是可用的。但是这样描述性不是非常好，因此你可以选择性地使用另一种更好的方法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(string first, string middle, string last)LookupName(long id) // 元组元素拥有了名称 </span><br><span class="line">//现在元组的接收者可以使用更具描述性的名字了： </span><br><span class="line">var names = LookupName(id); </span><br><span class="line">WriteLine($&quot;found &#123;names.first&#125;&#123;names.last&#125;.&quot;); </span><br><span class="line">//你也可以直接在元组字面量中指定元素名称： </span><br><span class="line">return (first: first, middle: middle,last: last); // 在字面量中命名元组元素</span><br></pre></td></tr></table></figure><p>通常来说你可以无视名字而将元组类型互相转换：只要每个元素之间是可转换的（assignable），元组类型即可自由地互相转换。 </p><p>元组是值类型，它们的元素是简单的公共、可修改的字段。它们具有值相等性，意味着如果两个元组间每个元素两两相等（且拥有相同的哈希值）则两个元组相等（且拥有相同的哈希值）。 </p><p>这使得元组在多返回值之外的许多场景也很有用。例如，如果你需要一个拥有多个键的字典，使用一个元组作为你的键，一切都会正常运行。如果你需要一个每个位置有多个值的列表，使用元组吧，诸如搜索列表这样的功能将会正确的工作。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本地方法（Local-functions）&quot;&gt;&lt;a href=&quot;#本地方法（Local-functions）&quot; class=&quot;headerlink&quot; title=&quot;本地方法（Local functions）&quot;&gt;&lt;/a&gt;本地方法（Local functions）&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（local function）：&lt;/strong&gt; &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public int Fibonacci(int x) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (x &amp;lt; 0) throw new ArgumentException(&amp;quot;Less negativity please!&amp;quot;, nameof(x)); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return Fib(x).current; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	(int current, int previous) Fib(int i) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (i == 0) return (1, 0); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var (p, pp) = Fib(i - 1); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return (p + pp, p); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="C#" scheme="https://luox78.github.io/categories/C/"/>
    
    
      <category term="C#特性" scheme="https://luox78.github.io/tags/C-%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luox78.github.io/2017/12/25/hello-world/"/>
    <id>https://luox78.github.io/2017/12/25/hello-world/</id>
    <published>2017-12-25T13:51:57.623Z</published>
    <updated>2017-12-27T15:14:33.446Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
