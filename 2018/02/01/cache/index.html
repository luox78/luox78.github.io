<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>细说 ASP.NET Cache 及其高级用法 | luox78</title>
  <meta name="description" content="Blog for luox78" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="theme-color" content=" rgb(59,95,208)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <link rel="shortcut icon" href="/images/dev.ico">
  <link rel="alternate" href="/atom.xml" title="luox78">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="许多做过程序性能优化的人，或者关注过程程序性能的人，应该都使用过各类缓存技术。 而我今天所说的Cache是专指ASP.NET的Cache，我们可以使用HttpRuntime.Cache访问到的那个Cache，而不是其它的缓存技术。 以前我在【我心目中的Asp.net核心对象】 这篇博客中简单地提过它，今天我打算为它写篇专题博客，专门来谈谈它，因为它实在是太重要了。在这篇博客中， 我不仅要介绍它的一">
<meta name="keywords" content="cache">
<meta property="og:type" content="article">
<meta property="og:title" content="细说 ASP.NET Cache 及其高级用法">
<meta property="og:url" content="https://luox78.github.io/2018/02/01/cache/index.html">
<meta property="og:site_name" content="luox78">
<meta property="og:description" content="许多做过程序性能优化的人，或者关注过程程序性能的人，应该都使用过各类缓存技术。 而我今天所说的Cache是专指ASP.NET的Cache，我们可以使用HttpRuntime.Cache访问到的那个Cache，而不是其它的缓存技术。 以前我在【我心目中的Asp.net核心对象】 这篇博客中简单地提过它，今天我打算为它写篇专题博客，专门来谈谈它，因为它实在是太重要了。在这篇博客中， 我不仅要介绍它的一">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2011/281816/2011122722172062.gif">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2011/281816/2011123011080183.gif">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2011/281816/2011123011083424.gif">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2011/281816/2011123011085942.gif">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2011/281816/2011122722184225.gif">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:image" content="https://pic002.cnblogs.com/images/2011/281816/2011122722185820.gif">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
<meta property="og:updated_time" content="2018-02-03T05:40:45.773Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="细说 ASP.NET Cache 及其高级用法">
<meta name="twitter:description" content="许多做过程序性能优化的人，或者关注过程程序性能的人，应该都使用过各类缓存技术。 而我今天所说的Cache是专指ASP.NET的Cache，我们可以使用HttpRuntime.Cache访问到的那个Cache，而不是其它的缓存技术。 以前我在【我心目中的Asp.net核心对象】 这篇博客中简单地提过它，今天我打算为它写篇专题博客，专门来谈谈它，因为它实在是太重要了。在这篇博客中， 我不仅要介绍它的一">
<meta name="twitter:image" content="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/style.css">
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
</head>

<body>
  <div id="loading">
    <div id="loading-center">
    <div id="loading-center-absolute">
    <div class="object" id="object_one"></div>
    <div class="object" id="object_two"></div>
    <div class="object" id="object_three"></div>
    <div class="object" id="object_four"></div>
    <div class="object" id="object_five"></div>
    <div class="object" id="object_six"></div>
    <div class="object" id="object_seven"></div>
    <div class="object" id="object_eight"></div>
    <div class="object" id="object_big"></div>
    </div>
    </div>
     
    </div>
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				luox78
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/about.html'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="/about.html" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <!-- <script>
      var count=0;
      function setLoadingBarProgress() {
          if(count==100){
              count=0;
          }
          document.getElementById('loading-bar').style.width = count + "%";
      }
  </script> -->
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-cache"
	class="post white-box article-type-post"
	itemscope itemprop="blogPost">
<section class='meta'>
 <h2 class="title">
		 <a href="/2018/02/01/cache/">
				 细说 ASP.NET Cache 及其高级用法
		 </a>
 </h2>
 <time>
		 Feb 1, 2018
 </time>
 
    
    <div class='cats'>
        <a href="/categories/ASP-NET/">ASP.NET</a>
    </div>

 <span id="busuanzi_container_page_pv">
		 
		<a href="javascript:void(0)" class="read_cats">本文总阅读量:<span id="busuanzi_value_page_pv"></span>
		</a>
 </span>
</section>

<section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Cache的基本用途"><span class="toc-number">1.</span> <span class="toc-text">Cache的基本用途</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cache的定义"><span class="toc-number">2.</span> <span class="toc-text">Cache的定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cache常见用法"><span class="toc-number">3.</span> <span class="toc-text">Cache常见用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cache类的特点"><span class="toc-number">4.</span> <span class="toc-text">Cache类的特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存项的过期时间"><span class="toc-number">5.</span> <span class="toc-text">缓存项的过期时间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存项的依赖关系-依赖其它缓存项"><span class="toc-number">6.</span> <span class="toc-text">缓存项的依赖关系 - 依赖其它缓存项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存项的依赖关系-文件依赖"><span class="toc-number">7.</span> <span class="toc-text">缓存项的依赖关系 - 文件依赖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存项的移除优先级"><span class="toc-number">8.</span> <span class="toc-text">缓存项的移除优先级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存项的移除通知"><span class="toc-number">9.</span> <span class="toc-text">缓存项的移除通知</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#巧用缓存项的移除通知-实现【延迟操作】"><span class="toc-number">10.</span> <span class="toc-text">巧用缓存项的移除通知 实现【延迟操作】</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#巧用缓存项的移除通知-实现【自动加载配置文件】"><span class="toc-number">11.</span> <span class="toc-text">巧用缓存项的移除通知 实现【自动加载配置文件】</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#文件监视技术的选择"><span class="toc-number">12.</span> <span class="toc-text">文件监视技术的选择</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#各种缓存方案的共存"><span class="toc-number">13.</span> <span class="toc-text">各种缓存方案的共存</span></a></li></ol></section>

<section class="article typo">
 <div class="article-entry" itemprop="articleBody">
		 <p>许多做过程序性能优化的人，或者关注过程程序性能的人，应该都使用过各类缓存技术。 而我今天所说的Cache是专指ASP.NET的Cache，我们可以使用HttpRuntime.Cache访问到的那个Cache，而不是其它的缓存技术。</p>
<p>以前我在<a href="http://www.cnblogs.com/fish-li/archive/2011/08/21/2148640.html" target="_blank" rel="noopener">【我心目中的Asp.net核心对象】</a> 这篇博客中简单地提过它，今天我打算为它写篇专题博客，专门来谈谈它，因为它实在是太重要了。在这篇博客中， 我不仅要介绍它的一些常见用法，还将介绍它的一些高级用法。 在上篇博客<a href="http://www.cnblogs.com/fish-li/archive/2011/12/18/2292037.html" target="_blank" rel="noopener">【在.net中读写config文件的各种方法】</a> 的结尾处，我给大家留了一个问题，今天，我将在这篇博客中给出一个我认为较为完美的答案。</p>
<p>本文提到的【延迟操作】方法（如：延迟合并写入数据库）属于我的经验总结，希望大家能喜欢这个思路。<br><a id="more"></a><br><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="Cache的基本用途"><a href="#Cache的基本用途" class="headerlink" title="Cache的基本用途"></a>Cache的基本用途</h1><p>提到Cache，不得不说说它的主要功能：改善程序性能。<br>ASP.NET是一种动态页面技术，用ASP.NET技术做出来的网页几乎都是动态的，所谓动态是指：页面的内容会随着不同的用户或者持续更新的数据， 而呈现出不同的显示结果。既然是动态的，那么这些动态的内容是从哪里来的呢？我想绝大多数网站都有自己的数据源， 程序通过访问数据源获取页面所需的数据，然后根据一些业务规则的计算处理，最后变成适合页面展示的内容。</p>
<p>由于这种动态页面技术通常需要从数据源获取数据，并经过一些计算逻辑，最终变成一些HTML代码发给客户端显示。而这些计算过程显然也是有成本的。 这些处理成本最直接可表现为影响服务器的响应速度，尤其是当数据的处理过程变得复杂以及访问量变大时，会变得比较明显。 另一方面，有些数据并非时刻在发生变化，如果我们可以将一些变化不频繁的数据的最终计算结果（包括页面输出）缓存起来， 就可以非常明显地提升程序的性能，缓存的最常见且最重要的用途就体现在这个方面。 这也是为什么一说到性能优化时，一般都将缓存摆在第一位的原因。 我今天要说到的ASP.NET Cache也是可以实现这种缓存的一种技术。 不过，它还有其它的一些功能，有些是其它缓存技术所没有的。</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="Cache的定义"><a href="#Cache的定义" class="headerlink" title="Cache的定义"></a>Cache的定义</h1><p>在介绍Cache的用法前，我们先来看一下Cache的定义：（说明：我忽略了一些意义不大的成员） <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现用于 Web 应用程序的缓存。无法继承此类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Cache</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用于 Cache.Insert(...) 方法调用中的 absoluteExpiration 参数中以指示项从不过期。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DateTime NoAbsoluteExpiration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用作 Cache.Insert(...) 或 Cache.Add(...)</span></span><br><span class="line">    <span class="comment">//       方法调用中的 slidingExpiration 参数，以禁用可调过期。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> TimeSpan NoSlidingExpiration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取或设置指定键处的缓存项。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> <span class="keyword">this</span>[<span class="keyword">string</span> key] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指定项添加到 System.Web.Caching.Cache 对象，该对象具有依赖项、过期和优先级策略</span></span><br><span class="line">    <span class="comment">// 以及一个委托（可用于在从 Cache 移除插入项时通知应用程序）。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Add</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">object</span> <span class="keyword">value</span>, CacheDependency dependencies,</span></span></span><br><span class="line"><span class="function"><span class="params">                        DateTime absoluteExpiration, TimeSpan slidingExpiration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        CacheItemPriority priority, CacheItemRemovedCallback onRemoveCallback</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 System.Web.Caching.Cache 对象检索指定项。</span></span><br><span class="line">    <span class="comment">// key: 要检索的缓存项的标识符。</span></span><br><span class="line">    <span class="comment">// 返回结果: 检索到的缓存项，未找到该键时为 null。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> key</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">object</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">object</span> <span class="keyword">value</span>, CacheDependency dependencies</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">object</span> <span class="keyword">value</span>, CacheDependency dependencies,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    DateTime absoluteExpiration, TimeSpan slidingExpiration</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     向 System.Web.Caching.Cache 对象中插入对象，后者具有依赖项、过期和优先级策略</span></span><br><span class="line">    <span class="comment">//        以及一个委托（可用于在从 Cache 移除插入项时通知应用程序）。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 参数:</span></span><br><span class="line">    <span class="comment">//   key:</span></span><br><span class="line">    <span class="comment">//     用于引用该对象的缓存键。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   value:</span></span><br><span class="line">    <span class="comment">//     要插入缓存中的对象。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   dependencies:</span></span><br><span class="line">    <span class="comment">//     该项的文件依赖项或缓存键依赖项。当任何依赖项更改时，该对象即无效，</span></span><br><span class="line">    <span class="comment">//            并从缓存中移除。如果没有依赖项，则此参数包含 null。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   absoluteExpiration:</span></span><br><span class="line">    <span class="comment">//     所插入对象将过期并被从缓存中移除的时间。</span></span><br><span class="line">    <span class="comment">//        如果使用绝对过期，则 slidingExpiration 参数必须为 Cache.NoSlidingExpiration。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   slidingExpiration:</span></span><br><span class="line">    <span class="comment">//     最后一次访问所插入对象时与该对象过期时之间的时间间隔。如果该值等效于 20 分钟，</span></span><br><span class="line">    <span class="comment">//       则对象在最后一次被访问 20 分钟之后将过期并被从缓存中移除。如果使用可调过期，则</span></span><br><span class="line">    <span class="comment">//     absoluteExpiration 参数必须为 System.Web.Caching.Cache.NoAbsoluteExpiration。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   priority:</span></span><br><span class="line">    <span class="comment">//     该对象相对于缓存中存储的其他项的成本，由 System.Web.Caching.CacheItemPriority 枚举表示。</span></span><br><span class="line">    <span class="comment">//       该值由缓存在退出对象时使用；具有较低成本的对象在具有较高成本的对象之前被从缓存移除。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   onRemoveCallback:</span></span><br><span class="line">    <span class="comment">//     在从缓存中移除对象时将调用的委托（如果提供）。</span></span><br><span class="line">    <span class="comment">//            当从缓存中删除应用程序的对象时，可使用它来通知应用程序。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 异常:</span></span><br><span class="line">    <span class="comment">//   System.ArgumentException:</span></span><br><span class="line">    <span class="comment">//     为要添加到 Cache 中的项设置 absoluteExpiration 和 slidingExpiration 参数。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   System.ArgumentNullException:</span></span><br><span class="line">    <span class="comment">//     key 或 value 参数为 null。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   System.ArgumentOutOfRangeException:</span></span><br><span class="line">    <span class="comment">//     将 slidingExpiration 参数设置为小于 TimeSpan.Zero 或大于一年的等效值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">object</span> <span class="keyword">value</span>, CacheDependency dependencies,</span></span></span><br><span class="line"><span class="function"><span class="params">                        DateTime absoluteExpiration, TimeSpan slidingExpiration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        CacheItemPriority priority, CacheItemRemovedCallback onRemoveCallback</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从应用程序的 System.Web.Caching.Cache 对象移除指定项。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Remove</span>(<span class="params"><span class="keyword">string</span> key</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将对象与依赖项策略、到期策略和优先级策略</span></span><br><span class="line">    <span class="comment">// 以及可用来在从缓存中移除项【之前】通知应用程序的委托一起插入到 Cache 对象中。</span></span><br><span class="line">    <span class="comment">// 注意：此方法受以下版本支持：3.5 SP1、3.0 SP1、2.0 SP1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">object</span> <span class="keyword">value</span>, CacheDependency dependencies,</span></span></span><br><span class="line"><span class="function"><span class="params">                            DateTime absoluteExpiration, TimeSpan slidingExpiration,</span></span></span><br><span class="line"><span class="function"><span class="params">                            CacheItemUpdateCallback onUpdateCallback</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASP.NET为了方便我们访问Cache，在HttpRuntime类中加了一个静态属性Cache，这样，我们就可以在任意地方使用Cache的功能。 而且，ASP.NET还给它增加了二个“快捷方式”：Page.Cache, HttpContext.Cache，我们通过这二个对象也可以访问到HttpRuntime.Cache， 注意：这三者是在访问同一个对象。Page.Cache访问了HttpContext.Cache，而HttpContext.Cache又直接访问HttpRuntime.Cache</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="Cache常见用法"><a href="#Cache常见用法" class="headerlink" title="Cache常见用法"></a>Cache常见用法</h1><p>通常，我们使用Cache时，一般只有二个操作：读，写。<br>要从Cache中获取一个缓存项，我们可以调用Cache.Get(key)方法，要将一个对象放入缓存，我们可以调用Add, Insert方法。 然而，Add, Insert方法都有许多参数，有时我们或许只是想简单地放入缓存，一切接受默认值，那么还可以调用它的默认索引器， 我们来看一下这个索引器是如何工作的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> <span class="keyword">this</span>[string key]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Insert(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：读缓存，其实是在调用Get方法，而写缓存则是在调用Insert方法的最简单的那个重载版本。</p>
<p>注意了：Add方法也可以将一个对象放入缓存，这个方法有7个参数，而Insert也有一个签名类似的重载版本， 它们有着类似的功能：<strong>将指定项添加到 System.Web.Caching.Cache 对象，该对象具有依赖项、过期和优先级策略以及一个委托（可用于在从 Cache 移除插入项时通知应用程序）。</strong> 然而，它们有一点小的区别：<strong>当要加入的缓存项已经在Cache中存在时，Insert将会覆盖原有的缓存项目，而Add则不会修改原有缓存项。</strong></p>
<p>也就是说：如果您希望某个缓存项目一旦放入缓存后，就不要再被修改，那么调用Add确实可以防止后来的修改操作。 而调用Insert方法，则永远会覆盖已存在项（哪怕以前是调用Add加入的）。</p>
<p>从另一个角度看，Add的效果更像是 static readonly 的行为，而Insert的效果则像 static 的行为。<br>注意：我只是说【像】，事实上它们比一般的static成员有着更灵活的用法。</p>
<p>由于缓存项可以让我们随时访问，看起来确实有点static成员的味道，但它们有着更高级的特性，比如： 缓存过期（绝对过期，滑动过期），缓存依赖（依赖文件，依赖其它缓存项），移除优先级，缓存移除前后的通知等等。 后面我将会分别介绍这四大类特性。</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="Cache类的特点"><a href="#Cache类的特点" class="headerlink" title="Cache类的特点"></a>Cache类的特点</h1><p>Cache类有一个很难得的优点，用MSDN上的说话就是：</p>
<p>此类型是线程安全的。</p>
<p>为什么这是个难得的优点呢？因为在.net中，绝大多数类在实现时，都只是保证静态类型的方法是线程安全， 而不考虑实例方法是线程安全。这也算是一条基本的.NET设计规范原则。<br>对于那些类型，MSDN通常会用这样的话来描述：</p>
<p>此类型的公共静态（在 Visual Basic 中为 Shared）成员是线程安全的。但不能保证任何实例成员是线程安全的。</p>
<p>所以，这就意味着我们可以在任何地方读写Cache都不用担心Cache的数据在多线程环境下的数据同步问题。 多线程编程中，最复杂的问题就是数据的同步问题，而Cache已经为我们解决了这些问题。</p>
<p>不过我要提醒您：ASP.NET本身就是一个多线程的编程模型，所有的请求是由线程池的线程来处理的。 通常，我们在多线程环境中为了解决数据同步问题，一般是采用锁来保证数据同步， 自然地，ASP.NET也不例外，它为了解决数据的同步问题，内部也是采用了锁。</p>
<p>说到这里，或许有些人会想：既然只一个Cache的静态实例，那么这种锁会不会影响并发？<br>答案是肯定的，有锁肯定会在一定程度上影响并发，这是没有办法的事情。<br>然而，ASP.NET在实现Cache时，会根据CPU的个数创建多个缓存容器，尽量可能地减小冲突， 以下就是Cache创建的核心过程：<a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">internal static <span class="keyword">CacheInternal </span>Create()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">CacheInternal </span>internal2<span class="comment">;</span></span><br><span class="line">    int numSingleCaches = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    if( numSingleCaches == <span class="number">0</span> ) &#123;</span><br><span class="line">        uint numProcessCPUs = (uint)SystemInfo.GetNumProcessCPUs()<span class="comment">;</span></span><br><span class="line">        numSingleCaches = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        for( numProcessCPUs -= <span class="number">1</span><span class="comment">; numProcessCPUs &gt; 0; numProcessCPUs = numProcessCPUs &gt;&gt; 1 ) &#123;</span></span><br><span class="line">            numSingleCaches = numSingleCaches &lt;&lt; <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">CacheCommon </span><span class="keyword">cacheCommon </span>= new <span class="keyword">CacheCommon();</span></span><br><span class="line"><span class="keyword"> </span>   if( numSingleCaches == <span class="number">1</span> ) &#123;</span><br><span class="line">        internal2 = new <span class="keyword">CacheSingle(cacheCommon, </span>null, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        internal2 = new <span class="keyword">CacheMultiple(cacheCommon, </span>numSingleCaches)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">cacheCommon.SetCacheInternal(internal2);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">cacheCommon.ResetFromConfigSettings();</span></span><br><span class="line"><span class="keyword"> </span>   return internal2<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：CacheInternal是个内部用的包装类，Cache的许多操作都要由它来完成。</p>
<p>在上面的代码中，numSingleCaches的计算过程很重要，如果上面代码不容易理解，那么请看我下面的示例代码： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">uint</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ )</span><br><span class="line">        ShowCount(i);            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowCount</span>(<span class="params"><span class="keyword">uint</span> numProcessCPUs</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numSingleCaches = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( numProcessCPUs -= <span class="number">1</span>; numProcessCPUs &gt; <span class="number">0</span>; numProcessCPUs = numProcessCPUs &gt;&gt; <span class="number">1</span> ) &#123;</span><br><span class="line">        numSingleCaches = numSingleCaches &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Write(numSingleCaches + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序将会输出：</p>
<p>1,2,4,4,8,8,8,8,16,16,16,16,16,16,16,16,32,32,32,32</p>
<p>CacheMultiple的构造函数如下：<a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="title">CacheMultiple</span>(<span class="params">CacheCommon cacheCommon, <span class="keyword">int</span> numSingleCaches</span>) : <span class="title">base</span>(<span class="params">cacheCommon</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._cacheIndexMask = numSingleCaches - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>._caches = <span class="keyword">new</span> CacheSingle[numSingleCaches];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numSingleCaches; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._caches[i] = <span class="keyword">new</span> CacheSingle(cacheCommon, <span class="keyword">this</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在您应该明白了吧：CacheSingle其实是ASP.NET内部使用的缓存容器，多个CPU时，它会创建多个缓存容器。<br>在写入时，它是如何定位这些容器的呢？请继续看代码：<a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internal CacheSingle GetCacheSingle(<span class="keyword">int</span> hashCode)</span><br><span class="line">&#123;</span><br><span class="line">    hashCode = Math.Abs(hashCode);</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">index</span> = hashCode &amp; <span class="keyword">this</span>._cacheIndexMask;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._caches[<span class="keyword">index</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：参数中的hashCode是直接调用我们传的key.GetHashCode() ，GetHashCode是由Object类定义的。</p>
<p>所以，从这个角度看，虽然ASP.NET的Cache只有一个HttpRuntime.Cache静态成员，但它的内部却可能会包含多个缓存容器， 这种设计可以在一定程度上减少并发的影响。</p>
<p>不管如何设计，在多线程环境下，共用一个容器，冲突是免不了的。如果您只是希望简单的缓存一些数据， 不需要Cache的许多高级特性，那么，可以考虑不用Cache 。 比如：可以创建一个Dictionary或者Hashtable的静态实例，它也可以完成一些基本的缓存工作， 不过，我要提醒您：您要自己处理多线程访问数据时的数据同步问题。<br>顺便说一句：Hashtable.Synchronized(new Hashtable())也是一个线程安全的集合，如果想简单点，可以考虑它。</p>
<p>接下来，我们来看一下Cache的高级特性，这些都是Dictionary或者Hashtable不能完成的。</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="缓存项的过期时间"><a href="#缓存项的过期时间" class="headerlink" title="缓存项的过期时间"></a>缓存项的过期时间</h1><p>ASP.NET支持二种缓存项的过期策略：绝对过期和滑动过期。<br>\1. 绝对过期，这个容易理解：就是在缓存放入Cache时，指定一个具体的时间。当时间到达指定的时间的时，缓存项自动从Cache中移除。<br>\2. 滑动过期：某些缓存项，我们可能只希望在有用户在访问时，就尽量保留在缓存中，只有当一段时间内用户不再访问该缓存项时，才移除它， 这样可以优化内存的使用，因为这种策略可以保证缓存的内容都是【很热门】的。 操作系统的内存以及磁盘的缓存不都是这样设计的吗？而这一非常有用的特性，Cache也为我们准备好了，只要在将缓存项放入缓存时， 指定一个滑动过期时间就可以实现了。</p>
<p>以上二个选项分别对应Add, Insert方法中的DateTime absoluteExpiration, TimeSpan slidingExpiration这二个参数。<br>注意：这二个参数都是成对使用的，但不能同时指定它们为一个【有效】值，最多只能一个参数值有效。 当不使用另一个参数项时，请用Cache类定义二个static readonly字段赋值。</p>
<p>这二个参数比较简单，我就不多说了，只说一句：如果都使用Noxxxxx这二个选项，那么缓存项就一直保存在缓存中。（或许也会被移除）</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="缓存项的依赖关系-依赖其它缓存项"><a href="#缓存项的依赖关系-依赖其它缓存项" class="headerlink" title="缓存项的依赖关系 - 依赖其它缓存项"></a>缓存项的依赖关系 - 依赖其它缓存项</h1><p>ASP.NET Cache有个很强大的功能，那就是缓存依赖。一个缓存项可以依赖于另一个缓存项。 以下示例代码创建了二个缓存项，且它们间有依赖关系。首先请看页面代码： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Key1 的缓存内容：<span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> HttpRuntime.Cache[<span class="string">"key1"</span>] </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"CacheDependencyDemo.aspx"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"SetKey1Cache"</span> <span class="attr">value</span>=<span class="string">"设置Key1的值"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"SetKey2Cache"</span> <span class="attr">value</span>=<span class="string">"设置Key2的值"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>页面后台代码：<a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> partial <span class="class"><span class="keyword">class</span> <span class="title">CacheDependencyDemo</span> :</span> System.Web.UI.Page</span><br><span class="line">&#123;</span><br><span class="line">    [SubmitMethod(AutoRedirect=<span class="literal">true</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetKey1Cache</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SetKey2Cache();</span><br><span class="line"></span><br><span class="line">        CacheDependency dep = <span class="keyword">new</span> CacheDependency(null, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">"key2"</span> &#125;);</span><br><span class="line">        HttpRuntime.Cache.Insert(<span class="string">"key1"</span>, DateTime.Now.ToString(), dep, </span><br><span class="line">                                    Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [SubmitMethod(AutoRedirect=<span class="literal">true</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetKey2Cache</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HttpRuntime.Cache.Insert(<span class="string">"key2"</span>, Guid.NewGuid().ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行这个示例页面时，运行结果如下图所示， 点击按钮【设置Key1的值】时，将会出现缓存项的内容（左图）。点击按钮【设置Key2的值】时，此时将获取不到缓存项的内容（右图）。</p>
<p><img src="https://pic002.cnblogs.com/images/2011/281816/2011122722172062.gif" alt="img"></p>
<p>根据结果并分析代码，我们可以看出，在创建Key1的缓存项时，我们使用了这种缓存依赖关系：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheDependency dep = <span class="keyword">new</span> <span class="type">CacheDependency</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="type">string</span>[] &#123; <span class="string">"key2"</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>所以，当我们更新Key2的缓存项时，Key1的缓存就失效了（不存在）。</p>
<p>不要小看了这个示例。的确，仅看这几行示例代码，或许它们实在是没有什么意义。 那么，我就举个实际的使用场景来说明它的使用价值。</p>
<p><img src="https://pic002.cnblogs.com/images/2011/281816/2011123011080183.gif" alt="img"></p>
<p>上面这幅图是我写的一个小工具。在示意图中，左下角是一个缓存表CacheTable，它由一个叫Table1BLL的类来维护。 CacheTable的数据来源于Table1，由Table1.aspx页面显示出来。 同时，ReportA, ReportB的数据也主要来源于Table1，由于Table1的访问几乎绝大多数都是读多写少，所以，我将Table1的数据缓存起来了。 而且，ReportA, ReportB这二个报表采用GDI直接画出（由报表模块生成，可认是Table1BLL的上层类），鉴于这二个报表的浏览次数较多且数据源是读多写少， 因此，这二个报表的输出结果，我也将它们缓存起来。</p>
<p>在这个场景中，我们可以想像一下：如果希望在Table1的数据发生修改后，如何让二个报表的缓存结果失效？<br>让Table1BLL去通知那二个报表模块，还是Table1BLL去直接删除二个报表的缓存？<br>其实，不管是选择前者还是后者，当以后还需要在Table1的CacheTable上做其它的缓存实现时（可能是其它的新报表）， 那么，势必都要修改Table1BLL，那绝对是个失败的设计。 这也算是模块间耦合的所带来的恶果。</p>
<p>幸好，ASP.NET Cache支持一种叫做缓存依赖的特性，我们只需要让Table1BLL公开它缓存CacheTable的KEY就可以了（假设KEY为 CacheTableKey）， 然后，其它的缓存结果如果要基于CacheTable，设置一下对【<strong>CacheTableKey</strong>】的依赖就可以实现这样的效果： <strong>当CacheTable更新后，被依赖的缓存结果将会自动清除。</strong>这样就彻底地解决了模块间的缓存数据依赖问题。</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="缓存项的依赖关系-文件依赖"><a href="#缓存项的依赖关系-文件依赖" class="headerlink" title="缓存项的依赖关系 - 文件依赖"></a>缓存项的依赖关系 - 文件依赖</h1><p>在上篇博客<a href="http://www.cnblogs.com/fish-li/archive/2011/12/18/2292037.html" target="_blank" rel="noopener">【在.net中读写config文件的各种方法】</a>的结尾， 我给大家留了一个问题：<br><strong>我希望在用户修改了配置文件后，程序能立刻以最新的参数运行，而且不用重启网站。</strong><br>今天我就来回答这个问题，并给出所需的全部实现代码。</p>
<p>首先，我要说明一点：上次博客的问题，虽然解决方案与Cache的文件依赖有关，但还需与缓存的移除通知配合使用才能完美的解决问题。 为了便于内容的安排，我先使用Cache的文件依赖来简单的实现一个粗糙的版本，在本文的后续部分再来完善这个实现。</p>
<p>先来看个粗糙的版本。假如我的网站中有这样一个配置参数类型： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 模拟网站所需的运行参数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RunOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> WebSiteUrl;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> UserName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我可以将它配置在这样一个XML文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">RunOptions</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">WebSiteUrl</span>&gt;</span>http://www.cnblogs.com/fish-li<span class="tag">&lt;/<span class="name">WebSiteUrl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">UserName</span>&gt;</span>fish li<span class="tag">&lt;/<span class="name">UserName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RunOptions</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再来一个用于显示运行参数的页面： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>WebSiteUrl: <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> WebSiteApp.RunOptions.WebSiteUrl </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>UserName: <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> WebSiteApp.RunOptions.UserName </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>下面的代码就可以实现：<strong>在XML修改后，浏览页面就能立即看到最新的参数值</strong>： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">WebSiteApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span> RunOptionsCacheKey = Guid.NewGuid().ToString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RunOptions RunOptions</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 首先尝试从缓存中获取运行参数</span></span><br><span class="line">            RunOptions options = HttpRuntime.Cache[RunOptionsCacheKey] <span class="keyword">as</span> RunOptions;</span><br><span class="line">            <span class="keyword">if</span>( options == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// 缓存中没有，则从文件中加载</span></span><br><span class="line">                <span class="keyword">string</span> path = HttpContext.Current.Server.MapPath(<span class="string">"~/App_Data/RunOptions.xml"</span>);</span><br><span class="line">                options = RwConfigDemo.XmlHelper.XmlDeserializeFromFile&lt;RunOptions&gt;(path, Encoding.UTF8);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把从文件中读到的结果放入缓存，并设置与文件的依赖关系。</span></span><br><span class="line">                CacheDependency dep = <span class="keyword">new</span> CacheDependency(path);</span><br><span class="line">                <span class="comment">// 如果您的参数较复杂，与多个文件相关，那么也可以使用下面的方式，传递多个文件路径。</span></span><br><span class="line">                <span class="comment">//CacheDependency dep = new CacheDependency(new string[] &#123; path &#125;);</span></span><br><span class="line">                HttpRuntime.Cache.Insert(RunOptionsCacheKey, options, dep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> options;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里仍然是在使用CacheDependency，只是我们现在是给它的构造函数的第一个参数传递要依赖的文件名。</p>
<p>在即将结束对缓存的依赖介绍之前，还要补充二点：<br>\1. CacheDependency还支持【嵌套】，即：CacheDependency的构造函数中支持传入其它的CacheDependency实例，这样可以构成一种非常复杂的树状依赖关系。<br>\2. 缓存依赖的对象还可以是SQL SERVER，具体可参考SqlCacheDependency</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="缓存项的移除优先级"><a href="#缓存项的移除优先级" class="headerlink" title="缓存项的移除优先级"></a>缓存项的移除优先级</h1><p>缓存的做法有很多种，一个静态变量也可以称为是一个缓存。一个静态的集合就是一个缓存的容器了。 我想很多人都用Dictionary，List，或者Hashtable做过缓存容器，我们可以使用它们来保存各种数据，改善程序的性能。 一般情况下，如果我们直接使用这类集合去缓存各类数据，那么，那些数据所占用的内存将不会被回收，哪怕它们的使用机会并不是很多。 当缓存数据越来越多时，它们所消耗的内存自然也会越来越多。那么，能不能在内存不充足时，释放掉一些访问不频繁的缓存项呢？</p>
<p>这个问题也确实是个较现实的问题。虽然，使用缓存会使用程序运行更快，但是，我们数据会无限大，不可能统统缓存起来， 毕竟，内存空间是有限的。因此，我们可以使用前面所说的<strong>基于一段时间内不再访问</strong>就删除的策略来解决这个问题。 然而，在我们编码时，根本不知道我们的程序会运行在什么配置标准的计算机上，因此，根本不可能会对内存的大小作出任何假设， 此时，我们可能会希望当缓存占用过多的内存时，且当内存不够时，能自动移除一些不太重要的缓存项，这或许也比较有意义。</p>
<p>对于这个需求，在.net framework提供了二种解决办法，一种是使用WeakReference类，另一种是使用Cache 。 不过，既然我们是在使用ASP.NET，选择Cache当然会更方便。 在Cache的Add, Insert方法的某些重载版本中，可以指定缓存项的保存优先级策略，由参数CacheItemPriority priority来传入。 其中，CacheItemPriority是一个枚举类型，它包含了如下枚举值： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定 Cache 对象中存储的项的相对优先级。</span></span><br><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">CacheItemPriority</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//  在服务器释放系统内存时，具有该优先级级别的缓存项最有可能被从缓存删除。</span></span><br><span class="line">    Low = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在服务器释放系统内存时，具有该优先级级别的缓存项比分配了 CacheItemPriority.Normal</span></span><br><span class="line">    <span class="comment">//  优先级的项更有可能被从缓存删除。</span></span><br><span class="line">    BelowNormal = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在服务器释放系统内存时，具有该优先级级别的缓存项很有可能被从缓存删除，</span></span><br><span class="line">    <span class="comment">//  其被删除的可能性仅次于具有 CacheItemPriority.Low</span></span><br><span class="line">    <span class="comment">//  或 CacheItemPriority.BelowNormal 优先级的那些项。这是默认选项。</span></span><br><span class="line">    Normal = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  缓存项优先级的默认值为 CacheItemPriority.Normal。</span></span><br><span class="line">    Default = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在服务器释放系统内存时，具有该优先级级别的缓存项被删除的可能性</span></span><br><span class="line">    <span class="comment">//  比分配了 CacheItemPriority.Normal 优先级的项要小。</span></span><br><span class="line">    AboveNormal = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在服务器释放系统内存时，具有该优先级级别的缓存项最不可能被从缓存删除。</span></span><br><span class="line">    High = <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在服务器释放系统内存时，具有该优先级级别的缓存项将不会被自动从缓存删除。</span></span><br><span class="line">    <span class="comment">//  但是，具有该优先级级别的项会根据项的绝对到期时间或可调整到期时间与其他项一起被移除。</span></span><br><span class="line">    NotRemovable = <span class="number">6</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：当我们调用Cache的Add, Insert方法时，如果不指定CacheItemPriority选项，最终使用Normal所代表的优先级。 如果我们希望将某个可能不太重要的数据放入缓存时，可以指定优先级为Low或者BelowNormal。 如果想让缓存项在内存不足时，也不会被移除（除非到期或者依赖项有改变），可使用NotRemovable。</p>
<p>显然，我们可以使用这个特性来控制缓存对内存压力的影响。 其它的缓存方案，如static Collection + WeakReference也较难实现这样灵活的控制。</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="缓存项的移除通知"><a href="#缓存项的移除通知" class="headerlink" title="缓存项的移除通知"></a>缓存项的移除通知</h1><p>ASP.NET Cache与一些static变量所实现的缓存效果并不相同，它的缓存项是可以根据一些特定的条件失效的，那些失效的缓存将会从内存中移除。 虽然，某些移除条件并不是由我们的代码直接解发的，但ASP.NET还是提供一种方法让我们可以在缓存项在移除时，能通知我们的代码。</p>
<p>注意哦：ASP.NET Cache支持移除【前】通知 和 移除【后】通知二种通知方式。</p>
<p>我们可以在调用Add, Insert方法时，通过参数onRemoveCallback传递一个CacheItemRemovedCallback类型的委托，以便在移除指定的缓存项时， 能够通知我们。这个委托的定义如下： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 定义在从 System.Web.Caching.Cache 移除缓存项时通知应用程序的回调方法。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="key"&gt;</span>从缓存中移除的键（当初由Add, Insert传入的）。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="value"&gt;</span>与从缓存中移除的键关联的缓存项（当初由Add, Insert传入的）。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="reason"&gt;</span>从缓存移除项的原因。 <span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">CacheItemRemovedCallback</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">object</span> <span class="keyword">value</span>, CacheItemRemovedReason reason</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  指定从 System.Web.Caching.Cache 对象移除项的原因。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CacheItemRemovedReason</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  该项是通过指定相同键的 Cache.Insert(System.String,System.Object)</span></span><br><span class="line">    <span class="comment">//  方法调用或 Cache.Remove(System.String) 方法调用从缓存中移除的。</span></span><br><span class="line">    Removed = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  从缓存移除该项的原因是它已过期。</span></span><br><span class="line">    Expired = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  之所以从缓存中移除该项，是因为系统要通过移除该项来释放内存。</span></span><br><span class="line">    Underused = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  从缓存移除该项的原因是与之关联的缓存依赖项已更改。</span></span><br><span class="line">    DependencyChanged = <span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>委托的各个参数的含义以及移除原因，在注释中都有明确的解释，我也不再重复了。<br>我想：有很多人知道Cache的Add, Insert方法有这个参数，也知道有这个委托，但是，它们有什么用呢？ 在后面的二个小节中，我将提供二个示例来演示这一强大的功能。</p>
<p>通常，我们会以下面这种方式从Cache中获取结果：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RunOptions <span class="keyword">options</span> = HttpRuntime.Cache[RunOptionsCacheKey] as RunOptions;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">options</span> == <span class="keyword">null</span> ) &#123;</span><br><span class="line">    <span class="comment">// 缓存中没有，则从文件中加载</span></span><br><span class="line">    <span class="comment">// ..................................</span></span><br><span class="line"></span><br><span class="line">    HttpRuntime.Cache.Insert(RunOptionsCacheKey, <span class="keyword">options</span>, dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">options</span>;</span><br></pre></td></tr></table></figure>
<p>这其实也是一个惯用法了：先尝试从缓存中获取，如果没有，则从数据源中加载，并再次放入缓存。</p>
<p>为什么会在访问Cache时返回null呢？答案无非就是二种原因：1. 根本没有放入Cache，2. 缓存项失效被移除了。<br>这种写法本身是没有问题，可是，如果从数据源中加载数据的时间较长，情况会怎样呢？<br>显然，会影响后面第一次的访问请求。您有没有想过，如果缓存项能一直放在Cache中，那不就可以了嘛。 是的，通常来说，只要您在将一个对象放入Cache时，不指定过期时间，不指定缓存依赖，且设置为永不移除，那么对象确实会一直在Cache中， 可是，过期时间和缓存依赖也很有用哦。如何能二者兼得呢？</p>
<p>为了解决这个问题，微软在.net framework的3.5 SP1、3.0 SP1、2.0 SP1版本中，加入了【移除前通知】功能，不过，这个方法仅受Insert支持， 随之而来的还有一个委托和一个移除原因的枚举定义： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 定义一个回调方法，用于在从缓存中移除缓存项之前通知应用程序。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="key"&gt;</span>要从缓存中移除的项的标识符。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="reason"&gt;</span>要从缓存中移除项的原因。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="expensiveObject"&gt;</span>此方法返回时，包含含有更新的缓存项对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="dependency"&gt;</span>此方法返回时，包含新的依赖项的对象。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="absoluteExpiration"&gt;</span>此方法返回时，包含对象的到期时间。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="slidingExpiration"&gt;</span>此方法返回时，包含对象的上次访问时间和对象的到期时间之间的时间间隔。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">CacheItemUpdateCallback</span>(<span class="params"><span class="keyword">string</span> key, CacheItemUpdateReason reason, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">out</span> <span class="keyword">object</span> expensiveObject, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">out</span> CacheDependency dependency, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">out</span> DateTime absoluteExpiration, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">out</span> TimeSpan slidingExpiration</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 指定要从 Cache 对象中移除缓存项的原因。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CacheItemUpdateReason</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 指定要从缓存中移除项的原因是绝对到期或可调到期时间间隔已到期。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Expired = <span class="number">1</span>,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 指定要从缓存中移除项的原因是关联的 CacheDependency 对象发生了更改。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    DependencyChanged = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：CacheItemUpdateReason这个枚举只有二项。原因请看MSDN的解释：</p>
<p>与 CacheItemRemovedReason 枚举不同，此枚举不包含 Removed 或 Underused 值。可更新的缓存项是不可移除的，因而绝不会被 ASP.NET 自动移除，即使需要释放内存也是如此。</p>
<p><strong>再一次提醒：</strong>有时我们确实需要缓存失效这个特性，但是，缓存失效后会被移除。 虽然我们可以让后续的请求在获取不到缓存数据时，从数据源中加载，也可以在CacheItemRemovedCallback回调委托中， 重新加载缓存数据到Cache中，<strong>但是在数据的加载过程中，Cache并不包含我们所期望的缓存数据，如果加载时间越长，这种【空缺】效果也会越明显。</strong> 这样会影响（后续的）其它请求的访问。为了保证让我们所期望的缓存数据能够一直存在于Cahce中，且仍有失效机制，我们可以使用【移除前通知】功能。</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="巧用缓存项的移除通知-实现【延迟操作】"><a href="#巧用缓存项的移除通知-实现【延迟操作】" class="headerlink" title="巧用缓存项的移除通知 实现【延迟操作】"></a>巧用缓存项的移除通知 实现【延迟操作】</h1><p>我看过一些ASP.NET的书，也看过一些人写的关于Cache方面的文章，基本上，要么是一带而过，要么只是举个毫无实际意义的示例。 可惜啊，这么强大的特性，我很少见到有人把它用起来。</p>
<p>今天，我就举个有实际意义的示例，再现Cache的强大功能！</p>
<p>我有这样一个页面，可以让用户调整（上下移动）某个项目分支记录的上线顺序：</p>
<p><img src="https://pic002.cnblogs.com/images/2011/281816/2011123011083424.gif" alt="img"></p>
<p>当用户需要调整某条记录的位置时，页面会弹出一个对话框，要求输入一个调整原因，并会发邮件通知所有相关人员。</p>
<p><img src="https://pic002.cnblogs.com/images/2011/281816/2011123011085942.gif" alt="img"></p>
<p>由于界面的限制，一次操作（点击上下键头）只是将一条记录移动一个位置，当要对某条记录执行跨越多行移动时，必须进行多次移动。 考虑到操作的方便性以及不受重复邮件的影响，程序需要实现这样一个需求： 页面只要求输入一次原因便可以对一条记录执行多次移动操作，并且不要多次发重复邮件，而且要求将最后的移动结果在邮件中发出来。</p>
<p>这个需求很合理，毕竟谁都希望操作简单。</p>
<p>那么如何实现这个需求呢？这里要从二个方面来实现，首先，在页面上我们应该要完成这个功能，对一条记录只弹一次对话框。 由于页面与服务端的交互全部采用Ajax方式进行（不刷新），状态可以采用JS变量来维持，所以这个功能在页面中是很容易实现。 再来看一下服务端，由于服务端并没有任何状态，当然也可以由页面把它的状态传给服务端，但是，哪次操作是最后一次呢？ 显然，这是无法知道的，最后只能修改需求，如果用户在2分钟之内不再操作某条记录时，便将最近一次操作视为最后一次操作。</p>
<p>基于新的需求，程序必须记录用户的最近一次操作，以便在2分钟不操作后，发出一次邮件，但要包含第一次输入的原因， 还应包含最后的修改结果哦。</p>
<p>该怎么实现这个需求呢？ 我立即就想到了ASP.NET Cache，因为我了解它，知道它能帮我完成这个功能。下面我来说说在服务端是如何实现的。</p>
<p><strong>整个实现的思路是：</strong><br>\1. 客户端页面还是每次将记录的RowGuid, 调整方向，调整原因，这三个参数发到服务端。<br>\2. 服务端在处理完顺序调整操作后，将要发送的邮件信息Insert到Cache中，同时提供slidingExpiration和onRemoveCallback参数。<br>\3. 在CacheItemRemovedCallback回调委托中，忽略CacheItemRemovedReason.Removed的通知，如果是其它的通知，则发邮件。</p>
<p>为了便于理解，我特意为大家准备了一个示例。整个示例由三部分组成：一个页面，一个JS文件，服务端代码。先来看页面代码： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 为了简单，示例页面只处理一条记录，且将记录的RowGuid直接显示出来。<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        实际场景中，这个RowGuid应该可以从一个表格的【当前选择行】中获取到。</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 当前选择行的 RowGuid = <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"spanRowGuid"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> Guid.NewGuid().ToString() </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        当前选择行的 Sequence= <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"spanSequence"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnMoveUp"</span> <span class="attr">value</span>=<span class="string">"上移"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnMoveDown"</span> <span class="attr">value</span>=<span class="string">"下移"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>页面的显示效果如下：</p>
<p><img src="https://pic002.cnblogs.com/images/2011/281816/2011122722184225.gif" alt="img"></p>
<p>处理页面中二个按钮的JS代码如下： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户输入的调整记录的原因</span></span><br><span class="line"><span class="keyword">var</span> g_reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"#btnMoveUp"</span>).click( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; MoveRec(<span class="number">-1</span>); &#125; );</span><br><span class="line">    $(<span class="string">"#btnMoveDown"</span>).click( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; MoveRec(<span class="number">1</span>); &#125; );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MoveRec</span>(<span class="params">direction</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( ~~($(<span class="string">"#spanSequence"</span>).text()) + direction &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        alert(<span class="string">"已经不能上移了。"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( g_reason == <span class="literal">null</span> )&#123;</span><br><span class="line">        g_reason = prompt(<span class="string">"请输入调整记录顺序的原因："</span>, <span class="string">"由于什么什么原因，我要调整..."</span>);</span><br><span class="line">        <span class="keyword">if</span>( g_reason == <span class="literal">null</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">"/AjaxDelaySendMail/MoveRec.fish"</span>,</span><br><span class="line">        data: &#123; <span class="attr">RowGuid</span>: $(<span class="string">"#spanRowGuid"</span>).text(), </span><br><span class="line">                Direction: direction,</span><br><span class="line">                Reason: g_reason</span><br><span class="line">        &#125;,</span><br><span class="line">        type: <span class="string">"POST"</span>, <span class="attr">dataType</span>: <span class="string">"text"</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">responseText</span>)</span>&#123;</span><br><span class="line">            $(<span class="string">"#spanSequence"</span>).text(responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：在服务端，我使用了我在<a href="http://www.cnblogs.com/fish-li/archive/2011/09/05/2168073.html" target="_blank" rel="noopener">【用Asp.net写自己的服务框架】</a>那篇博客中提供的服务框架， 服务端的全部代码是这个样子的：<strong>（注意代码中的注释）</strong> <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 移动记录的相关信息。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveRecInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> RowGuid;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Direction;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Reason;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="meta">MyService</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AjaxDelaySendMail</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MyServiceMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoveRec</span>(<span class="params">MoveRecInfo info</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里就不验证从客户端传入的参数了。实际开发中这个是必须的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先来调整记录的顺序，示例程序没有数据库，就用Cache来代替。</span></span><br><span class="line">        <span class="keyword">int</span> sequence = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>.TryParse(HttpRuntime.Cache[info.RowGuid] <span class="keyword">as</span> <span class="keyword">string</span>, <span class="keyword">out</span> sequence);</span><br><span class="line">        <span class="comment">// 简单地示例一下调整顺序。</span></span><br><span class="line">        sequence += info.Direction;</span><br><span class="line">        HttpRuntime.Cache[info.RowGuid] = sequence.ToString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> key = info.RowGuid +<span class="string">"_DelaySendMail"</span>;</span><br><span class="line">        <span class="comment">// 这里我不直接发邮件，而是把这个信息放入Cache中，并设置2秒的滑过过期时间，并指定移除通知委托</span></span><br><span class="line">        <span class="comment">// 将操作信息放在缓存，并且以覆盖形式放入，这样便可以实现保存最后状态。</span></span><br><span class="line">        <span class="comment">// 注意：这里我用Insert方法。</span></span><br><span class="line">        HttpRuntime.Cache.Insert(key, info, <span class="literal">null</span>, Cache.NoAbsoluteExpiration,</span><br><span class="line">            TimeSpan.FromMinutes(<span class="number">2.0</span>), CacheItemPriority.NotRemovable, MoveRecInfoRemovedCallback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sequence;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveRecInfoRemovedCallback</span>(<span class="params"><span class="keyword">string</span> key, <span class="keyword">object</span> <span class="keyword">value</span>, CacheItemRemovedReason reason</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( reason == CacheItemRemovedReason.Removed )</span><br><span class="line">            <span class="keyword">return</span>;        <span class="comment">// 忽略后续调用HttpRuntime.Cache.Insert()所触发的操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 能运行到这里，就表示是肯定是缓存过期了。</span></span><br><span class="line">        <span class="comment">// 换句话说就是：用户2分钟再也没操作过了。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从参数value取回操作信息</span></span><br><span class="line">        MoveRecInfo info = (MoveRecInfo)<span class="keyword">value</span>;</span><br><span class="line">        <span class="comment">// 这里可以对info做其它的处理。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后发一次邮件。整个延迟发邮件的过程就处理完了。</span></span><br><span class="line">        MailSender.SendMail(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能让JavaScript能直接调用C#中的方法，还需要在web.config中加入如下配置：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&lt;httpHandlers&gt;</span></span><br><span class="line">    &lt;<span class="built_in">add</span> path=<span class="string">"*.fish"</span> <span class="keyword">verb</span>=<span class="string">"*"</span> validate=<span class="string">"false"</span> <span class="built_in">type</span>=<span class="string">"MySimpleServiceFramework.AjaxServiceHandler"</span>/&gt;</span><br><span class="line">&lt;/httpHandlers&gt;</span><br></pre></td></tr></table></figure>
<p>好了，示例代码就是这些。如果您有兴趣，可以在本文的结尾处下载这些示例代码，自己亲自感受一下利用Cache实现的【延迟处理】的功能。</p>
<p>其实这种【延迟处理】的功能是很有用的，比如还有一种适用场景：有些数据记录可能需要频繁更新，如果每次更新都去写数据库，肯定会对数据库造成一定的压力， <strong>但由于这些数据也不是特别重要</strong>，因此，我们可以利用这种【延迟处理】来将写数据库的时机进行<strong>合并处理</strong>， 最终我们可以实现：将多次的写入变成一次或者少量的写入操作，我称这样效果为：<strong>延迟合并写入</strong></p>
<p>这里我就对数据库的<strong>延迟合并写入</strong>提供一个思路：将需要写入的数据记录放入Cache，调用Insert方法并提供slidingExpiration和onRemoveCallback参数， 然后在CacheItemRemovedCallback回调委托中，模仿我前面的示例代码，将多次变成一次。不过，这样可能会有一个问题：如果数据是一直在修改，那么就一直不会写入数据库。 最后如果网站重启了，数据可能会丢失。如果担心这个问题，那么，可以在回调委托中，遇到CacheItemRemovedReason.Removed时，使用计数累加的方式，当到达一定数量后， 再写入数据库。比如：遇到10次CacheItemRemovedReason.Removed我就写一次数据库，这样就会将原来需要写10次的数据库操作变成一次了。 当然了，如果是其它移除原因，写数据库总是必要的。注意：<strong>对于金额这类敏感的数据，绝对不要使用这种方法。</strong></p>
<p>再补充二点：<br>\1. 当CacheItemRemovedCallback回调委托被调用时，缓存项已经不在Cache中了。<br>\2. 在CacheItemRemovedCallback回调委托中，我们还可以将缓存项重新放入缓存。<br>有没有想过：这种设计可以构成一个循环？如果再结合参数slidingExpiration便可实现一个定时器的效果。</p>
<p>关于缓存的失效时间，我要再提醒一点：通过absoluteExpiration, slidingExpiration参数所传入的时间，当缓存时间生效时，缓存对象并不会立即移除， <strong>ASP.NET Cache大约以20秒的频率去检查这些已过时的缓存项。</strong></p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="巧用缓存项的移除通知-实现【自动加载配置文件】"><a href="#巧用缓存项的移除通知-实现【自动加载配置文件】" class="headerlink" title="巧用缓存项的移除通知 实现【自动加载配置文件】"></a>巧用缓存项的移除通知 实现【自动加载配置文件】</h1><p>在本文的前部分的【文件依赖】小节中，有一个示例演示了：当配置文件更新后，页面可以显示最新的修改结果。 在那个示例中，为了简单，我直接将配置参数放在Cache中，每次使用时再从Cache中获取。 如果配置参数较多，这种做法或许也会影响性能，毕竟配置参数并不会经常修改，如果能直接访问一个静态变量就能获取到，应该会更快。 通常，我们可能会这样做： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RunOptions s_RunOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RunOptions RunOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// s_RunOptions 的初始化放在Init方法中了，会在Global.asax的Application_Start事件中调用。</span></span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> s_RunOptions; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RunOptions <span class="title">LoadRunOptions</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> path = Path.Combine(AppDataPath, <span class="string">"RunOptions.xml"</span>);</span><br><span class="line">    <span class="keyword">return</span> RwConfigDemo.XmlHelper.XmlDeserializeFromFile&lt;RunOptions&gt;(path, Encoding.UTF8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这种做法有一缺点就是：不能在配置文件更新后，自动加载最新的配置结果。</p>
<p>为了解决这个问题，我们可以使用Cache提供的文件依赖以及移除通知功能。 前面的示例演示了移除后通知功能，这里我再演示一下移除前通知功能。<br><strong>说明：事实上，完成这个功能，可以仍然使用移除后通知，只是移除前通知我还没有演示，然而，这里使用移除前通知并没有显示它的独有的功能。</strong></p>
<p>下面的代码演示了在配置文件修改后，自动更新运行参数的实现方式：<strong>（注意代码中的注释）</strong> <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> s_RunOptionsCacheDependencyFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RunOptions <span class="title">LoadRunOptions</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> path = Path.Combine(AppDataPath, <span class="string">"RunOptions.xml"</span>);</span><br><span class="line">    <span class="comment">// 注意啦：访问文件是可能会出现异常。不要学我，我写的是示例代码。</span></span><br><span class="line">    RunOptions options = RwConfigDemo.XmlHelper.XmlDeserializeFromFile&lt;RunOptions&gt;(path, Encoding.UTF8);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = System.Threading.Interlocked.CompareExchange(<span class="keyword">ref</span> s_RunOptionsCacheDependencyFlag, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保只调用一次就可以了。</span></span><br><span class="line">    <span class="keyword">if</span>( flag == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 让Cache帮我们盯住这个配置文件。</span></span><br><span class="line">        CacheDependency dep = <span class="keyword">new</span> CacheDependency(path);</span><br><span class="line">        HttpRuntime.Cache.Insert(RunOptionsCacheKey, <span class="string">"Fish Li"</span>, dep,</span><br><span class="line">            Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration, RunOptionsUpdateCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunOptionsUpdateCallback</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">string</span> key, CacheItemUpdateReason reason, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">out</span> <span class="keyword">object</span> expensiveObject, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">out</span> CacheDependency dependency, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">out</span> DateTime absoluteExpiration, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">out</span> TimeSpan slidingExpiration</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意哦：在这个方法中，不要出现【未处理异常】，否则缓存对象将被移除。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明：这里我并不关心参数reason，因为我根本就没有使用过期时间</span></span><br><span class="line">    <span class="comment">//        所以，只有一种原因：依赖的文件发生了改变。</span></span><br><span class="line">    <span class="comment">//        参数key我也不关心，因为这个方法是【专用】的。</span></span><br><span class="line"></span><br><span class="line">    expensiveObject = <span class="string">"http://www.cnblogs.com/fish-li/"</span>;</span><br><span class="line">    dependency = <span class="keyword">new</span> CacheDependency(Path.Combine(AppDataPath, <span class="string">"RunOptions.xml"</span>));</span><br><span class="line">    absoluteExpiration = Cache.NoAbsoluteExpiration;</span><br><span class="line">    slidingExpiration = Cache.NoSlidingExpiration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新加载配置参数</span></span><br><span class="line">    s_RunOptions = LoadRunOptions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改动很小，只是LoadRunOptions方法做了修改了而已，但是效果却很酷。</p>
<p>还记得我在上篇博客<a href="http://www.cnblogs.com/fish-li/archive/2011/12/18/2292037.html" target="_blank" rel="noopener">【在.net中读写config文件的各种方法】</a>的结尾处留下来的问题吗？ 这个示例就是我的解决方案。</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="文件监视技术的选择"><a href="#文件监视技术的选择" class="headerlink" title="文件监视技术的选择"></a>文件监视技术的选择</h1><p>对于文件监视，我想有人或许会想到FileSystemWatcher。正好我就来说说关于【文件监视技术】的选择问题。<br>说明，本文所有结论均为我个人的观点，仅供参考。</p>
<p>这个组件，早在做WinForm开发时就用过了，对它也是印象比较深的。<br>它有一个包装不好的地方是：<strong>事件会重复发出。</strong>比如：一次文件的保存操作，它却引发了二次事件。<br>什么，你不信？ 正好，我还准备了一个示例程序。</p>
<p><img src="https://pic002.cnblogs.com/images/2011/281816/2011122722185820.gif" alt="img"></p>
<p>说明：图片中显示了发生过二次事件，但我只是在修改了文件后，做了一次保存操作而已。 本文的结尾处有我的示例程序，您可以自己去试一下。这里为了方便，还是贴出相关代码： <a href="javascript:void(0" target="_blank" rel="noopener"><img src="http://images.cnblogs.com/cnblogs_com/fish-li/297352/r_collapse.png" alt="img"></a>;)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Shown</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fileSystemWatcher1.Path = Environment.CurrentDirectory;</span><br><span class="line">    <span class="keyword">this</span>.fileSystemWatcher1.Filter = <span class="string">"RunOptions.xml"</span>;</span><br><span class="line">    <span class="keyword">this</span>.fileSystemWatcher1.NotifyFilter = System.IO.NotifyFilters.LastWrite;</span><br><span class="line">    <span class="keyword">this</span>.fileSystemWatcher1.EnableRaisingEvents = <span class="literal">true</span>;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fileSystemWatcher1_Changed</span>(<span class="params"><span class="keyword">object</span> sender, System.IO.FileSystemEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> message = <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125; &#123;1&#125;."</span>, e.Name, e.ChangeType);</span><br><span class="line">    <span class="keyword">this</span>.listBox1.Items.Add(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个类的使用，只想说一点：会引发的事件很多，因此一定要注意过滤。以下引用MSDN的一段说明：</p>
<p>Windows 操作系统在 FileSystemWatcher 创建的缓冲区中通知组件文件发生更改。如果短时间内有很多更改，则缓冲区可能会溢出。这将导致组件失去对目录更改的跟踪，并且它将只提供一般性通知。使用 InternalBufferSize 属性来增加缓冲区大小的开销较大，因为它来自无法换出到磁盘的非页面内存，所以应确保缓冲区大小适中（尽量小，但也要有足够大小以便不会丢失任何文件更改事件）。若要避免缓冲区溢出，请使用 NotifyFilter 和 IncludeSubdirectories 属性，以便可以筛选掉不想要的更改通知。</p>
<p>幸运的是，ASP.NET Cache并没有使用这个组件，我们不用担心文件依赖而引发的重复操作问题。 它直接依赖于webengine.dll所提供的API，因此，建议在ASP.NET应用程序中，优先使用Cache所提供的文件依赖功能。</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html#_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h1 id="各种缓存方案的共存"><a href="#各种缓存方案的共存" class="headerlink" title="各种缓存方案的共存"></a>各种缓存方案的共存</h1><p>ASP.NET Cache是一种缓存技术，然而，我们在ASP.NET程序中还可以使用其它的缓存技术， 这些不同的缓存也各有各自的长处。由于ASP.NET Cache不能提供对外访问能力，因此，它不可能取代以memcached为代表的分布式缓存技术， 但它由于是不需要跨进程访问，效率也比分布式缓存的速度更快。如果将ASP.NET Cache设计成【一级缓存】， 分布式缓存设计成【二级缓存】，就像CPU的缓存那样，那么将能同时利用二者的所有的优点，实现更完美的功能以及速度。</p>
<p>其实缓存是没有一个明确定义的技术，一个static变量也是一个缓存，一个static集合就是一个缓存容器了。 这种缓存与ASP.NET Cache相比起来，显然static变量的访问速度会更快，如果static集合不是设计得很差的话， 并发的冲突也可能会比ASP.NET Cache小，也正是因为这一点，static集合也有着广泛的使用。 然而，ASP.NET Cache的一些高级功能，如：过期时间，缓存依赖（包含文件依赖），移除通知，也是static集合不具备的。 因此，合理地同时使用它们，会让程序有着最好的性能，也同时拥有更强大的功能。</p>
<blockquote>
<p>原文<a href="http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html" target="_blank" rel="noopener">http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html</a></p>
</blockquote>

 </div>
 
 <div class="article-tags tags">
		 
		 <a href="/tags/cache/">cache</a>
		 
 </div>
 
<div id="comments" style="margin: 5px auto;">
	<div id="comment"></div>
                        <script>
                            new Valine({
                        el: '#comment' ,
                        notify:false, 
                        verify:false, 
                        appId: 'oTcHLJ1mpOGAcKcahsaQEBaQ-gzGzoHsz',
                        appKey: 'Jq4QEoyIo2Y40s3PHny873nz',
                        placeholder: ' ( *￣▽￣)((≧︶≦*)',
                        path:window.location.pathname, 
						avatar:'retro'
                    });
                        </script>
</div>
 
 <div class="art-item-footer">
		 
		 <span class="art-item-left">
				 <i class="icon icon-chevron-thin-left"></i>prev：<a href="/2018/02/01/thread01/" rel="prev" title="多线程01">
						 多线程01
				 </a>
		 </span>
		 
		 
		 <span class="art-item-right">
				 next：<a href="/2018/01/29/IEnumerableECT/" rel="next" title="CSharp中的集合接口，类之间的关系">
						 CSharp中的集合接口，类之间的关系
				 </a><i class="icon icon-chevron-thin-right"></i>
		 </span>
		 
 </div>
 
</section>

</article>
<script>
window.subData = {
 title: '细说 ASP.NET Cache 及其高级用法',
 tools: true
}
</script>

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/images/avatar.jpg' />

<div class='header'>luox78</div>
<div class='content'>
<div class='desc'>It's always not too late to learn</div>
</div>
</section>

  <section class='m_widget'>
<div>
    <embed style="color:#FFF;" height="60" width="250" src="https://luox78.github.io/images/田馥甄-你就不要想起我.mp3" autostart="true"  loop="true" id="MediaPlayer" name="MediaPlayer" />
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/ASP-NET/"><div class='name'>ASP.NET</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/C/"><div class='name'>C#</div><div class='badget'>14</div></a></li>
    
        <li><a class="flat-box" href="/categories/DailyLearning/"><div class='name'>DailyLearning</div><div class='badget'>4</div></a></li>
    
        <li><a class="flat-box" href="/categories/JQuery/"><div class='name'>JQuery</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/JavaScript/"><div class='name'>JavaScript</div><div class='badget'>21</div></a></li>
    
        <li><a class="flat-box" href="/categories/Learning/"><div class='name'>Learning</div><div class='badget'>1</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/C-特性/" style="font-size: 15.5px; color: #606060">C#特性</a> <a href="/tags/DI/" style="font-size: 14px; color: #808080">DI</a> <a href="/tags/Entity-Framework/" style="font-size: 15.5px; color: #606060">Entity Framework</a> <a href="/tags/HtmlHelper拓展/" style="font-size: 14px; color: #808080">HtmlHelper拓展</a> <a href="/tags/IIS请求流程/" style="font-size: 14px; color: #808080">IIS请求流程</a> <a href="/tags/IOC/" style="font-size: 15.5px; color: #606060">IOC</a> <a href="/tags/Json/" style="font-size: 14px; color: #808080">Json</a> <a href="/tags/LINQ/" style="font-size: 15.5px; color: #606060">LINQ</a> <a href="/tags/MD5/" style="font-size: 14px; color: #808080">MD5</a> <a href="/tags/NOPI/" style="font-size: 14px; color: #808080">NOPI</a> <a href="/tags/SqlHelper/" style="font-size: 14px; color: #808080">SqlHelper</a> <a href="/tags/asp-net-mvc/" style="font-size: 14px; color: #808080">asp.net mvc</a> <a href="/tags/autofac/" style="font-size: 14px; color: #808080">autofac</a> <a href="/tags/bitwiseOperations/" style="font-size: 14px; color: #808080">bitwiseOperations</a> <a href="/tags/cache/" style="font-size: 14px; color: #808080">cache</a> <a href="/tags/http协议/" style="font-size: 14px; color: #808080">http协议</a> <a href="/tags/jQueryfoundation/" style="font-size: 17px; color: #404040">jQueryfoundation</a> <a href="/tags/jsfoundation/" style="font-size: 18.5px; color: #202020">jsfoundation</a> <a href="/tags/path/" style="font-size: 14px; color: #808080">path</a> <a href="/tags/request/" style="font-size: 14px; color: #808080">request</a> <a href="/tags/swagger/" style="font-size: 14px; color: #808080">swagger</a> <a href="/tags/thread/" style="font-size: 15.5px; color: #606060">thread</a> <a href="/tags/三层/" style="font-size: 15.5px; color: #606060">三层</a> <a href="/tags/分页/" style="font-size: 14px; color: #808080">分页</a> <a href="/tags/单例模式/" style="font-size: 14px; color: #808080">单例模式</a> <a href="/tags/发邮件/" style="font-size: 14px; color: #808080">发邮件</a> <a href="/tags/工厂模式/" style="font-size: 14px; color: #808080">工厂模式</a> <a href="/tags/模拟IIS/" style="font-size: 14px; color: #808080">模拟IIS</a> <a href="/tags/深入理解JS/" style="font-size: 20px; color: #000">深入理解JS</a> <a href="/tags/线程/" style="font-size: 14px; color: #808080">线程</a>
    </div>
</div>



  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://github.com/luox78">
            <div class='name'>Github</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://www.baidu.com">
            <div class='name'>Baidu</div>
        </a></li>
    
    </ul>
</div>
</section>

      </aside>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/luox78" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>
    <span>
        Powered by:<a href="https://hexo.io/" class="codename" target="_blank">
                       hexo
        </a>
    </span>
    <span> - </span>
    <span>
        Theme: <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename" target="_blank">MaterialFlow</a> 
    </span>
    <span> - </span>
    <span id="busuanzi_container_site_pv">
        本站总访问量:
        <a href='http://ibruce.info/2015/04/04/busuanzi/' class="codename" target="_blank">
            <span id="busuanzi_value_site_pv"></span>
        </a>
    </span>
</div>
  
</footer>


  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>
<!--隐藏不是主页的wiget-->
<script>
  if(document.location.href !== "https://luox78.github.io/" && document.location.href !== "https://luox78.github.io/archives/" && document.location.href !== "http://localhost:4000/"){
    var foo = document.getElementsByClassName("l_side");
    for (let index = 0; index < foo.length; index++) {
      foo[index].style.display="none";
    }
  }
  Waves.attach('.vbtn', ['waves-button', 'waves-float']);
  Waves.attach(".u-search-form", ['.waves-circle']);
  Waves.init();

  //添加tr显示效果
  $(".article-entry>table tbody tr:odd").css("backgroundColor","rgb(235,236,238)");
	$("#loading").fadeOut(1000);
</script>


</body>
</html>
