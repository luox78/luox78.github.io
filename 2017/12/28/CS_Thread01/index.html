<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>C#中的多线程 - 01基础知识 | luox78</title>
  <meta name="description" content="Blog for luox78" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="theme-color" content=" rgb(59,95,208)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <link rel="shortcut icon" href="/images/dev.ico">
  <link rel="alternate" href="/atom.xml" title="luox78">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：">
<meta name="keywords" content="thread">
<meta property="og:type" content="article">
<meta property="og:title" content="C#中的多线程 - 01基础知识">
<meta property="og:url" content="https://luox78.github.io/2017/12/28/CS_Thread01/index.html">
<meta property="og:site_name" content="luox78">
<meta property="og:description" content="1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://luox78.github.io/images/threading/NewThread.png">
<meta property="og:updated_time" content="2017-12-31T12:44:41.774Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C#中的多线程 - 01基础知识">
<meta name="twitter:description" content="1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：">
<meta name="twitter:image" content="https://luox78.github.io/images/threading/NewThread.png">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/style.css">
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
</head>

<body>
  <div id="loading">
    <div id="loading-center">
    <div id="loading-center-absolute">
    <div class="object" id="object_one"></div>
    <div class="object" id="object_two"></div>
    <div class="object" id="object_three"></div>
    <div class="object" id="object_four"></div>
    <div class="object" id="object_five"></div>
    <div class="object" id="object_six"></div>
    <div class="object" id="object_seven"></div>
    <div class="object" id="object_eight"></div>
    <div class="object" id="object_big"></div>
    </div>
    </div>
     
    </div>
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				luox78
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/about.html'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="/about.html" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <!-- <script>
      var count=0;
      function setLoadingBarProgress() {
          if(count==100){
              count=0;
          }
          document.getElementById('loading-bar').style.width = count + "%";
      }
  </script> -->
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-CS_Thread01"
	class="post white-box article-type-post"
	itemscope itemprop="blogPost">
<section class='meta'>
 <h2 class="title">
		 <a href="/2017/12/28/CS_Thread01/">
				 C#中的多线程 - 01基础知识
		 </a>
 </h2>
 <time>
		 Dec 28, 2017
 </time>
 
    
    <div class='cats'>
        <a href="/categories/C/">C#</a>
    </div>

 <span id="busuanzi_container_page_pv">
		 
		<a href="javascript:void(0)" class="read_cats">本文总阅读量:<span id="busuanzi_value_page_pv"></span>
		</a>
 </span>
</section>

<section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1简介及概念"><span class="toc-number">1.</span> <span class="toc-text">1简介及概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1Join-和-Sleep"><span class="toc-number">1.1.</span> <span class="toc-text">1.1Join 和 Sleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2线程是如何工作的"><span class="toc-number">1.2.</span> <span class="toc-text">1.2线程是如何工作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3线程-vs-进程"><span class="toc-number">1.3.</span> <span class="toc-text">1.3线程 vs 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4线程的使用与误用"><span class="toc-number">1.4.</span> <span class="toc-text">1.4线程的使用与误用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2创建和启动线程"><span class="toc-number">2.</span> <span class="toc-text">2创建和启动线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1向线程传递数据"><span class="toc-number">2.1.</span> <span class="toc-text">2.1向线程传递数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-表达式与被捕获变量"><span class="toc-number">2.1.1.</span> <span class="toc-text">Lambda 表达式与被捕获变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2线程命名"><span class="toc-number">2.2.</span> <span class="toc-text">2.2线程命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3前台与后台线程"><span class="toc-number">2.3.</span> <span class="toc-text">2.3前台与后台线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4线程优先级"><span class="toc-number">2.4.</span> <span class="toc-text">2.4线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5异常处理"><span class="toc-number">2.5.</span> <span class="toc-text">2.5异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3线程池"><span class="toc-number">3.</span> <span class="toc-text">3线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1通过-TPL-使用线程池"><span class="toc-number">3.1.</span> <span class="toc-text">3.1通过 TPL 使用线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2不通过-TPL-使用线程池"><span class="toc-number">3.2.</span> <span class="toc-text">3.2不通过 TPL 使用线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QueueUserWorkItem"><span class="toc-number">3.2.1.</span> <span class="toc-text">QueueUserWorkItem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步委托"><span class="toc-number">3.2.2.</span> <span class="toc-text">异步委托</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3优化线程池"><span class="toc-number">3.3.</span> <span class="toc-text">3.3优化线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最小线程数量是如何起作用的？"><span class="toc-number">3.3.1.</span> <span class="toc-text">最小线程数量是如何起作用的？</span></a></li></ol></li></ol></li></ol></section>

<section class="article typo">
 <div class="article-entry" itemprop="articleBody">
		 <h2 id="1简介及概念"><a href="#1简介及概念" class="headerlink" title="1简介及概念"></a>1简介及概念</h2><p>C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。</p>
<p>一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：</p>
<a id="more"></a>
<blockquote>
<p>所有示例都假定已经引用了以下命名空间：</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Threading;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread (WriteY);  <span class="comment">// 创建新线程</span></span><br><span class="line">    t.Start();                       <span class="comment">// 启动新线程，执行WriteY()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时，在主线程做其它事情</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) Console.Write (<span class="string">"x"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) Console.Write (<span class="string">"y"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyy</span><br><span class="line">yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>主线程创建了一个新线程<code>t</code>来不断打印字母 “ y “，与此同时，主线程在不停打印字母 “ x “。</p>
<p><a href="https://luox78.github.io/images/threading/NewThread.png"><img src="https://luox78.github.io/images/threading/NewThread.png" alt="启动新线程"></a></p>
<p>线程一旦启动，线程的<code>IsAlive</code>属性值就会为<code>true</code>，直到线程结束。当传递给<code>Thread</code>的构造方法的委托执行完成时，线程就会结束。一旦结束，该线程不能再重新启动。</p>
<p>CLR 为每个线程分配各自独立的栈空间，因此局部变量是独立的。在下面的例子中，我们定义一个拥有局部变量的方法，然后在主线程和新创建的线程中同时执行该方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread (Go).Start();      <span class="comment">// 在新线程执行Go()</span></span><br><span class="line">  Go();                         <span class="comment">// 在主线程执行Go()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 定义和使用局部变量 - 'cycles'</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> cycles = <span class="number">0</span>; cycles &lt; <span class="number">5</span>; cycles++) Console.Write (<span class="string">'?'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<code>??????????</code></p>
<p>变量<code>cycles</code>的副本是分别在各自的栈中创建的，因此才会输出 10 个问号。</p>
<p>线程可以通过对同一对象的引用来共享数据。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">bool</span> done;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ThreadTest tt = <span class="keyword">new</span> ThreadTest();   <span class="comment">// 创建一个公共的实例</span></span><br><span class="line">    <span class="keyword">new</span> Thread (tt.Go).Start();</span><br><span class="line">    tt.Go();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意： Go现在是一个实例方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!done) &#123; done = <span class="literal">true</span>; Console.WriteLine (<span class="string">"Done"</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于两个线程是调用了同一个的<code>ThreadTest</code>实例上的<code>Go()</code>，它们共享了<code>done</code>字段，因此输出结果是一次 “ Done “，而不是两次。</p>
<p>输出结果：<code>Done</code></p>
<p>静态字段提供了另一种在线程间共享数据的方式，以下是一个静态的<code>done</code>字段的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> done;    <span class="comment">// 静态字段在所有线程中共享</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (Go).Start();</span><br><span class="line">    Go();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123; done = <span class="literal">true</span>; Console.WriteLine (<span class="string">"Done"</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个例子引出了一个关键概念[线程安全（thread safety）]。上述两个例子的输出实际上是不确定的：” Done “ 有可能会被打印两次。如果在<code>Go</code>方法里调换指令的顺序，” Done “ 被打印两次的几率会大幅提高：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Go()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">done</span>) &#123; Console.WriteLine (<span class="string">"Done"</span>); <span class="keyword">done</span> = <span class="keyword">true</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Done</span><br><span class="line">Done   (很可能!)</span><br></pre></td></tr></table></figure>
<p>这个问题是因为一个线程对<code>if</code>中的语句估值的时候，另一个线程正在执行<code>WriteLine</code>语句，这时<code>done</code>还没有被设置为<code>true</code>。</p>
<p>修复这个问题需要在读写公共字段时，获得一个[排它锁（互斥锁，exclusive lock ）]。C# 提供了[lock]来达到这个目的：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> done;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (Go).Start();</span><br><span class="line">    Go();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (locker)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123; Console.WriteLine (<span class="string">"Done"</span>); done = <span class="literal">true</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当两个线程同时争夺一个锁的时候（例子中的<code>locker</code>），一个线程等待，或者说[阻塞]，直到锁变为可用。这样就确保了在同一时刻只有一个线程能进入临界区（critical section，不允许并发执行的代码），所以 “ Done “ 只被打印了一次。像这种用来避免在多线程下的不确定性的方式被称为[线程安全（thread-safe）]。</p>
<p>在线程间共享数据是造成多线程复杂、难以定位的错误的主要原因。尽管这通常是必须的，但应该尽可能保持简单。</p>
<p>一个线程被阻塞时，不会消耗 CPU 资源。</p>
<h3 id="1-1Join-和-Sleep"><a href="#1-1Join-和-Sleep" class="headerlink" title="1.1Join 和 Sleep"></a>1.1Join 和 Sleep</h3><p>可以通过调用<code>Join</code>方法来等待另一个线程结束，例如：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread (Go);</span><br><span class="line">  t.Start();</span><br><span class="line">  t.<span class="keyword">Join</span>();</span><br><span class="line">  Console.<span class="keyword">WriteLine</span> (<span class="string">"Thread t has ended!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Go()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) Console.<span class="keyword">Write</span> (<span class="string">"y"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 “ y “ 1,000 次之后，紧接着会输出 “ Thread t has ended! “。当调用<code>Join</code>时可以使用一个超时参数，以毫秒或是<code>TimeSpan</code>形式。如果线程正常结束则返回<code>true</code>，如果超时则返回<code>false</code>。</p>
<p><code>Thread.Sleep</code>会将当前的线程阻塞一段时间：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="built-in">Sleep</span> (TimeSpan.FromHours (<span class="number">1</span>));  <span class="comment">// 阻塞 1小时</span></span><br><span class="line">Thread.<span class="built-in">Sleep</span> (<span class="number">500</span>);                     <span class="comment">// 阻塞 500 毫秒</span></span><br></pre></td></tr></table></figure>
<p>当使用<code>Sleep</code>或<code>Join</code>等待时，线程是[阻塞（blocked）]状态，因此不会消耗 CPU 资源。</p>
<p><code>Thread.Sleep(0)</code>会立即释放当前的时间片，将 CPU 资源出让给其它线程。Framework 4.0 新的<code>Thread.Yield()</code>方法与其相同，除了它只会出让给运行在相同处理器核心上的其它线程。</p>
<p><code>Sleep(0)</code>和<code>Yield</code>在调整代码性能时偶尔有用，它也是一个很好的诊断工具，可以用于找出[线程安全（thread safety）]的问题。如果在你代码的任意位置插入<code>Thread.Yield()</code>会影响到程序，基本可以确定存在 bug。</p>
<h3 id="1-2线程是如何工作的"><a href="#1-2线程是如何工作的" class="headerlink" title="1.2线程是如何工作的"></a>1.2线程是如何工作的</h3><p>线程在内部由一个线程调度器（thread scheduler）管理，一般 CLR 会把这个任务交给操作系统完成。线程调度器确保所有活动的线程能够分配到适当的执行时间，并且保证那些处于等待或阻塞状态（例如，等待排它锁或者用户输入）的线程不消耗CPU时间。</p>
<p>在单核计算机上，线程调度器会进行时间切片（time-slicing），快速的在活动线程中切换执行。在 Windows 操作系统上，一个时间片通常在十几毫秒（译者注：默认 15.625ms），远大于 CPU 在线程间进行上下文切换的开销（通常在几微秒区间）。</p>
<p>在多核计算机上，多线程的实现是混合了时间切片和真实的并发，不同的线程同时运行在不同的 CPU 核心上。几乎可以肯定仍然会使用到时间切片，因为操作系统除了要调度其它的应用，还需要调度自身的线程。</p>
<p>线程的执行由于外部因素（比如时间切片）被中断称为被抢占（preempted）。在大多数情况下，线程无法控制其在何时及在什么代码处被抢占。</p>
<h3 id="1-3线程-vs-进程"><a href="#1-3线程-vs-进程" class="headerlink" title="1.3线程 vs 进程"></a>1.3线程 vs 进程</h3><p>好比多个进程并行在计算机上执行，多个线程是在一个进程中并行执行。进程是完全隔离的，而线程是在一定程度上隔离。一般的，线程与运行在相同程序中的其它线程共享堆内存。这就是线程为何有用的部分原因，一个线程可以在后台获取数据，而另一个线程可以同时显示已获取到的数据。</p>
<h3 id="1-4线程的使用与误用"><a href="#1-4线程的使用与误用" class="headerlink" title="1.4线程的使用与误用"></a>1.4线程的使用与误用</h3><p>多线程有许多用处，下面是通常的应用场景：</p>
<ul>
<li><p>维持用户界面的响应</p>
<p>使用工作线程并行运行时间消耗大的任务，这样主UI线程就仍然可以响应键盘、鼠标的事件。</p>
</li>
<li><p>有效利用 CPU</p>
<p>多线程在一个线程等待其它计算机或硬件设备响应时非常有用。当一个线程在执行任务时被阻塞，其它线程就可以利用这个空闲出来的CPU核心。</p>
</li>
<li><p>并行计算</p>
<p>在多核心或多处理器的计算机上，计算密集型的代码如果通过分治策略（divide-and-conquer，见[第 5 部分]）将工作量分摊到多个线程，就可以提高计算速度。</p>
</li>
<li><p>推测执行（speculative execution）</p>
<p>在多核心的计算机上，有时可以通过推测之后需要被执行的工作，提前执行它们来提高性能。[LINQPad**]就使用了这个技术来加速新查询的创建。另一种方式就是可以多线程并行运行解决相同问题的不同算法，因为预先不知道哪个算法更好，这样做就可以尽早获得结果。</p>
</li>
<li><p>允许同时处理请求</p>
<p>在服务端，客户端请求可能同时到达，因此需要并行处理（如果你使用 ASP.NET、WCF、Web Services 或者 Remoting，.NET Framework 会自动创建线程）。这在客户端同样有用，例如处理 P2P 网络连接，或是处理来自用户的多个请求。</p>
</li>
</ul>
<p>如果使用了 ASP.NET 和 WCF 之类的技术，可能[不会注意到多线程被使用]，除非是访问共享数据时（比如通过静态字段共享数据）。如果没有正确的[加锁]，就[可能产生线程安全问题]。</p>
<p>多线程同样也会带来缺点，最大的问题是它提高了程序的复杂度。使用多个线程本身并不复杂，复杂的是线程间的交互（一般是通过共享数据）。无论线程间的交互是否有意为之，都会带来较长的开发周期，以及带来间歇的、难以重现的 bug。因此，最好保证线程间的交互尽量少，并坚持简单和已被证明的多线程交互设计。这篇文章主要就是关于如何处理这种复杂的问题，如果能够移除线程间交互，那会轻松许多。</p>
<p>一个好的策略是把多线程逻辑使用可重用的类封装，以便于独立的检验和测试。.NET Framework 提供了许多高层的线程构造，之后会讲到。</p>
<p>当频繁地调度和切换线程时（并且如果活动线程数量大于 CPU 核心数），多线程会增加资源和 CPU 的开销，线程的创建和销毁也会增加开销。多线程并不总是能提升程序的运行速度，如果使用不当，反而可能降低速度。 例如，当需要进行大量的磁盘 I/O 时，几个工作线程顺序执行可能会比 10 个线程同时执行要快。（在[使用 <code>Wait</code> 和 <code>Pulse</code> 进行同步]中，将会描述如何实现 [生产者 / 消费者队列]，它提供了上述功能。）</p>
<h2 id="2创建和启动线程"><a href="#2创建和启动线程" class="headerlink" title="2创建和启动线程"></a>2创建和启动线程</h2><p>像我们在简介中看到的那样，使用<code>Thread</code>类的构造方法来创建线程，通过传递<code>ThreadStart</code>委托来指明线程从哪里开始运行，下面是<code>ThreadStart</code>委托的定义：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ThreadStart</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>调用<code>Start</code>方法后，线程开始执行，直到它所执行的方法返回后，线程终止。下面这个例子使用完整的 C# 语法创建<code>TheadStart</code>委托：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread (<span class="keyword">new</span> ThreadStart (Go));</span><br><span class="line">    t.Start();   <span class="comment">// 在新线程运行 GO()</span></span><br><span class="line">    Go();        <span class="comment">// 同时在主线程运行 GO()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">"hello!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，线程<code>t</code>执行<code>Go()</code>方法，几乎同时主线程也执行<code>Go()</code>方法，结果将打印两个 hello。</p>
<p>线程也可以使用更简洁的语法创建，使用方法组（method group），让 C# 编译器推断<code>ThreadStart</code>委托类型：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span> t = <span class="literal">new</span> <span class="keyword">Thread</span> (Go);    <span class="comment">// 无需显式使用 ThreadStart</span></span><br></pre></td></tr></table></figure>
<p>另一个快捷的方式是使用 lambda 表达式或者匿名方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread ( <span class="function"><span class="params">()</span> =&gt;</span> Console.WriteLine (<span class="string">"Hello!"</span>) );</span><br><span class="line">  t.Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1向线程传递数据"><a href="#2-1向线程传递数据" class="headerlink" title="2.1向线程传递数据"></a>2.1向线程传递数据</h3><p>向一个线程的目标方法传递参数最简单的方式是使用 lambda 表达式调用目标方法，在表达式内指定参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread ( () =&gt; Print (<span class="string">"Hello from t!"</span>) );</span><br><span class="line">  t.Start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span> <span class="params">(<span class="built_in">string</span> message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Console.WriteLine (message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式，可以向方法传递任意数量的参数。甚至可以将整个实现封装为一个多语句的 lambda 表达式：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread (<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine (<span class="string">"I'm running on another thread!"</span>);</span><br><span class="line">  Console.WriteLine (<span class="string">"This is so easy!"</span>);</span><br><span class="line">&#125;).Start();</span><br></pre></td></tr></table></figure>
<p>在 C# 2.0 中，也可以很容易的使用匿名方法来进行相同的操作：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">new</span> <span class="keyword">Thread</span> (delegate()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="params">...</span></span><br><span class="line">&#125;).Start();</span><br></pre></td></tr></table></figure>
<p>另一个方法是向<code>Thread</code>的<code>Start</code>方法传递参数：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Thread t = <span class="keyword">new</span> Thread (Print);</span><br><span class="line">  t.Start (<span class="string">"Hello from t!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span> (<span class="params"><span class="keyword">object</span> messageObj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">string</span> message = (<span class="keyword">string</span>) messageObj;    <span class="comment">// 需要强制类型转换</span></span><br><span class="line">  Console.WriteLine (message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样是因为<code>Thread</code>的构造方法通过重载来接受两个委托中的任意一个：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ThreadStart</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ParameterizedThreadStart</span> (<span class="params"><span class="keyword">object</span> obj</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><code>ParameterizedThreadStart</code>的限制是它只接受一个参数。并且由于它是<code>object</code>类型，通常需要类型转换。</p>
<h4 id="Lambda-表达式与被捕获变量"><a href="#Lambda-表达式与被捕获变量" class="headerlink" title="Lambda 表达式与被捕获变量"></a>Lambda 表达式与被捕获变量</h4><p>如我们所见，lambda 表达式是向线程传递数据的最强大的方法。然而必须小心，不要在启动线程之后误修改被捕获变量（captured variables）。例如，考虑下面的例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++)</span></span><br><span class="line">  new Thread (() =&gt; Console.Write (<span class="name">i</span>)).Start()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>输出结果是不确定的！可能是这样<code>0223557799</code>。</p>
<p>问题在于变量<code>i</code>在整个循环中指向相同的内存地址。所以，每一个线程在调用<code>Console.Write</code>时，都在使用这个值在运行时会被改变的变量！</p>
<p>类似的问题在[C# 4.0 in a Nutshell**]的第 8 章的 “Captured Variables” 有描述。这个问题与多线程没什么关系，而是和 C# 的捕获变量的规则有关（在<code>for</code>和<code>foreach</code>的场景下有时不是很理想）。</p>
<p>解决方法就是使用临时变量，如下所示：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++)</span></span><br><span class="line">&#123;</span><br><span class="line">  int temp = i<span class="comment">;</span></span><br><span class="line">  new Thread (() =&gt; Console.Write (<span class="name">temp</span>)).Start()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量<code>temp</code>对于每一个循环迭代是局部的。所以，每一个线程会捕获一个不同的内存地址，从而不会产生问题。我们可以使用更为简单的代码来演示前面的问题：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string text = <span class="string">"t1"</span><span class="comment">;</span></span><br><span class="line">Thread <span class="built_in">t1</span> = new Thread ( () =&gt; Console.WriteLine (text) )<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">"t2"</span><span class="comment">;</span></span><br><span class="line">Thread <span class="built_in">t2</span> = new Thread ( () =&gt; Console.WriteLine (text) )<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">t1</span>.Start()<span class="comment">;</span></span><br><span class="line"><span class="built_in">t2</span>.Start()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>因为两个lambda表达式捕获了相同的<code>text</code>变量，<code>t2</code>会被打印两次：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t2</span></span><br><span class="line"><span class="built_in">t2</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2线程命名"><a href="#2-2线程命名" class="headerlink" title="2.2线程命名"></a>2.2线程命名</h3><p>每一个线程都有一个 Name 属性，我们可以设置它以便于调试。这在 Visual Studio 中非常有用，因为线程的名字会显示在线程窗口（Threads Window）与调试位置（Debug Location）工具栏上。线程的名字只能设置一次，以后尝试修改会抛出异常。</p>
<p>静态的<code>Thread.CurrentThread</code>属性会返回当前执行的线程。在下面的例子中，我们设置主线程的名字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadNaming</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread.CurrentThread.Name = <span class="string">"main"</span>;</span><br><span class="line">    Thread worker = <span class="keyword">new</span> Thread (Go);</span><br><span class="line">    worker.Name = <span class="string">"worker"</span>;</span><br><span class="line">    worker.Start();</span><br><span class="line">    Go();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">"Hello from "</span> + Thread.CurrentThread.Name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3前台与后台线程"><a href="#2-3前台与后台线程" class="headerlink" title="2.3前台与后台线程"></a>2.3前台与后台线程</h3><p>默认情况下，显式创建的线程都是前台线程（foreground threads）。只要有一个前台线程在运行，程序就可以保持存活，而后台线程（background threads）并不能保持程序存活。当一个程序中所有前台线程停止运行时，仍在运行的所有后台线程会被强制终止。</p>
<p>线程的前台/后台状态与它的优先级和执行时间的分配无关。</p>
<p>可以通过线程的<code>IsBackground</code>属性来查询或修改线程的前后台状态。如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> <span class="params">(<span class="built_in">string</span>[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Thread worker = <span class="keyword">new</span> Thread ( () =&gt; Console.ReadLine() );</span><br><span class="line">    <span class="keyword">if</span> (args.Length &gt; <span class="number">0</span>) worker.IsBackground = <span class="literal">true</span>;</span><br><span class="line">    worker.Start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个程序以无参数的形式运行，工作线程会默认为前台，并在<code>ReadLine</code>时等待用户输入回车。此时主线程退出，但是程序仍然在运行，因为有一个前台线程依然存活。</p>
<p>相反，如果给<code>Main()</code>传递了参数，工作线程设置为后台状态，当主线程结束时，程序几乎立即退出（终止<code>ReadLine</code>需要一咪咪时间）。</p>
<p>当进程以这种方式结束时，后台线程执行栈中所有<code>finally</code>块就会被避开。如果程序依赖<code>finally</code>（或是<code>using</code>）块来执行清理工作，例如释放资源或是删除临时文件，就可能会产生问题。为了避免这种问题，在退出程序时可以显式的等待这些后台线程结束。有两种方法可以实现：</p>
<ul>
<li>如果是自己创建的线程，在线程上调用[<code>Join</code>](方法。</li>
<li>如果是使用[线程池线程]，使用[事件等待句柄]。</li>
</ul>
<p>在任一种情况下，都应指定一个超时时间，从而可以放弃由于某种原因而无法正常结束的线程。这是后备的退出策略：我们希望程序最后可以关闭，而不是让用户去开任务管理器<code>(╯-_-)╯╧══╧</code></p>
<p>如果用户使用任务管理器强行终止了 .NET 进程，所有线程都会被当作后台线程一般丢弃。这是通过观察得出的结论，并不是通过文档，而且可能会因为 CLR 和操作系统的版本不同而有不同的行为。</p>
<p>前台线程不需要这种处理，但是必须小心避免会使线程无法结束的 bug。程序无法正常退出的一个很有可能的原因就是仍有前台线程存在。</p>
<h3 id="2-4线程优先级"><a href="#2-4线程优先级" class="headerlink" title="2.4线程优先级"></a>2.4线程优先级</h3><p>线程的<code>Priority</code>属性决定了相对于操作系统中的其它活动线程，它可以获得多少执行时间。线程优先级的取值如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ThreadPriority</span> &#123; <span class="title">Lowest</span>, <span class="title">BelowNormal</span>, <span class="title">Normal</span>, <span class="title">AboveNormal</span>, <span class="title">Highest</span> &#125;</span></span><br></pre></td></tr></table></figure>
<p>只有当多个线程同时活动时，线程优先级才有意义。</p>
<blockquote>
<p>在提升线程优先级前请三思，这可能会导致其它线程的资源饥饿（resource starvation，译者注：指没有分配到足够的CPU时间来运行）等问题。</p>
</blockquote>
<p>提升线程的优先级是无法使其能够处理实时任务的，因为它还受到程序进程优先级的影响。要进行实时任务，必须同时使用<code>System.Diagnostics</code>中的<code>Process</code>类来提升进程的优先级（记得这不是我告诉你的）：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="built_in">Process</span> p = <span class="built_in">Process</span>.GetCurrentProcess())</span><br><span class="line">  p.PriorityClass = ProcessPriorityClass.High;</span><br></pre></td></tr></table></figure>
<p><code>ProcessPriorityClass.High</code>实际上就是一个略低于最高优先级<code>Realtime</code>的级别。将一个进程的优先级设置为<code>Realtime</code>是通知操作系统，我们绝不希望该进程将 CPU 时间出让给其它进程。如果你的程序误入一个无限循环，会发现甚至是操作系统也被锁住了，就只好去按电源按钮了<code>o(&gt;_&lt;)o</code>　正是由于这一原因，High 通常是实时程序的最好选择。</p>
<p>如果实时程序拥有用户界面，提升进程的优先级会导致大量的 CPU 时间被用于屏幕更新，这会降低整台机器的速度（特别是当 UI 很复杂时）。降低主线程的优先级，并提升进程的优先级可以保证需要进行实时任务的工作线程不会被屏幕重绘所抢占。但是这依然没有解决其它程序的CPU时间饥饿的问题，因为操作系统依然为这个进程分配了大量 CPU 资源。</p>
<p>理想的解决方案是分离 UI 线程和实时工作线程，使用两个进程分别运行。这样就可以分别设置各自的进程优先级，彼此之间通过 Remoting 或是内存映射文件进行通信。内存映射文件十分适用于这一任务，在<a href="http://www.albahari.com/nutshell/" target="_blank" rel="noopener">C# 4.0 in a Nutshell**</a>的第 14 和 25 章会讲到。</p>
<p>即使是提升了进程优先级，托管环境在处理强实时需求时仍然有限制。除了自动垃圾回收带来的延迟，操作系统也不能够完全满足实时任务的需要，即便是非托管的程序也是如此。最好的解决办法还是使用独立的硬件或者专门的实时平台。</p>
<h3 id="2-5异常处理"><a href="#2-5异常处理" class="headerlink" title="2.5异常处理"></a>2.5异常处理</h3><p>当线程开始运行后，其创建代码所在的<code>try / catch / finally</code>块与该线程不再有任何关系。考虑下面的程序：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread (Go).Start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 永远执行不到这里</span></span><br><span class="line">    Console.WriteLine (<span class="string">"Exception!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">null</span>; &#125;   <span class="comment">// 产生 NullReferenceException 异常</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子中的<code>try / catch</code>语句是无效的，而新创建的线程将会遇到一个未处理的<code>NullReferenceException</code>。因为主线程直接跳过catch。</p>
</blockquote>
<p>修改方法是将异常处理移到<code>Go</code>方法中：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">new</span> Thread (Go).Start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Go()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">null</span>;    <span class="comment">// 异常会在下面被捕获</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 一般会记录异常， 和/或通知其它线程我们遇到问题了</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在生产环境的程序中，所有线程的入口方法处都应该有一个异常处理器，就如同在主线程所做的那样（一般可能是在执行栈上靠近入口的地方）。未处理的异常会使得整个程序停止运行，弹出一个难看的对话框。</p>
<p>在写异常处理块的时候，最好不要忽略错误。一般应该记录异常详细信息，然后可以弹出一个对话框让用户可以选择是否自动把这些信息提交到你的服务器。最后应该关闭程序，因为很可能错误已经破坏的程序的状态。然而这么做会导致用户丢失当前的工作，比如打开的文档。</p>
<p>WPF 和 Windows Forms 应用中的“全局”异常处理事件（<code>Application.DispatcherUnhandledException</code>和<code>Application.ThreadException</code>）只会在主UI线程有未处理的异常时触发。对于工作线程上的异常仍然需要手动处理。</p>
<p><code>AppDomain.CurrentDomain.UnhandledException</code>会对所有未处理的异常触发，但是它不提供阻止程序退出的办法。</p>
<p>然而在某些情况下，可以不必处理工作线程上的异常，因为 .NET Framework 会为你处理。这些会在接下来的内容中讲到：</p>
<ul>
<li>[异步委托]</li>
<li>[<code>BackgroundWorker</code>]</li>
<li>[任务并行库（TPL）]</li>
</ul>
<h2 id="3线程池"><a href="#3线程池" class="headerlink" title="3线程池"></a>3线程池</h2><blockquote>
<p>当启动一个线程时，会有几百毫秒的时间花费在准备一些额外的资源上，例如一个新的私有局部变量栈这样的事情。每个线程会占用（默认情况下）1MB 内存。线程池（thread pool）可以通过共享与回收线程来减轻这些开销，允许多线程应用在很小的粒度上而没有性能损失。在多核心处理器以分治（divide-and-conquer）的风格执行计算密集代码时将会十分有用。</p>
</blockquote>
<p>线程池会限制其同时运行的工作线程总数。太多的活动线程会加重操作系统的管理负担，也会降低 CPU 缓存的效果。一旦达到数量限制，任务就会进行排队，等待一个任务完成后才会启动另一个。这使得程序任意并发成为可能，例如 web 服务器。（异步方法模式（asynchronous method pattern）是进一步高效利用线程池的高级技术，我们在<a href="http://www.albahari.com/nutshell/" target="_blank" rel="noopener">C# 4.0 in a Nutshell**</a>的 23 章来讲）。</p>
<p>有多种方法可以使用线程池：</p>
<ul>
<li>通过[任务并行库（TPL）]（Framework 4.0 中加入）</li>
<li>调用[<code>ThreadPool.QueueUserWorkItem</code>]</li>
<li>通过[异步委托]</li>
<li>通过[<code>BackgroundWorker</code>]</li>
</ul>
<p>以下构造会间接使用线程池：</p>
<ul>
<li>WCF、Remoting、ASP.NET 和 ASMX 网络服务应用</li>
<li>[<code>System.Timers.Timer</code>]和 [<code>System.Threading.Timer</code>]</li>
<li>.NET Framework 中名字以 <em>Async</em> 结尾的方法，例如<code>WebClient</code>上的方法（使用[基于事件的异步模式，EAP]），和大部分<code>BeginXXX</code>方法（异步编程模型模式，APM）</li>
<li>PLINQ</li>
</ul>
<p>任务并行库（Task Parallel Library，TPL）与 PLINQ 足够强大并面向高层，即使使用线程池并不重要，也应该使用它们来辅助多线程。我们会在[第 5 部分]中进行更详细的讨论。现在，简单看一下如何使用[<code>Task</code>]类作为在线程池线程上运行委托的简单方法。</p>
<p>在使用线程池线程时有几点需要小心：</p>
<ul>
<li>无法设置线程池线程的<code>Name</code>属性，这会令调试更为困难（当然，调试时也可以在 Visual Studio 的线程窗口中给线程附加备注）。</li>
<li>线程池线程永远是[后台线程]（一般不是问题）。</li>
<li>[阻塞]线程池线程可能会在程序早期带来额外的延迟，除非调用了<code>ThreadPool.SetMinThreads</code>（见[优化线程池]）。</li>
</ul>
<p>可以改变线程池线程的[优先级]，当它用完后返回线程池时会被恢复到默认状态。</p>
<p>可以通过<code>Thread.CurrentThread.IsThreadPoolThread</code>属性来查询当前是否运行在线程池线程上。</p>
<h3 id="3-1通过-TPL-使用线程池"><a href="#3-1通过-TPL-使用线程池" class="headerlink" title="3.1通过 TPL 使用线程池"></a>3.1通过 TPL 使用线程池</h3><p>可以很容易的使用<em>任务并行库</em>（Task Parallel Library，TPL）中的[<code>Task</code>]类来使用线程池。</p>
<blockquote>
<p><code>Task</code>类在 Framework 4.0 时被加入：如果你熟悉旧式的构造，可以将非泛型的<code>Task</code>类看作[<code>ThreadPool.QueueUserWorkItem</code>]的替代，而泛型的<code>Task&lt;TResult&gt;</code>看作[异步委托]的替代。比起旧式的构造，新式的构造会更快速，更方便，并且更灵活。</p>
</blockquote>
<p>要使用非泛型的<code>Task</code>类，调用<code>Task.Factory.StartNew</code>，并传递目标方法的委托：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span>    <span class="comment">// Task 类在 System.Threading.Tasks 命名空间中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Task.Factory.StartNew (Go);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Console.WriteLine (<span class="string">"Hello from the thread pool!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Task.Factory.StartNew</code>返回一个<code>Task</code>对象，可以用来监视任务，例如通过调用<code>Wait</code>)方法来等待其结束。</p>
<p>当调用<code>Task</code>的[<code>Wait</code>方法]时，所有未处理的异常会在宿主线程被重新抛出。（如果不调用<code>Wait</code>而是丢弃不管，未处理的异常会[像普通的线程那样]结束程序。（译者注：在 .NET 4.5 中，为了支持基于<code>async / await</code>的异步模式，<code>Task</code>中这种“未观察”的异常默认会被忽略，而不会导致程序结束。</p>
<p>泛型的<code>Task&lt;TResult&gt;</code>类是非泛型<code>Task</code>的子类。它可以使你在其完成执行后得到一个返回值。在下面的例子中，我们使用<code>Task&lt;TResult&gt;</code>来下载一个网页：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> Main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 启动 task：</span></span><br><span class="line">  Task&lt;<span class="built_in">string</span>&gt; task = Task.Factory.StartNew&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">    ( <span class="function"><span class="params">()</span> =&gt;</span> DownloadString (<span class="string">"http://www.gkarch.com"</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行其它工作，它会和 task 并行执行：</span></span><br><span class="line">  RunSomeOtherMethod();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 Result 属性获取返回值：</span></span><br><span class="line">  <span class="comment">// 如果仍在执行中, 当前进程会阻塞等待直到 task 结束：</span></span><br><span class="line">  <span class="built_in">string</span> result = task.Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">string</span> DownloadString (<span class="built_in">string</span> uri)</span><br><span class="line">&#123;</span><br><span class="line">  using (<span class="keyword">var</span> wc = <span class="keyword">new</span> System.Net.WebClient())</span><br><span class="line">    <span class="keyword">return</span> wc.DownloadString (uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（这里的<code>&lt;string&gt;</code> 类型参数是为了示例的清晰，它可以被省略，让编译器推断。）</p>
<p>查询task的<code>Result</code>属性时，未处理的异常会被封装在[<code>AggregateException</code>]中自动重新抛出。然而，如果没有查询<code>Result</code>属性（并且也没有调用<code>Wait</code>），未处理的异常会令程序结束。</p>
<p>TPL 具有更多的特性，非常适合于利用多核处理器。关于 TPL 的讨论我们在[第 5 部分]中继续。</p>
<h3 id="3-2不通过-TPL-使用线程池"><a href="#3-2不通过-TPL-使用线程池" class="headerlink" title="3.2不通过 TPL 使用线程池"></a>3.2不通过 TPL 使用线程池</h3><p>如果是使用 .NET Framework 4.0 以前的版本，则不能使用任务并行库。你必须通过一种旧的构造使用线程池：<code>ThreadPool.QueueUserWorkItem</code>与异步委托。这两者之间的不同在于异步委托可以让你从线程中返回数据，同时异步委托还可以将异常封送回调用方。</p>
<h4 id="QueueUserWorkItem"><a href="#QueueUserWorkItem" class="headerlink" title="QueueUserWorkItem"></a>QueueUserWorkItem</h4><p>要使用<code>QueueUserWorkItem</code>，仅需要使用希望在线程池线程上运行的委托来调用该方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ThreadPool.QueueUserWorkItem (Go);</span><br><span class="line">  ThreadPool.QueueUserWorkItem (Go, <span class="number">123</span>);</span><br><span class="line">  Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span> (<span class="params"><span class="keyword">object</span> data</span>)   <span class="comment">// 第一次调用时 data 为 null</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Console.WriteLine (<span class="string">"Hello from the thread pool! "</span> + data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello <span class="built_in">from</span> <span class="keyword">the</span> thread pool!</span><br><span class="line">Hello <span class="built_in">from</span> <span class="keyword">the</span> thread pool! <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>目标方法<code>Go</code>，必须接受单一一个<code>object</code>参数（来满足<code>WaitCallback</code>委托）。这提供了一种向方法传递数据的便捷方式，就像<code>ParameterizedThreadStart</code>一样。与<code>Task</code>不同，<code>QueueUserWorkItem</code>并不会返回一个对象来帮助我们在后续管理其执行。并且，你必须在目标代码中显式处理异常，未处理的异常会[令程序结束]</p>
<h4 id="异步委托"><a href="#异步委托" class="headerlink" title="异步委托"></a>异步委托</h4><p><code>ThreadPool.QueueUserWorkItem</code>并没有提供在线程执行结束之后从线程中返回值的简单机制。异步委托调用（asynchronous delegate invocations ）解决了这一问题，可以允许双向传递任意数量的参数。而且，异步委托上的未处理异常可以方便的原线程上重新抛出（更确切的说，在调用<code>EndInvoke</code>的线程上），所以它们不需要显式处理。</p>
<p>不要混淆异步委托和异步方法（asynchronous methods ，以 <em>Begin</em> 或 <em>End</em> 开始的方法，比如<code>File.BeginRead</code>/<code>File.EndRead</code>）。异步方法表面上看使用了相似的方式，但是其实是为了解决更困难的问题。我们在<a href="http://www.albahari.com/nutshell/" target="_blank" rel="noopener">C# 4.0 in a Nutshell**</a>的第 23 章中描述。</p>
<p>下面是如何通过异步委托启动一个工作线程：</p>
<ol>
<li><p>创建目标方法的委托（通常是一个<code>Func</code>类型的委托）。</p>
</li>
<li><p>在该委托上调用<code>BeginInvoke</code>，保存其<code>IAsyncResult</code>类型的返回值。</p>
<p><code>BeginInvokde</code>会立即返回。当线程池线程正在工作时，你可以执行其它的动作。</p>
</li>
<li><p>当需要结果时，在委托上调用<code>EndInvoke</code>，传递所保存的<code>IAsyncResult</code>对象。</p>
</li>
</ol>
<p>接下来的例子中，我们使用异步委托调用来和主线程中并行运行一个返回字行串长度的简单方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; method = Work;</span><br><span class="line">  IAsyncResult cookie = method.BeginInvoke (<span class="string">"test"</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 这里可以并行执行其它任务</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">int</span> result = method.EndInvoke (cookie);</span><br><span class="line">  Console.WriteLine (<span class="string">"String length is: "</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Work</span> (<span class="params"><span class="keyword">string</span> s</span>) </span>&#123; <span class="keyword">return</span> s.Length; &#125;</span><br></pre></td></tr></table></figure>
<p><code>EndInvoke</code>会做三件事：</p>
<ol>
<li>如果异步委托还没有结束，它会等待异步委托完成执行。</li>
<li>它会接收返回值（也包括<code>ref</code>和<code>out</code>方式的参数）。</li>
<li>它会向调用线程抛出未处理的异常。</li>
</ol>
<blockquote>
<p>如果使用异步委托调用的方法没有返回值，技术上你仍然需要调用<code>EndInvoke</code>。在实践中，这里存在争论，因为不调用<code>EndInvoke</code>也不会有什么损失。然而如果你选择不调用它，就需要考虑目标方法中的异常处理来避免错误无法察觉。</p>
<p>（译者注：<a href="https://msdn.microsoft.com/zh-cn/library/2e08f6yc.aspx" target="_blank" rel="noopener">MSDN文档**</a>中明确写了 “无论您使用何种方法，都要调用 <strong>EndInvoke</strong> 来完成异步调用。”，所以最好不要偷懒。）</p>
</blockquote>
<p>当调用<code>BeginInvoke</code>时也可以指定一个回调委托。这是一个在完成时会被自动调用的、接受<code>IAsyncResult</code>对象的方法。这样可以在后面的代码中“忘记”异步委托，但是需要在回调方法里做点其它工作：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; method = Work;</span><br><span class="line">  method.BeginInvoke (<span class="string">"test"</span>, Done, method);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Work</span> (<span class="params"><span class="keyword">string</span> s</span>) </span>&#123; <span class="keyword">return</span> s.Length; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Done</span> (<span class="params">IAsyncResult cookie</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = (Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;) cookie.AsyncState;</span><br><span class="line">  <span class="keyword">int</span> result = target.EndInvoke (cookie);</span><br><span class="line">  Console.WriteLine (<span class="string">"String length is: "</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BeginInvoke</code>的最后一个参数是一个用户状态对象，用于设置<code>IAsyncResult</code>的<code>AsyncState</code>属性。它可以是需要的任何东西，在这个例子中，我们用它向回调方法传递<code>method</code>委托，这样才能够在它上面调用<code>EndInvoke</code>。</p>
<h3 id="3-3优化线程池"><a href="#3-3优化线程池" class="headerlink" title="3.3优化线程池"></a>3.3优化线程池</h3><p>线程池初始时其池内只有一个线程。随着任务的分配，线程池管理器就会向池内“注入”新线程来满足工作负荷的需要，直到最大数量的限制。在足够的非活动时间之后，线程池管理器在认为“回收”一些线程能够带来更好的吞吐量时进行线程回收。</p>
<p>可以通过调用<code>ThreadPool.SetMaxThreads</code>方法来设置线程池可以创建的线程上限；默认如下：</p>
<ul>
<li>Framework 4.0，32位环境下：1023</li>
<li>Framework 4.0，64位环境下：32768</li>
<li>Framework 3.5：每个核心 250</li>
<li>Framework 2.0：每个核心 25</li>
</ul>
<p>（这些数字可能根据硬件和操作系统不同而有差异。）数量这么多是因为要确定[阻塞]（等待一些条件，比如远程计算机的相应）的线程的条件是否被满足。</p>
<p>也可以通过<code>ThreadPool.SetMinThreads</code>设置线程数量下限。下限的作用比较奇妙：它是一种高级的优化技术，用来指示线程池管理器在达到下限之前不要延迟线程的分配。当存在[阻塞]线程时，提高下限可以改善程序并发性。</p>
<p>默认下限数量是 CPU 核心数，也就是能充分利用 CPU 的最小数值。在服务器环境下（比如 IIS 中的 ASP.NET），下限数量一般要高的多，差不多 50 或者更高。</p>
<h4 id="最小线程数量是如何起作用的？"><a href="#最小线程数量是如何起作用的？" class="headerlink" title="最小线程数量是如何起作用的？"></a>最小线程数量是如何起作用的？</h4><blockquote>
<p><strong>将线程池的最小线程数设置为 <em>x</em> 并不是立即创建至少 <em>x</em> 个线程，而是线程会根据需要来创建。这个数值是指示线程池管理器当需要的时候，立即 创建 <em>x</em> 个线程</strong>。那么问题是为什么线程池在其它情况下会延迟创建线程？</p>
</blockquote>
<p>答案是为了防止短生命周期的任务导致线程数量短暂高峰，使程序的内存足迹（memory footprint）快速膨胀。为了描述这个问题，考虑在一个 4 核的计算机上运行一个客户端程序，它一次发起了 40 个任务请求。如果每个任务都是一个 10ms 的计算，假设它们平均分配在 4 个核心上，总共的开销就是 100ms 多。理想情况下，我们希望这 40 个任务运行在 <em>4</em> 个线程上：</p>
<ul>
<li>如果线程数量更少，就无法充分利用 4 个核心。</li>
<li>如果线程数量更多，会浪费内存和 CPU 时间去创建不必要的线程。</li>
</ul>
<p>线程池就是以这种方式工作的。让线程数量和 CPU 核心数量匹配，就能够既保持小的内存足迹，又不损失性能。当然这也需要线程都能被充分使用（在这个例子中满足该条件）。</p>
<p>但是，现在来假设任务不是进行 10ms 的计算，而是请求互联网，使用半秒钟等待响应，此时本地 CPU 是空闲状态。线程池管理器的线程经济策略（译者注：指上面说的线程数量匹配核心数）这时就不灵了，应该创建更多的线程，让所有的请求同时进行。</p>
<p>幸运的是，线程池管理器还有一个后备方案。如果在半秒内没有能够响应请求队列，就会再创建一个新的线程，以此类推，直到线程数量上限。</p>
<p><strong>半秒的等待时间是一把双刃剑。一方面它意味着一次性的短暂任务不会使程序快速消耗不必要的40MB（或者更多）的内存。另一方面，在线程池线程被阻塞时，比如在请求数据库或者调用<code>WebClient.DownloadFile</code>，就进行不必要的等待。</strong>因为这种原因，你可以通过调用<code>SetMinThreads</code>来让线程池管理器在分配最初的 <em>x</em> 个线程时不要等待，例如：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.SetMinThreads (<span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>（第二个参数是表示多少个线程分配给 I/O 完成端口（I/O completion ports，IOCP），来被APM使用，这会在<a href="http://www.albahari.com/nutshell/" target="_blank" rel="noopener">C# 4.0 in a Nutshell**</a> 的第 23 章描述。）</p>
<p>最小线程数量的默认值是 CPU 核心数。</p>
<blockquote>
<p>总结：面对长时间等待的线程，因为这些线程只占时间，并不需要cpu计算，所以线程池管理器之前的平分策略就出现了问题，由此引入半秒等待机制，一旦此线程运行时间超过半秒就直接开启新的线程给新任务。但半秒等待机制还是存在利弊，利是防止很多线程的同时开启一下子占用大量内存，弊是必须等待半秒线程管理器才会开启新线程导致时间浪费，此时设置最小线程数量显得尤为重要，可以有效的防止等待，也不会占用很多内存（根据你自己的设置）</p>
</blockquote>

 </div>
 
 <div class="article-tags tags">
		 
		 <a href="/tags/thread/">thread</a>
		 
 </div>
 
<div id="comments" style="margin: 5px auto;">
	<div id="comment"></div>
                        <script>
                            new Valine({
                        el: '#comment' ,
                        notify:false, 
                        verify:false, 
                        appId: 'oTcHLJ1mpOGAcKcahsaQEBaQ-gzGzoHsz',
                        appKey: 'Jq4QEoyIo2Y40s3PHny873nz',
                        placeholder: ' ( *￣▽￣)((≧︶≦*)',
                        path:window.location.pathname, 
						avatar:'retro'
                    });
                        </script>
</div>
 
 <div class="art-item-footer">
		 
		 <span class="art-item-left">
				 <i class="icon icon-chevron-thin-left"></i>prev：<a href="/2017/12/28/JavaScript02/" rel="prev" title="初识JavaScript02">
						 初识JavaScript02
				 </a>
		 </span>
		 
		 
		 <span class="art-item-right">
				 next：<a href="/2017/12/27/JavaScript01/" rel="next" title="初识JavaScript01">
						 初识JavaScript01
				 </a><i class="icon icon-chevron-thin-right"></i>
		 </span>
		 
 </div>
 
</section>

</article>
<script>
window.subData = {
 title: 'C#中的多线程 - 01基础知识',
 tools: true
}
</script>

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/images/avatar.jpg' />

<div class='header'>luox78</div>
<div class='content'>
<div class='desc'>It's always not too late to learn</div>
</div>
</section>

  <section class='m_widget'>
        <div class='header'>田馥甄-你就不要想起我</div>
<div>
    <audio src="https://luox78.github.io/images/田馥甄-你就不要想起我.mp3" controls="controls" style="width:250px;">
        田馥甄-你就不要想起我
    </audio>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/ASP-NET/"><div class='name'>ASP.NET</div><div class='badget'>9</div></a></li>
    
        <li><a class="flat-box" href="/categories/ASP-NET-MVC/"><div class='name'>ASP.NET MVC</div><div class='badget'>4</div></a></li>
    
        <li><a class="flat-box" href="/categories/C/"><div class='name'>C#</div><div class='badget'>15</div></a></li>
    
        <li><a class="flat-box" href="/categories/DailyLearning/"><div class='name'>DailyLearning</div><div class='badget'>6</div></a></li>
    
        <li><a class="flat-box" href="/categories/JQuery/"><div class='name'>JQuery</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/JavaScript/"><div class='name'>JavaScript</div><div class='badget'>21</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/ASP-NET-MVC5-编程实战/" style="font-size: 15.5px; color: #606060">ASP.NET MVC5 编程实战</a> <a href="/tags/Ajax/" style="font-size: 14px; color: #808080">Ajax</a> <a href="/tags/AjaxHelper/" style="font-size: 14px; color: #808080">AjaxHelper</a> <a href="/tags/C-特性/" style="font-size: 15.5px; color: #606060">C#特性</a> <a href="/tags/DI/" style="font-size: 14px; color: #808080">DI</a> <a href="/tags/Entity-Framework/" style="font-size: 15.5px; color: #606060">Entity Framework</a> <a href="/tags/HtmlHelper拓展/" style="font-size: 14px; color: #808080">HtmlHelper拓展</a> <a href="/tags/HttpModule/" style="font-size: 14px; color: #808080">HttpModule</a> <a href="/tags/HttpRequest/" style="font-size: 14px; color: #808080">HttpRequest</a> <a href="/tags/HttpResponse/" style="font-size: 14px; color: #808080">HttpResponse</a> <a href="/tags/HttpUtility/" style="font-size: 14px; color: #808080">HttpUtility</a> <a href="/tags/IIS请求流程/" style="font-size: 14px; color: #808080">IIS请求流程</a> <a href="/tags/IOC/" style="font-size: 15.5px; color: #606060">IOC</a> <a href="/tags/Json/" style="font-size: 14px; color: #808080">Json</a> <a href="/tags/LINQ/" style="font-size: 15.5px; color: #606060">LINQ</a> <a href="/tags/MD5/" style="font-size: 14px; color: #808080">MD5</a> <a href="/tags/NOPI/" style="font-size: 14px; color: #808080">NOPI</a> <a href="/tags/SqlHelper/" style="font-size: 14px; color: #808080">SqlHelper</a> <a href="/tags/asp-net-mvc/" style="font-size: 14px; color: #808080">asp.net mvc</a> <a href="/tags/autofac/" style="font-size: 14px; color: #808080">autofac</a> <a href="/tags/bitwiseOperations/" style="font-size: 14px; color: #808080">bitwiseOperations</a> <a href="/tags/cache/" style="font-size: 15.5px; color: #606060">cache</a> <a href="/tags/database-first/" style="font-size: 14px; color: #808080">database first</a> <a href="/tags/entity-framework/" style="font-size: 14px; color: #808080">entity framework</a> <a href="/tags/entity-framework-designer/" style="font-size: 14px; color: #808080">entity framework designer</a> <a href="/tags/filters/" style="font-size: 14px; color: #808080">filters</a> <a href="/tags/https/" style="font-size: 14px; color: #808080">https</a> <a href="/tags/http协议/" style="font-size: 14px; color: #808080">http协议</a> <a href="/tags/jQueryfoundation/" style="font-size: 17px; color: #404040">jQueryfoundation</a> <a href="/tags/jsfoundation/" style="font-size: 18.5px; color: #202020">jsfoundation</a> <a href="/tags/linq-to-ef/" style="font-size: 14px; color: #808080">linq to ef</a> <a href="/tags/model-first/" style="font-size: 14px; color: #808080">model first</a> <a href="/tags/path/" style="font-size: 14px; color: #808080">path</a> <a href="/tags/request/" style="font-size: 14px; color: #808080">request</a> <a href="/tags/swagger/" style="font-size: 14px; color: #808080">swagger</a> <a href="/tags/thread/" style="font-size: 15.5px; color: #606060">thread</a> <a href="/tags/tips/" style="font-size: 14px; color: #808080">tips</a> <a href="/tags/viewstate/" style="font-size: 14px; color: #808080">viewstate</a> <a href="/tags/三层/" style="font-size: 15.5px; color: #606060">三层</a> <a href="/tags/分页/" style="font-size: 14px; color: #808080">分页</a> <a href="/tags/单例模式/" style="font-size: 14px; color: #808080">单例模式</a> <a href="/tags/发邮件/" style="font-size: 14px; color: #808080">发邮件</a> <a href="/tags/工厂模式/" style="font-size: 14px; color: #808080">工厂模式</a> <a href="/tags/文件上传下载/" style="font-size: 14px; color: #808080">文件上传下载</a> <a href="/tags/模拟IIS/" style="font-size: 14px; color: #808080">模拟IIS</a> <a href="/tags/深入理解JS/" style="font-size: 20px; color: #000">深入理解JS</a> <a href="/tags/深入理解aspx/" style="font-size: 14px; color: #808080">深入理解aspx</a> <a href="/tags/简单三层/" style="font-size: 14px; color: #808080">简单三层</a> <a href="/tags/线程/" style="font-size: 14px; color: #808080">线程</a> <a href="/tags/缩略图/" style="font-size: 14px; color: #808080">缩略图</a> <a href="/tags/错误页/" style="font-size: 14px; color: #808080">错误页</a>
    </div>
</div>



  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://github.com/luox78">
            <div class='name'>Github</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://www.baidu.com">
            <div class='name'>Baidu</div>
        </a></li>
    
    </ul>
</div>
</section>

      </aside>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/luox78" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>
    <span>
        Powered by:<a href="https://hexo.io/" class="codename" target="_blank">
                       hexo
        </a>
    </span>
    <span> - </span>
    <span>
        Theme: <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename" target="_blank">MaterialFlow</a> 
    </span>
    <span> - </span>
    <span id="busuanzi_container_site_pv">
        本站总访问量:
        <a href='http://ibruce.info/2015/04/04/busuanzi/' class="codename" target="_blank">
            <span id="busuanzi_value_site_pv"></span>
        </a>
    </span>
</div>
  
</footer>


  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>
<!--隐藏不是主页的wiget-->
<script>
  if(document.location.href !== "https://luox78.github.io/" && document.location.href !== "https://luox78.github.io/archives/" && document.location.href !== "http://localhost:4000/"){
    var foo = document.getElementsByClassName("l_side");
    for (let index = 0; index < foo.length; index++) {
      foo[index].style.display="none";
    }
  }
  Waves.attach('.vbtn', ['waves-button', 'waves-float']);
  Waves.attach(".u-search-form", ['.waves-circle']);
  Waves.init();

  //添加tr显示效果
  $(".article-entry>table tbody tr:odd").css("backgroundColor","rgb(235,236,238)");
	$("#loading").fadeOut(1000);
  $("ol").attr("type",1);
</script>


</body>
</html>
