<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>C#7 特性 | luox78</title>
  <meta name="description" content="Blog for luox78" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="theme-color" content=" rgb(59,95,208)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <link rel="shortcut icon" href="/images/dev.ico">
  <link rel="alternate" href="/atom.xml" title="luox78">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="作者：Mads Torgersen译者：Vicey Wang  这是一篇描述上周四作为 Visual Studio 2017 的一部分所发行的 C# 7.0 中的新语言特性的文章。">
<meta name="keywords" content="C#特性">
<meta property="og:type" content="article">
<meta property="og:title" content="C#7 特性">
<meta property="og:url" content="https://luox78.github.io/2017/12/26/CS7/index.html">
<meta property="og:site_name" content="luox78">
<meta property="og:description" content="作者：Mads Torgersen译者：Vicey Wang  这是一篇描述上周四作为 Visual Studio 2017 的一部分所发行的 C# 7.0 中的新语言特性的文章。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-11T12:38:20.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C#7 特性">
<meta name="twitter:description" content="作者：Mads Torgersen译者：Vicey Wang  这是一篇描述上周四作为 Visual Studio 2017 的一部分所发行的 C# 7.0 中的新语言特性的文章。">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/style.css">
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
</head>

<body>
  <div id="loading">
    <div id="loading-center">
    <div id="loading-center-absolute">
    <div class="object" id="object_one"></div>
    <div class="object" id="object_two"></div>
    <div class="object" id="object_three"></div>
    <div class="object" id="object_four"></div>
    <div class="object" id="object_five"></div>
    <div class="object" id="object_six"></div>
    <div class="object" id="object_seven"></div>
    <div class="object" id="object_eight"></div>
    <div class="object" id="object_big"></div>
    </div>
    </div>
     
    </div>
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				luox78
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/about.html'>
								About
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="/about.html" class="nav-about nav">
				About
			</a>
		
	</nav>
</aside>

  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <!-- <script>
      var count=0;
      function setLoadingBarProgress() {
          if(count==100){
              count=0;
          }
          document.getElementById('loading-bar').style.width = count + "%";
      }
  </script> -->
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-CS7"
	class="post white-box article-type-post"
	itemscope itemprop="blogPost">
<section class='meta'>
 <h2 class="title">
		 <a href="/2017/12/26/CS7/">
				 C#7 特性
		 </a>
 </h2>
 <time>
		 Dec 26, 2017
 </time>
 
    
    <div class='cats'>
        <a href="/categories/C/">C#</a>
    </div>

 <span id="busuanzi_container_page_pv">
		 
		<a href="javascript:void(0)" class="read_cats">本文总阅读量:<span id="busuanzi_value_page_pv"></span>
		</a>
 </span>
</section>

<section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Out-变量（Out-variables"><span class="toc-number">1.</span> <span class="toc-text">Out 变量（Out variables)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式匹配（Pattern-matching）"><span class="toc-number">2.</span> <span class="toc-text">模式匹配（Pattern matching）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#具有模式的-Is-表达式"><span class="toc-number">2.1.</span> <span class="toc-text">具有模式的 Is 表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具有模式的-Switch-语句"><span class="toc-number">3.</span> <span class="toc-text">具有模式的 Switch 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元组（Tuples）"><span class="toc-number">4.</span> <span class="toc-text">元组（Tuples）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解构（Deconstruction）"><span class="toc-number">5.</span> <span class="toc-text">解构（Deconstruction）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法（Local-functions）"><span class="toc-number">6.</span> <span class="toc-text">本地方法（Local functions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字面量改进"><span class="toc-number">7.</span> <span class="toc-text">字面量改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用返回和引用本地变量（Ref-returns-and-locals）"><span class="toc-number">8.</span> <span class="toc-text">引用返回和引用本地变量（Ref returns and locals）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更加一般化的-Async-返回类型"><span class="toc-number">9.</span> <span class="toc-text">更加一般化的 Async 返回类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多的表达式体成员（Expression-bodied-members）"><span class="toc-number">10.</span> <span class="toc-text">更多的表达式体成员（Expression bodied members）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抛出表达式（Throw-expressions）"><span class="toc-number">11.</span> <span class="toc-text">抛出表达式（Throw expressions）</span></a></li></ol></section>

<section class="article typo">
 <div class="article-entry" itemprop="articleBody">
		 <blockquote>
<p>作者：<a href="http://link.zhihu.com/?target=https%3A//social.msdn.microsoft.com/profile/Mads%2BTorgersen%2B-%2BMSFT" target="_blank" rel="noopener">Mads Torgersen</a><br>译者：<a href="https://www.zhihu.com/people/yiwwan/activities" target="_blank" rel="noopener">Vicey Wang</a></p>
</blockquote>
<p>这是一篇描述上周四作为 <a href="http://link.zhihu.com/?target=https%3A//blogs.msdn.microsoft.com/visualstudio/2017/03/07/announcing-visual-studio-2017-general-availability-and-more/" target="_blank" rel="noopener">Visual Studio 2017</a> 的一部分所发行的 C# 7.0 中的新语言特性的文章。</p>
<a id="more"></a>
<p>C# 7.0 新增了许多新功能并引入了对数据消费、代码简化和性能的关注。也许最重要的新特性是使返回多个结果更加方便的元组（tuples），和可以用来简化由数据形状而决定的代码的模式匹配（pattern matching）。但是还有许多大大小小的新功能。我们希望它们能够组合起来以使你的代码更加有效率和干净，并使你更开心，富有生产力。</p>
<p>如果你对这些特性的设计流程感兴趣的话，你可以在 <a href="http://link.zhihu.com/?target=https%3A//github.com/dotnet/csharplang" target="_blank" rel="noopener">C# 语言设计 Github 站点</a> 找到设计笔记、建议和大量的讨论。</p>
<p>如果感觉这篇文章似曾相识，那可能是由于去年八月发行的一个预备版本而造成的。在 C# 7.0 的最终版本中，少部分细节被修改了，其中一些是为了响应帖子中精彩的反馈而修改的。</p>
<p>好好享受 C# 7.0，好好享受 hacking 吧！</p>
<p>Mads Torgersen, C# 语言团队 PM</p>
<h2 id="Out-变量（Out-variables"><a href="#Out-变量（Out-variables" class="headerlink" title="Out 变量（Out variables)"></a>Out 变量（Out variables)</h2><p>在之前的 C# 版本中，使用 out 参数并不像我们期盼的那样流畅。在你能够使用 out 参数来调用一个函数之前，你首先需要声明待传入的变量。同时由于你一般不会初始化这些变量（它们毕竟会被这些方法覆写），你也无法使用 var 来声明它们，而是需要指定完整的类型：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintCoordinates</span>(<span class="params">Point p</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="comment">// 需要“预声明”</span></span><br><span class="line">    p.GetCoordinates(<span class="keyword">out</span> x, <span class="keyword">out</span> y);</span><br><span class="line">    WriteLine(<span class="string">$"(<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C# 7.0 中我们添加了<em> out 变量</em>；使你能够在传入一个 out 参数的地方声明一个变量：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintCoordinates</span>(<span class="params">Point p</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.GetCoordinates(<span class="keyword">out</span> <span class="keyword">int</span> x, <span class="keyword">out</span> <span class="keyword">int</span> y);</span><br><span class="line">    WriteLine(<span class="string">$"(<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，这些变量位于包含它们的代码块的作用域，因此之后的代码可以使用它们。许多种类的语句不会建立它们自己的代码块，因此在这些语句中声明的 out 变量通常被引入到（这个）封闭作用域中。</p>
<p>由于 out 变量直接以 out 参数的形式声明，编译器通常可以分辨它们的类型应该是什么（除非有冲突的重载），所以完全可以用 var 替代类型来声明它们：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.GetCoordinates(<span class="keyword">out</span> <span class="keyword">var</span> x, <span class="keyword">out</span> <span class="keyword">var</span> y);</span><br></pre></td></tr></table></figure>
<p>Out 参数的一个常见使用场景是会返回一个指示是否成功的 Try… 模式，然后 out 参数来携带获得的结果：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintStars</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span>.TryParse(s, <span class="keyword">out</span> <span class="keyword">var</span> i)) &#123; WriteLine(<span class="keyword">new</span> <span class="keyword">string</span>(<span class="string">'*'</span>, i)); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; WriteLine(<span class="string">"Cloudy - no stars tonight!"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也允许以 _（下划线）形式“舍弃” out 参数，来使你忽略你不关心的参数：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.GetCoordinates(<span class="keyword">out</span> <span class="keyword">var</span> x, <span class="keyword">out</span> _); <span class="comment">// 我只关心 x</span></span><br></pre></td></tr></table></figure>
<h2 id="模式匹配（Pattern-matching）"><a href="#模式匹配（Pattern-matching）" class="headerlink" title="模式匹配（Pattern matching）"></a>模式匹配（Pattern matching）</h2><p>C# 7.0 引入了<em>模式匹配</em>的概念，一种从抽象的角度来说，指可以测试一个值是否有某种特定的“形状”、并在满足这一条件的时候从值中提取信息的句法元素。</p>
<p>C# 7.0 中的模式的例子有：</p>
<ul>
<li>c（c 为 C# 中的一个常量表达式）形式的常量模式（Constant pattern），来测试输入是否等于 c</li>
<li>T x（T 为一个类型，x 为一个标识符）形式的类型模式（Type pattern），来测试输入是否有类型 T，并在满足条件的时候将值提取成全新的 T 类型的变量 x</li>
<li>var x（x 为一个标识符）形式的变量匹配（Var patterns），这种匹配总是能够成功，并会将输入的值简单的放入一个全新的与输入类型相同的变量 x 中。</li>
</ul>
<p>这只是个开始——模式现在是 C# 中的一种新的语言元素了，我们也希望在未来能向 C# 中加入更多的模式。</p>
<p>在 C# 7.0 中我们用模式改进了两个已有的语言结构：</p>
<ul>
<li>is 表达式的右边现在可以是表达式，而不仅仅是类型了</li>
<li>switch 语句中的 case 子句现在可以匹配模式，而不仅仅是常量了</li>
</ul>
<p>在未来的 C# 版本中我们会添加更多可以使用模式的地方。</p>
<h3 id="具有模式的-Is-表达式"><a href="#具有模式的-Is-表达式" class="headerlink" title="具有模式的 Is 表达式"></a>具有模式的 Is 表达式</h3><p>这里有一个用常量模式和类型模式来使用 is 表达式的例子：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintStars</span>(<span class="params"><span class="keyword">object</span> o</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">is</span> <span class="literal">null</span>)<span class="keyword">return</span>;     <span class="comment">// 常量模式 “null”</span></span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">is</span> <span class="keyword">int</span> i)) <span class="keyword">return</span>; <span class="comment">// 类型模式 “int i”    </span></span><br><span class="line">    WriteLine(<span class="keyword">new</span> <span class="keyword">string</span>(<span class="string">'*'</span>, i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，<em>模式变量（**pattern variables）</em>——通过模式引入的变量——和之前描述过的 out 变量很像，都可以在表达式中声明，也可以在最近的作用域中使用。和 out 变量一样，模式变量也是可以修改的。我们经常以“表达式变量”来统称 out 变量和模式变量。</p>
<p>模式和 Try 模式通常可以被很好地组合使用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">is</span> <span class="keyword">int</span> i || (o <span class="keyword">is</span> <span class="keyword">string</span> s &amp;&amp; <span class="keyword">int</span>.TryParse(s, <span class="keyword">out</span> i)) &#123; <span class="comment">/* 使用 i */</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="具有模式的-Switch-语句"><a href="#具有模式的-Switch-语句" class="headerlink" title="具有模式的 Switch 语句"></a>具有模式的 Switch 语句</h2><p>我们正在使 switch 语句一般化，因此：</p>
<ul>
<li>你可以筛选任意类型（不仅仅是原生类型）</li>
<li>模式可以被用在 case 子句中</li>
<li>Case 子句可以有额外的限制条件</li>
</ul>
<p>这是个简单的例子：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(shape)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Circle c:</span><br><span class="line">        WriteLine(<span class="string">$"circle with radius <span class="subst">&#123;c.Radius&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> Rectangle s <span class="title">when</span> (<span class="params">s.Length == s.Height</span>):</span></span><br><span class="line"><span class="function">        <span class="title">WriteLine</span>(<span class="params"><span class="string">$"<span class="subst">&#123;s.Length&#125;</span> x <span class="subst">&#123;s.Height&#125;</span> square"</span></span>)</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Rectangle r:</span><br><span class="line">        WriteLine(<span class="string">$"<span class="subst">&#123;r.Length&#125;</span> x <span class="subst">&#123;r.Height&#125;</span> rectangle"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        WriteLine(<span class="string">"&lt;unknown shape&gt;"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(shape));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个新扩展的 switch 语句有一些需要注意的事项：</p>
<ul>
<li>现在 case 子句的顺序变得重要了：就如 catch 子句一样，case 子句不再一定不相交，第一个匹配的项将被选择。因此将正方形的情况（见上图例）放在矩形之前很重要。同样，编译器会帮你标出永远无法到达的分支。在此之前你无法指定计算顺序，因此这不会造成（旧代码）行为的大变化。</li>
<li>default 子句将总是在最后被计算： 即使 null 的情况被放在最后，它仍会在 default 子句被选中之前被检查。这是为了与现存的语义兼容。然而，良好的习惯通常会将 default 子句放在最后。</li>
<li>在最后的 null 子句不会无法到达： 这是因为类型模式（的行为）以目前的 is 表达式为例子，且不会与 null 匹配。这保证了 null 值不会意外地被类型模式抢先匹配；你需要更加明确如何处理它们（或是将它们留给 default 子句）。</li>
</ul>
<p>由 case …: 标签引入的模式变量只在当前的 switch 节有效。</p>
<h2 id="元组（Tuples）"><a href="#元组（Tuples）" class="headerlink" title="元组（Tuples）"></a>元组（Tuples）</h2><p>我们经常希望能从一个方法中返回一个以上的结果。旧版本的 C# 中的选项远远达不到令人满意的程度：</p>
<ul>
<li>Out 参数： 使用起来很笨拙（哪怕你使用了上面所述的改进），并且无法在 async 方法中使用。</li>
<li>System.Tuple&lt;…&gt; 返回类型： 用起来很啰嗦，并且需要分配一个元组对象。</li>
<li>自定义每个方法的传输类型： 需要用一大堆代码来实现一个类，而目的仅仅是临时打包几个变量。</li>
<li>通过动态类型返回匿名类： 性能有瓶颈，且没有静态类型检查。</li>
</ul>
<p>为了在这方面做得更好，C# 7.0 加入了<em>元组类型（<strong>tuple types</strong>）</em>和<em>元组字面量（<strong>tuple literals</strong>）</em>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">string</span>) LookupName(<span class="keyword">long</span> id) <span class="comment">// 元组返回类型</span></span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 从数据储存中取出第一个、中间和最后一个数据</span></span><br><span class="line">    <span class="keyword">return</span> (first, middle, last); <span class="comment">// 元组字面量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法现在会很有效率地返回三个字符串，包装成一个元组值中的元素。</p>
<p>方法的调用者将会收到一个元组，并可以分别访问各个元素：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = LookupName(id);</span><br><span class="line">WriteLine(<span class="string">$"found <span class="subst">&#123;names.Item1&#125;</span> <span class="subst">&#123;names.Item3&#125;</span>."</span>);</span><br></pre></td></tr></table></figure>
<p>Item1 等是元组元素的默认名称，并且总是可用的。但是这样描述性不是非常好，因此你可以选择性地使用另一种更好的方法：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">string</span> <span class="keyword">first</span>, <span class="keyword">string</span> <span class="keyword">middle</span>, <span class="keyword">string</span> <span class="keyword">last</span>) LookupName(<span class="keyword">long</span> id)<span class="comment"> // 元组元素拥有了名称</span></span><br></pre></td></tr></table></figure>
<p>现在元组的接收者可以使用更具描述性的名字了：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = LookupName(id);</span><br><span class="line">WriteLine(<span class="string">$"found <span class="subst">&#123;names.first&#125;</span> <span class="subst">&#123;names.last&#125;</span>."</span>);</span><br></pre></td></tr></table></figure>
<p>你也可以直接在元组字面量中指定元素名称：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">return</span> (<span class="keyword">first</span>: <span class="keyword">first</span>, <span class="keyword">middle</span>: <span class="keyword">middle</span>, <span class="keyword">last</span>: <span class="keyword">last</span>);<span class="comment"> // 在字面量中命名元组元素</span></span><br></pre></td></tr></table></figure>
<p>通常来说你可以无视名字而将元组类型互相转换：只要每个元素之间是可转换的（assignable），元组类型即可自由地互相转换。</p>
<p>元组是值类型，它们的元素是简单的公共、可修改的字段。它们具有值相等性，意味着如果两个元组间每个元素两两相等（且拥有相同的哈希值）则两个元组相等（且拥有相同的哈希值）。</p>
<p>这使得元组在多返回值之外的许多场景也很有用。例如，如果你需要一个拥有多个键的字典，使用一个元组作为你的键，一切都会正常运行。如果你需要一个每个位置有多个值的列表，使用元组吧，诸如搜索列表这样的功能将会正确的工作。</p>
<p>元组依赖于一族被称为 ValueTuple&lt;…&gt; 的底层泛型结构类型。如果你指向了一个还未包含这些类型的框架，你可以从 Nuget 中获得它们：</p>
<ul>
<li>在解决方案管理器中右击项目并选中“管理 NuGet 程序包”</li>
<li>选择“浏览”标签并将“nuget.org”选为“程序包源”</li>
<li>搜索“System.ValueTuple”并安装它。</li>
</ul>
<h2 id="解构（Deconstruction）"><a href="#解构（Deconstruction）" class="headerlink" title="解构（Deconstruction）"></a>解构（Deconstruction）</h2><p>另一个使用元组的方法是去解构它们。一个<em>解构声明（deconstructing declaration**）</em>是一种用来将一个元组（或其他值类型)分成许多部分并将这些部分分别转换为全新的变量的语法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">string</span> first, <span class="keyword">string</span> middle, <span class="keyword">string</span> last) = LookupName(id1); <span class="comment">// 解构声明</span></span><br><span class="line">WriteLine(<span class="string">$"found <span class="subst">&#123;first&#125;</span> <span class="subst">&#123;last&#125;</span>."</span>);</span><br></pre></td></tr></table></figure>
<p>在一个解构声明中，你可以为独立的变量声明使用 var：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">var</span> <span class="built_in">first</span>, <span class="built_in">var</span> middle, <span class="built_in">var</span> <span class="built_in">last</span>) = LookupName(id1); // 在内部使用 <span class="built_in">var</span></span><br></pre></td></tr></table></figure>
<p>甚至把一个单独的 var 放在括号外作为缩写：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var (<span class="name">first</span>, middle, last) = LookupName(<span class="name">id1</span>)<span class="comment">; // 在外部使用 var</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过 解构分配（deconstructing assignment）将其解构到已存在的变量上：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">first</span>, middle, last) = LookupName(<span class="name">id2</span>)<span class="comment">; // 解构分配</span></span><br></pre></td></tr></table></figure>
<p>解构不仅仅适用于元组。任何类型都可以被解构，只要它拥有一个如下形式的（实例或扩展）解构方法（deconstructor method）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deconstruct</span>(<span class="params"><span class="keyword">out</span> T1 x1, ..., <span class="keyword">out</span> Tn xn</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>Out 参数构成解构的结果。</p>
<p>（为什么它使用 out 参数而不是返回一个元组？那是因为这样一来你可以对不同的值的数量拥有不同的重载了）。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> X &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Y &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>) </span>&#123; X = x; Y = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deconstruct</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> x, <span class="keyword">out</span> <span class="keyword">int</span> y</span>) </span>&#123; x = X; y = Y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">var</span> myX, <span class="keyword">var</span> myY) = GetPoint(); <span class="comment">// 调用 Deconstruct(out myX, out myY);</span></span><br></pre></td></tr></table></figure>
<p>它将成为一种常见的模式，通过以这种方式“对称地”拥有构造器和解构器。</p>
<p>如同 out 变量，我们允许在解构中“舍弃”你不关心的部分：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">var</span> myX, <span class="literal">_</span>) = GetPoint(); <span class="comment">// 我只关心 myX</span></span><br></pre></td></tr></table></figure>
<h2 id="本地方法（Local-functions）"><a href="#本地方法（Local-functions）" class="headerlink" title="本地方法（Local functions）"></a>本地方法（Local functions）</h2><p>有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 本地函数（local function）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"Less negativity please!"</span>, <span class="keyword">nameof</span>(x));</span><br><span class="line">    <span class="keyword">return</span> Fib(x).current;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">int</span> current, <span class="keyword">int</span> previous) Fib(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">var</span> (p, pp) = Fib(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (p + pp, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用域内的参数和本地变量都在本地方法中可用，就如同在 lambda 表达式中一样。</p>
<p>例如，被实现为迭代器的方法通常需要一个非迭代的包装函数以在调用时检查参数。（迭代器本身在 MoveNext 被调用之前不会开始）。本地方法完美的适用于这种场景：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, <span class="keyword">bool</span>&gt; filter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(source));</span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(filter));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Iterator();</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerable&lt;T&gt; <span class="title">Iterator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> element <span class="keyword">in</span> source) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter(element)) &#123; <span class="keyword">yield</span> <span class="keyword">return</span> element; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Iterator 是 Filter 旁的私有函数，它可能会被其他成员意外地直接使用（而没有参数检查）。同时，它还需要接收与 Filter 相同的参数，而不是直接在作用域中使用它们。</p>
<h2 id="字面量改进"><a href="#字面量改进" class="headerlink" title="字面量改进"></a>字面量改进</h2><p>C# 7.0 允许 _（下划线）在数字字面量中作为数字分隔符 （digit separator）：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var d</span> = 123_456;</span><br><span class="line"><span class="attribute">var x</span> = 0xAB_CD_EF;</span><br></pre></td></tr></table></figure>
<p>你可以将它们放置在任意位置来增强可读性。它们不会影响值。</p>
<p>同时，C# 7.0 引入了二进制字面量（binary literals），这样你可以直接指定位模板而不用将十六进制记号牢记于心。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var b</span> = 0b1010_1011_1100_1101_1110_1111;</span><br></pre></td></tr></table></figure>
<h2 id="引用返回和引用本地变量（Ref-returns-and-locals）"><a href="#引用返回和引用本地变量（Ref-returns-and-locals）" class="headerlink" title="引用返回和引用本地变量（Ref returns and locals）"></a>引用返回和引用本地变量（Ref returns and locals）</h2><p>就像你可以在 C# 中以引用方式传值（使用 ref 修饰符）一样，你现在可以以引用方式返回值，并将它们以引用的方式存在本地变量中。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="keyword">int</span> <span class="title">Find</span>(<span class="params"><span class="keyword">int</span> number, <span class="keyword">int</span>[] numbers</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == number) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">ref</span> numbers[i]; <span class="comment">// 返回储存的位置，而不是值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(number)&#125;</span> not found"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">15</span>, <span class="number">-39</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">-12</span> &#125;;</span><br><span class="line"><span class="keyword">ref</span> <span class="keyword">int</span> place = <span class="function"><span class="keyword">ref</span> <span class="title">Find</span>(<span class="params"><span class="number">7</span>, array</span>)</span>; <span class="comment">// 为 7 在数列中的位置起个别名</span></span><br><span class="line">place = <span class="number">9</span>; <span class="comment">// 在数列中以 9 替换 7</span></span><br><span class="line">WriteLine(array[<span class="number">4</span>]); <span class="comment">// 输出 9</span></span><br></pre></td></tr></table></figure>
<p>这对向很大的数据结构中传递占位符来说非常有用。例如，一个游戏可能将它的数据存在一个庞大的预先分配好的结构体数组（以避免垃圾回收的停顿）中。现在方法可以返回直接指向这种解构的引用，调用者可以借此来读或者修改数据。</p>
<p>为了确保这样做是安全的，有一些限制：</p>
<ul>
<li>你只能返回“可以安全返回”的引用：一种是传给你的，另一种是指向对象中的字段的。</li>
<li>引用本地变量被初始化到一个确定的储存位置，且不可被修改为指向另一个（引用变量）。</li>
</ul>
<h2 id="更加一般化的-Async-返回类型"><a href="#更加一般化的-Async-返回类型" class="headerlink" title="更加一般化的 Async 返回类型"></a>更加一般化的 Async 返回类型</h2><p>在此之前，C# 中的 async 方法只能返回 void，Task 或是 Task<t> 中的一个。C# 7.0 允许用这样的方式定义其他的类型以使它们可以从被 async 方法所返回。</t></p>
<p>例如，我们现在有一个 ValueTask<t> 结构类型。它被用来防止 async 操作的结果在仍在 await 的时候就可用的情况下的 Task<t> 对象的创建。对大多数 async 场景，例如使用到缓存，这可以大幅减少内存分配并可以获得巨大的性能提升。</t></t></p>
<p>你可以想象得到，有许多种能使这种“类 Task”类型非常有用的方法。正确的创建它们可能不是那么直观，因此我们并不期待大多数人来造自己的轮子，但是它们将会出现在框架和 API 中，然后调用者们就可以像今天使用 Task 一样地返回并 await 它们了。</p>
<h2 id="更多的表达式体成员（Expression-bodied-members）"><a href="#更多的表达式体成员（Expression-bodied-members）" class="headerlink" title="更多的表达式体成员（Expression bodied members）"></a>更多的表达式体成员（Expression bodied members）</h2><p>表达式体方法，属性等是 C# 6.0 中的一大亮点，但我们并未所有成员上启用它。C# 7.0 在可以拥有表达式体的列表中添加了访问器、构造器和析构器：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentDictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; names = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = GetId();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>=&gt; names.TryAdd(id, name); <span class="comment">// 构造器</span></span><br><span class="line">    ~Person() =&gt; names.TryRemove(id, <span class="keyword">out</span> *);              <span class="comment">// 析构器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; names[id];                                 <span class="comment">// get 访问器</span></span><br><span class="line">        <span class="keyword">set</span> =&gt; names[id] = <span class="keyword">value</span>;                         <span class="comment">// set 访问器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是由社区贡献的特性的一个例子，而不是微软 C# 编译器团队（贡献的）。对，开源！</p>
<h2 id="抛出表达式（Throw-expressions）"><a href="#抛出表达式（Throw-expressions）" class="headerlink" title="抛出表达式（Throw expressions）"></a>抛出表达式（Throw expressions）</h2><p>在表达式中抛出异常非常简单：只要调用一个为你做这件事的方法！但是在 C# 7.0 中我们直接允许将 throw 在特定位置作为一个表达式：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>=&gt; Name = name ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(name));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetFirstName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> parts = Name.Split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">return</span> (parts.Length &gt; <span class="number">0</span>) ? parts[<span class="number">0</span>] : <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"No name!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetLastName</span>(<span class="params"></span>) </span>=&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（全文完）</p>

 </div>
 
 <div class="article-tags tags">
		 
		 <a href="/tags/C-特性/">C#特性</a>
		 
 </div>
 
<div id="comments" style="margin: 5px auto;">
	<div id="comment"></div>
                        <script>
                            new Valine({
                        el: '#comment' ,
                        notify:false, 
                        verify:false, 
                        appId: 'oTcHLJ1mpOGAcKcahsaQEBaQ-gzGzoHsz',
                        appKey: 'Jq4QEoyIo2Y40s3PHny873nz',
                        placeholder: ' ( *￣▽￣)((≧︶≦*)',
                        path:window.location.pathname, 
						avatar:'retro'
                    });
                        </script>
</div>
 
 <div class="art-item-footer">
		 
		 <span class="art-item-left">
				 <i class="icon icon-chevron-thin-left"></i>prev：<a href="/2017/12/26/CS6/" rel="prev" title="C#6 特性">
						 C#6 特性
				 </a>
		 </span>
		 
		 
		 <span class="art-item-right">
				 next：<a href="/2017/12/25/hello-world/" rel="next" title="Hello World">
						 Hello World
				 </a><i class="icon icon-chevron-thin-right"></i>
		 </span>
		 
 </div>
 
</section>

</article>
<script>
window.subData = {
 title: 'C#7 特性',
 tools: true
}
</script>

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/images/avatar.jpg' />

<div class='header'>luox78</div>
<div class='content'>
<div class='desc'>It's always not too late to learn</div>
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://github.com/luox78">
            <div class='name'>Github</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://www.baidu.com">
            <div class='name'>Baidu</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/C/"><div class='name'>C#</div><div class='badget'>6</div></a></li>
    
        <li><a class="flat-box" href="/categories/DailyLearning/"><div class='name'>DailyLearning</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/JavaScript/"><div class='name'>JavaScript</div><div class='badget'>20</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/C-特性/" style="font-size: 16px; color: #555">C#特性</a> <a href="/tags/Json/" style="font-size: 14px; color: #808080">Json</a> <a href="/tags/LINQ/" style="font-size: 14px; color: #808080">LINQ</a> <a href="/tags/bitwiseOperations/" style="font-size: 14px; color: #808080">bitwiseOperations</a> <a href="/tags/jsfoundation/" style="font-size: 18px; color: #2b2b2b">jsfoundation</a> <a href="/tags/path/" style="font-size: 14px; color: #808080">path</a> <a href="/tags/thread/" style="font-size: 16px; color: #555">thread</a> <a href="/tags/深入理解JS/" style="font-size: 20px; color: #000">深入理解JS</a>
    </div>
</div>



      </aside>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/luox78" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>
    <span>
        Powered by:<a href="https://hexo.io/" class="codename" target="_blank">
                       hexo
        </a>
    </span>
    <span> - </span>
    <span>
        Theme: <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename" target="_blank">MaterialFlow</a> 
    </span>
    <span> - </span>
    <span id="busuanzi_container_site_pv">
        本站总访问量:
        <a href='http://ibruce.info/2015/04/04/busuanzi/' class="codename" target="_blank">
            <span id="busuanzi_value_site_pv"></span>
        </a>
    </span>
</div>
  
</footer>


  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>
<!--隐藏不是主页的wiget-->
<script>
  if(document.location.href !== "https://luox78.github.io/" && document.location.href !== "https://luox78.github.io/archives/"){
    var foo = document.getElementsByClassName("l_side");
    for (let index = 0; index < foo.length; index++) {
      foo[index].style.display="none";
    }
  }
  Waves.attach('.vbtn', ['waves-button', 'waves-float']);
  Waves.attach(".u-search-form", ['.waves-circle']);
  Waves.init();

	$("#loading").fadeOut(1000);
</script>


</body>
</html>
