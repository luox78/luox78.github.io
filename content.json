{"meta":{"title":"luox78","subtitle":"Daily Learning","description":"Blog for luox78","author":"luox78","url":"https://luox78.github.io"},"pages":[],"posts":[{"title":"初识JavaScript01","slug":"JavaScript01","date":"2017-12-27T12:55:09.751Z","updated":"2017-12-27T15:05:01.468Z","comments":true,"path":"2017/12/27/JavaScript01/","link":"","permalink":"https://luox78.github.io/2017/12/27/JavaScript01/","excerpt":"","text":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt; 默认如果直接在script标签中定义变量，则属于“全局作用域范围”(全局执行环境)，即属于window对象。1 . 全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源2 . 一个页面中的多个script标签中的变量可以互相访问。3 . JS有垃圾回收机制，会定时对可释放资源的变量回收。将变量设置为null则表示可以被回收了。12345678910&lt;!-- more --&gt;&lt;script&gt; function name(parameters) &#123; var i = 0; i++; alert(i); &#125; //方法无返回值，会返回undefined alert(name());&lt;/script&gt; 1234567&lt;script&gt; var i = 1;&lt;/script&gt;&lt;script&gt; //全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源 alert(i);//1&lt;/script&gt; 方法内部不使用var定义的变量相当于全局变量1234567891011&lt;script&gt; function f1(parameters) &#123; i = 100; //var i = 100; &#125;&lt;/script&gt;&lt;script&gt; f1(); alert(i);//100 //alert(i);使用未定义&lt;/script&gt; switchjs中switch中的判断是严格判断就是全等于（===）123456789101112&lt;script&gt; var i = 90; switch (i) &#123; case 90: alert(&quot;number&quot;); break; case &quot;90&quot;: alert(&quot;string&quot;); break; default: &#125;&lt;/script&gt; js类型转换注意点： 1 Number（）将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN 2 String（）转换不成功返回undefined， toString（）报错 3 Boolean（）转换当为0或为空（值为空或者null）时返回false，其余返回true1234567891011121314151617181920&lt;script&gt; alert(parseInt(&quot;90&quot;)); //90 alert(parseInt(&quot;90aaaaaaaaaa&quot;)); //90 alert(parseInt(&quot;aaaaaa&quot;)); //NaN alert(parseInt(111, 2)); //代表给定一个二进制的数111输出十进制 alert(parseFloat(10.111)); //10.111 alert(Number(&quot;40addd&quot;)); //将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN //alert(isNaN(&quot;aaa&quot;)); //true var str; alert(String(str)); //undefined alert(str.toString()); //报错 //boolean var b1 = Boolean(&quot;&quot;); //false - 空字符串 var b2 = Boolean(&quot;hello&quot;); //true - 非空字符串 var b1 = Boolean(50); //true - 非零数字 var b1 = Boolean(null); //false – null var b1 = Boolean(0); //false - 零 var b1 = Boolean(new object()); //true - 对象 &lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[]},{"title":"LINQ","slug":"Ten_LINQ_Myth","date":"2017-12-26T14:34:53.555Z","updated":"2017-12-26T15:22:53.861Z","comments":true,"path":"2017/12/26/Ten_LINQ_Myth/","link":"","permalink":"https://luox78.github.io/2017/12/26/Ten_LINQ_Myth/","excerpt":"","text":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3); 2 All LINQ queries must use query syntax. lambda syntax query syntax 12345678//Here&apos;s an example of lambda syntax:string[] people = new [] &#123; &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); Here&apos;s the same thing expressed in query syntax://string[] people = new [] &#123; &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; &#125;;var filteredPeople = from p in people where p.Length &gt; 3 select p; 3 To retrieve all customers from the customer table, you must perform a query similar to the following:12345678910111213141516171819The expression:from c in db.Customers select c is a frivolous query! You can simply go:db.CustomersSimilarly, the following LINQ to XML query:var xe = from e in myXDocument.Descendants (&quot;phone&quot;) select e;can be simplified to:var xe = myXDocument.Descendants (&quot;phone&quot;);And this:Customer customer = (from c in db.Customers where c.ID == 123 select c) .Single();can be simplified to:Customer customer = db.Customers.Single (c =&gt; c.ID == 123); 4 A LINQ to SQL or EF query will be executed in one round-trip only if the query was built in a single step.LINQ follows a lazy evaluation model, which means queries execute not when constructed, but when enumerated. This means you can build up a query in as many steps as you like, and it won’t actually hit the server until you eventually start consuming the results. For instance, the following query retrieves the names of all customers whose name starts with the letter ‘A’, and who have made at least two purchases. We build this query in three steps:123456var query = db.Customers.Where (c =&gt; c.Name.StartsWith (&quot;A&quot;));query = query.Where (c =&gt; c.Purchases.Count() &gt;= 2);var result = query.Select (c =&gt; c.Name);foreach (string name in result) // Only now is the query executed! Console.WriteLine (name); 5 Because SQL emits flat result sets, LINQ queries must be structured to emit flat result sets, too.For example, if you want to retrieve the names of customers in the state of WA along with all their purchases, you can simply do the following:1234567from c in db.Customerswhere c.State == &quot;WA&quot;select new&#123; c.Name, c.Purchases // An EntitySet (collection)&#125; The hierarchical result from this query is much easier to work with than a flat result set! We can achieve the same result without association properties as follows:1234567from c in db.Customerswhere c.State == &quot;WA&quot;select new&#123; c.Name, Purchases = db.Purchases.Where (p =&gt; p.CustomerID == c.ID)&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"LINQ","slug":"LINQ","permalink":"https://luox78.github.io/tags/LINQ/"}]},{"title":"C#6 特性","slug":"CS6","date":"2017-12-26T12:27:56.003Z","updated":"2017-12-26T12:50:01.912Z","comments":true,"path":"2017/12/26/CS6/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS6/","excerpt":"","text":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符 空操作符 ( ?. )123456if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0) &#123; Console.WriteLine(user.Project.Tasks.First().Name); &#125; //现在Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 注意： 上面的代码虽然可以让我们少些很多代码，而且也减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常，那么使用这个特性反而隐藏了Bug NameOf利用nameof减少手写带来的错误 12345Person p;if(p == null)&#123; throw new Exception(&quot;nameof(Person)&quot;); &#125; 表达式方法体1private static string SayHello() =&gt; &quot;Hello World&quot;; 自动属性初始化器1234567891011121314151617181920//以前public class Person &#123; public int Age &#123; get; set; &#125; public Person() &#123; Age = 100; &#125; &#125; //现在public class Person &#123; public int Age &#123; get; private set; &#125; &#125; //同时增加了只读属性初始化public class Person &#123; public int Age &#123; get; &#125; = 100; &#125; Index 初始化器1234567var names = new Dictionary&lt;int, string&gt; &#123; [1] = &quot;Jack&quot;, [2] = &quot;Alex&quot;, [3] = &quot;Eric&quot;, [4] = &quot;Jo&quot; &#125;; using 静态类的方法可以使用 static using123456789101112using System; using static System.Math; namespace CSharp6NewFeatures &#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(Log10(5)+PI); &#125; &#125; &#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"C#7 特性","slug":"CS7","date":"2017-12-25T16:01:58.230Z","updated":"2017-12-26T12:11:25.519Z","comments":true,"path":"2017/12/26/CS7/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS7/","excerpt":"","text":"本地方法（Local functions）有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 （local function）： 123456789101112public int Fibonacci(int x) &#123; if (x &lt; 0) throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x)); return Fib(x).current; (int current, int previous) Fib(int i) &#123; if (i == 0) return (1, 0); var (p, pp) = Fib(i - 1); return (p + pp, p); &#125; &#125; 元组（Tuples）我们经常希望能从一个方法中返回一个以上的结果。旧版本的 C#中的选项远远达不到令人满意的程度： Out 参数： 使用起来很笨拙（哪怕你使用了上面所述的改进），并且无法在 async 方法中使用。 System.Tuple&lt;…&gt; 返回类型： 用起来很啰嗦，并且需要分配一个元组对象。 自定义每个方法的传输类型： 需要用一大堆代码来实现一个类，而目的仅仅是临时打包几个变量。 通过动态类型返回匿名类： 性能有瓶颈，且没有静态类型检查。 为了在这方面做得更好，C# 7.0 加入了元组类型（tuple types）和元组字面量（tupleliterals）： 12345(string, string, string) LookupName(long id) // 元组返回类型 &#123; // 从数据储存中取出第一个、中间和最后一个数据 return (first, middle, last); // 元组字面量 &#125; 这种方法现在会很有效率地返回三个字符串，包装成一个元组值中的元素。 方法的调用者将会收到一个元组，并可以分别访问各个元素： 123var names = LookupName(id); WriteLine($&quot;found &#123;names.Item1&#125;&#123;names.Item3&#125;.&quot;); Item1等是元组元素的默认名称，并且总是可用的。但是这样描述性不是非常好，因此你可以选择性地使用另一种更好的方法： 123456(string first, string middle, string last)LookupName(long id) // 元组元素拥有了名称 //现在元组的接收者可以使用更具描述性的名字了： var names = LookupName(id); WriteLine($&quot;found &#123;names.first&#125;&#123;names.last&#125;.&quot;); //你也可以直接在元组字面量中指定元素名称： return (first: first, middle: middle,last: last); // 在字面量中命名元组元素 通常来说你可以无视名字而将元组类型互相转换：只要每个元素之间是可转换的（assignable），元组类型即可自由地互相转换。 元组是值类型，它们的元素是简单的公共、可修改的字段。它们具有值相等性，意味着如果两个元组间每个元素两两相等（且拥有相同的哈希值）则两个元组相等（且拥有相同的哈希值）。 这使得元组在多返回值之外的许多场景也很有用。例如，如果你需要一个拥有多个键的字典，使用一个元组作为你的键，一切都会正常运行。如果你需要一个每个位置有多个值的列表，使用元组吧，诸如搜索列表这样的功能将会正确的工作。","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-25T13:51:57.623Z","updated":"2017-12-25T13:51:57.623Z","comments":true,"path":"2017/12/25/hello-world/","link":"","permalink":"https://luox78.github.io/2017/12/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}