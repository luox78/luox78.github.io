{"meta":{"title":"luox78","subtitle":"Daily Learning","description":"Blog for luox78","author":"luox78","url":"https://luox78.github.io"},"pages":[],"posts":[{"title":"05JavaScript深入之作用域链","slug":"JavaScript深入之作用域链","date":"2018-01-04T12:12:50.527Z","updated":"2018-01-04T12:47:19.899Z","comments":true,"path":"2018/01/04/JavaScript深入之作用域链/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之作用域链/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言 在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲作用域链。 作用域链在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建在《JavaScript深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 举个例子： 123456 function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为： 123456789foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 12Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 捋一捋以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = \"global scope\";function checkscope()&#123; var scope2 = 'local scope'; return scope2;&#125;checkscope(); 执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = &#123; Scope: checkscope.[[scope]],&#125; 4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 12345678checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;&#125; 5.第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: [AO, [[Scope]]]&#125; 6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: 'local scope' &#125;, Scope: [AO, [[Scope]]]&#125; 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 下一篇文章《JavaScript深入之从ECMAScript规范解读this》 本文相关链接《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"03JavaScript深入之执行上下文栈","slug":"JavaScript深入之执行上下文栈","date":"2018-01-04T12:12:50.525Z","updated":"2018-01-04T12:47:14.515Z","comments":true,"path":"2018/01/04/JavaScript深入之执行上下文栈/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之执行上下文栈/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第三篇，讲解执行上下文栈的是如何执行的，也回答了第二篇中的略难的思考题。 顺序执行？","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第三篇，讲解执行上下文栈的是如何执行的，也回答了第二篇中的略难的思考题。 顺序执行？ 如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟： 123456789101112131415var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 然而去看这段代码： 12345678910111213141516function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 打印的结果却是两个 foo2。 刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 执行上下文栈接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 1ECStack = []; 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext： 123ECStack = [ globalContext]; 现在 JavaScript 遇到下面的这段代码了： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码： 123456789101112131415161718192021// 伪代码// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 解答思考题好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript深入之词法作用域和动态作用域》最后的问题： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 让我们模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 让我们模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。 下一篇文章《JavaScript深入之变量对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"07JavaScript深入之执行上下文","slug":"JavaScript深入之执行上下文","date":"2018-01-04T12:12:50.523Z","updated":"2018-01-04T12:47:09.114Z","comments":true,"path":"2018/01/04/JavaScript深入之执行上下文/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之执行上下文/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言 在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析我们分析第一段代码： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 123ECStack = [ globalContext]; 2.全局上下文初始化 12345globalContext = &#123; VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO&#125; 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 12345ECStack = [ fContext, checkscopeContext, globalContext]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1234ECStack = [ checkscopeContext, globalContext]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 第二段代码就留给大家去尝试模拟它的执行过程。 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。 下一篇文章《JavaScript深入之闭包》 相关链接《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 《JavaScript深入之作用域链》 《JavaScript深入之从ECMAScript规范解读this》 重要参考《一道js面试题引发的思考》 本文写的太好，给了我很多启发。感激不尽！ 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"01JavaScript深入之从原型到原型链","slug":"JavaScript深入之从原型到原型链","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:53.275Z","comments":true,"path":"2018/01/04/JavaScript深入之从原型到原型链/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之从原型到原型链/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象 我们先使用构造函数创建一个对象： 123456function Person() &#123;&#125;var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'Kevin';var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor ，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() &#123;&#125;Person.prototype.name = 'Kevin';var person = new Person();person.name = 'Daisy';console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = 'Kevin'console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？ null，我们可以打印： 1console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子： 12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor __proto__其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 下一篇文章JavaScript深入之词法作用域和动态作用域 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"13JavaScript深入之类数组对象与arguments","slug":"JavaScript深入之类数组对象与arguments","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:47:03.392Z","comments":true,"path":"2018/01/04/JavaScript深入之类数组对象与arguments/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之类数组对象与arguments/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十三篇，讲解类数组对象与对象的相似与差异以及arguments的注意要点 类数组对象","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十三篇，讲解类数组对象与对象的相似与差异以及arguments的注意要点 类数组对象 所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象 举个例子： 12345678var array = ['name', 'age', 'sex'];var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125; 即便如此，为什么叫做类数组对象呢？ 那让我们从读写、获取长度、遍历三个方面看看这两个对象。 读写12345console.log(array[0]); // nameconsole.log(arrayLike[0]); // namearray[0] = 'new name';arrayLike[0] = 'new name'; 长度12console.log(array.length); // 3console.log(arrayLike.length); // 3 遍历123456for(var i = 0, len = array.length; i &lt; len; i++) &#123; ……&#125;for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; ……&#125; 是不是很像？ 那类数组对象可以使用数组的方法吗？比如： 1arrayLike.push('4'); 然而上述代码会报错: arrayLike.push is not a function 所以终归还是类数组呐…… 调用数组方法如果类数组就是任性的想用数组的方法怎么办呢？ 既然无法直接调用，我们可以用 Function.call 间接调用： 1234567891011var arrayLike = &#123;0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;Array.prototype.join.call(arrayLike, '&amp;'); // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item)&#123; return item.toUpperCase();&#125;); // [\"NAME\", \"AGE\", \"SEX\"] 类数组转对象在上面的例子中已经提到了一种类数组转数组的方法，再补充三个： 123456789var arrayLike = &#123;0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;// 1. sliceArray.prototype.slice.call(arrayLike); // [\"name\", \"age\", \"sex\"] // 2. spliceArray.prototype.splice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"] // 3. ES6 Array.fromArray.from(arrayLike); // [\"name\", \"age\", \"sex\"] // 4. applyArray.prototype.concat.apply([], arrayLike) 那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？ 要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。 Arguments对象接下来重点讲讲 Arguments 对象。 Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。 举个例子： 12345function foo(name, age, sex) &#123; console.log(arguments);&#125;foo('name', 'age', 'sex') 打印结果如下： 我们可以看到除了类数组的索引属性和length属性之外，还有一个callee属性，接下来我们一个一个介绍。 length属性Arguments对象的length属性，表示实参的长度，举个例子： 12345678910function foo(b, c, d)&#123; console.log(\"实参的长度为：\" + arguments.length)&#125;console.log(\"形参的长度为：\" + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1 callee属性Arguments 对象的 callee 属性，通过它可以调用函数自身。 讲个闭包经典面试题使用 callee 的解决方法： 123456789101112131415var data = [];for (var i = 0; i &lt; 3; i++) &#123; (data[i] = function () &#123; console.log(arguments.callee.i) &#125;).i = i;&#125;data[0]();data[1]();data[2]();// 0// 1// 2 接下来讲讲 arguments 对象的几个注意要点： arguments 和对应参数的绑定12345678910111213141516171819202122232425262728function foo(name, age, sex, hobbit) &#123; console.log(name, arguments[0]); // name name // 改变形参 name = 'new name'; console.log(name, arguments[0]); // new name new name // 改变arguments arguments[1] = 'new age'; console.log(age, arguments[1]); // new age new age // 测试未传入的是否会绑定 console.log(sex); // undefined sex = 'new sex'; console.log(sex, arguments[2]); // new sex undefined arguments[3] = 'new hobbit'; console.log(hobbit, arguments[3]); // undefined new hobbit&#125;foo('name', 'age') 传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享 除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。 传递参数将参数从一个函数传递到另一个函数 123456789// 使用 apply 将 foo 的参数传递给 barfunction foo() &#123; bar.apply(this, arguments);&#125;function bar(a, b, c) &#123; console.log(a, b, c);&#125;foo(1, 2, 3) 强大的ES6使用ES6的 … 运算符，我们可以轻松转成数组。 12345function func(...arguments) &#123; console.log(arguments); // [1, 2, 3]&#125;func(1, 2, 3); 应用arguments的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。 如果要总结这些场景的话，暂时能想到的包括： 参数不定长 函数柯里化 递归调用 函数重载… 欢迎留言回复。 下一篇文章JavaScript深入之创建对象的多种方式以及优缺点 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"11JavaScript深入之bind的模拟实现","slug":"JavaScript深入之bind的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:45:47.438Z","comments":true,"path":"2018/01/04/JavaScript深入之bind的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之bind的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十一篇，通过bind函数的模拟实现，带大家真正了解bind的特性 bind一句话介绍 bind:","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十一篇，通过bind函数的模拟实现，带大家真正了解bind的特性 bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 返回函数的模拟实现从第一个特点开始，我们举个例子： 123456789101112var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;// 返回了一个函数var bindFoo = bar.bind(foo); bindFoo(); // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看《JavaScript深入之call和apply的模拟实现》。我们来写第一版的代码： 12345678// 第一版Function.prototype.bind2 = function (context) &#123; var self = this; return function () &#123; return self.apply(context); &#125;&#125; 此外，之所以 return self.apply(context)，是考虑到绑定函数可能是有返回值的，依然是这个例子： 1234567891011var foo = &#123; value: 1&#125;;function bar() &#123; return this.value;&#125;var bindFoo = bar.bind(foo);console.log(bindFoo()); // 1 传参的模拟实现接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： 12345678910111213141516var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(this.value); console.log(name); console.log(age);&#125;var bindFoo = bar.bind(foo, 'daisy');bindFoo('18');// 1// daisy// 18 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 这可咋办？不急，我们用 arguments 进行处理： 1234567891011121314// 第二版Function.prototype.bind2 = function (context) &#123; var self = this; // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1); return function () &#123; // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); &#125;&#125; 构造函数效果的模拟实现完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： 12345678910111213141516171819202122232425var value = 2;var foo = &#123; value: 1&#125;;function bar(name, age) &#123; this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age);&#125;bar.prototype.friend = 'kevin';var bindFoo = bar.bind(foo, 'daisy');var obj = new bindFoo('18');// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 (哈哈，我这是为我的下一篇文章《JavaScript深入系列之new的模拟实现》打广告)。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： 12345678910111213141516// 第三版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); &#125; // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound;&#125; 如果对原型链稍有困惑，可以查看《JavaScript深入之从原型到原型链》。 构造函数效果的优化实现但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： 1234567891011121314151617// 第四版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ 三个小问题接下来处理些小问题: 1.apply 这段代码跟 MDN 上的稍有不同 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是： 12self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于 context 是否存在的判断，然而这个是错误的！ 举个例子： 1234567891011var value = 2;var foo = &#123; value: 1, bar: bar.bind(null)&#125;;function bar() &#123; console.log(this.value);&#125;foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ 2.调用 bind 的不是函数咋办？ 不行，我们要报错！ 123if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");&#125; 3.我要在线上用 那别忘了做个兼容： 123Function.prototype.bind = Function.prototype.bind || function () &#123; ……&#125;; 当然最好是用 es5-shim 啦。 最终代码所以最最后的代码就是： 1234567891011121314151617181920Function.prototype.bind2 = function (context) &#123; if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 下一篇文章《JavaScript深入系列之new的模拟实现》 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入系列之new的模拟实现》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"12JavaScript深入之new的模拟实现","slug":"JavaScript深入之new的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:08.214Z","comments":true,"path":"2018/01/04/JavaScript深入之new的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之new的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十二篇，通过new的模拟实现，带大家揭开使用new获得构造函数实例的真相 new一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十二篇，通过new的模拟实现，带大家揭开使用new获得构造函数实例的真相 new一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。 举个例子： 12345678910111213141516171819202122// Otaku 御宅族，简称宅function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;// 因为缺乏锻炼的缘故，身体强度让人担忧Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin 从这个例子中，我们可以看到，实例 person 可以： 访问到 Otaku 构造函数里的属性 访问到 Otaku.prototype 中的属性 接下来，我们可以尝试着模拟一下了。 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的： 12345678function Otaku () &#123; ……&#125;// 使用 newvar person = new Otaku(……);// 使用 objectFactoryvar person = objectFactory(Otaku, ……) 初步实现分析： 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。 现在，我们可以尝试着写第一版了： 1234567891011121314// 第一版代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;; 在这一版中，我们： 用new Object() 的方式新建了一个对象 obj 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 返回 obj 更多关于： 原型与原型链，可以看《JavaScript深入之从原型到原型链》 apply，可以看《JavaScript深入之call和apply的模拟实现》 经典继承，可以看《JavaScript深入之继承》 复制以下的代码，到浏览器中，我们可以做一下测试： 12345678910111213141516171819202122232425262728function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;;var person = objectFactory(Otaku, 'Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin []~(￣▽￣)~** 返回值效果实现接下来我们再来看一种情况，假如构造函数有返回值，举个例子： 12345678910111213141516function Otaku (name, age) &#123; this.strength = 60; this.age = age; return &#123; name: name, habit: 'Games' &#125;&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。 而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？ 再举个例子： 12345678910111213function Otaku (name, age) &#123; this.strength = 60; this.age = age; return 'handsome boy';&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 再来看第二版的代码，也是最后一版的代码： 1234567891011121314// 第二版的代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === 'object' ? ret : obj;&#125;; 下一篇文章JavaScript深入之类数组对象与arguments 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之继承》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"04JavaScript深入之变量对象","slug":"JavaScript深入之变量对象","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:23.366Z","comments":true,"path":"2018/01/04/JavaScript深入之变量对象/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之变量对象/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第四篇，具体讲解执行上下文中的变量对象与活动对象。全局上下文下的变量对象是什么？函数上下文下的活动对象是如何分析和执行的？还有两个思考题帮你加深印象，快来看看吧！ 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第四篇，具体讲解执行上下文中的变量对象与活动对象。全局上下文下的变量对象是什么？函数上下文下的活动对象是如何分析和执行的？还有两个思考题帮你加深印象，快来看看吧！ 前言 在上篇《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。 全局上下文我们先了解一个概念，叫全局对象。在 W3School 中也有介绍： 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 如果看的不是很懂的话，容我再来介绍下全局对象: 1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。 1console.log(this); 2.全局对象是由 Object 构造函数实例化的一个对象。 1console.log(this instanceof Object); 3.预定义了一堆，嗯，一大堆函数和属性。 123// 都能生效console.log(Math.random());console.log(this.Math.random()); 4.作为全局变量的宿主。 12var a = 1;console.log(this.a); 5.客户端 JavaScript 中，全局对象有 window 属性指向自身。 12345var a = 1;console.log(window.a);this.window.b = 2;console.log(this.b); 花了一个大篇幅介绍全局对象，其实就想说： 全局上下文中的变量对象就是全局对象呐！ 函数上下文在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码， 变量对象会包括： 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 举个例子： 12345678910function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 在进入执行上下文后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c()&#123;&#125;, d: undefined&#125; 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 还是上面的例子，当代码执行完后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression \"d\"&#125; 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 思考题最后让我们看几个例子： 1.第一题 123456789101112function foo() &#123; console.log(a); a = 1;&#125;foo(); // ???function bar() &#123; a = 1; console.log(a);&#125;bar(); // ??? 第一段会报错：Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是： 12345AO = &#123; arguments: &#123; length: 0 &#125;&#125; 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。 2.第二题 1234567console.log(foo);function foo()&#123; console.log(\"foo\");&#125;var foo = 1; 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 下一篇文章《JavaScript深入之作用域链》 本文相关链接《JavaScript深入之执行上下文栈》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"06JavaScript深入之从ECMAScript规范解读this","slug":"JavaScript深入之从ECMAScript规范解读this","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:47.643Z","comments":true,"path":"2018/01/04/JavaScript深入之从ECMAScript规范解读this/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之从ECMAScript规范解读this/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第六篇，本篇我们追根溯源，从ECMAScript5规范解读this在函数调用时到底是如何确定的。 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第六篇，本篇我们追根溯源，从ECMAScript5规范解读this在函数调用时到底是如何确定的。 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲 this，然而不好讲。 …… 因为我们要从 ECMASciript5 规范开始讲起。 先奉上 ECMAScript 5.1 规范地址： 英文版：http://es5.github.io/#x15.1 中文版：http://yanhaijing.com/es5/#115 让我们开始了解规范吧！ Types首先是第 8 章 Types： Types are further subclassified into ECMAScript language types and specification types. An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object. A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. 我们简单的翻译一下： ECMAScript 的类型分为语言类型和规范类型。 ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。 而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。 没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。 今天我们要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。 Reference那什么又是 Reference ？ 让我们看 8.7 章 The Reference Specification Type： The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators. 所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。 抄袭尤雨溪大大的话，就是： 这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。 再看接下来的这段具体介绍 Reference 的内容： A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String. 这段讲述了 Reference 的构成，由三个组成部分，分别是： base value referenced name strict reference 可是这些到底是什么呢？ 我们简单的理解的话： base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。 referenced name 就是属性的名称。 举个例子： 12345678var foo = 1;// 对应的Reference是：var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 再举个例子： 1234567891011121314var foo = &#123; bar: function () &#123; return this; &#125;&#125;; foo.bar(); // foo// bar对应的Reference是：var BarReference = &#123; base: foo, propertyName: 'bar', strict: false&#125;; 而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。 这两个方法很简单，简单看一看： 1.GetBase GetBase(V). Returns the base value component of the reference V. 返回 reference 的 base value。 2.IsPropertyReference IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false. 简单的理解：如果 base value 是一个对象，就返回true。 GetValue除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。 简单模拟 GetValue 的使用： 123456789var foo = 1;var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;;GetValue(fooReference) // 1; GetValue 返回对象属性真正的值，但是要注意： 调用 GetValue，返回的将是具体的值，而不再是一个 Reference 这个很重要，这个很重要，这个很重要。 如何确定this的值关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段： 看规范 11.2.3 Function Calls： 这里讲了当函数调用的时候，如何确定 this 的取值。 只看第一步、第六步、第七步： 1.Let ref be the result of evaluating MemberExpression. 6.If Type(ref) is Reference, then a.If IsPropertyReference(ref) is true, then i.Let thisValue be GetBase(ref). b.Else, the base of ref is an Environment Record i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). 7.Else, Type(ref) is not Reference. a. Let thisValue be undefined. 让我们描述一下： 1.计算 MemberExpression 的结果赋值给 ref 2.判断 ref 是不是一个 Reference 类型 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) 2.3 如果 ref 不是 Reference，那么 this 的值为 undefined 具体分析让我们一步一步看： 计算 MemberExpression 的结果赋值给 ref 什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions： MemberExpression : PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》 FunctionExpression // 函数定义表达式 MemberExpression [ Expression ] // 属性访问表达式 MemberExpression . IdentifierName // 属性访问表达式 new MemberExpression Arguments // 对象创建表达式 举个例子： 123456789101112131415161718192021function foo() &#123; console.log(this)&#125;foo(); // MemberExpression 是 foofunction foo() &#123; return function() &#123; console.log(this) &#125;&#125;foo()(); // MemberExpression 是 foo()var foo = &#123; bar: function () &#123; return this; &#125;&#125;foo.bar(); // MemberExpression 是 foo.bar 所以简单理解 MemberExpression 其实就是()左边的部分。 2.判断 ref 是不是一个 Reference 类型。 关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。 举最后一个例子： 12345678910111213141516171819var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar());//示例2console.log((foo.bar)());//示例3console.log((foo.bar = foo.bar)());//示例4console.log((false || foo.bar)());//示例5console.log((foo.bar, foo.bar)()); foo.bar()在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？ 查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步： Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 我们得知该表达式返回了一个 Reference 类型！ 根据之前的内容，我们知道该值为： 12345var Reference = &#123; base: foo, name: 'bar', strict: false&#125;; 接下来按照 2.1 的判断流程走： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？ 前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。 base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。 这个时候我们就可以确定 this 的值了： 1this = GetBase(ref)， GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！ 唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。 (foo.bar)()看示例2： 1console.log((foo.bar)()); foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator 直接看结果部分： Return the result of evaluating Expression. This may be of type Reference. NOTE This algorithm does not apply GetValue to the result of evaluating Expression. 实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。 (foo.bar = foo.bar)()看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ): 计算的第三步： 3.Let rval be GetValue(rref). 因为使用了 GetValue，所以返回的值不是 Reference 类型， 按照之前讲的判断逻辑： 2.3 如果 ref 不是Reference，那么 this 的值为 undefined this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。 (false || foo.bar)()看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators： 计算第二步： 2.Let lval be GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined (foo.bar, foo.bar)()看示例5，逗号操作符，查看规范11.14 Comma Operator ( , ) 计算第二步： 2.Call GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined 揭晓结果所以最后一个例子的结果是： 1234567891011121314151617181920var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar()); // 2//示例2console.log((foo.bar)()); // 2//示例3console.log((foo.bar = foo.bar)()); // 1//示例4console.log((false || foo.bar)()); // 1//示例5console.log((foo.bar, foo.bar)()); // 1 注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。 补充最最后，忘记了一个最最普通的情况： 12345function foo() &#123; console.log(this)&#125;foo(); MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值： 12345var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 接下来进行判断： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。 IsPropertyReference(ref) 的结果为 false，进入下个判断： 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref) 查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。 所以最后 this 的值就是 undefined。 多说一句尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？ 123456789var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;console.log((false || foo.bar)()); // 1 此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。 此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。 下一篇文章《JavaScript深入之执行上下文》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"08JavaScript深入之闭包","slug":"JavaScript深入之闭包","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:16.025Z","comments":true,"path":"2018/01/04/JavaScript深入之闭包/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之闭包/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第八篇，介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第八篇，介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： 1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动： 1234567891011var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125; 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 下一篇文章JavaScript深入之参数按值传递 相关链接如果想了解执行上下文的具体变化，不妨循序渐进，阅读这六篇： 《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 《JavaScript深入之作用域链》 《JavaScript深入之从ECMAScript规范解读this》 《JavaScript深入之执行上下文》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"14JavaScript深入之创建对象的多种方式以及优缺点","slug":"JavaScript深入之创建对象的多种方式以及优缺点","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:36.114Z","comments":true,"path":"2018/01/04/JavaScript深入之创建对象的多种方式以及优缺点/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之创建对象的多种方式以及优缺点/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面这篇文章讲解创建对象的各种方式，以及优缺点。","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面这篇文章讲解创建对象的各种方式，以及优缺点。但是注意： 这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！ 1. 工厂模式1234567891011function createPerson(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson('kevin'); 缺点：对象无法识别，因为所有的实例都指向一个原型 2. 构造函数模式12345678function Person(name) &#123; this.name = name; this.getName = function () &#123; console.log(this.name); &#125;;&#125;var person1 = new Person('kevin'); 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次 2.1 构造函数模式优化12345678910function Person(name) &#123; this.name = name; this.getName = getName;&#125;function getName() &#123; console.log(this.name);&#125;var person1 = new Person('kevin'); 优点：解决了每个方法都要被重新创建的问题 缺点：这叫啥封装…… 3. 原型模式12345678910function Person(name) &#123;&#125;Person.prototype.name = 'keivn';Person.prototype.getName = function () &#123; console.log(this.name);&#125;;var person1 = new Person(); 优点：方法不会重新创建 缺点：1. 所有的属性和方法都共享 2. 不能初始化参数 3.1 原型模式优化123456789101112function Person(name) &#123;&#125;Person.prototype = &#123; name: 'kevin', getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：封装性好了一点 缺点：重写了原型，丢失了constructor属性 3.2 原型模式优化12345678910111213function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'kevin', getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：实例可以通过constructor属性找到所属构造函数 缺点：原型模式该有的缺点还是有 4. 组合模式构造函数模式与原型模式双剑合璧。 123456789101112function Person(name) &#123; this.name = name;&#125;Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：该共享的共享，该私有的私有，使用最广泛的方式 缺点：有的人就是希望全部都写在一起，即更好的封装性 4.1 动态原型模式12345678910function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype.getName = function () &#123; console.log(this.name); &#125; &#125;&#125;var person1 = new Person(); 注意：使用动态原型模式时，不能用对象字面量重写原型 解释下为什么： 1234567891011121314151617181920function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125; &#125; &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');// 报错 并没有该方法person1.getName();// 注释掉上面的代码，这句是可以执行的。person2.getName(); 为了解释这个问题，假设开始执行var person1 = new Person(&#39;kevin&#39;)。 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。 我们回顾下 new 的实现步骤： 首先新建一个对象 然后将对象的原型指向 Person.prototype 然后 Person.apply(obj) 返回这个对象 注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！ 如果你就是想用字面量方式写代码，可以尝试下这种： 12345678910111213141516171819function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125; &#125; return new Person(name); &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');person1.getName(); // kevinperson2.getName(); // daisy 5.1 寄生构造函数模式123456789101112131415function Person(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = new Person('kevin');console.log(person1 instanceof Person) // falseconsole.log(person1 instanceof Object) // true 寄生构造函数模式，我个人认为应该这样读： 寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。 也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！ 这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写： 12345678910111213141516171819202122function SpecialArray() &#123; var values = new Array(); for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]); &#125; values.toPipedString = function () &#123; return this.join(\"|\"); &#125;; return values;&#125;var colors = new SpecialArray('red', 'blue', 'green');var colors2 = SpecialArray('red2', 'blue2', 'green2');console.log(colors);console.log(colors.toPipedString()); // red|blue|greenconsole.log(colors2);console.log(colors2.toPipedString()); // red2|blue2|green2 你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。 但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。 在可以使用其他模式的情况下，不要使用这种模式。 但是值得一提的是，上面例子中的循环： 123for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]);&#125; 可以替换成： 1values.push.apply(values, arguments); 5.2 稳妥构造函数模式1234567891011121314151617function person(name)&#123; var o = new Object(); o.sayName = function()&#123; console.log(name); &#125;; return o;&#125;var person1 = person('kevin');person1.sayName(); // kevinperson1.name = \"daisy\";person1.sayName(); // kevinconsole.log(person1.name); // daisy 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 与寄生构造函数模式有两点不同： 新创建的实例方法不引用 this 不使用 new 操作符调用构造函数 稳妥对象最适合在一些安全的环境中。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。 下一篇文章JavaScript深入之继承的多种方式和优缺点 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之new的模拟实现》 《JavaScript深入之call和apply的模拟实现》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"02JavaScript深入之词法作用域和动态作用域","slug":"JavaScript深入之词法作用域和动态作用域","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:41.534Z","comments":true,"path":"2018/01/04/JavaScript深入之词法作用域和动态作用域/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之词法作用域和动态作用域/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第二篇，JavaScript采用词法作用域，什么语言采用了动态作用域？两者的区别又是什么？还有一个略难的思考题，快来看看吧。 作用域","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第二篇，JavaScript采用词法作用域，什么语言采用了动态作用域？两者的区别又是什么？还有一个略难的思考题，快来看看吧。 作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设JavaScript采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 动态作用域也许你会好奇什么语言是动态作用域？ bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。 123456789value=1function foo () &#123; echo $value;&#125;function bar () &#123; local value=2; foo;&#125;bar 这个文件也可以在github博客仓库中找到。 思考题最后，让我们看一个《JavaScript权威指南》中的例子： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 但是在这里真正想让大家思考的是： 虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下一篇文章————《JavaScript深入之执行上下文栈》。 下一篇文章JavaScript深入之执行上下文栈 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"09JavaScript深入之参数按值传递","slug":"JavaScript深入之参数按值传递","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:30.018Z","comments":true,"path":"2018/01/04/JavaScript深入之参数按值传递/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之参数按值传递/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 按值传递举个简单的例子： 1234567var value = 1;function foo(v) &#123; v = 2; console.log(v); //2&#125;foo(value);console.log(value) // 1 很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，函数中修改的都是 _value 的值，而不会影响原来的 value 值。 引用传递拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题。 所以还有另一种传递方式叫做按引用传递。 所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。 举个例子： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o.value = 2; console.log(o.value); //2&#125;foo(obj);console.log(obj.value) // 2 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按引用传递成功呢？ 而这究竟是不是引用传递呢？ 第三种传递方式不急，让我们再看个例子： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o = 2; console.log(o); //2&#125;foo(obj);console.log(obj.value) // 1 如果 JavaScript 采用的是引用传递，外层的值也会被修改呐，这怎么又没被改呢？所以真的不是引用传递吗？ 这就要讲到其实还有第三种传递方式，叫按共享传递。 而共享传递是指，在传递对象的时候，传递对象的引用的副本。 注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！ 所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。 最后，你可以这样理解： 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。 所以，高程，谁叫你是红宝书嘞！ 下一篇文章JavaScript深入之call和apply的模拟实现 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"15JavaScript深入之继承的多种方式和优缺点","slug":"JavaScript深入之继承的多种方式和优缺点","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:58.484Z","comments":true,"path":"2018/01/04/JavaScript深入之继承的多种方式和优缺点/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之继承的多种方式和优缺点/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十五篇，讲解JavaScript各种继承方式和优缺点。 写在前面","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十五篇，讲解JavaScript各种继承方式和优缺点。 写在前面 本文讲解JavaScript各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！ 1.原型链继承1234567891011121314151617function Parent () &#123; this.name = 'kevin';&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 12345678910111213141516171819function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向Parent传参 2.借用构造函数(经典继承)1234567891011121314151617function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child('kevin');console.log(child1.name); // kevinvar child2 = new Child('daisy');console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 3.组合继承原型链继承和经典继承双剑合璧。 1234567891011121314151617181920212223242526272829303132function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [\"red\", \"blue\", \"green\"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 4.原型式继承12345function createObj(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 5. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj (o) &#123; var clone = object.create(o); clone.sayName = function () &#123; console.log('hi'); &#125; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6. 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18'); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122232425function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin', '18');console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候：prototype(Child, Parent); 引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之new的模拟实现》 《JavaScript深入之创建对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"10JavaScript深入之call和apply的模拟实现","slug":"JavaScript深入之call和apply的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:45:55.246Z","comments":true,"path":"2018/01/04/JavaScript深入之call和apply的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之call和apply的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十篇，通过call和apply的模拟实现，带你揭开call和apply改变this的真相 call一句话介绍 call：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十篇，通过call和apply的模拟实现，带你揭开call和apply改变this的真相 call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： 123456// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call2(foo); // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： 1234567891011121314var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call(foo, 'kevin', 18);// kevin// 18// 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： 1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = &#123;// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// &#125;// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']');&#125;// 执行后 args为 [\"arguments[1]\", \"arguments[2]\", \"arguments[3]\"] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 1234567891011121314151617181920212223242526// 第二版Function.prototype.call2 = function(context) &#123; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; eval('context.fn(' + args +')'); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call2(foo, 'kevin', 18); // kevin// 18// 1 (๑•̀ㅂ•́)و✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： 1.this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： 12345678var value = 1;function bar() &#123; console.log(this.value);&#125;bar.call(null); // 1 虽然这个例子本身不使用 call，结果依然一样。 2.函数是可以有返回值的！ 举个例子： 12345678910111213141516171819var obj = &#123; value: 1&#125;function bar(name, age) &#123; return &#123; value: this.value, name: name, age: age &#125;&#125;console.log(bar.call(obj, 'kevin', 18));// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 第三版Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ apply的模拟实现apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现： 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; 下一篇文章JavaScript深入之bind的模拟实现 重要参考知乎问题 不能使用call、apply、bind，如何用 js 实现 call 或者 apply 的功能？ 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"初识JavaScript04","slug":"JavaScript04","date":"2018-01-03T13:46:51.448Z","updated":"2018-01-04T15:10:04.660Z","comments":true,"path":"2018/01/03/JavaScript04/","link":"","permalink":"https://luox78.github.io/2018/01/03/JavaScript04/","excerpt":"window对象的属性 document.write()会覆盖原有的全部内容","text":"window对象的属性 document.write()会覆盖原有的全部内容 123456789&lt;body&gt; 你是谁&lt;input type=\"button\" id=\"btn\" value=\"click\" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById(\"btn\").onclick = function () &#123; document.write('&lt;font size=\"7\"&gt;luox78&lt;/font&gt;'); &#125;&lt;/script&gt; document.getElementById(),getElementsByName(),`getElementsByTagName, 1234567891011&lt;body&gt; &lt;input type=\"text\" name=\"txt\" /&gt; &lt;input type=\"text\" name=\"txt\" /&gt; &lt;input type=\"text\" name=\"txt\"/&gt;&lt;/body&gt;&lt;script&gt; var inputs = document.getElementsByName(\"txt\"); for (var i = 0; i &lt; inputs.length; i++) &#123; inputs[i].value = \"luox78\"; &#125;&lt;/script&gt; 注意循环中使用this,javascript执行上下文 12345678910111213141516171819202122232425&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;script&gt;&gt; //点击一个按钮，被点击的按钮显示“呜呜”，其他按钮显示“哈哈”&gt; var inputs = document.getElementsByName('btn');&gt; for (var i = 0; i &lt; inputs.length; i++) &#123;&gt; if (inputs[i].type == 'button') &#123;&gt; inputs[i].onclick = function() &#123;&gt; for (var j = 0; j &lt; inputs.length; j++) &#123;&gt; if (inputs[j].type == 'button') &#123;&gt; inputs[j].value = \"哈哈\";&gt; &#125;&gt; &#125;&gt; this.value = \"呜呜\";&gt; //inputs[i].value = \"呜呜\"; 这样写不能达到预期的效果&gt; &#125;;&gt; &#125;&gt; &#125;&gt; &lt;/script&gt;&gt; &gt; ​ 事件冒泡演示 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=\"div1\" style=\"height: 200px; background-color: aquamarine\"&gt; &lt;div id=\"div2\" style=\"background-color: black; width: 600px;height: 200px;\"&gt; &lt;div id=\"div3\" style=\"background-color: blue; height: 200px;width: 300px\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById(\"div1\").onclick= function() &#123; console.log(this.id); &#125; document.getElementById(\"div2\").onclick = function () &#123; console.log(this.id); &#125; document.getElementById(\"div3\").onclick = function () &#123; console.log(this.id); &#125;&lt;/script&gt;结果（分别点击div1，div2，div3）： div1 div2 div1 div3 div2 div1 将div3中console.log(this.id)改成console.log(window.event.srcElement.id)，效果一致，但window.event.srcElement.id为事件源 如何取消事件冒泡呢？使用window.event.cancelBubble=true，在div3 onclick中加入window.event.cancelBubble=true，console中只输出了div3 动态添加元素演示点击按钮添加td 123456789101112131415161718192021222324&lt;body&gt; &lt;input id=\"txt\" type=\"text\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"add remark\" /&gt; &lt;br /&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;评论&lt;/th&gt; &lt;/thead&gt; &lt;tbody id=\"tbody\"&gt;&lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(\"btn2\").onclick = function () &#123; var txt = document.getElementById(\"txt\").value; var tbody = document.getElementById(\"tbody\"); if (txt != null &amp;&amp; txt.length != 0) &#123; var tr = document.createElement(\"tr\"); var td = document.createElement(\"td\"); tr.appendChild(td); td.textContent = txt; tbody.appendChild(tr); &#125; &#125;&lt;/script&gt; document.XXX方法： createElement(&#39;element&#39;);创建一个节点 appendChild(node); 追加一个节点 removeChild(node);移除一个节点 replaceChild(new,old);替换一个节点 insertBefore(new,参照);把节点加到前面（插到某个节点前面） 属性： firstChild lastChild 动态设置styledocument.getElementById(&quot;XXX&quot;).style或document.getElementById(&quot;XXX&quot;)下","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"同步基础","slug":"CS_Thread02","date":"2018-01-02T13:19:59.458Z","updated":"2018-01-03T11:46:34.983Z","comments":true,"path":"2018/01/02/CS_Thread02/","link":"","permalink":"https://luox78.github.io/2018/01/02/CS_Thread02/","excerpt":"1同步概要在第 1 部分：基础知识中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。 下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。","text":"1同步概要在第 1 部分：基础知识中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。 下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。 同步构造可以分为以下四类： 简单的阻塞方法 这些方法会使当前线程等待另一个线程结束或是自己等待一段时间。Sleep、Join与Task.Wait都是简单的阻塞方法。 锁构造 锁构造能够限制每次可以执行某些动作或是执行某段代码的线程数量。排它锁构造是最常见的，它每次只允许一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。标准的排它锁构造是lock（Monitor.Enter/Monitor.Exit）、Mutex与 SpinLock。非排它锁构造是Semaphore、SemaphoreSlim以及读写锁。 信号构造 信号构造可以使一个线程暂停，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：事件等待句柄（event wait handle ）和Monitor类的Wait / Pluse方法。Framework 4.0 加入了CountdownEvent与Barrier类。 非阻塞同步构造 非阻塞同步构造通过调用处理器指令来保护对公共字段的访问。CLR 与 C# 提供了下列非阻塞构造：Thread.MemoryBarrier 、Thread.VolatileRead、Thread.VolatileWrite、volatile关键字以及Interlocked类。 阻塞这个概念对于前三类来说都非常重要，接下来我们简要的剖析下它。 1.1阻塞当线程的执行由于某些原因被暂停，比如调用Sleep等待一段时间，或者通过Join或EndInvoke方法等待其它线程结束时，则认为此线程被阻塞（blocked）。被阻塞的线程会立即出让（yields）其处理器时间片，之后不再消耗处理器时间，直到阻塞条件被满足。可以通过线程的ThreadState属性来检查一个线程是否被阻塞： 1bool blocked = (someThread.ThreadState &amp; ThreadState.WaitSleepJoin) != 0; （上面例子中线程状态可能在进行状态判断和依据状态进行操作之间发生改变，因此这段代码仅可用于调试诊断的场景。） 当一个线程被阻塞或是解除阻塞时，操作系统会进行上下文切换（context switch），这会带来几微秒的额外时间开销。 阻塞会在以下 4 种情况下解除（电源按钮可不能算╮(╯▽╰)╭）： 阻塞条件被满足 操作超时（如果指定了超时时间） 通过Thread.Interrupt中断 通过Thread.Abort中止 通过Suspend方法（已过时，不应该再使用）暂停线程的执行不被认为是阻塞。 1.2阻塞 vs 自旋有时线程必须暂停，直到特定条件被满足。信号构造和锁构造可以通过在条件被满足前阻塞线程来实现。但是还有一种更为简单的方法：线程可以通过自旋（spinning）来等待条件被满足。例如： 123while (!proceed);// 或者：while (DateTime.Now &lt; nextStartTime); 一般来说，这会非常浪费处理器时间：因为对 CLR 和操作系统来说，这个线程正在执行重要的计算，就给它分配了相应的资源。 有时会组合使用阻塞与自旋： 1while (!proceed) Thread.Sleep (10); 尽管并不优雅，但是这比仅使用自旋更高效（一般来说）。然而这样也可能会出现问题，这是由proceed标识上的并发问题引起的。正确的使用和锁构造和信号构造可以避免这个问题。 自旋在等待的条件很快（大致几微秒）就能被满足的情况下更高效，因为它避免了上下文切换带来的额外开销。.NET Framework 提供了专门的方法和类型来辅助实现自旋，在第 5 部分会讲到。 1.3线程状态可以通过线程的ThreadState属性来查询线程状态，它会返回一个ThreadState类型的按位方式组合的枚举值，其中包含了三“层”信息。然而大多数值都是冗余的、无用的或者过时不建议使用的。下图是其中一“层”信息： 下面的代码可以提取线程状态中最有用的 4 个值: Unstarted、Running、WaitSleepJoin和Stopped： 123456public static ThreadState SimpleThreadState (ThreadState ts)&#123; return ts &amp; (ThreadState.Unstarted | ThreadState.WaitSleepJoin | ThreadState.Stopped);&#125; ThreadState属性在进行调试诊断时有用，但不适合用来进行同步，因为线程状态可能在判断状态和依据状态进行操作之间发生改变。 2锁排它锁用于确保同一时间只允许一个线程执行指定的代码段。主要的两个排它锁构造是lock和Mutex（互斥体）。其中lock更快，使用也更方便。而Mutex的优势是它可以跨进程的使用。 在这一节里，我们从介绍lock构造开始，然后介绍Mutex和信号量（semaphore）（用于非排它场景）。稍后在第 4 部分会介绍读写锁（reader / writer lock）。 Framework 4.0 加入了SpinLock结构体，可以用于高并发场景。 让我们从下边这个类开始： 12345678910class ThreadUnsafe&#123; static int _val1 = 1, _val2 = 1; static void Go() &#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0; &#125;&#125; 这个类不是线程安全的：如果Go方法同时被两个线程调用，可能会产生除数为零错误，因为可能在一个线程刚好执行完if的判断语句但还没执行Console.WriteLine语句时，_val2就被另一个线程设置为零。 下边使用lock解决这个问题： 1234567891011121314class ThreadSafe&#123; static readonly object _locker = new object(); static int _val1, _val2; static void Go() &#123; lock (_locker) &#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0; &#125; &#125;&#125; 同一时间只有一个线程可以锁定同步对象（这里指_locker），并且其它竞争锁的线程会被阻塞，直到锁被释放。如果有多个线程在竞争锁，它们会在一个“就绪队列（ready queue）”中排队，并且遵循先到先得的规则（需要说明的是，Windows 系统和 CLR 的差别可能导致这个队列在有时会不遵循这个规则）。因为一个线程的访问不能与另一个线程相重叠，排它锁有时也被这样描述：它强制对锁保护的内容进行顺序（serialized）访问。在这个例子中，我们保护的是Go方法的内部逻辑，还有_val1与_val2字段。 在竞争锁时被阻塞的线程，它的线程状态是WaitSleepJoin。在中断与中止中，我们会描述如何通过其它线程强制释放被阻塞的线程，这是一种可以用于结束线程的重型技术（译者注：这里指它们应该被作为在没有其它更为优雅的办法时的最后手段）。 锁构造比较 构造 用途 跨进程 开销* lock（Monitor.Enter/Monitor.Exit） 确保同一时间只有一个线程可以访问资源或代码 - 20ns Mutex yes 1000ns SemaphoreSlim（Framework 4.0 中加入） 确保只有不超过指定数量的线程可以并发访问资源或代码 - 200ns Semaphore yes 1000ns ReaderWriterLockSlim（Framework 3.5 中加入） 允许多个读线程和一个写线程共存 - 40ns ReaderWriterLock（已过时） - 100ns * 时间代表在同一线程上一次进行加锁和释放锁（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。 2.1Monitor.Enter 与 Monitor.ExitC# 的lock语句是一个语法糖，它其实就是使用了try / finally来调用Monitor.Enter与Monitor.Exit方法。下面是在之前示例中的Go方法内部所发生的事情（简化的版本）： 1234567Monitor.Enter (_locker);try&#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0;&#125;finally &#123; Monitor.Exit (_locker); &#125; 如果在同一个对象上没有先调用Monitor.Enter就调用Monitor.Exit会抛出一个异常。 lockTaken 重载刚刚所描述的就是 C# 1.0、2.0 和 3.0 的编译器翻译lock语句产生的代码。 然而它有一个潜在的缺陷。考虑这样的情况：在Monitor.Enter的实现内部或者在Monitor.Enter与try中间有异常被抛出（可能是因为在线程上调用了Abort，或者有OutOfMemoryException异常被抛出），这时不一定能够获得锁。如果获得了锁，那么该锁就不会被释放，因为不可能执行到try / finally内，这会导致锁泄漏。 为了避免这种危险，CLR 4.0 的设计者为Monitor.Enter添加了下面的重载： 1public static void Enter (object obj, ref bool lockTaken); 当（且仅当）Enter方法抛出异常，锁没有能够获得时，lockTaken为false。 下边是正确的使用方式（这就是 C# 4.0 对于lock语句的翻译）： 1234567bool lockTaken = false;try&#123; Monitor.Enter (_locker, ref lockTaken); // 你的代码...&#125;finally &#123; if (lockTaken) Monitor.Exit (_locker); &#125; TryEnterMonitor还提供了一个TryEnter方法，允许以毫秒或是TimeSpan方式指定超时时间。如果获得了锁，该方法会返回true，而如果由于超时没有获得锁，则会返回false。TryEnter也可以以无参数的形式进行调用，这是对锁进行“测试”，如果不能立即获得锁就会立即返回false。 类似于Enter方法，该方法在 CLR 4.0 中也被重载来接受lockTaken参数。 2.2选择同步对象对所有参与同步的线程可见的任何对象都可以被当作同步对象使用，但有一个硬性规定：同步对象必须为引用类型。同步对象一般是私有的（因为这有助于封装锁逻辑），并且一般是一个实例或静态字段。同步对象也可以就是其要保护的对象，如下面例子中的_list字段： 12345678910class ThreadSafe&#123; List &lt;string&gt; _list = new List &lt;string&gt;(); void Test() &#123; lock (_list) &#123; _list.Add (\"Item 1\"); // ... 一个只被用来加锁的字段（例如前面例子中的_locker）可以精确控制锁的作用域与粒度。对象自己（this），甚至是其类型都可以被当作同步对象来使用： 123lock (this) &#123; ... &#125;// 或者：lock (typeof (Widget)) &#123; ... &#125; // 保护对静态资源的访问 这种方式的缺点在于并没有对锁逻辑进行封装，从而很难避免死锁与过多的阻塞。同时类型上的锁也可能会跨越应用程序域（application domain）边界（在同一进程内）。 你也可以在被 lambda 表达式或匿名方法所捕获的局部变量上加锁。 锁在任何情况下都不会限制对同步对象本身的访问。换句话说，x.ToString()不会因为其它线程调用lock(x)而阻塞，两个线程都要调用lock(x)才能使阻塞发生。 2.3何时加锁简单的原则是，需要在访问任意可写的共享字段（any writable shared field）时加锁。即使是最简单的操作，例如对一个字段的赋值操作，都必须考虑同步。在下面的类中，Increment与Assign方法都不是线程安全的： 123456class ThreadUnsafe&#123; static int _x; static void Increment() &#123; _x++; &#125; static void Assign() &#123; _x = 123; &#125;&#125; 以下是线程安全的版本： 12345678class ThreadSafe&#123; static readonly object _locker = new object(); static int _x; static void Increment() &#123; lock (_locker) _x++; &#125; static void Assign() &#123; lock (_locker) _x = 123; &#125;&#125; 在非阻塞同步（nonblocking synchronization）中，我们会解释这种需求是如何产生的，以及在这些场景下内存屏障（memory barrier，内存栅栏，内存栅障）和Interlocked类如何提供替代方法进行锁定。 2.4锁与原子性如果一组变量总是在相同的锁内进行读写，就可以称为原子的（atomically）读写。假定字段x与y总是在对locker对象的lock内进行读取与赋值： 1lock (locker) &#123; if (x != 0) y /= x; &#125; 可以说x和y是被原子的访问的，因为上面的代码块无法被其它的线程分割或抢占。如果被其它线程分割或抢占，x和y就可能被别的线程修改导致计算结果无效。而现在 x和y总是在相同的排它锁中进行访问，因此不会出现除数为零的错误。 在lock锁内抛出异常将打破锁的原子性，考虑如下代码： 12345678910decimal _savingsBalance, _checkBalance;void Transfer (decimal amount)&#123; lock (_locker) &#123; _savingsBalance += amount; _checkBalance -= amount + GetBankFee(); &#125;&#125; 如果GetBankFee()方法内抛出异常，银行可能就要损失钱财了。在这个例子中，我们可以通过更早的调用GetBankFee()来避免这个问题。对于更复杂情况，解决方案是在catch或finally中实现“回滚（rollback）”逻辑。 指令原子性是一个相似但不同的概念： 如果一条指令可以在 CPU 上不可分割地执行，那么它就是原子的。（见非阻塞同步） 2.5嵌套锁线程可以用嵌套（重入）的方式重对相同的对象进行加锁： 123456lock (locker) lock (locker) lock (locker) &#123; // ... &#125; 或者： 123Monitor.Enter (locker); Monitor.Enter (locker); Monitor.Enter (locker);// ...Monitor.Exit (locker); Monitor.Exit (locker); Monitor.Exit (locker); 在这样的场景中，只有当最外层的lock语句退出或是执行了匹配数目的Monitor.Exit语句时，对象才会被解锁。 嵌套锁可以用于在锁中调用另一个方法（也使用了同一对象来锁定）： 123456789101112131415static readonly object _locker = new object();static void Main()&#123; lock (_locker) &#123; AnotherMethod(); // 这里依然拥有锁，因为锁是可重入的 &#125;&#125;static void AnotherMethod()&#123; lock (_locker) &#123; Console.WriteLine (\"Another method\"); &#125;&#125; 线程只会在第一个（最外层）lock处阻塞。 2.6死锁当两个线程等待的资源都被对方占用时，它们都无法执行，这就产生了死锁。演示死锁最简单的方法就是使用两个锁： 123456789101112131415object locker1 = new object();object locker2 = new object();new Thread (() =&gt; &#123; lock (locker1) &#123; Thread.Sleep (1000); lock (locker2); // 死锁 &#125; &#125;).Start();lock (locker2)&#123; Thread.Sleep (1000); lock (locker1); // 死锁&#125; 更复杂的死锁链可能由三个或更多的线程创建。 在标准环境下，CLR 不会像SQL Server一样自动检测和解决死锁。除非你指定了锁定的超时时间，否则死锁会造成参与的线程无限阻塞。（在SQL CLR 集成宿主环境中，死锁能够被自动检测，并在其中一个线程上抛出可捕获的异常。） 死锁是多线程中最难解决的问题之一，尤其是在有很多关联对象的时候。这个困难在根本上在于无法确定调用方（caller）已经拥有了哪些锁。 你可能会锁定类x中的私有字段a，而并不知道调用方（或者调用方的调用方）已经锁住了类y中的字段b。同时，另一个线程正在执行顺序相反的操作，这样就创建了死锁。讽刺的是，这个问题会由于（良好的）面向对象的设计模式而加剧，因为这类模式建立的调用链直到运行时才能确定。 流行的建议：“以一致的顺序对对象加锁以避免死锁”，尽管它对于我们最初的例子有帮助，但是很难应用到刚才所描述的场景。更好的策略是：如果发现在锁区域中的对其它类的方法调用最终会引用回当前对象，就应该小心，同时考虑是否真的需要对其它类的方法调用加锁（往往是需要的，但是有时也会有其它选择）。更多的依靠声明方式（declarative）与数据并行（data parallelism）、不可变类型（immutable types）与非阻塞同步构造（ nonblocking synchronization constructs），可以减少对锁的需要。 有另一种思路来帮助理解这个问题：当你在拥有锁的情况下访问其它类的代码，对于锁的封装就存在潜在的泄露。这不是 CLR 或 .NET Framework 的问题，而是因为锁本身的局限性。锁的问题在许多研究项目中被分析，包括软件事务内存（Software Transactional Memory）。 另一个死锁的场景是：如果已拥有一个锁，在调用Dispatcher.Invoke（在 WPF 程序中）或是Control.Invoke（在 Windows Forms 程序中）时，如果 UI 恰好要运行等待同一个锁的另一个方法，就会在这里发生死锁。这通常可以通过调用BeginInvoke而不是Invoke来简单的修复。或者，可以在调用Invoke之前释放锁，但是如果是调用方获得的锁，那么这种方法可能并不会起作用。我们在富客户端应用与线程亲和中来解释Invoke和BeginInvoke。 2.7性能锁是非常快的，在一个 2010 时代的计算机上，没有竞争的情况下获取并释放锁一般只需 20 纳秒。如果存在竞争，产生的上下文切换会把开销增加到微秒的级别，并且线程被重新调度前可能还会等待更久的时间。如果需要锁定的时间很短，那么可以使用自旋锁（SpinLock）来避免上下文切换的开销。 如果获取锁后保持的时间太长而不释放，就会降低并发度，同时也会加大死锁的风险。 2.8互斥体（Mutex）互斥体类似于 C# 的lock，不同在于它是可以跨越多个进程工作。换句话说，Mutex可以是机器范围（computer-wide）的，也可以是程序范围（application-wide）的。 没有竞争的情况下，获取并释放Mutex需要几微秒的时间，大约比lock慢 50 倍。 使用Mutex类时，可以调用WaitOne方法来加锁，调用ReleaseMutex方法来解锁。关闭或销毁Mutex会自动释放锁。与lock语句一样，Mutex只能被获得该锁的线程释放。 跨进程Mutex的一种常见的应用就是确保只运行一个程序实例。下面演示了这是如何实现的： 12345678910111213141516171819202122232425class OneAtATimePlease&#123; static void Main() &#123; // 命名的 Mutex 是机器范围的，它的名称需要是唯一的 // 比如使用公司名+程序名，或者也可以用 URL using (var mutex = new Mutex (false, \"oreilly.com OneAtATimeDemo\")) &#123; // 可能其它程序实例正在关闭，所以可以等待几秒来让其它实例完成关闭 if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false)) &#123; Console.WriteLine (\"Another app instance is running. Bye!\"); return; &#125; RunProgram(); &#125; &#125; static void RunProgram() &#123; Console.WriteLine (\"Running. Press Enter to exit\"); Console.ReadLine(); &#125;&#125; 如果在终端服务（Terminal Services）下运行，机器范围的Mutex默认仅对于运行在相同终端服务器会话的应用程序可见。要使其对所有终端服务器会话可见，需要在其名字前加上Global\\。 2.9信号量（Semaphore）信号量类似于一个夜总会：它具有一定的容量，并且有保安把守。一旦满员，就不允许其他人进入，这些人将在外面排队。当有一个人离开时，排在最前头的人便可以进入。这种构造最少需要两个参数：夜总会中当前的空位数以及夜总会的总容量。 容量为 1 的信号量与Mutex和lock类似，所不同的是信号量没有“所有者”，它是线程无关（thread-agnostic）的。任何线程都可以在调用Semaphore上的Release方法，而对于Mutex和lock，只有获得锁的线程才可以释放。 SemaphoreSlim是 Framework 4.0 加入的轻量级的信号量，功能与Semaphore相似，不同之处是它对于并行编程的低延迟需求做了优化。在传统的多线程方式中也有用，因为它支持在等待时指定取消标记 （cancellation token）。但它不能跨进程使用。 在Semaphore上调用WaitOne或Release会产生大概 1 微秒的开销，而SemaphoreSlim产生的开销约是其四分之一。 信号量在有限并发的需求中有用，它可以阻止过多的线程同时执行特定的代码段。在下面的例子中，五个线程尝试进入一个只允许三个线程进入的夜总会： 12345678910111213141516171819class TheClub&#123; static SemaphoreSlim _sem = new SemaphoreSlim (3); // 容量为 3 static void Main() &#123; for (int i = 1; i &lt;= 5; i++) new Thread (Enter).Start (i); &#125; static void Enter (object id) &#123; Console.WriteLine (id + \" wants to enter\"); _sem.Wait(); Console.WriteLine (id + \" is in!\"); // 同时只能有 Thread.Sleep (1000 * (int) id); // 3个线程 Console.WriteLine (id + \" is leaving\"); // 执行这里 _sem.Release(); &#125;&#125; 输出结果： 1234567891011121 wants to enter1 is in!2 wants to enter2 is in!3 wants to enter3 is in!4 wants to enter5 wants to enter1 is leaving4 is in!2 is leaving5 is in! 如果Sleep语句被替换为密集的磁盘 I/O 操作，由于Semaphore限制了过多的并发硬盘活动，就可能改善整体性能。 类似于Mutex，命名的Semaphore也可以跨进程使用。 3线程安全说一个程序或方法是线程安全（ thread-safe）的，是指它在任意的多线程场景中都不存在不确定性。线程安全主要是通过锁以及减少线程交互来实现。 一般的类型很少有完全线程安全的，原因如下： 完全线程安全的开发负担很重，特别是如果一个类型有很多字段的情况（在任意多线程并发的情况下每个字段都有交互的潜在可能）。 线程安全可能会损失性能（某种程度上，无论类型是否实际被用于多线程都会增加损耗）。 线程安全的类型并不能确保使用该类型的程序也是线程安全的，为了实现程序线程安全所涉及的工作经常会使得类型线程安全成为多余。 因此线程安全通常只会在需要时再实现，只为了处理特定的多线程场景。 然而，有些方法可以用来“作弊” ，使庞大和复杂的类在多线程环境中安全运行。一种方法是牺牲粒度，将大段代码甚至是访问的整个对象封装在一个排它锁内，从而保证在高层上能进行顺序访问。事实上，如果我们希望在多线程环境中使用线程不安全的第三方代码（或大多数 Framework 的类型）时，这种策略是十分有用的。它仅仅是简单的使用了相同的排它锁，来保护对非线程安全对象上所有属性、方法和字段的访问。这种解决方案适用于对象的方法都能够快速执行的场景（否则会导致大量的阻塞）。 除基本类型外，很少有 .NET Framework 的类型能在比并发读取更高的需求下保证其实例成员是线程安全的。实现线程安全的责任就落在了开发人员身上，一般就是使用排它锁。（命名空间System.Collections.Concurrent中的类型是个例外，它们是线程安全的数据结构。） 另一种“作弊”的方法是通过最小化共享数据来减少线程交互。这是一种优秀的方法，隐式的用于“ 无状态（stateless）”的中间层程序和网页服务器中。由于多个客户端请求可以同时到达，服务端方法就必须是线程安全的。无状态设计（因可伸缩性（scalability）好而流行）在本质上限制了交互的可能性，因为类并不需要持久化请求之间的数据。线程交互仅限于静态字段，比如在内存中缓存通用数据，或者提供认证和审计这样的基础服务时需要考虑。 实现线程安全的最后一种方式是使用自动锁机制（automatic locking regime）。如果继承 ContextBoundObject 类并使用 Synchronization 特性，.NET Framework 就可以实现这种机制。当该对象上的方法或属性被调用时，一个对象范围（object-wide）的锁就会自动作用于整个方法或属性的调用。尽管这样降低了实现线程安全的负担，但是也有它的问题：它很可能造成死锁、降低并发度并引起并非有意的重入。正是由于这些原因，手动加锁通常是更好的选择（直到有更好用的自动锁机制出现）。 3.1线程安全与 .NET Framework 类型锁可以用来将线程不安全的代码转换为线程安全的代码。.NET Framework 就是一个好例子：几乎所有的非基本类型的实例成员都不是线程安全的（对于比只读访问更高的需求），然而如果对指定对象的所有访问都通过锁进行保护，它们就可以被用于多线程代码中。例如，两个线程同时向同一个List中添加对象，然后枚举它： 12345678910111213141516171819class ThreadSafe&#123; static List &lt;string&gt; _list = new List &lt;string&gt;(); static void Main() &#123; new Thread (AddItem).Start(); new Thread (AddItem).Start(); &#125; static void AddItem() &#123; lock (_list) _list.Add (\"Item \" + _list.Count); string[] items; lock (_list) items = _list.ToArray(); foreach (string s in items) Console.WriteLine (s); &#125;&#125; 在这个例子中，我们使用_list对象本身来加锁。如果有两个关联的List，就需要选择一个公共对象来加锁（可以使用其中一个List对象，然而更好的方式是使用一个独立的字段）。 枚举 .NET 的集合也不是线程安全的，因为如果在枚举的过程中集合被修改则会抛出异常。在这个例子中，我们并没有将整个枚举过程加锁，而是首先将其中的对象复制到一个数组中。如果我们要进行的枚举可能很耗时，那么可以通过上述方式避免过长时间锁定。（另一种解决方案是使用读写锁（reader / writer lock）） 对线程安全的对象加锁有时也需要对线程安全的对象加锁，为了举例说明，假设 Framework 的List类是线程安全的，我们要给它添加一个条目： 1if (!_list.Contains (newItem)) _list.Add (newItem); 无论List本身是否线程安全，上面的语句都不是线程安全的！为了防止if条件判断执行后，在实际添加条目之前，被其它线程抢占修改了_list，整个if所包含的代码都需要封装在一个锁中。并且在所有要修改_list的地方都要使用这个锁。例如，下面的语句也需要封装在相同的锁中： 1_list.Clear(); 这也是为了确保了它不会在前面语句的执行过程中抢先执行。换句话说，我们不得不像对于非线程安全的集合一样锁定线程安全的集合（这使得对于List类是线程安全的假设变得多余）。 在高并发的环境下，对集合的访问加锁可能会产生大量阻塞，为此 Framework 4.0 提供了线程安全的队列、栈和字典。 静态成员将对对象的访问封装在一个自定义锁中的方式，只有当所有参与并发的线程都知道并使用这个锁时才能起作用。然而如果需要加锁的逻辑有更大范围那就不是这么简单了。最糟糕的情况就是public类型中的静态成员。比如，我们假设DateTime结构体上的静态属性DateTime.Now不是线程安全的，即两个并发线程调用会导致错误的输出或是异常。使用外部加锁进行修正的唯一方法就是在调用DateTime.Now之前对类型本身加锁：lock(typeof(DateTime))。这仅适用于所有的程序员都接受这样做（这不太可能）。此外，对类型加锁也有其自身的问题。 因此，DateTime结构体的静态成员都经过细致的处理，来保证它是线程安全的。这在 .NET Framework 中是一个通用模式：静态成员是线程安全的，而实例成员则不是。编写类型让别人使用时，遵守这种模式就不会令别人感到困惑和遇到难以解决的线程安全问题。换句话说，保证静态成员的线程安全，就不会妨碍你的类型的使用者实现线程安全。 静态方法的线程安全是必须由明确的编码实现的，不是说把方法写成静态的就能自动实现线程安全！ 只读线程安全使类型对于并发只读访问是线程安全的会很有益，这意味着使用者可以避免使用排它锁。许多 .NET Framework 类型都遵循这一原则：例如集合对于并发读是线程安全的。 自己遵循这一愿则也很简单：如果我们希望一个类型对于并发只读访问是线程安全的，那么不要在使用者期望是只读的方法内修改字段（也不要加锁后修改）。例如，在集合的ToArray()方法的实现中，也许会从压紧（compacting）集合的内部结构开始。然而，这会导致使用者认为是只读的操作并非线程安全。 只读线程安全也是枚举器与可枚举类型分离的原因之一：两个线程可以在一个集合上同时进行枚举，因为它们会分别获得单独的枚举器。 如果缺乏文档，在认为一个方法是只读前一定要谨慎。一个很好的例子是Random类：当调用Random.Next()时，它会更新私有的种子（seed）值。因此，或者对Random类的使用加锁，或者每个线程使用单独的实例。 3.2应用服务器中的线程安全应用服务器需要使用多线程来处理多个客户端的同时请求。WCF、ASP.NET 以及 Web Services 应用都是隐式多线程的。使用 TCP 或 HTTP 之类网络通道的远程（Remoting）服务应用程序也是如此。这意味着服务端编程必须考虑线程安全，考虑在处理客户端请求的线程间是否存在交互的可能。幸运的是，这种交互的可能性不大，一般服务端类要不然是无状态的（无字段），要不然就有为每个客户端或每个请求创建单独对象实例的激活模型。交互通常仅在静态字段上出现，有时是用于在内存中缓存数据库数据来提高性能。 例如，有一个查询数据库的RetrieveUser方法： 12// User 是一个自定义类型，包含用户数据的字段internal User RetrieveUser (int id) &#123; ... &#125; 如果对这个方法的调用很频繁，可以通过在一个静态Dictionary中缓存查询结果来提高性能。下边是一个考虑了线程安全的方案： 1234567891011121314151617static class UserCache&#123; static Dictionary &lt;int, User&gt; _users = new Dictionary &lt;int, User&gt;(); internal static User GetUser (int id) &#123; User u = null; lock (_users) if (_users.TryGetValue (id, out u)) return u; u = RetrieveUser (id); // 从数据库获取数据 lock (_users) _users [id] = u; return u; &#125;&#125; 至少必须要在读取和更新字典时加锁来保证线程安全。在这个例子中，在加锁的便捷和性能之间进行了平衡。我们的设计略有一些效率问题：如果两个线程同时使用未缓存过数据的id调用这个方法，RetrieveUser就可能被调用两次，并且其中一次对字典的更新是不必要的。对整个方法加锁可以避免这一问题，但会导致更糟的效率：整个缓存在调用RetrieveUser的期间都会被加锁，在这段时间内，其它需要这样获取用户信息的线程都会被阻塞。 3.3富客户端应用与线程亲和（译者注：这里的 thread affinity 译为线程亲和，是指 UI 控件与线程的一种“绑定”关系，而不是通常理解中的线程与 CPU 核心的绑定关系。） WPF 与 Windows Forms 库都遵循基于线程亲和的模型。尽管它们有各自的实现，但是原理非常相似。 富客户端的构成主要基于DependencyObject（WPF 中）或是Control（Windows Forms 中）。这些对象具有线程亲和性（thread affinity），意思是只有创建它们的线程才能访问其成员。违反这一原则会引起不可预料的行为，或是抛出异常。 这样的好处是访问 UI 对象时并不需要加锁。而坏处是，如果希望调用在另一线程 Y 上创建的对象 X 的成员，就必须将请求封送（marshal）到线程 Y 。通过下列方法显式实现： WPF 中：在其Dispatcher对象上调用Invoke或BeginInvoke。 Windows Forms 中：调用Control对象上的Invoke或BeginInvoke。 Invoke和BeginInvoke都接受一个委托，代表我们希望在目标控件上运行的的方法。Invoke是同步工作的：调用方在封送的委托执行完成前会被阻塞；BeginInvoke是异步工作的：调用方立即返回，封送请求被加入队列（使用与处理键盘、鼠标、定时器事件相同的消息队列）。 假定窗体包含一个名为txtMessage的文本框，我们希望使用一个工作线程更新其内容，下面是 WPF 的示例： 1234567891011121314151617181920public partial class MyWindow : Window&#123; public MyWindow() &#123; InitializeComponent(); new Thread (Work).Start(); &#125; void Work() &#123; Thread.Sleep (5000); // 模拟耗时任务 UpdateMessage (\"The answer\"); &#125; void UpdateMessage (string message) &#123; Action action = () =&gt; txtMessage.Text = message; Dispatcher.Invoke (action); &#125;&#125; Windows Forms 的代码类似，所不同的是我们调用Form的Invoke方法： 12345void UpdateMessage (string message)&#123; Action action = () =&gt; txtMessage.Text = message; this.Invoke (action);&#125; Framework 提供了两个构造来简化这个过程： BackgroundWorker 任务延续（Task continuations） 工作线程 vs UI 线程我们可以认为富客户端应用程序中有两种不同的线程类别：UI 线程和工作线程。UI 线程创建（并“占有”） UI 元素，工作线程则不会；工作线程通常执行长时间任务，例如获取数据。 大多数的富客户端应用只有一个 UI 线程（它也是应用程序的主线程），它再去根据需要创建工作线程，可以直接创建或者使用BackgroundWorker。这些工作线程可以将代码封送回主 UI 线程来更新控件或报告工作进度。 那么，应用程序何时会需要多个 UI 线程呢？主要的应用场景是：如果应用具有多个顶级窗口，每个顶级窗口都是被称为单文档界面（Single Document Interface，SDI）的程序，例如 Microsoft Word。每个 SDI 窗口通常会在任务栏上显示为独立的应用程序，并且与其它的 SDI 窗口在功能上基本隔离。通过为每一个这样的窗口设置独立的 UI 线程，可以使应用程序有更好的响应。 3.4不可变对象不可变对象的状态不能被修改，无论通过外部还是内部。不可变对象的字段通常被声明为只读的，并且在构造过程中就会被初始化好。 不变性（immutability ）是函数式编程的一个标志：不是修改对象，而是使用不同的属性创建一个新的对象。LINQ 就遵循这种模式。不变性在多线程中也很有价值，它可以通过消除（或是最小化）写入的可能来避免共享可写状态的问题。 使用不可变对象的一个模式是：封装一组相关的字段来最小化锁定的时长。下面的例子中，假设有两个字段： 12int _percentComplete;string _statusMessage; 我们希望对其进行原子的读 / 写操作。除了加锁之外，也可以定义如下的不可变类： 12345678910111213class ProgressStatus // 代表某活动进度&#123; public readonly int PercentComplete; public readonly string StatusMessage; // 这个类可能还有其它很多字段... public ProgressStatus (int percentComplete, string statusMessage) &#123; PercentComplete = percentComplete; StatusMessage = statusMessage; &#125;&#125; 然后，我们可以定义一个该类型的字段，以及一个用于加锁的对象： 12readonly object _statusLocker = new object();ProgressStatus _status; 现在，我们就可以读 / 写该类型的值，而仅需要为一次赋值加锁： 1234var status = new ProgressStatus (50, \"Working on it\");// 想象一下我们曾经在这要处理多少个字段 ...// ...lock (_statusLocker) _status = status; // 非常短暂的锁 要读取该对象，首先获取该对象的一个副本（在锁内），然后就可以读取其值而不需要继续占有锁： 12345ProgressStatus statusCopy;lock (_locker ProgressStatus) statusCopy = _status; // 也是一个短暂的锁int pc = statusCopy.PercentComplete;string msg = statusCopy.StatusMessage;// ... （译者注：上面代码有误，lock中应该是_statusLocker。这里的statusCopy也不是真正的副本，而仅仅相当于_status的别名，这么做是为了通过刷新处理器缓存，获取_status当前的一致状态。） 技术上讲，最后两行代码的线程安全，是因为之前的lock进行了隐式的内存屏障（memory barrier）。 需要注意的是，这种无锁（译者注：这里不是说完全没有用到锁，而是指锁非常短暂）的方法可以避免一组相关字段出现不一致的情况。但它无法阻止后续的操作修改数据，因此，通常需要使用锁。在第 5 部分中，将会看到使用不变性来简化多线程的更多示例，包括PLINQ。 可以根据先前的值安全的创建一个新的ProgressStatus对象（例如：在其上可以“增加”PercentComplete的值），而仅需锁定一行代码。实际上不使用锁都可以，我们可以显式使用内存屏障、Interlocked.CompareExchange还有自旋等待。这种高级技术将在稍后的并行编程中讲解。 4使用事件等待句柄进行信号同步（译者注：signal / signalling 直译是信号 / 发信号，一般在通讯领域用于控制的信号称为信令，但是计算机领域一般还是称之为信号。这里的 signaling 指使用信号进行线程同步，翻译成信号或者信号同步。） 事件等待句柄（event wait handle）用于信号同步。信号同步就是一个线程进行等待，直到它收到其它线程的通知的过程。事件等待句柄是最简单的信号构造，与 C# 的事件（译者注：指基于event关键字的事件模式）无关。它们有三个成员：AutoResetEvent、ManualResetEvent以及CountdownEvent( Framework 4.0 中加入)。前两个的功能基本都是在它们的基类EventWaitHandle上实现的。 信号构造比较 构造 用途 跨进程 开销* AutoResetEvent 使线程在收到其它线程信号时解除阻塞一次 yes 1000ns ManualResetEvent 使线程在收到其它线程信号时解除阻塞，并且不继续阻塞直到被复位 yes 1000ns ManualResetEventSlim（Framework 4.0 中加入） - 40ns CountdownEvent（Framework 4.0 中加入） 使线程在收到预定数量的信号时解除阻塞 - 40ns Barrier（Framework 4.0 中加入） 实现线程执行屏障 - 80ns Wait 和 Pulse 使线程阻塞，直到自定义条件被满足 - 120ns每个Pulse * 时间代表在同一线程上进行发信号并等待（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。 4.1AutoResetEventAutoResetEvent就像验票闸机：插入一张票，就只允许一个人通过。类名字里的 “ auto “ 是指打开的闸门可以自动关闭，或着说在有人通过后 “reset （复位）”。在闸机处调用WaitOne方法（等待这 “one（一个）” 闸机打开），线程就会进入等待或者说阻塞。票的插入则通过调用Set方法。如果有多个线程调用WaitOne，便会在闸机前排队（与锁同样，由于操作系统的差异，这个等待队列的先入先出顺序有时可能被破坏）。票可以来自任意线程，换句话说，任何能够访问这个AutoResetEvent对象的（非阻塞）线程都可以调用Set方法来放行一个被阻塞的线程。 有两种方式可以创建AutoResetEvent对象，第一种是通过构造方法： 1var auto = new AutoResetEvent (false); （如果传递ture给构造方法则相当于在创建后立即调用Set方法。） 第二种方式是像下边的代码这样创建AutoResetEvent： 1var auto = new EventWaitHandle (false, EventResetMode.AutoReset); 在接下来的例子中，一个线程开始等待直到收到另一个线程的信号。 1234567891011121314151617class BasicWaitHandle&#123; static EventWaitHandle _waitHandle = new AutoResetEvent (false); static void Main() &#123; new Thread (Waiter).Start(); Thread.Sleep (1000); // 暂停 1 秒 _waitHandle.Set(); // 唤醒 Waiter &#125; static void Waiter() &#123; Console.WriteLine (\"Waiting...\"); _waitHandle.WaitOne(); // 等待通知 Console.WriteLine (\"Notified\"); &#125; 输出结果： 1Waiting... (pause) Notified. 如果在没有线程等待的时候调用Set，该事件等待句柄会保持“打开”状态直到有线程调用WaitOne。这个行为可以帮助避免一个前往闸机的线程和一个正在插入票的线程之间的配合问题（“糟糕，票早插入了 1 微秒，真不幸，你要永远等下去了！”）。然而，在一个没有任何线程在等待的闸机上反复调用Set并不会允许一堆线程通过：仅仅允许下一个通过，多出来的票被“浪费”了。 在AutoResetEvent上调用Reset可以关闭闸机（应该是开启状态的），这个调用不会等待或阻塞。 WaitOne接受一个可选的timeout参数，如果等待不是由于收到了信号，而是超时结束则返回false。 调用WaitOne并给定一个为 0 的超时时间，可以用来测试等待句柄是否是“打开”的，并且不会阻塞调用方。但是要记住，如果AutoResetEvent是打开的则会复位（关闭）它。 销毁等待句柄（译者注：这里把 dispose 翻译为销毁。） 一旦等待句柄使用完成，可以调用它的Close方法来释放操作系统资源。或者，也可以简单地丢弃所有对等待句柄的引用，让垃圾回收器在稍后处理它（等待句柄实现了销毁模式，会在析构方法中调用Close）。这是少数几个能被接受的（有争论）依赖这种备用机制的场景之一，因为等待句柄对操作系统而言是轻量级资源（异步委托（asynchronous delegates）就是这样来释放其IAsyncResult的等待句柄的 ）。 等待句柄在应用程序域被卸载时会自动地释放。 双向信号我们设定一种场景：主线程需要连续向工作线程发 3 次信号。如果主线程只是在等待句柄上快速的多次调用Set，第 2 个和第 3 个信号可能会丢失，这是由于工作线程可能要花时间去处理每个信号。 解决方案是：主线程需要在发信号前等待工作线程就绪。这可以再用一个AutoResetEvent做到，例如： 12345678910111213141516171819202122232425262728293031323334353637class TwoWaySignaling&#123; static EventWaitHandle _ready = new AutoResetEvent (false); static EventWaitHandle _go = new AutoResetEvent (false); static readonly object _locker = new object(); static string _message; static void Main() &#123; new Thread (Work).Start(); _ready.WaitOne(); // 首先等待工作线程就绪 lock (_locker) _message = \"ooo\"; _go.Set(); // 通知工作线程执行 _ready.WaitOne(); lock (_locker) _message = \"ahhh\"; // 给工作线程其它信息 _go.Set(); _ready.WaitOne(); lock (_locker) _message = null; // 发信号通知工作线程退出 _go.Set(); &#125; static void Work() &#123; while (true) &#123; _ready.Set(); // 表示我们准备好了 _go.WaitOne(); // 等待开始 lock (_locker) &#123; if (_message == null) return; // 优雅地退出 Console.WriteLine (_message); &#125; &#125; &#125;&#125; 输出结果： 12oooahhh 这里我们使用了一个为null的消息来指示工作线程结束。对于无限运行（译者注：指类似这里的while (true)方式无限循环）的线程，退出机制是非常重要的！ 生产者 / 消费者队列生产者 / 消费者队列是一个在多线程中常见的需求，它是这样工作的： 建立一个队列，用于描述需要执行的工作项，或需要处理的数据。 当有任务需要执行时，把它加入队列中，这样调用方就可以继续处理其它事情。 一个或多个工作线程在后台工作，它们从队列中取出工作项并执行。 这种模型的好处是，可以精确控制工作线程的数量，使你能够限制 CPU 和其它资源的消耗。比如，如果任务执行密集的磁盘 I/O 操作，可以仅使用一个工作线程来执行工作，这样能够避免操作系统和其它应用出现饥饿。其它类型的应用也许就可以使用 20 个工作线程。也可以在队列生命周期内动态添加和移除工作线程。CLR 的线程池本身就是一种生产者 / 消费者队列。 生产者 / 消费者队列一般只是存放需要任务处理的数据项，例如数据项可能是文件名，而任务是加密这些文件。 下边的例子，使用一个AutoResetEvent发信号给工作线程，工作线程在所有任务都已完成时（或者说队列为空时）会处于等待状态。通过加入null任务来通知工作线程结束： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Threading;using System.Collections.Generic;class ProducerConsumerQueue : IDisposable&#123; EventWaitHandle _wh = new AutoResetEvent (false); Thread _worker; readonly object _locker = new object(); Queue&lt;string&gt; _tasks = new Queue&lt;string&gt;(); public ProducerConsumerQueue() &#123; _worker = new Thread (Work); _worker.Start(); &#125; public void EnqueueTask (string task) &#123; lock (_locker) _tasks.Enqueue (task); _wh.Set(); &#125; public void Dispose() &#123; EnqueueTask (null); // 通知消费者退出 _worker.Join(); // 等待消费者线程完成执行 _wh.Close(); // 释放所有系统资源 &#125; void Work() &#123; while (true) &#123; string task = null; lock (_locker) if (_tasks.Count &gt; 0) &#123; task = _tasks.Dequeue(); if (task == null) return; &#125; if (task != null) &#123; Console.WriteLine (\"Performing task: \" + task); Thread.Sleep (1000); // 模拟执行工作... &#125; else _wh.WaitOne(); // 没有任务了，等待信号 &#125; &#125;&#125; 为保证线程安全，我们使用了一个锁来保护对Queue&lt;string&gt;的访问。在Dispose方法中，我们也显式关闭了等待句柄，因为在程序生命周期中，有可能会创建和销毁许多这个类的实例。 下边是测试这个队列的主方法： 123456789101112static void Main()&#123; using (ProducerConsumerQueue q = new ProducerConsumerQueue()) &#123; q.EnqueueTask (\"Hello\"); for (int i = 0; i &lt; 10; i++) q.EnqueueTask (\"Say \" + i); q.EnqueueTask (\"Goodbye!\"); &#125; // 使用 using 语句结束时会调用 q 的 Dispose 方法 // 该方法向队列中插入一个 null 的任务，并等待消费者完成退出。&#125; 输出结果： 12345678Performing task: HelloPerforming task: Say 1Performing task: Say 2Performing task: Say 3......Performing task: Say 9Goodbye! Framework 4.0 提供了一个新的类型BlockingCollection，它实现了生产者 / 消费者队列的功能。 前面我们自己写的生产者 / 消费者队列还是有价值的，它不仅仅为了举例说明AutoResetEvent和线程安全，也是更多其它复杂构造的基础。例如，如果想要实现有界阻塞队列（bounded blocking queue）（可以限制队列中任务的个数），并且希望支持取消（和移除）队列中工作项，我们的代码就是一个很好的起点。之后在讨论Wait 和 Pulse时会让这个的生产者 / 消费者队列的例子更进一步。 4.2ManualResetEventManualResetEvent就像一个普通的门。调用Set方法打开门，允许任意数量的线程调用WaitOne方法来通过。调用Reset方法关闭门。如果线程在一个关闭的门上调用WaitOne方法将会被阻塞，当门下次打开时，会被立即放行。除这些不同以外，ManualResetEvent就和AutoResetEvent差不多了。 与AutoResetEvent类似，可以使用两种方式构造ManualResetEvent: 12var manual1 = new ManualResetEvent (false);var manual2 = new EventWaitHandle (false, EventResetMode.ManualReset); 从 Framework 4.0 开始，提供了另一个版本的ManualResetEvent，名为ManualResetEventSlim。后者为短等待时间做了优化，它提供了进行一定次数迭代自旋的能力，也实现了一种更有效的管理机制，允许通过CancellationToken取消Wait等待。但它不能用于跨进程的信号同步。ManualResetEventSlim不是WaitHandle的子类，但它提供一个WaitHandle的属性，会返回一个基于WaitHandle的对象（使用它的性能和一般的等待句柄相同）。 信号构造与性能对于AutoResetEvent和ManualResetEvent，使用它们等待或者发信号需要大概 1 微秒时间（假设没有阻塞）。 ManualResetEventSlim和CountdownEvent在等待时间很短的情况下可以比上面两个快 50 倍。这是因为它们不依赖操作系统，并能择机使用自旋构造。 然而大多数情况下，信号构造自身的开销并不会造成瓶颈，所以很少需要去考虑。高度并发的场景是个例外，我们将在第 5 部分进行讨论。 ManualResetEvent在需要让一个线程解除其它多个线程的阻塞时有用。如果是相反的需求，可以使用CountdownEvent。 4.3CountdownEventCountdownEvent 可以让你等待 1 个以上的线程。这个类型是 Framework 4.0 加入的，并且是一个高效的纯托管实现。 如果在使用较早版本的 .NET Framework，也不是没有办法。稍后我们会介绍如何使用Wait 和 Pulse来实现CountdownEvent。 使用CountdownEvent时，需要指定一个计数器数值，也就是你希望等待的线程数量： 1var countdown = new CountdownEvent (3); // 初始计数为 3 调用Signal方法会将计数减 1，调用Wait会阻塞直到计数为 0。例如： 123456789101112131415161718static CountdownEvent _countdown = new CountdownEvent (3);static void Main()&#123; new Thread (SaySomething).Start (\"I am thread 1\"); new Thread (SaySomething).Start (\"I am thread 2\"); new Thread (SaySomething).Start (\"I am thread 3\"); _countdown.Wait(); // 阻塞直到收到 3 次信号 Console.WriteLine (\"All threads have finished speaking!\");&#125;static void SaySomething (object thing)&#123; Thread.Sleep (1000); Console.WriteLine (thing); _countdown.Signal();&#125; 有时通过使用结构化并行（structured parallelism）构造会比CountdownEvent更容易解决问题。我们将在第 5 部分来说明（PLINQ 和 Parallel类）。 调用AddCount，可以增加CountdownEvent的计数。然而，如果计数已经为 0，就会抛出一个异常：是无法通过调用AddCount来复位（unsignal）的。为避免异常，可以用TryAddCount替代，它在当前计数为 0 时会返回false。 想要复位，可以调用Reset：把构造复位到初始状态，计数恢复原值。 像ManualResetEventSlim一样，CountdownEvent也提供WaitHandle属性，可以在其它类或方法希望得到一个基于WaitHandle的对象时使用。 4.4创建跨进程的 EventWaitHandleEventWaitHandle的构造方法允许以命名的方式进行创建，这样它就可以跨进程使用。名称就是一个字符串，可以随意起名，但是注意不要和别人的命名冲突！如果名字在计算机上已存在，你就会获取一个它对应的EventWaitHandle的引用，否则操作系统会创建一个新的。例如： 12EventWaitHandle wh = new EventWaitHandle (false, EventResetMode.AutoReset, \"MyCompany.MyApp.SomeName\"); 如果两个应用程序分别执行这个代码，它们就可以进行信号同步：这个等待句柄可以在跨这两个进程内的所有线程中使用。 4.5等待句柄和线程池如果你的应用有很多线程，这些线程大部分时间都在阻塞，那么可以通过调用ThreadPool.RegisterWaitForSingleObject来减少资源消耗。这个方法接受一个委托，它会在向等待句柄发信号时执行。当处于等待状态时，它不会浪费线程资源： 123456789101112131415161718static ManualResetEvent _starter = new ManualResetEvent (false);public static void Main()&#123; RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject (_starter, Go, \"Some Data\", -1, true); Thread.Sleep (5000); Console.WriteLine (\"Signaling worker...\"); _starter.Set(); Console.ReadLine(); reg.Unregister (_starter); // 完成后的清理&#125;public static void Go (object data, bool timedOut)&#123; Console.WriteLine (\"Started - \" + data); // 执行任务 ....&#125; 输出结果： 123(5 second delay)Signaling worker...Started - Some Data 当向等待句柄发信号时（或者已超时），委托会在一个线程池线程运行。 除等待句柄和委托外，RegisterWaitForSingleObject还接受一个“黑盒”对象，它会被传递给委托的目标方法（像ParameterizedThreadStart一样）；还有一个以毫秒为单位的超时时间（-1 代表没有超时时间）；和一个布尔值用来设置请求是一次性的还是可重复的。 RegisterWaitForSingleObject在需要处理很多并发请求的应用服务器中非常有用。假如你需要在ManualResetEvent上阻塞，调用WaitOne就可以了： 12345void AppServerMethod()&#123; _wh.WaitOne(); // ... 继续执行&#125; 如果 100 个客户端调用这个方法，就会有 100 个服务端线程被浪费在阻塞上。把_wh.WaitOne换成RegisterWaitForSingleObject可以让方法立即返回，就不会浪费线程资源： 1234567891011void AppServerMethod&#123; RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject (_wh, Resume, null, -1, true); // ...&#125;static void Resume (object data, bool timedOut)&#123; // ... 继续执行&#125; 传递给Resume的data对象可以用来传递和暂存一些瞬态数据。 4.6WaitAny、WaitAll 和 SignalAndWait除了Set、WaitOne和Reset方法外，在WaitHandle类上还有一些静态方法用来解决更复杂的同步问题。 WaitAny、WaitAll和SignalAndWait方法可以向多个等待句柄发信号和进行等待操作。等待句柄可以是不同的类型（包括Mutex和Semaphore，因为它们都派生自抽象类WaitHandle）。对于ManualResetEventSlim和CountdownEvent，也可以通过它们的WaitHandle属性来让这些方法使用。 WaitAll和SignalAndWait与旧有的 COM 架构有古怪的联系：这些方法要求调用方必须在多线程套间（multithreaded apartment）中，这个模式最不适合交互操作。比如 WPF 或 Windows 应用程序的主线程就不能在这种模式下操作剪贴板。我们稍后会讨论到它们的替代方案。 WaitHandle.WaitAny等待一组等待句柄中任意一个，WaitHandle.WaitAll等待给定的所有等待句柄。这个等待是原子的，就是说如果在等待两个AutoResetEvent： WaitAny当任意一个事件处于“打开”状态时就能结束等待。 WaitAll当两个事件同时处于“打开”状态时才能结束等待。 （译者注：见前文，AutoResetEvent在被Set时，如果没有线程在等待，会保持“打开”状态，直到有线程等待它，会放行一个线程，并“关闭”或者说“复位”。这里用WaitAny等待两个AutoResetEvent，那么它只会触发其中一个的复位，另一个如果也被Set，会继续保持“打开”；而如果是WaitAll，则必须两个都处于“打开”状态才能结束等待，同时触发两个事件的复位。） SignalAndWait会调用一个WaitHandle的Set方法，然后调用另一个WaitHandle的WaitOne方法。在向第一个句柄发信号后，会（让当前线程）跳到第二个句柄的等待队列的最前位置。你可以把它看作是“交换”两个信号，在一对EventWaitHandle上调用这个方法来设定两个线程的会合点（rendezvous），或者说是让它们在某一个时间点“相遇”。不管是AutoResetEvent还是ManualResetEvent都可以用来实现这个技巧。第一个线程执行： 1WaitHandle.SignalAndWait (wh1, wh2); 而第二个线程相反： 1WaitHandle.SignalAndWait (wh2, wh1); WaitAll 和 SignalAndWait 的替代方案WaitAll和SignalAndWait不能运行在单线程套间（single-threaded apartment）中。幸运的是，还有替代方案。对于SignalAndWait，其实很少需要它的插队机制：例如在上边的会合例子中，如果等待句柄完全只是为了会合使用，那么就可以在第一个句柄上调用Set，然后在第二个句柄上调用WaitOne。在Barrier类中，我们将探索实现线程会合的另外一个方法。 对于WaitAll，有时可以使用Parallel 类的 Invoke 方法来替代，这个我们将在第 5 部分讨论。（我们也会讨论Task和任务延续（continuations），以及如何使用TaskFactory的ContinueWhenAny作为WaitAny的替代。） 对于其它情况，答案是使用底层的方法来解决所有信号同步问题：见Wait 和 Pulse。 5同步上下文（译者注：这里的同步上下文（synchronization context）并不是指System.Threading.SynchronizationContext类。而是指 CLR 的自动锁机制中的同步域或者说加锁的范围。） 对于手动锁定，另一种实现方案是使用声明方式（declaratively）来锁定。通过从ContextBoundObject类派生并添加Synchronization特性，可以指示 CLR 自动加锁。例如： 12345678910111213141516171819202122232425using System;using System.Threading;using System.Runtime.Remoting.Contexts;[Synchronization]public class AutoLock : ContextBoundObject&#123; public void Demo() &#123; Console.Write (\"Start...\"); Thread.Sleep (1000); // 这里我们无法抢占 Console.WriteLine (\"end\"); // 感谢自动锁 &#125;&#125;public class Test&#123; public static void Main() &#123; AutoLock safeInstance = new AutoLock(); new Thread (safeInstance.Demo).Start(); new Thread (safeInstance.Demo).Start(); safeInstance.Demo(); //并发调用 Demo 3 次 &#125;&#125; 输出结果： 123Start... endStart... endStart... end CLR 确保了同一时刻只有一个线程可以执行 safeInstance中的代码。它通过创建了一个同步对象，并在每次调用safeInstance的方法和属性时进行锁定来实现。锁的作用范围，在这里是指safeInstance对象，被称为同步上下文（synchronization context）。 那么，它是如何工作的呢？一个线索是Synchronization特性的命名空间：System.Runtime.Remoting.Contexts。ContextBoundObject可以被认为是一个“远程（remote）”对象，这意味着所有方法的调用都是会被拦截。为了实现这种拦截，当我们实例化AutoLock时，CLR 自动返回了一个具有相同方法和属性的AutoLock的代理对象，它扮演着中间人角色。自动锁定就是在中间人上进行的。总的来说，这种拦截会在每次方法调用时增加大概 1 微秒的开销。 自动同步不能用于保护静态成员，也不能用于非派生自 ContextBoundObject的类。（例如：Windows Forms 窗体） 锁在内部以相同的方式运作，可以期待下面的例子与之前的有一样的结果： 1234567891011121314151617181920212223[Synchronization]public class AutoLock : ContextBoundObject&#123; public void Demo() &#123; Console.Write (\"Start...\"); Thread.Sleep (1000); Console.WriteLine (\"end\"); &#125; public void Test() &#123; new Thread (Demo).Start(); new Thread (Demo).Start(); new Thread (Demo).Start(); Console.ReadLine(); &#125; public static void Main() &#123; new AutoLock().Test(); &#125;&#125; （注意我们偷偷加了Console.ReadLine语句。）因为这个类的对象在同一时间只有一个线程可以执行代码，三个新线程将阻塞在Demo方法处，直到Test 方法完成，也就是要等待ReadLine完成。因此只有在按了回车键之后，才会得到和之前一样的结果。这种线程安全的重型武器足以阻碍所有类内部的多线程！ 此外，我们仍未解决之前描述的一个问题：如果AutoLock是一个集合类，如果在其它类中执行下面的代码，那么仍然需要加锁： 1if (safeInstance.Count &gt; 0) safeInstance.RemoveAt (0); 除非执行这段代码的类本身也是一个同步的ContextBoundObject！ 同步上下文的作用域可以扩展到超过单一对象的范围。默认情况下，如果一个同步对象在另一个类中被实例化，它们会共享同一个同步上下文（换言之，就是一个巨大的锁！）。这个行为可以通过在Synchronization特性构造方法中使用一个整型标识来改变，可以使用下列SynchronizationAttribute类中定义的常量之一： 常量 作用 NOT_SUPPORTED 相当于不使用Synchronized特性 SUPPORTED 如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则保持非同步状态 REQUIRED（默认值） 如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则创建新的同步上下文 REQUIRES_NEW 始终创建新的同步上下文 所以如果SynchronizedA在SynchronizedB中被实例化，而SynchronizedB使用下面这种声明的话，它们就有各自的同步上下文： 12[Synchronization (SynchronizationAttribute.REQUIRES_NEW)]public class SynchronizedB : ContextBoundObject &#123; // ... 越大的同步上下文越容易管理，但是并发的可能性就越低。另一方面，分离的同步上下文则容易造成死锁，例如： 1234567891011121314151617181920[Synchronization]public class Deadlock : ContextBoundObject&#123; public Deadlock Other; public void Demo() &#123; Thread.Sleep (1000); Other.Hello(); &#125; void Hello() &#123; Console.WriteLine (\"hello\"); &#125;&#125;public class Test&#123; static void Main() &#123; Deadlock dead1 = new Deadlock(); Deadlock dead2 = new Deadlock(); dead1.Other = dead2; dead2.Other = dead1; new Thread (dead1.Demo).Start(); dead2.Demo(); &#125;&#125; 因为两个Deadlock的实例都是在Test中创建的，而Test是非同步类，所以这两个实例会拥有它自己的同步上下文，因此有它自己的锁。当它们互相调用的时候，用不了多久就会死锁（确切的说是一秒！）。如果Deadlock和 Test是由不同的开发团队写的，这个问题会藏的很深。别指望负责Test的团队能意识到他们犯了什么错，更别指望能知道如何解决了。而对于显式的加锁，死锁的原因通常更容易被发现。 5.1重入（译者注：在单线程场景下，方法没有退出前自身再被调用也是重入，比如显式的递归调用，或者隐式的通过消息队列机制等等，这种重入和作者讨论的多线程场景下的重入并不是完全相同的概念。） 线程安全方法有时也被称为可重入的（reentrant），因为它可能在执行中途被抢占，然后在另外的线程再被调用也不会有问题。在一般意义上，线程安全和可重入是同义词或者是密切相关的。 然而，在自动锁机制下，重入有另一个更危险的潜在问题。如果Synchronization特性的reentrant参数为true： 1[Synchronization(true)] 那么在执行离开上下文时，同步上下文的锁会被临时释放。在之前的例子中，这可以防止死锁的发生，当然是符合我们期望的。但是，一个副作用是，在过渡期间，任何线程都可以自由的调用原对象上的任何方法（重新进入（re-entering）同步上下文），这会导致多线程编程异常复杂，应该极力避免它。这就是可重入的问题。 因为[Synchronization(true)]作用于类上，就导致了类中所有会离开同步上下文的方法调用都会带来可重入的副作用问题。 虽然可重入可能是危险的，但有些时候几乎没有其它选择。例如，在一个同步类内部实现了多线程，方法是通过委托把逻辑交给运行在其它同步上下文中的工作线程。如果没有重入，那么工作线程就可能会导致彼此之间或是原线程的阻塞。 这凸显了自动同步的一个基本缺点：范围过大的锁定作用域将制造出巨大的麻烦：死锁、可重入以及降低并发度。这使得手动锁定在任何场景都显得更为合适，而并不仅仅只在简单的场景下。 原文：http://www.albahari.com/threading/part2.aspx翻译：https://blog.gkarch.com/threading/part2.html","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://luox78.github.io/tags/thread/"}]},{"title":"初识JavaScript03","slug":"JavaScript03","date":"2017-12-31T11:50:33.903Z","updated":"2018-01-04T13:54:33.153Z","comments":true,"path":"2017/12/31/JavaScript03/","link":"","permalink":"https://luox78.github.io/2017/12/31/JavaScript03/","excerpt":"Array对象 js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组 赋值","text":"Array对象 js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组 赋值 123456789101112131415//1var arr = new Array(3); arr[0] = 0; arr[1] = 1; arr[2] = 2; alert(arr);//0,1,2 arr[3] = 3;//0,1,2,3 alert(arr); //2 for(var i=0;i&lt;5;i++)&#123; arr[i]=i; &#125; //3 var arr=[1,2,3,\"string\"]; var arr=new Array(1,2,3,\"string\"); Json(键值对)12345var arr=&#123;\"gender\":\"male\",\"name\":\"luox78\",\"age\":18&#125;;for(var key in arr)&#123; alert(key+arr[key]); //取值的另一种方式 arr.key&#125; 原型 相当于C#拓展方法 注意：不能跨script标签使用 123456//简易的邮箱判断String.prototype.checkEmail=function()&#123; return this.indexOf(\"@\")&gt;0?true:false;&#125;;var str=\"111@163.com\";alert(str.checkEmail());//true; DOM DOM document object model 为什么要有dom为了更方便的操作html。DOM就是把Html页面模拟成一个对象，就像XDocument一样，把Xml模拟成了一个对象，提供了操作各个节点的方法，直接调用就可以了。 window，document对象 window代表浏览器整个窗口，alert等操作只能用window操作(window可以省略) document代表整个页面，只能操作页面元素 ，及内置方法 1234window.alert(\"hello\");var n=90;window.alert(window.n);//90document.getElementById('btn').id; 但通过window获取元素时会碰到一个问题，就是元素嵌套必须一层一层访问，如访问form中的buttonwindow.form1.btn.id，此时应该使用document对象简化操作,document.getElementById(&#39;btn&#39;).id document演示1234567//当click时先弹出body area 然后才是html body 涉及事件冒泡document.body.onmousedown=function()&#123; alert(\"body area\");&#125;document.onmousedown=function()&#123; alert(\"html area\");&#125; window常见方法 window.alert(&#39;大家好!&#39;);//弹出警告对话框 window.confirm(&#39;确定要删除吗？&#39;);//确定、取消对话框，返回true或false; 123456789101112&lt;body&gt; &lt;input type=\"button\" id=\"btn3\"/&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(\"btn3\").onclick= function() &#123; if (window.confirm(\"Are you sure to delete?\")) &#123; alert(\"delete success\"); &#125; else &#123; alert(\"delete failed\"); &#125; &#125;&lt;/script&gt; window.navigate(url);//将网页重新导航到url,只支持IE、Opera11.6,建议使用window.location.href=&#39;url&#39;;//支持大多数浏览器 123456window.onload = function() &#123; window.navigate(\"https://luox78.github.io\"); &#125;//基本上都不行window.onload = function () &#123; window.location.href = \"https://luox78.github.io\"; &#125;//推荐使用 window.setInterval(function,delay)每个delay ms执行一次 setTimeout(function,delay)只会执行一次，clearTimeout(setId)是为了清理占用的内存 1234567891011//botton value自增例子&lt;script&gt; var num = parseInt(document.getElementById(\"btn\").value); var setId = setInterval(function () &#123; document.getElementById(\"btn\").value = num++; &#125;, 1); document.getElementById(\"btn\").onclick= function() &#123; clearInterval(setId);//计时器一旦被销毁不能再创建 &#125;&lt;/script&gt; 事件 跟C#中事件，委托差不多 注意点： 事件=函数名，等于给事件赋值不会调用 事件=函数名（），会执行一次函数，这种赋值其实并不正确，事件应该不能等于函数返回值 &lt;body&gt;中 123456&lt;body&gt; &lt;input type=\"button\" id=\"btn\"/&gt; &lt;input type=\"button\" onclick=\"f1();\" /&gt; &lt;input type=\"button\" onclick=f1 /&gt; &lt;input type=\"button\" id=\"btn2\" value=\"change method\"/&gt;&lt;/body&gt; onclick=f1;的意思就是说onclick触发的方法就是f1. onclick=“f1();”的意思就是说onclick直接调用window.f1(); &lt;script&gt;中 12345678910111213&lt;script&gt; function f1() &#123; alert(\"f1\"); &#125; function f3() &#123; alert(\"f3\"); &#125; document.getElementById(\"btn\").onclick = f1; document.getElementById(\"btn2\").onclick = function() &#123; document.getElementById(\"btn\").onclick = f3; alert(\"change completed\"); &#125;&lt;/script&gt; body、document对象的事件 window.onload 网页加载完毕时触发，浏览器是一边下载文档、一边解析执行，可能会出现JavaScript执行时需要操作某个元素，这个元素还没有加载，如果这样就要把操作的代码放到body的onload事件中，或者可以把JavaScript放到元素之后。元素的onload事件是元素自己加载完毕时触发，body onload才是全部加载完成 window.控件Id（不建议使用),document.getElementById(“控件Id”);(推荐) onunload（页面卸载后触发） 网页关闭（或者离开）后触发。//刷新页面的时候、关闭选项卡的时候（多个选项卡） onbeforeunload（页面卸载前触发） 在网页准备关闭（或者离开）前触发。//注意浏览器缓存 &lt;bodyonbeforeunload=“return ‘真的要放弃发帖退出吗?’; ”&gt;。显示的文字随浏览器版本而有差异。// =“window.event.returnValue=‘’只兼容IE 除了属性之外，当然还有通用的HTML元素的事件：onclick（单击）、ondblclick（双击）、onkeydown（按键按下）、onkeypress（点击按键）、onkeyup（按键释放）、onmousedown（鼠标按下）、onmousemove（鼠标移动）、onmouseout（鼠标离开元素范围）、onmouseover（鼠标移动到元素范围）、onmouseup（鼠标按键释放）、oncontextmenu（在浏览器中单击鼠标右键显示”右键菜单”时触发）等。 window对象事件,属性 window.location window.location.href=‘’;//重新导航到新页面,可以取值，也可以赋值。 window.location.reload();//刷新当前页 window.event 123456789&lt;script&gt; document.getElementById(\"dv\").onmousedown= function() &#123; if (window.event.shiftKey) &#123; alert(\"you have pressed the shift\"); &#125; else &#123; alert(\"only mouse click\"); &#125; &#125;&lt;/script&gt; window.event.shiftKey .ctrlKey .altKey etc 获取是否按下某键 clientX、clientY发生事件时鼠标在客户区域的坐标(指显示html区域)； screenX、screenY发生事件时鼠标在屏幕上的坐标； offsetX、offsetY发生事件时鼠标相对于事件源（比如点击按钮时触发onclick）的坐标。当页面中有&lt;!DOCTYPE（文档定义）时，对offsetX和offsetY单击时的解析不同(使用onmousedown的时候与onclick测试结果不同)（单击按钮中文字的时候。） (window.event.returnValue)returnValue属性，如果将returnValue设置为false，就会取消默认事件的处理。在超链接的onclick里面禁止访问href的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。(onsubmit=&quot;window.event.returnValue=false;&quot;) •window.event.returnValue不兼容火狐浏览器 •FireFox:e. preventDefault();取消事件的默认动作。 •直接写return false;IE、FF、Chrome都可以。 window.event.button，发生事件时鼠标按键，IE:1为左键，2为右键，4中滑轮,3左右键同时按下//要测试event.button的值的时候，请在onmousedown事件中测试 ​ window.screen对象，获取屏幕的信息 1234window.onload= function() &#123; alert(screen.width); alert(screen.height); &#125; clipboardData 对象，对粘贴板的操作 onpaste,oncopy事件 12345678910&lt;script&gt; document.body.oncopy = function () &#123; alert(\"forbid copy\"); return false; &#125; document.body.onpaste= function() &#123; alert(\"forbid paste\"); return false; &#125;&lt;/script&gt; window.clipboardData.getData``window.clipboardData.setData已弃用，新的粘贴复制方法下面介绍 ​ js实现各种复制到剪贴板的方法一、实现点击按钮，复制文本框中的的内容 12345678&lt;script type=\"text/javascript\"&gt; function copyUrl2() &#123; var Url2 = document.getElementById(\"biao1\"); Url2.select(); // 选择对象 document.execCommand(\"Copy\"); // 执行浏览器复制命令 alert(\"已复制好，可贴粘。\"); &#125;&lt;/script&gt; 二、点击文本框时，复制文本框里面的内容 123456789&lt;input onclick=\"oCopy(this)\" value=\"你好.要copy的内容!\"&gt;&lt;script language=\"javascript\"&gt; function oCopy(obj) &#123; obj.select(); js = obj.createTextRange(); js.execCommand(\"Copy\") alert(\"复制成功!\"); &#125;&lt;/script&gt; 三、复制文本框或者隐藏域中的内容 12345678910111213141516&lt;script language=\"javascript\"&gt; function CopyUrl(target) &#123; target.value = myimg.value; target.select(); js = myimg.createTextRange(); js.execCommand(\"Copy\"); alert(\"复制成功!\"); &#125; function AddImg(target) &#123; target.value = \"[IMG]\" + myimg.value + \"[/ img]\"; target.select(); js = target.createTextRange(); js.execCommand(\"Copy\"); alert(\"复制成功!\"); &#125;&lt;/script&gt; 四、复制 span 标记中的内容 123456789101112&lt;script type=\"text/javascript\"&gt; function copyText(obj) &#123; var rng = document.body.createTextRange(); rng.moveToElementText(obj); rng.scrollIntoView(); rng.select(); rng.execCommand(\"Copy\"); rng.collapse(false); alert(\"复制成功!\"); &#125;&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"初识JavaScript02","slug":"JavaScript02","date":"2017-12-28T13:39:52.479Z","updated":"2017-12-31T14:26:24.140Z","comments":true,"path":"2017/12/28/JavaScript02/","link":"","permalink":"https://luox78.github.io/2017/12/28/JavaScript02/","excerpt":"js中的事件1 通过调用方法名或在“”内部写2 通过id，使用document.getElementById实现事件","text":"js中的事件1 通过调用方法名或在“”内部写2 通过id，使用document.getElementById实现事件 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;input id=\"btn\" type=\"button\" value=\"show time\" onclick=\"alert(new Date().toLocaleString());\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"show time\" onclick=\"f1();\" /&gt; &lt;input id=\"btn3\" type=\"button\" value=\"show time\" /&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"#\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"javascript:void(0);\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"javascript:alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //alert(new Date().toLocaleString()); function f1() &#123; alert(new Date().toLocaleDateString()); &#125; document.getElementById('btn3').onclick = function f2() &#123; alert(new Date().toLocaleDateString()); &#125; //script 写在上面要加一个窗体以加载事件以防止报错 window.onload = function () &#123; document.getElementById('btn3').onclick = function f2() &#123; alert(new Date().toLocaleDateString()); &#125; &#125;&lt;/script&gt; js调试1 直接在vs中点调试，下断点2 直接在浏览器中调试，按f12-调试 js中的函数1 JavaScript中声明函数的方式：（无需声明返回值类型） 1234567function add(i1, i2) &#123; return i1 + i2; //如果不写return返回的是undefined &#125;int add(int i1,int i2)//C#写法 2 不需要声明返回值类型、参数类型。函数定义以function开头。 1234567var r = add(1, 2);alert(r);r = add(\"你好\", \"tom\");alert(r); 3 JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。 4 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectAll、focus等函数名不要用。//不要与系统函数重名。(在单击事件中调用自己定义的focus方法，有问题。与系统的focus()方法重名了) 注意点1 js方法小写开头 2 js中定义名字的方法没有返回值接受到的是undefined 3 js不支持方法重载，只认最后一个 12345678function add(n1,n2) &#123; return n1 + n2; &#125; function add(n1, n2, n3) &#123; return n1 + n2 + n3; &#125; alert(add(1, 2));//NaN,此时调用的三个参数的add，n3位undefined，导致最后结果为NaN 12345678function add(n1, n2, n3) &#123; return n1 + n2 + n3; &#125; function add(n1, n2) &#123; return n1 + n2; &#125; alert(add(1, 2, 3));//3 通过arguments实现传入多个值123456789function add() &#123; var sum = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum; &#125; alert(add(10, 20, 30));//60 4 return写成return {Name:’yzk’,Age:18};而不要写成： 12345return&#123; Name:’yzk’, Age:18&#125; 原因是js会在语句末尾自动增加”分号”，如果将大括号另起一行，则return语句后自动增加“分号”后，返回值就变成了undefined了。 5 12345var x = 10;function add(n) &#123; n = n + 1; return n &#125;alert(add(x));//4 js搜索的是整个页面的方法，当出现重名的方法，js会使用最后一个（一般是同一个script标签中，涉及加载问题）function add(n) &#123; n = n + 3; return n; &#125;alert(add(x));//4 匿名函数 为了解决方法名冲突（主要是导入文件） 1 写法一 123456//js为动态类型，只有运行时才知道方法有没有返回值，所以f此时代表的是方法 var f = function (n) &#123; return n + 1; &#125; var n = f(10); alert(n);//11 2 写法二 1234//跟第一种一个意思，没有接受方法而已(function(n) &#123; return n + 1; &#125;)(10); 3 写法三 创建一个方法对象，参数传入：方法的参数和方法体，浏览器解析成正常方法所以效率低，不推荐 12var m = new Function(\"m\", \"n\", \"return m+n\");alert(m(10, 20)); js的闭包 定义：在一定函数里面再定义一个函数，•内部函数函数能访问外部函数作用域范围内的变量，这时这个内部函数就叫做闭包。 无论这个内部函数在哪里被调用都能访问的到外部函数作用域中的那些变量。12345678910function f1() &#123; var n = 100; function f2() &#123; alert(n); &#125; return f2(); &#125; var res = f1(); res(); 闭包的目的： ​ * 通过闭包实现访问闭包外方法的局部变量（解决在匿名函数中调用局部变量相关的问题） ​ * 这样使得局部变量一直保存在内存中，模拟面向对象 闭包如何实现的： ​ * 通过作用域链（使用变量先搜索自己作用域里面的数，没有再往上搜索）​ 闭包模拟面向对象 闭包获取数据会长时间占用内存，尽量减少使用js中利用函数可以模拟面向对象123456789101112131415&lt;script&gt; //类名首字母大写以示区分 function Person()&#123; &#125; var per=new Person(); per.name=\"luox78\"; per.age=18; per.say=function ()&#123; alert(\"hello\"); &#125; alert(per.name); per.say();&lt;/script&gt; 123456789&lt;script&gt; function Person(name)&#123; this.name=name; &#125; var per=new Person(\"luo78\"); //访问里面变量的两种方法 alert(per.name); alert(per[\"name\"]);&lt;/script&gt; js里面string的常用方法length 返回字符串长度charAt(index) 返回index位置的字符split(&quot;分隔符&quot;,limit) 多个分隔符使用正则表达式，limit代表返回个数js中数组可以直接显示，中间是逗号隔开1234var str = \"1|2|3|4#6\";alert(str.split(\"|\"));//1,2,3,4//js中split使用正则，且使用直接//转义特殊字符alert(str.split(\\☆|#\\)); substr(startindex,len) 返回截取start位置后len长度的字符串123var str=\"luox78\";alert(str.substr(2));//ox78alert(str.substr(2,2));//ox substring(startindex,stopindex) 返回截取start位置到stop位置的字符串1alert(str.substring(0,3));//luo toUpperCase() toLowerCase() 返回大写，小写match() replace() search() 后面dom部分涉及indexOf(&quot;str&quot;,position) 返回str的索引位置， str指想找的字符串，position指想找的第几个","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"C#中的多线程 - 01基础知识","slug":"CS_Thread01","date":"2017-12-28T12:50:03.698Z","updated":"2017-12-31T12:44:41.774Z","comments":true,"path":"2017/12/28/CS_Thread01/","link":"","permalink":"https://luox78.github.io/2017/12/28/CS_Thread01/","excerpt":"1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：","text":"1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子： 所有示例都假定已经引用了以下命名空间： 12using System;using System.Threading; 12345678910111213141516class ThreadTest&#123; static void Main() &#123; Thread t = new Thread (WriteY); // 创建新线程 t.Start(); // 启动新线程，执行WriteY() // 同时，在主线程做其它事情 for (int i = 0; i &lt; 1000; i++) Console.Write (\"x\"); &#125; static void WriteY() &#123; for (int i = 0; i &lt; 1000; i++) Console.Write (\"y\"); &#125;&#125; 输出结果： 1234xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx... 主线程创建了一个新线程t来不断打印字母 “ y “，与此同时，主线程在不停打印字母 “ x “。 线程一旦启动，线程的IsAlive属性值就会为true，直到线程结束。当传递给Thread的构造方法的委托执行完成时，线程就会结束。一旦结束，该线程不能再重新启动。 CLR 为每个线程分配各自独立的栈空间，因此局部变量是独立的。在下面的例子中，我们定义一个拥有局部变量的方法，然后在主线程和新创建的线程中同时执行该方法。 1234567891011static void Main()&#123; new Thread (Go).Start(); // 在新线程执行Go() Go(); // 在主线程执行Go()&#125;static void Go()&#123; // 定义和使用局部变量 - 'cycles' for (int cycles = 0; cycles &lt; 5; cycles++) Console.Write ('?');&#125; 输出结果：?????????? 变量cycles的副本是分别在各自的栈中创建的，因此才会输出 10 个问号。 线程可以通过对同一对象的引用来共享数据。例如： 1234567891011121314151617class ThreadTest&#123; bool done; static void Main() &#123; ThreadTest tt = new ThreadTest(); // 创建一个公共的实例 new Thread (tt.Go).Start(); tt.Go(); &#125; // 注意： Go现在是一个实例方法 void Go() &#123; if (!done) &#123; done = true; Console.WriteLine (\"Done\"); &#125; &#125;&#125; 由于两个线程是调用了同一个的ThreadTest实例上的Go()，它们共享了done字段，因此输出结果是一次 “ Done “，而不是两次。 输出结果：Done 静态字段提供了另一种在线程间共享数据的方式，以下是一个静态的done字段的例子： 123456789101112131415class ThreadTest&#123; static bool done; // 静态字段在所有线程中共享 static void Main() &#123; new Thread (Go).Start(); Go(); &#125; static void Go() &#123; if (!done) &#123; done = true; Console.WriteLine (\"Done\"); &#125; &#125;&#125; 以上两个例子引出了一个关键概念[线程安全（thread safety）]。上述两个例子的输出实际上是不确定的：” Done “ 有可能会被打印两次。如果在Go方法里调换指令的顺序，” Done “ 被打印两次的几率会大幅提高： 1234static void Go()&#123; if (!done) &#123; Console.WriteLine (\"Done\"); done = true; &#125;&#125; 输出结果： 12DoneDone (很可能!) 这个问题是因为一个线程对if中的语句估值的时候，另一个线程正在执行WriteLine语句，这时done还没有被设置为true。 修复这个问题需要在读写公共字段时，获得一个[排它锁（互斥锁，exclusive lock ）]。C# 提供了[lock]来达到这个目的： 12345678910111213141516171819class ThreadSafe&#123; static bool done; static readonly object locker = new object(); static void Main() &#123; new Thread (Go).Start(); Go(); &#125; static void Go() &#123; lock (locker) &#123; if (!done) &#123; Console.WriteLine (\"Done\"); done = true; &#125; &#125; &#125;&#125; 当两个线程同时争夺一个锁的时候（例子中的locker），一个线程等待，或者说[阻塞]，直到锁变为可用。这样就确保了在同一时刻只有一个线程能进入临界区（critical section，不允许并发执行的代码），所以 “ Done “ 只被打印了一次。像这种用来避免在多线程下的不确定性的方式被称为[线程安全（thread-safe）]。 在线程间共享数据是造成多线程复杂、难以定位的错误的主要原因。尽管这通常是必须的，但应该尽可能保持简单。 一个线程被阻塞时，不会消耗 CPU 资源。 1.1Join 和 Sleep可以通过调用Join方法来等待另一个线程结束，例如： 123456789101112static void Main()&#123; Thread t = new Thread (Go); t.Start(); t.Join(); Console.WriteLine (\"Thread t has ended!\");&#125;static void Go()&#123; for (int i = 0; i &lt; 1000; i++) Console.Write (\"y\");&#125; 输出 “ y “ 1,000 次之后，紧接着会输出 “ Thread t has ended! “。当调用Join时可以使用一个超时参数，以毫秒或是TimeSpan形式。如果线程正常结束则返回true，如果超时则返回false。 Thread.Sleep会将当前的线程阻塞一段时间： 12Thread.Sleep (TimeSpan.FromHours (1)); // 阻塞 1小时Thread.Sleep (500); // 阻塞 500 毫秒 当使用Sleep或Join等待时，线程是[阻塞（blocked）]状态，因此不会消耗 CPU 资源。 Thread.Sleep(0)会立即释放当前的时间片，将 CPU 资源出让给其它线程。Framework 4.0 新的Thread.Yield()方法与其相同，除了它只会出让给运行在相同处理器核心上的其它线程。 Sleep(0)和Yield在调整代码性能时偶尔有用，它也是一个很好的诊断工具，可以用于找出[线程安全（thread safety）]的问题。如果在你代码的任意位置插入Thread.Yield()会影响到程序，基本可以确定存在 bug。 1.2线程是如何工作的线程在内部由一个线程调度器（thread scheduler）管理，一般 CLR 会把这个任务交给操作系统完成。线程调度器确保所有活动的线程能够分配到适当的执行时间，并且保证那些处于等待或阻塞状态（例如，等待排它锁或者用户输入）的线程不消耗CPU时间。 在单核计算机上，线程调度器会进行时间切片（time-slicing），快速的在活动线程中切换执行。在 Windows 操作系统上，一个时间片通常在十几毫秒（译者注：默认 15.625ms），远大于 CPU 在线程间进行上下文切换的开销（通常在几微秒区间）。 在多核计算机上，多线程的实现是混合了时间切片和真实的并发，不同的线程同时运行在不同的 CPU 核心上。几乎可以肯定仍然会使用到时间切片，因为操作系统除了要调度其它的应用，还需要调度自身的线程。 线程的执行由于外部因素（比如时间切片）被中断称为被抢占（preempted）。在大多数情况下，线程无法控制其在何时及在什么代码处被抢占。 1.3线程 vs 进程好比多个进程并行在计算机上执行，多个线程是在一个进程中并行执行。进程是完全隔离的，而线程是在一定程度上隔离。一般的，线程与运行在相同程序中的其它线程共享堆内存。这就是线程为何有用的部分原因，一个线程可以在后台获取数据，而另一个线程可以同时显示已获取到的数据。 1.4线程的使用与误用多线程有许多用处，下面是通常的应用场景： 维持用户界面的响应 使用工作线程并行运行时间消耗大的任务，这样主UI线程就仍然可以响应键盘、鼠标的事件。 有效利用 CPU 多线程在一个线程等待其它计算机或硬件设备响应时非常有用。当一个线程在执行任务时被阻塞，其它线程就可以利用这个空闲出来的CPU核心。 并行计算 在多核心或多处理器的计算机上，计算密集型的代码如果通过分治策略（divide-and-conquer，见[第 5 部分]）将工作量分摊到多个线程，就可以提高计算速度。 推测执行（speculative execution） 在多核心的计算机上，有时可以通过推测之后需要被执行的工作，提前执行它们来提高性能。[LINQPad**]就使用了这个技术来加速新查询的创建。另一种方式就是可以多线程并行运行解决相同问题的不同算法，因为预先不知道哪个算法更好，这样做就可以尽早获得结果。 允许同时处理请求 在服务端，客户端请求可能同时到达，因此需要并行处理（如果你使用 ASP.NET、WCF、Web Services 或者 Remoting，.NET Framework 会自动创建线程）。这在客户端同样有用，例如处理 P2P 网络连接，或是处理来自用户的多个请求。 如果使用了 ASP.NET 和 WCF 之类的技术，可能[不会注意到多线程被使用]，除非是访问共享数据时（比如通过静态字段共享数据）。如果没有正确的[加锁]，就[可能产生线程安全问题]。 多线程同样也会带来缺点，最大的问题是它提高了程序的复杂度。使用多个线程本身并不复杂，复杂的是线程间的交互（一般是通过共享数据）。无论线程间的交互是否有意为之，都会带来较长的开发周期，以及带来间歇的、难以重现的 bug。因此，最好保证线程间的交互尽量少，并坚持简单和已被证明的多线程交互设计。这篇文章主要就是关于如何处理这种复杂的问题，如果能够移除线程间交互，那会轻松许多。 一个好的策略是把多线程逻辑使用可重用的类封装，以便于独立的检验和测试。.NET Framework 提供了许多高层的线程构造，之后会讲到。 当频繁地调度和切换线程时（并且如果活动线程数量大于 CPU 核心数），多线程会增加资源和 CPU 的开销，线程的创建和销毁也会增加开销。多线程并不总是能提升程序的运行速度，如果使用不当，反而可能降低速度。 例如，当需要进行大量的磁盘 I/O 时，几个工作线程顺序执行可能会比 10 个线程同时执行要快。（在[使用 Wait 和 Pulse 进行同步]中，将会描述如何实现 [生产者 / 消费者队列]，它提供了上述功能。） 2创建和启动线程像我们在简介中看到的那样，使用Thread类的构造方法来创建线程，通过传递ThreadStart委托来指明线程从哪里开始运行，下面是ThreadStart委托的定义： 1public delegate void ThreadStart(); 调用Start方法后，线程开始执行，直到它所执行的方法返回后，线程终止。下面这个例子使用完整的 C# 语法创建TheadStart委托： 1234567891011121314class ThreadTest&#123; static void Main() &#123; Thread t = new Thread (new ThreadStart (Go)); t.Start(); // 在新线程运行 GO() Go(); // 同时在主线程运行 GO() &#125; static void Go() &#123; Console.WriteLine (\"hello!\"); &#125;&#125; 在这个例子中，线程t执行Go()方法，几乎同时主线程也执行Go()方法，结果将打印两个 hello。 线程也可以使用更简洁的语法创建，使用方法组（method group），让 C# 编译器推断ThreadStart委托类型： 1Thread t = new Thread (Go); // 无需显式使用 ThreadStart 另一个快捷的方式是使用 lambda 表达式或者匿名方法： 12345static void Main()&#123; Thread t = new Thread ( () =&gt; Console.WriteLine (\"Hello!\") ); t.Start();&#125; 2.1向线程传递数据向一个线程的目标方法传递参数最简单的方式是使用 lambda 表达式调用目标方法，在表达式内指定参数: 12345678910static void Main()&#123; Thread t = new Thread ( () =&gt; Print (\"Hello from t!\") ); t.Start();&#125;static void Print (string message)&#123; Console.WriteLine (message);&#125; 使用这种方式，可以向方法传递任意数量的参数。甚至可以将整个实现封装为一个多语句的 lambda 表达式： 12345new Thread (() =&gt;&#123; Console.WriteLine (\"I'm running on another thread!\"); Console.WriteLine (\"This is so easy!\");&#125;).Start(); 在 C# 2.0 中，也可以很容易的使用匿名方法来进行相同的操作： 1234new Thread (delegate()&#123; ...&#125;).Start(); 另一个方法是向Thread的Start方法传递参数： 1234567891011static void Main()&#123; Thread t = new Thread (Print); t.Start (\"Hello from t!\");&#125;static void Print (object messageObj)&#123; string message = (string) messageObj; // 需要强制类型转换 Console.WriteLine (message);&#125; 可以这样是因为Thread的构造方法通过重载来接受两个委托中的任意一个： 12public delegate void ThreadStart();public delegate void ParameterizedThreadStart (object obj); ParameterizedThreadStart的限制是它只接受一个参数。并且由于它是object类型，通常需要类型转换。 Lambda 表达式与被捕获变量如我们所见，lambda 表达式是向线程传递数据的最强大的方法。然而必须小心，不要在启动线程之后误修改被捕获变量（captured variables）。例如，考虑下面的例子： 12for (int i = 0; i &lt; 10; i++) new Thread (() =&gt; Console.Write (i)).Start(); 输出结果是不确定的！可能是这样0223557799。 问题在于变量i在整个循环中指向相同的内存地址。所以，每一个线程在调用Console.Write时，都在使用这个值在运行时会被改变的变量！ 类似的问题在[C# 4.0 in a Nutshell**]的第 8 章的 “Captured Variables” 有描述。这个问题与多线程没什么关系，而是和 C# 的捕获变量的规则有关（在for和foreach的场景下有时不是很理想）。 解决方法就是使用临时变量，如下所示： 12345for (int i = 0; i &lt; 10; i++)&#123; int temp = i; new Thread (() =&gt; Console.Write (temp)).Start();&#125; 变量temp对于每一个循环迭代是局部的。所以，每一个线程会捕获一个不同的内存地址，从而不会产生问题。我们可以使用更为简单的代码来演示前面的问题： 12345678string text = \"t1\";Thread t1 = new Thread ( () =&gt; Console.WriteLine (text) );text = \"t2\";Thread t2 = new Thread ( () =&gt; Console.WriteLine (text) );t1.Start();t2.Start(); 因为两个lambda表达式捕获了相同的text变量，t2会被打印两次： 12t2t2 2.2线程命名每一个线程都有一个 Name 属性，我们可以设置它以便于调试。这在 Visual Studio 中非常有用，因为线程的名字会显示在线程窗口（Threads Window）与调试位置（Debug Location）工具栏上。线程的名字只能设置一次，以后尝试修改会抛出异常。 静态的Thread.CurrentThread属性会返回当前执行的线程。在下面的例子中，我们设置主线程的名字： 12345678910111213141516class ThreadNaming&#123; static void Main() &#123; Thread.CurrentThread.Name = \"main\"; Thread worker = new Thread (Go); worker.Name = \"worker\"; worker.Start(); Go(); &#125; static void Go() &#123; Console.WriteLine (\"Hello from \" + Thread.CurrentThread.Name); &#125;&#125; 2.3前台与后台线程默认情况下，显式创建的线程都是前台线程（foreground threads）。只要有一个前台线程在运行，程序就可以保持存活，而后台线程（background threads）并不能保持程序存活。当一个程序中所有前台线程停止运行时，仍在运行的所有后台线程会被强制终止。 线程的前台/后台状态与它的优先级和执行时间的分配无关。 可以通过线程的IsBackground属性来查询或修改线程的前后台状态。如下面的例子： 123456789class PriorityTest&#123; static void Main (string[] args) &#123; Thread worker = new Thread ( () =&gt; Console.ReadLine() ); if (args.Length &gt; 0) worker.IsBackground = true; worker.Start(); &#125;&#125; 如果这个程序以无参数的形式运行，工作线程会默认为前台，并在ReadLine时等待用户输入回车。此时主线程退出，但是程序仍然在运行，因为有一个前台线程依然存活。 相反，如果给Main()传递了参数，工作线程设置为后台状态，当主线程结束时，程序几乎立即退出（终止ReadLine需要一咪咪时间）。 当进程以这种方式结束时，后台线程执行栈中所有finally块就会被避开。如果程序依赖finally（或是using）块来执行清理工作，例如释放资源或是删除临时文件，就可能会产生问题。为了避免这种问题，在退出程序时可以显式的等待这些后台线程结束。有两种方法可以实现： 如果是自己创建的线程，在线程上调用[Join](方法。 如果是使用[线程池线程]，使用[事件等待句柄]。 在任一种情况下，都应指定一个超时时间，从而可以放弃由于某种原因而无法正常结束的线程。这是后备的退出策略：我们希望程序最后可以关闭，而不是让用户去开任务管理器(╯-_-)╯╧══╧ 如果用户使用任务管理器强行终止了 .NET 进程，所有线程都会被当作后台线程一般丢弃。这是通过观察得出的结论，并不是通过文档，而且可能会因为 CLR 和操作系统的版本不同而有不同的行为。 前台线程不需要这种处理，但是必须小心避免会使线程无法结束的 bug。程序无法正常退出的一个很有可能的原因就是仍有前台线程存在。 2.4线程优先级线程的Priority属性决定了相对于操作系统中的其它活动线程，它可以获得多少执行时间。线程优先级的取值如下： 1enum ThreadPriority &#123; Lowest, BelowNormal, Normal, AboveNormal, Highest &#125; 只有当多个线程同时活动时，线程优先级才有意义。 在提升线程优先级前请三思，这可能会导致其它线程的资源饥饿（resource starvation，译者注：指没有分配到足够的CPU时间来运行）等问题。 提升线程的优先级是无法使其能够处理实时任务的，因为它还受到程序进程优先级的影响。要进行实时任务，必须同时使用System.Diagnostics中的Process类来提升进程的优先级（记得这不是我告诉你的）： 12using (Process p = Process.GetCurrentProcess()) p.PriorityClass = ProcessPriorityClass.High; ProcessPriorityClass.High实际上就是一个略低于最高优先级Realtime的级别。将一个进程的优先级设置为Realtime是通知操作系统，我们绝不希望该进程将 CPU 时间出让给其它进程。如果你的程序误入一个无限循环，会发现甚至是操作系统也被锁住了，就只好去按电源按钮了o(&gt;_&lt;)o 正是由于这一原因，High 通常是实时程序的最好选择。 如果实时程序拥有用户界面，提升进程的优先级会导致大量的 CPU 时间被用于屏幕更新，这会降低整台机器的速度（特别是当 UI 很复杂时）。降低主线程的优先级，并提升进程的优先级可以保证需要进行实时任务的工作线程不会被屏幕重绘所抢占。但是这依然没有解决其它程序的CPU时间饥饿的问题，因为操作系统依然为这个进程分配了大量 CPU 资源。 理想的解决方案是分离 UI 线程和实时工作线程，使用两个进程分别运行。这样就可以分别设置各自的进程优先级，彼此之间通过 Remoting 或是内存映射文件进行通信。内存映射文件十分适用于这一任务，在C# 4.0 in a Nutshell**的第 14 和 25 章会讲到。 即使是提升了进程优先级，托管环境在处理强实时需求时仍然有限制。除了自动垃圾回收带来的延迟，操作系统也不能够完全满足实时任务的需要，即便是非托管的程序也是如此。最好的解决办法还是使用独立的硬件或者专门的实时平台。 2.5异常处理当线程开始运行后，其创建代码所在的try / catch / finally块与该线程不再有任何关系。考虑下面的程序： 1234567891011121314public static void Main()&#123; try &#123; new Thread (Go).Start(); &#125; catch (Exception ex) &#123; // 永远执行不到这里 Console.WriteLine (\"Exception!\"); &#125;&#125;static void Go() &#123; throw null; &#125; // 产生 NullReferenceException 异常 这个例子中的try / catch语句是无效的，而新创建的线程将会遇到一个未处理的NullReferenceException。因为主线程直接跳过catch。 修改方法是将异常处理移到Go方法中： 12345678910111213141516171819public static void Main()&#123; new Thread (Go).Start();&#125;static void Go()&#123; try &#123; // ... throw null; // 异常会在下面被捕获 // ... &#125; catch (Exception ex) &#123; // 一般会记录异常， 和/或通知其它线程我们遇到问题了 // ... &#125;&#125; 在生产环境的程序中，所有线程的入口方法处都应该有一个异常处理器，就如同在主线程所做的那样（一般可能是在执行栈上靠近入口的地方）。未处理的异常会使得整个程序停止运行，弹出一个难看的对话框。 在写异常处理块的时候，最好不要忽略错误。一般应该记录异常详细信息，然后可以弹出一个对话框让用户可以选择是否自动把这些信息提交到你的服务器。最后应该关闭程序，因为很可能错误已经破坏的程序的状态。然而这么做会导致用户丢失当前的工作，比如打开的文档。 WPF 和 Windows Forms 应用中的“全局”异常处理事件（Application.DispatcherUnhandledException和Application.ThreadException）只会在主UI线程有未处理的异常时触发。对于工作线程上的异常仍然需要手动处理。 AppDomain.CurrentDomain.UnhandledException会对所有未处理的异常触发，但是它不提供阻止程序退出的办法。 然而在某些情况下，可以不必处理工作线程上的异常，因为 .NET Framework 会为你处理。这些会在接下来的内容中讲到： [异步委托] [BackgroundWorker] [任务并行库（TPL）] 3线程池 当启动一个线程时，会有几百毫秒的时间花费在准备一些额外的资源上，例如一个新的私有局部变量栈这样的事情。每个线程会占用（默认情况下）1MB 内存。线程池（thread pool）可以通过共享与回收线程来减轻这些开销，允许多线程应用在很小的粒度上而没有性能损失。在多核心处理器以分治（divide-and-conquer）的风格执行计算密集代码时将会十分有用。 线程池会限制其同时运行的工作线程总数。太多的活动线程会加重操作系统的管理负担，也会降低 CPU 缓存的效果。一旦达到数量限制，任务就会进行排队，等待一个任务完成后才会启动另一个。这使得程序任意并发成为可能，例如 web 服务器。（异步方法模式（asynchronous method pattern）是进一步高效利用线程池的高级技术，我们在C# 4.0 in a Nutshell**的 23 章来讲）。 有多种方法可以使用线程池： 通过[任务并行库（TPL）]（Framework 4.0 中加入） 调用[ThreadPool.QueueUserWorkItem] 通过[异步委托] 通过[BackgroundWorker] 以下构造会间接使用线程池： WCF、Remoting、ASP.NET 和 ASMX 网络服务应用 [System.Timers.Timer]和 [System.Threading.Timer] .NET Framework 中名字以 Async 结尾的方法，例如WebClient上的方法（使用[基于事件的异步模式，EAP]），和大部分BeginXXX方法（异步编程模型模式，APM） PLINQ 任务并行库（Task Parallel Library，TPL）与 PLINQ 足够强大并面向高层，即使使用线程池并不重要，也应该使用它们来辅助多线程。我们会在[第 5 部分]中进行更详细的讨论。现在，简单看一下如何使用[Task]类作为在线程池线程上运行委托的简单方法。 在使用线程池线程时有几点需要小心： 无法设置线程池线程的Name属性，这会令调试更为困难（当然，调试时也可以在 Visual Studio 的线程窗口中给线程附加备注）。 线程池线程永远是[后台线程]（一般不是问题）。 [阻塞]线程池线程可能会在程序早期带来额外的延迟，除非调用了ThreadPool.SetMinThreads（见[优化线程池]）。 可以改变线程池线程的[优先级]，当它用完后返回线程池时会被恢复到默认状态。 可以通过Thread.CurrentThread.IsThreadPoolThread属性来查询当前是否运行在线程池线程上。 3.1通过 TPL 使用线程池可以很容易的使用任务并行库（Task Parallel Library，TPL）中的[Task]类来使用线程池。 Task类在 Framework 4.0 时被加入：如果你熟悉旧式的构造，可以将非泛型的Task类看作[ThreadPool.QueueUserWorkItem]的替代，而泛型的Task&lt;TResult&gt;看作[异步委托]的替代。比起旧式的构造，新式的构造会更快速，更方便，并且更灵活。 要使用非泛型的Task类，调用Task.Factory.StartNew，并传递目标方法的委托： 123456789static void Main() // Task 类在 System.Threading.Tasks 命名空间中&#123; Task.Factory.StartNew (Go);&#125;static void Go()&#123; Console.WriteLine (\"Hello from the thread pool!\");&#125; Task.Factory.StartNew返回一个Task对象，可以用来监视任务，例如通过调用Wait)方法来等待其结束。 当调用Task的[Wait方法]时，所有未处理的异常会在宿主线程被重新抛出。（如果不调用Wait而是丢弃不管，未处理的异常会[像普通的线程那样]结束程序。（译者注：在 .NET 4.5 中，为了支持基于async / await的异步模式，Task中这种“未观察”的异常默认会被忽略，而不会导致程序结束。 泛型的Task&lt;TResult&gt;类是非泛型Task的子类。它可以使你在其完成执行后得到一个返回值。在下面的例子中，我们使用Task&lt;TResult&gt;来下载一个网页： 12345678910111213141516171819static void Main()&#123; // 启动 task： Task&lt;string&gt; task = Task.Factory.StartNew&lt;string&gt; ( () =&gt; DownloadString (\"http://www.gkarch.com\") ); // 执行其它工作，它会和 task 并行执行： RunSomeOtherMethod(); // 通过 Result 属性获取返回值： // 如果仍在执行中, 当前进程会阻塞等待直到 task 结束： string result = task.Result;&#125;static string DownloadString (string uri)&#123; using (var wc = new System.Net.WebClient()) return wc.DownloadString (uri);&#125; （这里的&lt;string&gt; 类型参数是为了示例的清晰，它可以被省略，让编译器推断。） 查询task的Result属性时，未处理的异常会被封装在[AggregateException]中自动重新抛出。然而，如果没有查询Result属性（并且也没有调用Wait），未处理的异常会令程序结束。 TPL 具有更多的特性，非常适合于利用多核处理器。关于 TPL 的讨论我们在[第 5 部分]中继续。 3.2不通过 TPL 使用线程池如果是使用 .NET Framework 4.0 以前的版本，则不能使用任务并行库。你必须通过一种旧的构造使用线程池：ThreadPool.QueueUserWorkItem与异步委托。这两者之间的不同在于异步委托可以让你从线程中返回数据，同时异步委托还可以将异常封送回调用方。 QueueUserWorkItem要使用QueueUserWorkItem，仅需要使用希望在线程池线程上运行的委托来调用该方法： 1234567891011static void Main()&#123; ThreadPool.QueueUserWorkItem (Go); ThreadPool.QueueUserWorkItem (Go, 123); Console.ReadLine();&#125;static void Go (object data) // 第一次调用时 data 为 null&#123; Console.WriteLine (\"Hello from the thread pool! \" + data);&#125; 输出结果： 12Hello from the thread pool!Hello from the thread pool! 123 目标方法Go，必须接受单一一个object参数（来满足WaitCallback委托）。这提供了一种向方法传递数据的便捷方式，就像ParameterizedThreadStart一样。与Task不同，QueueUserWorkItem并不会返回一个对象来帮助我们在后续管理其执行。并且，你必须在目标代码中显式处理异常，未处理的异常会[令程序结束] 异步委托ThreadPool.QueueUserWorkItem并没有提供在线程执行结束之后从线程中返回值的简单机制。异步委托调用（asynchronous delegate invocations ）解决了这一问题，可以允许双向传递任意数量的参数。而且，异步委托上的未处理异常可以方便的原线程上重新抛出（更确切的说，在调用EndInvoke的线程上），所以它们不需要显式处理。 不要混淆异步委托和异步方法（asynchronous methods ，以 Begin 或 End 开始的方法，比如File.BeginRead/File.EndRead）。异步方法表面上看使用了相似的方式，但是其实是为了解决更困难的问题。我们在C# 4.0 in a Nutshell**的第 23 章中描述。 下面是如何通过异步委托启动一个工作线程： 创建目标方法的委托（通常是一个Func类型的委托）。 在该委托上调用BeginInvoke，保存其IAsyncResult类型的返回值。 BeginInvokde会立即返回。当线程池线程正在工作时，你可以执行其它的动作。 当需要结果时，在委托上调用EndInvoke，传递所保存的IAsyncResult对象。 接下来的例子中，我们使用异步委托调用来和主线程中并行运行一个返回字行串长度的简单方法： 123456789101112static void Main()&#123; Func&lt;string, int&gt; method = Work; IAsyncResult cookie = method.BeginInvoke (\"test\", null, null); // // 这里可以并行执行其它任务 // int result = method.EndInvoke (cookie); Console.WriteLine (\"String length is: \" + result);&#125;static int Work (string s) &#123; return s.Length; &#125; EndInvoke会做三件事： 如果异步委托还没有结束，它会等待异步委托完成执行。 它会接收返回值（也包括ref和out方式的参数）。 它会向调用线程抛出未处理的异常。 如果使用异步委托调用的方法没有返回值，技术上你仍然需要调用EndInvoke。在实践中，这里存在争论，因为不调用EndInvoke也不会有什么损失。然而如果你选择不调用它，就需要考虑目标方法中的异常处理来避免错误无法察觉。 （译者注：MSDN文档**中明确写了 “无论您使用何种方法，都要调用 EndInvoke 来完成异步调用。”，所以最好不要偷懒。） 当调用BeginInvoke时也可以指定一个回调委托。这是一个在完成时会被自动调用的、接受IAsyncResult对象的方法。这样可以在后面的代码中“忘记”异步委托，但是需要在回调方法里做点其它工作： 12345678910111213141516static void Main()&#123; Func&lt;string, int&gt; method = Work; method.BeginInvoke (\"test\", Done, method); // ... //&#125;static int Work (string s) &#123; return s.Length; &#125;static void Done (IAsyncResult cookie)&#123; var target = (Func&lt;string, int&gt;) cookie.AsyncState; int result = target.EndInvoke (cookie); Console.WriteLine (\"String length is: \" + result);&#125; BeginInvoke的最后一个参数是一个用户状态对象，用于设置IAsyncResult的AsyncState属性。它可以是需要的任何东西，在这个例子中，我们用它向回调方法传递method委托，这样才能够在它上面调用EndInvoke。 3.3优化线程池线程池初始时其池内只有一个线程。随着任务的分配，线程池管理器就会向池内“注入”新线程来满足工作负荷的需要，直到最大数量的限制。在足够的非活动时间之后，线程池管理器在认为“回收”一些线程能够带来更好的吞吐量时进行线程回收。 可以通过调用ThreadPool.SetMaxThreads方法来设置线程池可以创建的线程上限；默认如下： Framework 4.0，32位环境下：1023 Framework 4.0，64位环境下：32768 Framework 3.5：每个核心 250 Framework 2.0：每个核心 25 （这些数字可能根据硬件和操作系统不同而有差异。）数量这么多是因为要确定[阻塞]（等待一些条件，比如远程计算机的相应）的线程的条件是否被满足。 也可以通过ThreadPool.SetMinThreads设置线程数量下限。下限的作用比较奇妙：它是一种高级的优化技术，用来指示线程池管理器在达到下限之前不要延迟线程的分配。当存在[阻塞]线程时，提高下限可以改善程序并发性。 默认下限数量是 CPU 核心数，也就是能充分利用 CPU 的最小数值。在服务器环境下（比如 IIS 中的 ASP.NET），下限数量一般要高的多，差不多 50 或者更高。 最小线程数量是如何起作用的？ 将线程池的最小线程数设置为 x 并不是立即创建至少 x 个线程，而是线程会根据需要来创建。这个数值是指示线程池管理器当需要的时候，立即 创建 x 个线程。那么问题是为什么线程池在其它情况下会延迟创建线程？ 答案是为了防止短生命周期的任务导致线程数量短暂高峰，使程序的内存足迹（memory footprint）快速膨胀。为了描述这个问题，考虑在一个 4 核的计算机上运行一个客户端程序，它一次发起了 40 个任务请求。如果每个任务都是一个 10ms 的计算，假设它们平均分配在 4 个核心上，总共的开销就是 100ms 多。理想情况下，我们希望这 40 个任务运行在 4 个线程上： 如果线程数量更少，就无法充分利用 4 个核心。 如果线程数量更多，会浪费内存和 CPU 时间去创建不必要的线程。 线程池就是以这种方式工作的。让线程数量和 CPU 核心数量匹配，就能够既保持小的内存足迹，又不损失性能。当然这也需要线程都能被充分使用（在这个例子中满足该条件）。 但是，现在来假设任务不是进行 10ms 的计算，而是请求互联网，使用半秒钟等待响应，此时本地 CPU 是空闲状态。线程池管理器的线程经济策略（译者注：指上面说的线程数量匹配核心数）这时就不灵了，应该创建更多的线程，让所有的请求同时进行。 幸运的是，线程池管理器还有一个后备方案。如果在半秒内没有能够响应请求队列，就会再创建一个新的线程，以此类推，直到线程数量上限。 半秒的等待时间是一把双刃剑。一方面它意味着一次性的短暂任务不会使程序快速消耗不必要的40MB（或者更多）的内存。另一方面，在线程池线程被阻塞时，比如在请求数据库或者调用WebClient.DownloadFile，就进行不必要的等待。因为这种原因，你可以通过调用SetMinThreads来让线程池管理器在分配最初的 x 个线程时不要等待，例如： 1ThreadPool.SetMinThreads (50, 50); （第二个参数是表示多少个线程分配给 I/O 完成端口（I/O completion ports，IOCP），来被APM使用，这会在C# 4.0 in a Nutshell** 的第 23 章描述。） 最小线程数量的默认值是 CPU 核心数。 总结：面对长时间等待的线程，因为这些线程只占时间，并不需要cpu计算，所以线程池管理器之前的平分策略就出现了问题，由此引入半秒等待机制，一旦此线程运行时间超过半秒就直接开启新的线程给新任务。但半秒等待机制还是存在利弊，利是防止很多线程的同时开启一下子占用大量内存，弊是必须等待半秒线程管理器才会开启新线程导致时间浪费，此时设置最小线程数量显得尤为重要，可以有效的防止等待，也不会占用很多内存（根据你自己的设置）","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://luox78.github.io/tags/thread/"}]},{"title":"初识JavaScript01","slug":"JavaScript01","date":"2017-12-27T12:55:09.751Z","updated":"2018-01-01T11:38:56.825Z","comments":true,"path":"2017/12/27/JavaScript01/","link":"","permalink":"https://luox78.github.io/2017/12/27/JavaScript01/","excerpt":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt;","text":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt; 默认如果直接在script标签中定义变量，则属于“全局作用域范围”(全局执行环境)，即属于window对象。1 . 全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源2 . 一个页面中的多个script标签中的变量可以互相访问。3 . JS有垃圾回收机制，会定时对可释放资源的变量回收。将变量设置为null则表示可以被回收了。 123456789&lt;script&gt; function name(parameters) &#123; var i = 0; i++; alert(i); &#125; //方法无返回值，会返回undefined alert(name());&lt;/script&gt; 1234567&lt;script&gt; var i = 1;&lt;/script&gt;&lt;script&gt; //全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源 alert(i);//1&lt;/script&gt; 方法内部不使用var定义的变量相当于全局变量1234567891011&lt;script&gt; function f1(parameters) &#123; i = 100; //var i = 100; &#125;&lt;/script&gt;&lt;script&gt; f1(); alert(i);//100 //alert(i);使用未定义&lt;/script&gt; switchjs中switch中的判断是严格判断就是全等于（===）123456789101112&lt;script&gt; var i = 90; switch (i) &#123; case 90: alert(\"number\"); break; case \"90\": alert(\"string\"); break; default: &#125;&lt;/script&gt; js类型转换注意点： 1 Number（）将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN 2 String（）转换不成功返回undefined， toString（）报错 3 Boolean（）转换当为0或为空（值为空或者null）时返回false，其余返回true1234567891011121314151617181920&lt;script&gt; alert(parseInt(\"90\")); //90 alert(parseInt(\"90aaaaaaaaaa\")); //90 alert(parseInt(\"aaaaaa\")); //NaN alert(parseInt(111, 2)); //代表给定一个二进制的数111输出十进制 alert(parseFloat(10.111)); //10.111 alert(Number(\"40addd\")); //将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN //alert(isNaN(\"aaa\")); //true var str; alert(String(str)); //undefined alert(str.toString()); //报错 //boolean var b1 = Boolean(\"\"); //false - 空字符串 var b2 = Boolean(\"hello\"); //true - 非空字符串 var b1 = Boolean(50); //true - 非零数字 var b1 = Boolean(null); //false – null var b1 = Boolean(0); //false - 零 var b1 = Boolean(new object()); //true - 对象 &lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"LINQ","slug":"Ten_LINQ_Myth","date":"2017-12-26T14:34:53.555Z","updated":"2018-01-01T11:38:28.505Z","comments":true,"path":"2017/12/26/Ten_LINQ_Myth/","link":"","permalink":"https://luox78.github.io/2017/12/26/Ten_LINQ_Myth/","excerpt":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3);","text":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3); 2 All LINQ queries must use query syntax. lambda syntax query syntax 12345678//Here's an example of lambda syntax:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); Here's the same thing expressed in query syntax://string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = from p in people where p.Length &gt; 3 select p; 3 To retrieve all customers from the customer table, you must perform a query similar to the following:12345678910111213141516171819The expression:from c in db.Customers select c is a frivolous query! You can simply go:db.CustomersSimilarly, the following LINQ to XML query:var xe = from e in myXDocument.Descendants (\"phone\") select e;can be simplified to:var xe = myXDocument.Descendants (\"phone\");And this:Customer customer = (from c in db.Customers where c.ID == 123 select c) .Single();can be simplified to:Customer customer = db.Customers.Single (c =&gt; c.ID == 123); 4 A LINQ to SQL or EF query will be executed in one round-trip only if the query was built in a single step.LINQ follows a lazy evaluation model, which means queries execute not when constructed, but when enumerated. This means you can build up a query in as many steps as you like, and it won’t actually hit the server until you eventually start consuming the results. For instance, the following query retrieves the names of all customers whose name starts with the letter ‘A’, and who have made at least two purchases. We build this query in three steps:123456var query = db.Customers.Where (c =&gt; c.Name.StartsWith (\"A\"));query = query.Where (c =&gt; c.Purchases.Count() &gt;= 2);var result = query.Select (c =&gt; c.Name);foreach (string name in result) // Only now is the query executed! Console.WriteLine (name); 5 Because SQL emits flat result sets, LINQ queries must be structured to emit flat result sets, too.For example, if you want to retrieve the names of customers in the state of WA along with all their purchases, you can simply do the following:1234567from c in db.Customerswhere c.State == \"WA\"select new&#123; c.Name, c.Purchases // An EntitySet (collection)&#125; The hierarchical result from this query is much easier to work with than a flat result set! We can achieve the same result without association properties as follows:1234567from c in db.Customerswhere c.State == \"WA\"select new&#123; c.Name, Purchases = db.Purchases.Where (p =&gt; p.CustomerID == c.ID)&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"LINQ","slug":"LINQ","permalink":"https://luox78.github.io/tags/LINQ/"}]},{"title":"C#6 特性","slug":"CS6","date":"2017-12-26T12:27:56.003Z","updated":"2018-01-01T11:37:40.958Z","comments":true,"path":"2017/12/26/CS6/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS6/","excerpt":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符","text":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符 空操作符 ( ?. )123456if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0) &#123; Console.WriteLine(user.Project.Tasks.First().Name); &#125; //现在Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 注意： 上面的代码虽然可以让我们少些很多代码，而且也减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常，那么使用这个特性反而隐藏了Bug NameOf利用nameof减少手写带来的错误 12345Person p;if(p == null)&#123; throw new Exception(\"nameof(Person)\"); &#125; 表达式方法体1private static string SayHello() =&gt; \"Hello World\"; 自动属性初始化器1234567891011121314151617181920//以前public class Person &#123; public int Age &#123; get; set; &#125; public Person() &#123; Age = 100; &#125; &#125; //现在public class Person &#123; public int Age &#123; get; private set; &#125; &#125; //同时增加了只读属性初始化public class Person &#123; public int Age &#123; get; &#125; = 100; &#125; Index 初始化器1234567var names = new Dictionary&lt;int, string&gt; &#123; [1] = \"Jack\", [2] = \"Alex\", [3] = \"Eric\", [4] = \"Jo\" &#125;; using 静态类的方法可以使用 static using123456789101112using System; using static System.Math; namespace CSharp6NewFeatures &#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(Log10(5)+PI); &#125; &#125; &#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"C#7 特性","slug":"CS7","date":"2017-12-25T16:01:58.230Z","updated":"2017-12-27T15:15:16.885Z","comments":true,"path":"2017/12/26/CS7/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS7/","excerpt":"本地方法（Local functions）有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 （local function）： 123456789101112public int Fibonacci(int x) &#123; if (x &lt; 0) throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x)); return Fib(x).current; (int current, int previous) Fib(int i) &#123; if (i == 0) return (1, 0); var (p, pp) = Fib(i - 1); return (p + pp, p); &#125; &#125;","text":"本地方法（Local functions）有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 （local function）： 123456789101112public int Fibonacci(int x) &#123; if (x &lt; 0) throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x)); return Fib(x).current; (int current, int previous) Fib(int i) &#123; if (i == 0) return (1, 0); var (p, pp) = Fib(i - 1); return (p + pp, p); &#125; &#125; 元组（Tuples）我们经常希望能从一个方法中返回一个以上的结果。旧版本的 C#中的选项远远达不到令人满意的程度： Out 参数： 使用起来很笨拙（哪怕你使用了上面所述的改进），并且无法在 async 方法中使用。 System.Tuple&lt;…&gt; 返回类型： 用起来很啰嗦，并且需要分配一个元组对象。 自定义每个方法的传输类型： 需要用一大堆代码来实现一个类，而目的仅仅是临时打包几个变量。 通过动态类型返回匿名类： 性能有瓶颈，且没有静态类型检查。 为了在这方面做得更好，C# 7.0 加入了元组类型（tuple types）和元组字面量（tupleliterals）： 12345(string, string, string) LookupName(long id) // 元组返回类型 &#123; // 从数据储存中取出第一个、中间和最后一个数据 return (first, middle, last); // 元组字面量 &#125; 这种方法现在会很有效率地返回三个字符串，包装成一个元组值中的元素。 方法的调用者将会收到一个元组，并可以分别访问各个元素： 123var names = LookupName(id); WriteLine($&quot;found &#123;names.Item1&#125;&#123;names.Item3&#125;.&quot;); Item1等是元组元素的默认名称，并且总是可用的。但是这样描述性不是非常好，因此你可以选择性地使用另一种更好的方法： 123456(string first, string middle, string last)LookupName(long id) // 元组元素拥有了名称 //现在元组的接收者可以使用更具描述性的名字了： var names = LookupName(id); WriteLine($&quot;found &#123;names.first&#125;&#123;names.last&#125;.&quot;); //你也可以直接在元组字面量中指定元素名称： return (first: first, middle: middle,last: last); // 在字面量中命名元组元素 通常来说你可以无视名字而将元组类型互相转换：只要每个元素之间是可转换的（assignable），元组类型即可自由地互相转换。 元组是值类型，它们的元素是简单的公共、可修改的字段。它们具有值相等性，意味着如果两个元组间每个元素两两相等（且拥有相同的哈希值）则两个元组相等（且拥有相同的哈希值）。 这使得元组在多返回值之外的许多场景也很有用。例如，如果你需要一个拥有多个键的字典，使用一个元组作为你的键，一切都会正常运行。如果你需要一个每个位置有多个值的列表，使用元组吧，诸如搜索列表这样的功能将会正确的工作。","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-25T13:51:57.623Z","updated":"2017-12-27T15:14:33.446Z","comments":true,"path":"2017/12/25/hello-world/","link":"","permalink":"https://luox78.github.io/2017/12/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}