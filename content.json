{"meta":{"title":"luox78","subtitle":"Daily Learning","description":"Blog for luox78","author":"luox78","url":"https://luox78.github.io"},"pages":[],"posts":[{"title":"ASP.NET MVC03","slug":"ASP.NET-MVC03","date":"2018-03-04T04:17:37.088Z","updated":"2018-03-04T11:43:06.685Z","comments":true,"path":"2018/03/04/ASP.NET-MVC03/","link":"","permalink":"https://luox78.github.io/2018/03/04/ASP.NET-MVC03/","excerpt":"jQuery Validatehttp://www.runoob.com/jquery/jquery-plugin-validate.html Mvc校验及数据批注解耦方法创建模型类 12345678public class UserInfo &#123; [StringLength(10,ErrorMessage = \"*10个字符以内\")] public string Name &#123; get; set; &#125; [Range(0,130,ErrorMessage = \"*0到130岁之间\")] public int Age &#123; get; set; &#125; &#125; 通过模型类的数据批注，mvc中html帮助器方法会创建带校验的html属性","text":"jQuery Validatehttp://www.runoob.com/jquery/jquery-plugin-validate.html Mvc校验及数据批注解耦方法创建模型类 12345678public class UserInfo &#123; [StringLength(10,ErrorMessage = \"*10个字符以内\")] public string Name &#123; get; set; &#125; [Range(0,130,ErrorMessage = \"*0到130岁之间\")] public int Age &#123; get; set; &#125; &#125; 通过模型类的数据批注，mvc中html帮助器方法会创建带校验的html属性 1234567&lt;div class=\"form-group\"&gt; @Html.LabelFor(model =&gt; model.Name, htmlAttributes: new &#123; @class = \"control-label col-md-2\" &#125;) &lt;div class=\"col-md-10\"&gt; @Html.EditorFor(model =&gt; model.Name, new &#123; htmlAttributes = new &#123; @class = \"form-control\" &#125; &#125;) @Html.ValidationMessageFor(model =&gt; model.Name, \"\", new &#123; @class = \"text-danger\" &#125;) &lt;/div&gt; &lt;/div&gt; Html.ValidationMessageFor中显示errormessage，生成对应的html标签： 1&lt;input class=\"form-control text-box single-line\" data-val=\"true\" data-val-number=\"字段 Age 必须是一个数字。\" data-val-range=\"*0到130岁之间\" data-val-range-max=\"130\" data-val-range-min=\"0\" data-val-required=\"Age 字段是必需的。\" id=\"Age\" name=\"Age\" type=\"number\" value=\"\" /&gt; 是通过反射元数据实现对特性的校验，js中使用的jquery validate实现的校验，服务器端校验可以通过ModelState.IsValid进行校验 有关从数据库中取出的数据，进行的数据批注会在每次模型改变时模板类的重新生成时消失，可以通过往同一名字的类中添加元数据进行解耦，最后结果是一样的 模型改为parital 123456789namespace _61.Models&#123; public partial class UserInfo &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125;&#125; 通过MetadataType特性共享UserInfoValidate的元数据 12345678910111213141516namespace _61.Models&#123; [MetadataType(typeof(UserInfoValidate))] public partial class UserInfo &#123; &#125; public class UserInfoValidate &#123; [StringLength(10, ErrorMessage = \"*10个字符以内\")] public string Name &#123; get; set; &#125; [Range(0, 130, ErrorMessage = \"*0到130岁之间\")] public int Age &#123; get; set; &#125; &#125;&#125; 补充：程序集包含：IL，元数据，Resource，程序集清单 元数据： 元数据以非特定语言的方式描述在代码中定义的每一类型和成员。元数据存储以下信息： 程序集的说明。 标识（名称、版本、区域性、公钥）。 导出的类型。 该程序集所依赖的其他程序集。 运行所需的安全权限。 类型的说明。 名称、可见性、基类和实现的接口。 成员（方法、字段、属性、事件、嵌套的类型）。 属性。 Mvc Ajax控制器 12345678910public ActionResult Index() &#123; return View(); &#125; public string GetTime(string message) &#123; Thread.Sleep(1000); return $\"&#123;DateTime.Now.ToString()&#125;--&#123;message&#125;\"; &#125; view 12345678910111213141516171819202122232425262728@section scripts&#123; &lt;script src=\"~/Scripts/jquery.unobtrusive-ajax.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"#loading\").css(\"display\", \"none\"); &#125;); function SuccessGetTime() &#123; alert(\"success\"); &#125; &lt;/script&gt;&#125; @using (Ajax.BeginForm(\"GetTime\",new AjaxOptions()&#123; Confirm = \"确认提交？\", HttpMethod = \"Post\", LoadingElementId = \"loading\", OnSuccess = \"SuccessGetTime\", UpdateTargetId = \"result\"&#125;))&#123; &lt;input type=\"text\" name=\"message\"/&gt; &lt;input type=\"submit\" value=\"submit\"/&gt;&#125; &lt;div id=\"loading\"&gt;正在加载&lt;/div&gt;&lt;div id=\"result\"&gt;&lt;/div&gt; 添加引用包&lt;script src=&quot;~/Scripts/jquery.unobtrusive-ajax.min.js&quot;&gt;&lt;/script&gt; new AjaxOptions()对象 过滤器https://luox78.github.io/2018/02/28/filters/ 123456789101112131415161718192021222324252627public class MyActionFilterAttribute : ActionFilterAttribute &#123; public string Name &#123; get; set; &#125; public override void OnActionExecuting(ActionExecutingContext filterContext) &#123; base.OnActionExecuting(filterContext); filterContext.HttpContext.Response.Write(Name + \" &lt;h1&gt;before action&lt;/h1&gt;\"); &#125; public override void OnActionExecuted(ActionExecutedContext filterContext) &#123; base.OnActionExecuted(filterContext); filterContext.HttpContext.Response.Write(Name + \" &lt;h1&gt;after action&lt;/h1&gt;\"); &#125; public override void OnResultExecuting(ResultExecutingContext filterContext) &#123; base.OnResultExecuting(filterContext); filterContext.HttpContext.Response.Write(Name + \" &lt;h1&gt;before Result&lt;/h1&gt;\"); &#125; public override void OnResultExecuted(ResultExecutedContext filterContext) &#123; base.OnResultExecuted(filterContext); filterContext.HttpContext.Response.Write(Name + \" &lt;h1&gt;after Result&lt;/h1&gt;\"); &#125; &#125; Name用于区分是谁的过滤器 12345[MyActionFilter(Name = \"Action\")] public ActionResult Index() &#123; return View(); &#125; 页面顺序：Action：before action → after action → before Result → after Result 添加全局的过滤器 12345678910public class FilterConfig &#123; public static void RegisterGlobalFilters(GlobalFilterCollection filters) &#123; filters.Add(new HandleErrorAttribute()); //添加的全局过滤器 filters.Add(new MyActionFilterAttribute()); &#125; &#125; 添加整个控制器过滤器 12345678910111213141516[MyActionFilter(Name = \"Controller\")] public class AjaxController : Controller &#123; // GET: Ajax [MyActionFilter(Name = \"Action\")] public ActionResult Index() &#123; return View(); &#125; public string GetTime(string message) &#123; Thread.Sleep(1000); return $\"&#123;DateTime.Now.ToString(CultureInfo.InvariantCulture)&#125;--&#123;message&#125;\"; &#125; &#125; 此时生成仍然是action的过滤器，因为过滤器会默认最近原则，可以使用AttributeUsage特性改变特性属性 12[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]//target 选择所有，允许多个特性共同作用 public class MyActionFilterAttribute : ActionFilterAttribute&#123;。。。&#125; 此时html 全局 before action→ Controller before action→ Action before action → Action after action→ Controller after action→ 全局 after action→ 全局 before Result→ Controller before Result→ Action before Result→ Action after Result→ Controller after Result→ 全局 after Result","categories":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://luox78.github.io/categories/ASP-NET-MVC/"}],"tags":[{"name":"jQuery Validate","slug":"jQuery-Validate","permalink":"https://luox78.github.io/tags/jQuery-Validate/"},{"name":"Mvc校验","slug":"Mvc校验","permalink":"https://luox78.github.io/tags/Mvc校验/"},{"name":"AjaxHelper","slug":"AjaxHelper","permalink":"https://luox78.github.io/tags/AjaxHelper/"},{"name":"filters","slug":"filters","permalink":"https://luox78.github.io/tags/filters/"}]},{"title":"ASP.NET MVC02","slug":"ASP.NET-MVC02","date":"2018-03-03T04:27:51.340Z","updated":"2018-03-03T15:34:37.871Z","comments":true,"path":"2018/03/03/ASP.NET-MVC02/","link":"","permalink":"https://luox78.github.io/2018/03/03/ASP.NET-MVC02/","excerpt":"接上篇更新，删除可以先找出实体，然后直接更改属性保存即可，删除直接调用remove 1234567var db = new luox78_成绩管理系统Entities();var college = db.College.FirstOrDefault(m =&gt; m.Autoid == 1);//更新college.CollegeName = \"changed\";//删除db.College.Remove(college);db.SaveChanges(); 根据主键查询可以使用Find方法","text":"接上篇更新，删除可以先找出实体，然后直接更改属性保存即可，删除直接调用remove 1234567var db = new luox78_成绩管理系统Entities();var college = db.College.FirstOrDefault(m =&gt; m.Autoid == 1);//更新college.CollegeName = \"changed\";//删除db.College.Remove(college);db.SaveChanges(); 根据主键查询可以使用Find方法 1var college1 = db.College.Find(1, 0);//这里College表中有两个主键 code firsthttps://www.cnblogs.com/lsxqw2004/archive/2015/08/07/4701979.html 上下文管理：实例管理12345678910111213public static DbContext GetCurrentDbContext() &#123; //第一次： DbContext dbContext = HttpContext.Current.Items[\"DbContext\"] as DbContext; if (dbContext == null) &#123; dbContext =new DbContext(\"\"); HttpContext.Current.Items[\"DbContext\"] = dbContext; &#125; return dbContext; &#125; 利用HttpContext.Current.Items存入DbContext 为什么用EF而不用原生的Ado.Net1、极大的提高开发效率：EF是微软自己的产品，跟VS开发工具集成度比较好，开发中代码都是强类型的，写代码效率非常高，自动化程度非常高，命令式的编程。 2、EF提供的模型设计器非常强大，不仅仅带来了设计数据库的革命，也附带来的自动化生成模型代码的功能也极大的提高开发和架构设计的效率 3、EF跨数据支持是ORM框架主要功能点之一，带来的是可以通过仅仅改变配置就可以做到跨数据库的能力。 4、使开发人员远离sql脚本 5、缺陷：性能差（生成sql脚本阶段），在复杂查询的时候生成的sql脚本效率不是很高。 MVC控制器： https://luox78.github.io/2018/02/07/ASP.NET%20MVC%20%E6%8E%A7%E5%88%B6%E5%99%A8/ 视图： https://luox78.github.io/2018/02/13/ASP.NET-MVC-%E8%A7%86%E5%9B%BE/ 管道流程： ISAPIRuntime.ProcessRequest()创建HttpWorkerRequest对象 →HttpRuntime.ProcessRequest()创建HttpContext，包含HttpRequest，HttpResponse等 →HttpAppicationFactory获取HttpApplication（根据Gloable文件）→ASP.NET管道流程 有关Application_Start()： 12345678910public class MvcApplication : System.Web.HttpApplication &#123; public string Name &#123; get; set; &#125; protected void Application_Start() &#123; Name = \"luox78\"; 。。。。 &#125; &#125; 关于Name有可能拿的到有可能拿不到，原因：MvcApplication创建在IIS应用程序池，有缓存的时候会返回池里面第一个，没有则创建新的 HttpAppicationFactory获取HttpApplication（根据Global文件）： 初始化工厂：根据Global编译到ApplicationType 确保Application_Start被调用 创建HttpApplication，先去缓存栈中取没有new 拓展方法使用一个技巧： 1234567891011//通过更改命名空间实现所有的view均可以使用自己定义的htmlhelpernamespace System.Web.Mvc&#123; public static class MyHelperExt &#123; public static MvcHtmlString MyLabel(this HtmlHelper helper, string text) &#123; return MvcHtmlString.Create($\"&lt;span&gt;MyLabel:&#123;text&#125;&lt;/span&gt;\"); &#125; &#125;&#125;","categories":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://luox78.github.io/categories/ASP-NET-MVC/"}],"tags":[{"name":"entity framework","slug":"entity-framework","permalink":"https://luox78.github.io/tags/entity-framework/"}]},{"title":"ASP.NET MVC01","slug":"ASP.NET-MVC01","date":"2018-03-02T13:05:54.325Z","updated":"2018-03-02T16:03:40.743Z","comments":true,"path":"2018/03/02/ASP.NET-MVC01/","link":"","permalink":"https://luox78.github.io/2018/03/02/ASP.NET-MVC01/","excerpt":"Entity Framework前期准备 自动属性 var 对象、集合初始化器 匿名类 拓展方法 lambda表达式 介绍托管于非托管代码 C，c++编译 –》dll动态链接库 –》 二进制机器码，直接交给操作系统运行 C# 编译dll（程序集） –》 IL –》CLR 即时编译JIT –》 二进制机器码","text":"Entity Framework前期准备 自动属性 var 对象、集合初始化器 匿名类 拓展方法 lambda表达式 介绍托管于非托管代码 C，c++编译 –》dll动态链接库 –》 二进制机器码，直接交给操作系统运行 C# 编译dll（程序集） –》 IL –》CLR 即时编译JIT –》 二进制机器码 介绍EF ADO NET Entity Framework是以ADO NET为基础所发展出来的对象关系对应O/R Mapping（ORM）解决方案 什么是0 / R Mapping 广义上，ORM指的是面向对象的对象模型和关系型数据库的数据结构之间的相互转换。 狭义上，ORM可以被认为是，基于关系型数据厍的数据存储，实现一个虚拟的面向对象的数据访问接口。理想情况下，基于这样一个面向对象的接口，持久化一个00对象应该不需要要了解任何关系型数据库存储数据的实现细节。 O（object 面向对象的对象模型）M（mapping xml文件）R（related 关系表） database first添加新项–》数据–》ADO.NET实体数据模型–》生成操作数据库上下文对象，model.cs，designer设计器 12345678910111213141516171819public partial class GraduationProjectEntities : DbContext &#123; public GraduationProjectEntities() : base(\"name=GraduationProjectEntities\")//base app.config里面的连接字符串 &#123; &#125; //创建模型时的配置，这里database first不管 protected override void OnModelCreating(DbModelBuilder modelBuilder) &#123; throw new UnintentionalCodeFirstException(); &#125; //表对应的DbSet public virtual DbSet&lt;C__MigrationHistory&gt; C__MigrationHistory &#123; get; set; &#125; public virtual DbSet&lt;ImageIndexes&gt; ImageIndexes &#123; get; set; &#125; public virtual DbSet&lt;TreeIndexes&gt; TreeIndexes &#123; get; set; &#125; public virtual DbSet&lt;TreeDetail&gt; TreeDetail &#123; get; set; &#125; &#125; Context：上下文，entity framework所有有关数据库的操作都封装在此类中 访问表两种方式dbContext.TreeDetail或者dbContext.Set&lt;TreeDetail&gt;() 创建好的edmx文件以xml形式打开 12345&lt;!-- SSDL content --&gt;&lt;edmx:StorageModels&gt;。。&lt;/edmx:StorageModels&gt;//存储模型&lt;!-- CSDL content --&gt;&lt;edmx:ConceptualModels&gt;。。&lt;/edmx:ConceptualModels&gt;//抽象概念模型对应着实体也就是模型类&lt;!-- C-S mapping content --&gt;//mapping信息 EF增删改插入 123456789101112131415161718//创建访问数据库统一入口var dbContext = new Entities();//直接add添加记录dbContext.Set&lt;Person&gt;().Add(new Person&#123; Id = 10, Name = \"luox\", Age = 11&#125;);//等同于dbContext.Entry(new Person&#123; Id = 10, Name = \"luox\", Age = 11&#125;).State = System.Data.Entity.EntityState.Added;//保存所有有标记的实体到数据库dbContext.SaveChanges(); 更新 123456789101112var dbContext = new Entities();//先获取再更新//修改必须要有主键，否则会报错var person = new Person&#123; Id = 2, Name = \"luox78\", Age = 18&#125;;//entity framework会根据状态生成对应的sqldbContext.Entry(person).State = System.Data.Entity.EntityState.Modified;dbContext.SaveChanges(); 删除 123456789var dbContext = new Entities(); //删除只要有主键就行了 var person = new Person &#123; Id = 2, &#125;; //entity framework会根据状态生成对应的sql dbContext.Entry(person).State = System.Data.Entity.EntityState.Deleted; dbContext.SaveChanges(); dbContext.Entry(person).State = System.Data.Entity.EntityState.Deleted；标记原理： 在ef保存改变里面的最后几步里面会遍历所有标记为删除，插入，更新的实体，将他们都执行相应的sql 12345678910/// &lt;summary&gt;接受在对象上下文中对对象所做的所有更改。&lt;/summary&gt; public virtual void AcceptAllChanges() &#123; if (this.ObjectStateManager.SomeEntryWithConceptualNullExists()) throw new InvalidOperationException(Strings.ObjectContext_CommitWithConceptualNull); foreach (ObjectStateEntry objectStateEntry in this.ObjectStateManager.GetObjectStateEntries(EntityState.Deleted)) objectStateEntry.AcceptChanges(); foreach (ObjectStateEntry objectStateEntry in this.ObjectStateManager.GetObjectStateEntries(EntityState.Added | EntityState.Modified)) objectStateEntry.AcceptChanges(); &#125; 报错： 对一个或多个实体的校验失败：一般是插入的数据格式与期望格式不匹配 EF生成流程ef封装操作 –》 ADO.NET操作–》sql–》执行 查询 linq –》 生成expression–》执行ADO.NET操作–》sql–》执行 与ADO.NET性能差距主要在封装，但相对于非常快的代码执行，ef性能差距主要表现在expression生成的sql代码有时候会有很大性能问题 model first添加新项–》数据–》空ef设计器模型–》编辑设计器 另一个用于数据库设计的工具powerdesign 创建实体Person，PersonInfo，College，Subject 明确表之间对应关系：一对一，一对多，多对多 设计器里面添加三条关系，将Person与其他表联系起来：一个人一个信息，多个学院对应多个人，多个学科对应多个人 针对一对一，一对多关系很简单就是在表里面增加一条外键即可，但是多对多如何实现： 虽然设计器里面只是简单的用—-线连接了起来但是，生成的数据库中会增加一个两张表主键的对应关系的表，使用根据模型生成数据库，执行生成的sql（注意保存数据，表会被drop掉），可以看到存有两张表主键的对应关系的表 数据库变化了，可以在设计器中右键从数据库更新模型 包含外键的数据插入通过设置一个人对应多个学科可以看到Person.cs里面多了 1public virtual ICollection&lt;Subject&gt; Subject &#123; get; set; &#125; Subject集合 1234567891011121314151617var dbEntities = new luox78_成绩管理系统Entities(); Subject subject1=new Subject() &#123; SubjectName = \"math\" &#125;; Subject subject2 = new Subject() &#123; SubjectName = \"english\" &#125;; Person person=new Person() &#123; Name = \"luox78\" &#125;; person.Subject.Add(subject1); person.Subject.Add(subject2); dbEntities.PersonSet.Add(person); dbEntities.SaveChanges(); 插入有外键的数据共有2种方法： 通过entity里面的集合添加 将关联实体里面的外键属性set成对应的主键 Linq查询sql：select * （1）from Person（2） where name=“luox78”（3） 真正的执行顺序应该是231，linq里面一方面为了更符合操作，一方面为了能点出属性，先写from最后select 123var details = from d in dbContext.TreeDetail where d.pingtaiziyuanhao == \"11111111111\" select d; 基本上所有的类sql语句都可以转换成拓展方法的形式，等同于 1var details = dbContext.TreeDetail.Where(d =&gt; d.pingtaiziyuanhao == \"11111111111\"); IQueryable接口即linq实现机制上文说道linq查询，返回值类型，我用的var，实际上是IQueryable，转到定义 123456789101112131415161718[__DynamicallyInvokable] public interface IQueryable : IEnumerable &#123; /// &lt;summary&gt;获取与 &lt;see cref=\"T:System.Linq.IQueryable\" /&gt; 的实例关联的表达式目录树。&lt;/summary&gt; /// &lt;returns&gt;与 &lt;see cref=\"T:System.Linq.IQueryable\" /&gt; 的此实例关联的 &lt;see cref=\"T:System.Linq.Expressions.Expression\" /&gt;。&lt;/returns&gt; [__DynamicallyInvokable] Expression Expression &#123; [__DynamicallyInvokable] get; &#125; /// &lt;summary&gt;获取在执行与 &lt;see cref=\"T:System.Linq.IQueryable\" /&gt; 的此实例关联的表达式目录树时返回的元素的类型。&lt;/summary&gt; /// &lt;returns&gt;一个 &lt;see cref=\"T:System.Type\" /&gt;，表示在执行与之关联的表达式目录树时返回的元素的类型。&lt;/returns&gt; [__DynamicallyInvokable] Type ElementType &#123; [__DynamicallyInvokable] get; &#125; /// &lt;summary&gt;获取与此数据源关联的查询提供程序。&lt;/summary&gt; /// &lt;returns&gt;与此数据源关联的 &lt;see cref=\"T:System.Linq.IQueryProvider\" /&gt;。&lt;/returns&gt; [__DynamicallyInvokable] IQueryProvider Provider &#123; [__DynamicallyInvokable] get; &#125; &#125; Expression：为linq编译时生成的表达式 ElementType：Expression返回类型 Provider：获取与此数据源关联的查询提供程序（对应数据源的驱动方法），linq可以提供对不同的集合类型查询，就是Provider实现的 延迟加载对于像 var details = from d in dbContext.TreeDetail where d.pingtaiziyuanhao == &quot;11111111111&quot; select d; 的linq语句，只是在编译时将detail中的属性填充满，真正存在数据库中的数据此时并没有取出 只有在使用到details时，才会执行sql查询 情况一： 12345678var dbContext = new GraduationProjectEntities(); var detail = dbContext.TreeDetail.Take(100).OrderBy(t =&gt; t.pingtaiziyuanhao); //List&lt;TreeDetail&gt; list = detail.ToList(); foreach (var treeDetail in list) &#123; Console.WriteLine($\"&#123;treeDetail.ziyuanbianhao&#125;--&#123;treeDetail.zhongzhimingcheng&#125;\"); &#125; dbContext.SaveChanges(); 只有在foreach时才会查询 问题 12345678foreach (var treeDetail in list) &#123; Console.WriteLine($\"&#123;treeDetail.ziyuanbianhao&#125;--&#123;treeDetail.zhongzhimingcheng&#125;\"); &#125; foreach (var treeDetail in list) &#123; Console.WriteLine($\"&#123;treeDetail.ziyuanbianhao&#125;--&#123;treeDetail.zhongzhimingcheng&#125;\"); &#125; 两次foreach会执行两遍查询：将IQueryable集合转换成List集合List&lt;TreeDetail&gt; list = detail.ToList(); 集合类型：本地型集合（数据存储在内存中），离线型集合（IQueryable，数据并没有分配至内存） 所以讲IQueryable转换成list实际就已经取出数据至内存中了 分页1var detail = dbContext.TreeDetail.Take(100).OrderBy(t =&gt; t.pingtaiziyuanhao).Skip(100*(2-1)); ef帮我们实现了相应的sql编写，查看sql语句可以看到就是通过row_number()实现的分页sql 方法链的where，select顺序没有限制，因为最后会编译成相应表达式","categories":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://luox78.github.io/categories/ASP-NET-MVC/"}],"tags":[{"name":"entity framework","slug":"entity-framework","permalink":"https://luox78.github.io/tags/entity-framework/"},{"name":"entity framework designer","slug":"entity-framework-designer","permalink":"https://luox78.github.io/tags/entity-framework-designer/"},{"name":"database first","slug":"database-first","permalink":"https://luox78.github.io/tags/database-first/"},{"name":"model first","slug":"model-first","permalink":"https://luox78.github.io/tags/model-first/"},{"name":"linq to ef","slug":"linq-to-ef","permalink":"https://luox78.github.io/tags/linq-to-ef/"}]},{"title":"Asp.Net MVC学习总结之过滤器详解","slug":"filters","date":"2018-02-28T13:39:16.001Z","updated":"2018-02-28T13:41:54.509Z","comments":true,"path":"2018/02/28/filters/","link":"","permalink":"https://luox78.github.io/2018/02/28/filters/","excerpt":"一、过滤器简介 1.1、理解什么是过滤器 1、过滤器（Filters）就是向请求处理管道中注入额外的逻辑。提供了一个简单而优雅的方式来实现横切关注点。 2、所谓的过滤器（Filters），MVC框架里面的过滤器完全不同于ASP.NET平台里面的Request.Filters和Response.Filter对象，它们主要是实现请求和响应流的传输。通常我们所说的过滤器是指MVC框架里面的过滤器。 3、过滤器可以注入一些代码逻辑到请求处理管道中，是基于C#的Attribute的实现。当负责调用Action的类ControllerActionInvoker在调用执行Action的时候会检查Action上面的Attribute并查看这些Attribute是否实现了指定的接口，以便进行额外的代码注入处理","text":"一、过滤器简介 1.1、理解什么是过滤器 1、过滤器（Filters）就是向请求处理管道中注入额外的逻辑。提供了一个简单而优雅的方式来实现横切关注点。 2、所谓的过滤器（Filters），MVC框架里面的过滤器完全不同于ASP.NET平台里面的Request.Filters和Response.Filter对象，它们主要是实现请求和响应流的传输。通常我们所说的过滤器是指MVC框架里面的过滤器。 3、过滤器可以注入一些代码逻辑到请求处理管道中，是基于C#的Attribute的实现。当负责调用Action的类ControllerActionInvoker在调用执行Action的时候会检查Action上面的Attribute并查看这些Attribute是否实现了指定的接口，以便进行额外的代码注入处理 1.2、理解为什么要使用过滤器 假设你做了一个小项目，其中某个功能是操作管理用户信息模块，有这样一个需求，对用户信息管理必须是已通过认证的用户才能操作，我们可以在每一个Action方法里面检查认证请求，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using MvcFilterDmo.Core;using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.Mvc;using System.Web.Security;namespace MvcFilterDmo.Controllers&#123; public class HomeController : Controller &#123; public ActionResult Index() &#123; if (!Request.IsAuthenticated) &#123; FormsAuthentication.RedirectToLoginPage(); &#125; //操作部分... return View(); &#125; public ActionResult Insert() &#123; if (!Request.IsAuthenticated) &#123; FormsAuthentication.RedirectToLoginPage(); &#125; //操作部分... return View(); &#125; public ActionResult Update() &#123; if (!Request.IsAuthenticated) &#123; FormsAuthentication.RedirectToLoginPage(); &#125; //操作部分... return View(); &#125; public ActionResult Delete() &#123; if (!Request.IsAuthenticated) &#123; FormsAuthentication.RedirectToLoginPage(); &#125; //操作部分... return View(); &#125; //其他Action操作方法 //... &#125;&#125; 通过上面的代码，可以发现使用这种方式检查请求认证有许多重复的地方，这也就是为什么要使用过滤器的原因，使用过滤器可以实现相同的效果。如下所示： 12345678910111213141516171819202122232425262728293031323334353637using MvcFilterDmo.Core;using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.Mvc;using System.Web.Security;namespace MvcFilterDmo.Controllers&#123; [Authorize] public class HomeController : Controller &#123; public ActionResult Index() &#123; //操作部分... return View(); &#125; public ActionResult Insert() &#123; //操作部分... return View(); &#125; public ActionResult Edit() &#123; //操作部分... return View(); &#125; public ActionResult Delete() &#123; //操作部分... return View(); &#125; //其他Action操作方法 //... &#125;&#125; 过滤器是.NET里面的特性（Attributes），它提供了添加到请求处理管道的额外方法。这里使用Authorize过滤器可以实现同样的效果，不过代码就显然比之前更加简洁优雅。 二、过滤器的使用 2.1、基本类型的过滤器 过滤器实现的机制：在MVC框架调用一个Action之前，它会检查方法的定义中是否实现了特性（Attributes），如果实现的话，那么在请求处理管道适当的位置，该特性定义的方法会被调用。 ActionFilterAttribute类既实现了IactionFilter接口，也实现IResultFilter接口。这是一个抽象类，它要求你必须提供一个实现。AuthorizeAttribute和HandleErrorAttribute类，则包含了一些有用的特性，并且可以不必创建派生类进行使用。 2.2、过滤器的应用、应用方式以及执行顺序 应用： 过滤器可以被应用到控制器上也可以用到Action方法上，应用到控制上时，表示所有的Action方法都有了这个过滤器，并且可以混合使用，或多次使用，如下所示： 1234567891011[A] //表示所有的Action方法都会应用A过滤器Public class DemoController：Controller&#123; [B]//B,C过滤器只作用于此Action方法，但它也会有A过滤器的应用效果 [C] Public ActionResult Index() &#123; //操作部分... return View(); &#125; &#125; 应用方式：特性的方式，如上面代码所示。 执行顺序：相同类型过滤器，执行顺序靠近方法的先执行，不同类型的过滤器一般执行顺序为【authorize—&gt;action—&gt;actionResult】至于异常过滤器不分先后，只要抛出异常时就会执行异常过滤器。如果要调整执行顺序，可以通过调整Order方法值大小来控制执行顺序，值越小，越先执行。下图是Action/Result过滤器应用的执行顺序图 (1)、相同类型过滤器应用示例：两个自定义Action过滤器MyFirstFilter，MyThreeFilter应用到同一个Action方法Index上。 Three控制器代码如下： MyFirstFilter 代码如下： MyThreeFilter代码如下： 运行结果如下： (2)、不同类型过滤器应用示例：有一个自定义Action过滤器MyFirstFilter，有一个自定义Result过滤器MySecondFilter，应用到同一个Action方法Index上。 Three控制器代码如下： MyFirstFilter 代码如下： MySecondFilter代码如下： 运行结果如下： 看完上面的解释，可能你现在对这些过滤器的执行顺序，以及如何自定义过滤器还不明白，不要紧，下面我们会逐一介绍这几个基本的过滤器的使用，以及如何自定义过滤器。 2.3、使用授权过滤器 所有实现了IAuthorizationFilter接口的都可以称之为授权过滤器:其定义如下： 1234public interface IAuthorizationFilter &#123; void OnAuthorization(AuthorizationContext filterContext); &#125; 由于MVC框架系统自带的AuthorizeAttribute实现有一些突出的功能，而这种牵涉到安全的代码一定要谨慎的编写，所以一般我们不会直接实现这个接口，而是去继承AuthorizeAttribute这个类，并重写其AuthorizeCore方法，签名为： bool AuthorizeCore(HttpContextBase httpContext) 而处理授权失败的时候，可以重写其HandleUnauthorizedRequest方法，其签名为： void HandleUnauthorizedRequest(AuthorizationContext context) 。注意：验证与授权是两回事，验证发生在授权之前。 默认的授权过滤器已经有了验证的功能，其验证的机理是利用Asp.net平台自带的验证机制，如表单验证和Windows验证。除了验证功能，它本身还有授权的功能。授权过滤器是所有过滤器中最早运行的。 经过Route到达了控制器的时候，在调用Action之前，MVC框架会检测在相关的Action上是否有授权过滤器，如果有会调用OnAuthorization方法，如果此方法批准了请求，才会调用相应的Action。 使用授权过滤器几种情况如下： 1.直接在Action上或者控制器上加Authorize，表示启用了验证，但不牵涉到授权。 2.添加Authorize(Users=“a,b”)]，表示启用了验证，并且也启用了授权，只有a或者b用户能访问此控制器。 3.当添加Authorize（Roles=“admin,Member”)]时的步骤如下： —利用asp.net自带的角色提供者，或者实现自己的角色提供者，实现自己的角色提供者时，只需要集成RoleProvider类型，并实现其中的所有方法或部分方法，最好实现所有方法。 —在Web程序的根目录的Web.config文件中配置角色管理者。 —在适当的Action中利用Roles类型来访问自己创建的RoleProvider中的相关方法。 使用内置的授权过滤器 MVC框架内置的授权过滤器AuthorizeAttribute，它允许我们使用这个类的两个公共属性来指定授权策略，如下所示： Users和Roles两者是并且的关系，例如Users=“a,b,c”,Roles=“admin”,表示用户是a，b,c 其中一个并且是Admin角色才能访问。 创建自定义的授权过滤器 方式一：直接实现IAuthorizationFilter接口，但不推荐这样做，因为牵涉到安全方面的代码。 方式二：继承AuthorizeAttribute这个类，并重写其AuthorizeCore方法，签名为： bool AuthorizeCore(HttpContextBase httpContext)，代码如下所示： 1234567891011121314public class MyAuthorizeAttribute : AuthorizeAttribute &#123; private string[] allowedUsers; public MyAuthorizeAttribute(params string[] users) &#123; allowedUsers = new string[] &#123; \"admin\", \"user1\", \"xf\" &#125;; &#125; protected override bool AuthorizeCore(HttpContextBase httpContext) &#123; return httpContext.Request.IsAuthenticated &amp;&amp;allowedUsers.Contains(httpContext.User.Identity.Name, StringComparer.InvariantCultureIgnoreCase); &#125; &#125; 2.4、使用动作过滤器 动作过滤器是可以以用于任何目的的多用途过滤器，创建自定义动作过滤器需要实现IActionFilter接口，该接口代码如下所示： 该接口定义了两个方法，MVC框架在调用动作方法之前，会调用OnActionExecting方法。在调用动作方法之后，则会调用OnActionExecuted方法。 实现OnActionExecting方法 参数ActionExecutingContext对象继承于ControllerContext，其中的2个属性： ActionDescriptor：提供了关于Action方法的相关信息 Result：类型为ActionResult，通过给这个属性设置一个非null的值就可以取消这个请求。 我们可以用过滤器来取消一个请求，通过设置Result属性即可。代码如下所示： 1234567891011121314public class MyActionFilterAttribute : FilterAttribute, IActionFilter &#123; public void OnActionExecuting(ActionExecutingContext filterContext) &#123; if(filterContext.HttpContext.Request.IsLocal) &#123; filterContext.Result = new HttpNotFoundResult(); &#125; &#125; public void OnActionExecuted(ActionExecutedContext filterContext) &#123; //未做实现 &#125; &#125; 这个例子通过用OnActionExecuting方法检查请求是否来自本地机器，如果是，编队用户返回一个“404”未找到的响应。运行结果如下图： 实现OnActionExecuted方法 我们也可以通过OnActionExecuted方法来执行一些跨越动作方法的任务，下面这个例子是计算动作方法运行的时间，代码如下： 12345678910111213141516171819public class MyActionFilterAttribute : FilterAttribute, IActionFilter &#123; private Stopwatch timer; public void OnActionExecuting(ActionExecutingContext filterContext) &#123; timer = Stopwatch.StartNew(); &#125; public void OnActionExecuted(ActionExecutedContext filterContext) &#123; timer.Stop(); if (filterContext.Exception == null) &#123; filterContext.HttpContext.Response.Write( string.Format(\"动作方法延迟的时间: &#123;0&#125;\", timer.Elapsed.TotalSeconds)); &#125; &#125; &#125;&#125; 我们将自定义的动作过滤器MyActionFilter应用到HomeController的Index方法上，运行结果如下： 2.5、使用结果过滤器 结果过滤器是多用途的过滤器，他会对动作方法所产生结果进行操作，结果过滤器实现IResultFilter接口，创建自定义结果过滤器需要现IResultFilter接口，该接口代码如下所示： 当结果过滤器运用于一个动作方法时，会在动作方法返回动作结果之前，调用OnResultExecuting方法，在返回动作结果之后，会调用OnResultExecuted方法。下面这个例子是计算动作方法返回结果运行的时间，代码如下： 12345678910111213public class MyResultFilterAttribute : FilterAttribute, IResultFilter &#123; private Stopwatch timer; public void OnResultExecuting(ResultExecutingContext filterContext) &#123; timer = Stopwatch.StartNew(); &#125; public void OnResultExecuted(ResultExecutedContext filterContext) &#123; timer.Stop(); filterContext.HttpContext.Response.Write(string.Format(\"结果执行延迟时间: &#123;0&#125;\", timer.Elapsed.TotalSeconds)); &#125;&#125; 我们将自定义的结果过滤器MyResultFilter应用到HomeController的Index方法上，运行结果如下： 需要注意的是：动作过滤器是运行在页面输出之前，结果过滤器是运行在页面输出之后。 2.6、使用异常过滤器 异常过滤器只有在调用一个动作方法而抛出未处理的异常才会运行，这种异常来自以下位置： A、另一种过滤器（授权、动作、或结果过滤器）。 B、动作方法本身。 C、当动作结果被执行时。 使用内置的异常过滤器 HandleErrorAttribute(处理程序错误特性)，它是MVC内嵌的异常过滤器，有以下3个重要的属性： 1.ExceptionType：类型为Type，表示希望被此过滤器处理的异常类型，包括其子类型，默认值为System.Exception 2.View:类型为string，表示此过滤器呈递的视图页面，默认值为Error 3.Master：呈递的视图页的母板页，如果不指定，视图会用其默认的母版页 内嵌的HandleErrorException只有在配置文件Web.config中配置的CustomError 的mode设置为on的时候才生效（其默认模式为RemoteOnly）,如下图所示： 此过滤器还会给视图传递一个HandleErrorInfo类型的对象给视图，以便视图可以显示一些额外的关于错误的信息。下面是使用异常过滤器的示例。 应用到Index动作方法上： 在Views/Shared文件夹下添加一个显示异常信息的视图页SpecialError.cshtml,页面代码如下： 1234567891011121314151617@model HandleErrorInfo &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;SpecialError&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt; There was a&lt;b&gt;@Model.Exception.GetType().Name&lt;/b&gt; while rendering&lt;b&gt;@Model.ControllerName&lt;/b&gt;'s &lt;b&gt;@Model.ActionName&lt;/b&gt; action &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行结果如下： 创建自定义的异常过滤器 如果我们对异常过滤器有特殊的需求，可以通过自定义的异常过滤器来完成，创建自定义异常过滤器必须实现IExceptionFilter接口，该接口代码如下： 当一个未知处理异常发生时，OnException方法会被调用。该方法的传递一个ExceptionContext对象，派生于ControllerContext类，定义了一些额外的过滤器专有属性如下表所示： 抛出的异常通过Exception属性是可以访问的。通过把ExceptionHandled属性设置为true,一个异常过滤器可以报告它已经处理了该异常，应用于一个动作的所有异常过滤器都会被调用。 需要注意的是：如果一个动作方法的所有异常过滤器均为把ExceptionHandled属性设置为true，MVC框架将使用默认的ASP.NET异常处理程序。 Result属性有异常过滤器使用，以告诉MVC框架要做什么，异常过滤器的两个主要应用是记录该异常到日志，并把适当的消息显示给用户。下面的代码将演示通过创建一个自定义的异常过滤器，当一个特定的钟类的未处理异常出现时，把该用户重定向到一个指定的错误页面。 123456789101112public class MyExectionAttribute:FilterAttribute,IExceptionFilter &#123; public void OnException(ExceptionContext filterContext) &#123; if(!filterContext.ExceptionHandled&amp;&amp; filterContext.Exception is NullReferenceException) &#123; filterContext.Result = new RedirectResult(\"~/Content/SpecialErrorPage.html\"); filterContext.ExceptionHandled = true; &#125; &#125;&#125; 然后在项目根目录添加一个名为Content的文件夹，在该文件夹下创建SpeciErrorPage.html文件，当异常被处理时，将以这个错误页面显示个用户。该页面代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Sorry&lt;/h1&gt; &lt;p&gt;this is a Excetption test&lt;/p&gt; There was aNullReferenceException while renderingHome's Index action &lt;/body&gt;&lt;/html&gt; 在控制器中应用MyExection异常过滤器，并主动让其抛出一个空引用异常，以便测试。 12345678public class HomeController : Controller &#123; [MyExection] public ActionResult Index() &#123; throw new NullReferenceException(); &#125; &#125; 运行结果如下： 总结：本文章简单总结了对过滤器的理解以及如何使用MVC框架内置基本的过滤器和如何自定义过滤器及应用。","categories":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://luox78.github.io/categories/ASP-NET-MVC/"}],"tags":[{"name":"filters","slug":"filters","permalink":"https://luox78.github.io/tags/filters/"}]},{"title":"ASP.NET08","slug":"ASP.NET08","date":"2018-02-28T11:29:06.105Z","updated":"2018-02-28T13:46:35.690Z","comments":true,"path":"2018/02/28/ASP.NET08/","link":"","permalink":"https://luox78.github.io/2018/02/28/ASP.NET08/","excerpt":"配置错误页1234567891011&lt;customErrors mode=\"On\" defaultRedirect=\"~/test2/404.htm\"&gt; &lt;error statusCode=\"403\" redirect=\"NoAccess.htm\" /&gt; &lt;error statusCode=\"404\" redirect=\"FileNotFound.htm\" /&gt; &lt;/customErrors&gt;---------------------------在Application_Error中发生错误时转向另外一个页面------------------------protected void Application_Error(object sender, EventArgs e) &#123; string errorMsg = Context.Error.Message + Environment.NewLine + Context.Error.StackTrace + \"【\" + DateTime.Now.ToString() + \"】\" + Environment.NewLine + \"====================================================\" + Environment.NewLine; File.AppendAllText(Server.MapPath(\"~/log.txt\"), errorMsg); Response.Redirect(\"~/test2/404.htm\"); &#125; mvc中只能将静态页面放在根目录或者创建一个Error控制器","text":"配置错误页1234567891011&lt;customErrors mode=\"On\" defaultRedirect=\"~/test2/404.htm\"&gt; &lt;error statusCode=\"403\" redirect=\"NoAccess.htm\" /&gt; &lt;error statusCode=\"404\" redirect=\"FileNotFound.htm\" /&gt; &lt;/customErrors&gt;---------------------------在Application_Error中发生错误时转向另外一个页面------------------------protected void Application_Error(object sender, EventArgs e) &#123; string errorMsg = Context.Error.Message + Environment.NewLine + Context.Error.StackTrace + \"【\" + DateTime.Now.ToString() + \"】\" + Environment.NewLine + \"====================================================\" + Environment.NewLine; File.AppendAllText(Server.MapPath(\"~/log.txt\"), errorMsg); Response.Redirect(\"~/test2/404.htm\"); &#125; mvc中只能将静态页面放在根目录或者创建一个Error控制器 缓存https://luox78.github.io/2018/02/01/cache/ 分布式：一个业务分拆多个子业务，部署在不同的服务器上（redis缓存） 集群：同一个业务，部署在多个服务器上 创建缓存 Cache[“key”]=value; Cache.Insert(); 1public void Insert(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration, CacheItemPriority priority, CacheItemRemovedCallback onRemoveCallback); dependencies：缓存依赖，一旦依赖的东西改变缓存失效 absoluteExpiration：绝对过期时间 slidingExpiration：滑动过期时间（相对每次使用之后） priority：被移除优先级 onRemoveCallback：被移除回调函数 文件依赖例子 1234567891011121314151617181920public ActionResult Test4() &#123; if(HttpRuntime.Cache[\"Time\"] == null) &#123; string time = GetTime(); HttpRuntime.Cache.Insert(\"Time\", time,new CacheDependency(Server.MapPath(\"~/Views/Cache/Cache.txt\"))); return View(model:time); &#125; else &#123; return View(model:HttpRuntime.Cache[\"Time\"]); &#125; &#125; //模拟耗时请求 public string GetTime() &#123; System.Threading.Thread.Sleep(3000); return DateTime.Now.ToString(); &#125; 1HttpRuntime.Cache.Insert(\"Time\", DateTime.Now.ToString(), null, Cache.NoAbsoluteExpiration, TimeSpan.FromSeconds(10.0)); 使用Cache.NoAbsoluteExpiration跳过设置绝对时间 数据库依赖 数据库缓存依赖 -S服务器名称 -E集成身份验证 -ed启动 -d数据库名称 -et指定缓冲依赖的表名 -t表名在vs2010的命令提示符中运行（切换到aspnet_regsql.exe所在的目录）aspnet_regsql -S steve-pc -E -ed -d apsxDb -et -t TblComments 缓存依赖禁用该数据库aspnet_regsql -S steve-pc -E -dd -d apsxDb 依赖于数据库的web.config配置 123456789&lt;system.web&gt; &lt;caching&gt; &lt;sqlCacheDependency enabled=\"true\"&gt; &lt;databases&gt; &lt;add name=\"apsxDbEntityName\" connectionStringName=\"connStr\" pollTime=\"500\"/&gt; &lt;/databases&gt; &lt;/sqlCacheDependency&gt; &lt;/caching&gt; &lt;/system.web&gt; 12System.Web.Caching.SqlCacheDependency dep = new System.Web.Caching.SqlCacheDependency(\"apsxDbEntityName\", \"Aspx_Students\");//webconfig里面的配置名+表名Cache.Insert(\"list\", list, dep); 缓存使用场景第一个：访问量大，变化比较少 典型场景：京东菜单项变化比较少，访问又特别大 HttpModule创建一个实现了IHttpModule接口的类。在Init方法中为HttpAplication参数注册事件。在web.config中配置使用具体的HttpModule 123&lt;httpModules&gt; &lt;add name=\"m1\" type=\"Ajax.CRUD.UI.test2.TestModule,应用程序集的名称\"/&gt; &lt;/httpModules&gt; 123456789101112131415161718192021public class StopIP : IHttpModule &#123; public void Dispose() &#123; //throw new NotImplementedException(); &#125; public void Init(HttpApplication context) &#123; context.BeginRequest += new EventHandler(context_BeginRequest); &#125; void context_BeginRequest(object sender, EventArgs e) &#123; HttpApplication ha = sender as HttpApplication; if (ha.Request.UserHostAddress == \"192.168.1.100\") &#123; ha.Response.Redirect(\"~/EP1.htm\"); &#125; &#125; &#125;","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"cache","slug":"cache","permalink":"https://luox78.github.io/tags/cache/"},{"name":"错误页","slug":"错误页","permalink":"https://luox78.github.io/tags/错误页/"},{"name":"HttpModule","slug":"HttpModule","permalink":"https://luox78.github.io/tags/HttpModule/"}]},{"title":"ASP.NET07","slug":"ASP.NET07","date":"2018-02-27T11:28:27.526Z","updated":"2018-02-28T13:41:37.781Z","comments":true,"path":"2018/02/27/ASP.NET07/","link":"","permalink":"https://luox78.github.io/2018/02/27/ASP.NET07/","excerpt":"AJAX:”Asynchronous JavaScript and XML”中文意思：异步JavaScript和XML。指一种创建交互式网页应用的网页开发技术。","text":"AJAX:”Asynchronous JavaScript and XML”中文意思：异步JavaScript和XML。指一种创建交互式网页应用的网页开发技术。 XmlHttpRequest对象AJAX优点Ajax在本质上是一个浏览器端的技术Ajax技术之主要目的在于局部交换客户端及服务器间之数据这个技术的主角XMLHttpRequest 的最主要特点，在于能够不用重新载入整个版面来更新资料，也就是所谓的Refresh without Reload(轻刷新)与服务器之间的沟通，完全是透过Javascript 来实行使用XMLHttpRequest 本身传送的数据量很小，所以反应会更快，也就让网络程式更像一个桌面应用程序AJAX 就是运用Javascript 在后台悄悄帮你去跟服务器要资料，最后再由Javascript 或DOM 来帮你呈现结果，因为所有动作都是由Javascript 代劳，所以省去了网页重载的麻烦，使用者也感受不到等待的痛苦 异步请求基本步骤使用XMLHttpRequest对象 按照下面模式，可以同步地XMLHttpRequest对象： 创建对象； - new (叫助手过来)创建请求； - open (告诉他要去做的事情)发送请求； - send (去吧) readyState属性readyState属性指出了XMLHttpRequest对象在发送/接收数据过程中所处的几个状态。XMLHttpRequest对象会经历5种不同的状态。 0：未初始化。new完后;1：已打开。对象已经创建并初始化，但还未调用send方法2：已发送。已经调用send 方法，但该对象正在等待状态码和头的返回；3：正在接收。已经接收了部分数据，但还不能使用该对象的属性和方法，因为状态和响应头不完整；4：已加载。所有数据接收完毕 XMLHttpRequest对象属性一、onreadystatechange属性，设置回调函数。二、readyState属性，获取当前XMLHttpRequest对象执行的状态： 1&gt; 0表示以创建XMLHttpRequest对象，但是还没有初始化，即没有调用open()方法设置XMLHttpRequest对象。 2&gt;1表示创建了XMLHttpRequest对象，并且调用了open()方法进行初始化，但是还没有调用send()方法。 3&gt;3表示浏览器正在接受服务器的响应数据。 4&gt;所有数据已经被接受完毕。 三、status属性，服务器返回的http状态码。（&gt;=200 and &lt;300、304未修改，读取缓存。都表示成功）四、statusText属性，服务器返回的状态码对应的友好的文字说明，比如200对应的OK.五、responseText属性，以字符串方式获取服务器对客户端的响应。六、responseXml属性，当请求的是一个xml文件时，或者响应头中Content-Type为：text/xml或application/xml时，返回一个XmlDocument对象（Dom节点对象），支持标准的dom的成员，比如：childNodes、documentElement、firstChild、lastChild、nextSibling、nodeName、nodeType、nodeValue、parentNode、doctype等。 XMLHttpRequest对象常用方法一、open(“get”,”url”,true)初始化，如果第三个参数为false,则js等待请求完毕后才会继续执行。二、setRequestHeader(“”,””)增加http请求头信息。在open()之后，send()之前调用。三、send(null);发送请求。send()方法的参数表示为在请求报文体中发送的数据内容。为了最大化的浏览器兼容问题，如果没有请求报文体就传递null。get请求没有请求报文体，所以一般为null。使用post请求时才需要设置报文体。四、getResponseHeader(“Content-Type”),根据响应的报文头获得报文内容。五、getAllResponseHeaders();获取所有的响应报文头内容。六、abort();取消当前的http请求，取消之后如果要重新发起请求，建议重新创建一个XMLHttpRequest对象。 Ajax使用注意 xhr只能向同一个域中的相同端口号、相同协议的url发起请求，不能跨域,否则会引起错误。 为了浏览器兼容,get请求时最好为send()传递null参数。 在创建了xhr对象后立刻设置onreadystatechange事件，这样就能监视到所有的状态。如果不需要监视其他状态只监视readyState==4的状态则可以在send()之前设置。 get请求时，请求中的QueryString的参数名称与参数值最好使用encodeURIComponent()进行编码。否则在某些浏览器下无法获取该值，比如IE. post请求时，为了像表单那样提交数据需要设置请求的Content-Type为：application/x-www-form-urlencoded。send(“键=值&amp;键=值”) 解析json格式时eval(“(“+json+”)”)。但有安全性问题 演示cshtml： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@&#123; Layout = \"~/Views/Shared/_Layout.cshtml\";&#125;&lt;button id=\"btn1\"&gt;click(get)&lt;/button&gt;&lt;div id=\"dv1\"&gt;Time&lt;/div&gt;&lt;button id=\"btn2\"&gt;click(post)&lt;/button&gt;&lt;div id=\"dv2\"&gt;&lt;/div&gt;@section scripts&#123; &lt;script&gt; //Get document.getElementById(\"btn1\").onclick=function ()&#123; var xhr; if (XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHttp\"); &#125; xhr.open(\"get\",\"@Url.Action(\"GetTime\")\"); xhr.onreadystatechange=function () &#123; if(xhr.readyState == 4)&#123; document.getElementById(\"dv1\").innerText=xhr.responseText; &#125; &#125; xhr.send(); &#125; //Post document.getElementById(\"btn2\").onclick=function ()&#123; var xhr; if (XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHttp\"); &#125; xhr.open(\"post\", \"@Url.Action(\"GetName\")\"); //加头 xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.onreadystatechange=function () &#123; if(xhr.readyState == 4)&#123; document.getElementById(\"dv2\").innerText=xhr.responseText; &#125; &#125; //send里面发送数据 xhr.send(\"name=luox78\"); &#125; &lt;/script&gt;&#125; controller： 1234567891011121314//get public ActionResult AjaxTest() &#123; return View(); &#125; public string GetTime() &#123; return DateTime.Now.ToString(); &#125;[HttpPost] public string GetName(string name) &#123; return name; &#125; 基于AjaxHelper的AjaxMVC框架本身提供了AjaxHelper类用于Ajax异步请求，所以如果你想省事，就用这种方式吧~ AjaxHelper帮助器方法： Helper method Description Ajax.ActionLink Creates a hyperlink to a controller action that fires an Ajax request when clicked Ajax.RouteLink Similar to Ajax.ActionLink, but generates a link to a particular route instead of a named controller action Ajax.BeginForm Creates a form element that submits its data to a particular controller action using Ajax Ajax.BeginRouteForm Similar to Ajax.BeginForm, but creates a form that sub- mits its data to a particular route instead of a named control- ler action Ajax.GlobalizationScript Creates an HTML script element that references a script that contains culture information Ajax.JavaScriptStringEncode Encodes a string to make sure that it can safely be used inside JavaScript 上面的方法貌似很多，但是实际开发中用到的就两个帮助器方法而已： Ajax.ActionLink()和Ajax.BeginForm() 这里有个问题：怎样让项目知道我们用的是MVC自带的Ajax呢？ 导入jsA、在Web.config里边配置： 1&lt;add key=\"UnobtrusiveJavaScriptEnabled\" value=\"true\" /&gt; B、在页面中引用下面的js类库即可： 123@section scripts&#123; &lt;script type=\"text/javascript\" src=\" @Url.Content(\"~/Scripts/jquery.unobtrusive-ajax.js\")\"&gt;&lt;/script&gt;&#125; 一般更为常见的是在布局页/Views/Shared/_Layout.cshtml 中引入，例如： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;＠ViewBag.Title&lt;/title&gt; &lt;script src=\"~/Scripts/jquery-1.8.2.min.js\"&gt;&lt;/script&gt; &lt;script src=\"~/Scripts/jquery.unobtrusive-ajax.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; ＠RenderBody（）&lt;/body&gt;&lt;/html&gt; Ajax.ActionLink()： 向客户端输出一个链接地址，当单击这个链接时可以Ajax调用Controller中的方法，Ajax.ActionLink()方法有许多重载，下面是其重载之一： public static string ActionLink(this AjaxHelper ajaxHelper, string linkText, string actionName, object routeValues, AjaxOptions ajaxOptions); linkText：是显示在客户端的文本 actionName：是Action的名字，默认情况下我们会使用当前的Controller。 routeValues：将传入到Controller中方法的参数 ajaxOptions：配置Ajax的一些选项 Confirm 获取或设置提交请求之前，显示在确认窗口中的消息。 HttpMethod 获取或设置 HTTP 请求方法（“Get”或“Post”）。 InsertionMode 获取或设置指定如何将响应插入目标 DOM 元素的模式。 LoadingElementId 获取或设置加载 Ajax 函数时要显示的 HTML 元素的 id 特性。 OnBegin 获取或设置更新页面之前，恰好调用的 JavaScript 函数的名称。 OnComplete 获取或设置实例化响应数据之后但更新页面之前，要调用的 JavaScript 函数。 OnFailure 获取或设置页面更新失败时，要调用的 JavaScript 函数。 OnSuccess 获取或设置成功更新页面之后，要调用的 JavaScript 函数。 UpdateTargetId 获取或设置要使用服务器响应来更新的 DOM 元素的 ID。 Url 获取或设置要向其发送请求的 URL。 备注： OnComplete和OnSuccess的区别：OnComplete是获取了Http请求时引发的，此时页面还没有进行更新，OnSuccess是在页面已经更新后引发的。 当加载数据须要花较长时候，为了避免假死状况，该当给用户一个反馈信息，如“正在加载…”字样。在 MVC 的 Unobtrusive Ajax 中经用AjaxOptions选项的 LoadingElementId 和 LoadingElementDuration 两个属性可轻松做到这一点，例如下面的设置： 123456AjaxOptions ajaxOpts = new AjaxOptions &#123; UpdateTargetId = \"tableBody\"， Url = Url.Action（\"GetPeopleData\"）， LoadingElementId = \"loading\"， LoadingElementDuration = 1000， &#125;; 对于URL，如果我们设置如下： 1234AjaxOptions ajaxOpts = new AjaxOptions &#123; UpdateTargetId = \"tableBody\"， Url = Url.Action（\"GetPeopleData\"） &#125;; 然后查看它生成的 form 属性： 12&lt;form id=\"form0\" action=\"/People/GetPeople\" method=\"post\" data-ajax-url=\"/People/GetPeopleData\" data-ajax-=\"＃tableBody\" data-ajax-mode=\"replace\" data-ajax=\"true\"&gt; 它生成了两个 Url，分别为 action 属性 和 data-ajax-url 属性的值，前者是 Ajax.BeginForm（） 办法按照当前 controller 和 action 名称生成的，后者是 AjaxOptions 的 Url 属性生成的。当浏览器没有禁用 JavaScript 时，Unobtrusive Ajax JS库会获取 data-ajax-url 属性的值作为 Url 产生 ajax 恳求。当浏览器禁用了 JavaScript 时，天然 action 属性的值决定了默示提交的 Url，自然访问该页面。固然局部未能刷新，但不会让用户体验很差。 使用Html.ActionLink方法的一个栗子： 12@Ajax.ActionLink(\"点击我\", \"getEntry\", new &#123; id = item.Id &#125;, new AjaxOptions &#123; HttpMethod = \"Post\", UpdateTargetId = \"detailsID\", InsertionMode = InsertionMode.Replace &#125;) 说明：“点击我”是生产的超链接文字；“getEntry”是当前控制器的Action方法；id = item.Id是向Action方法传递的参数；HttpMethod = “Post”, 说明Ajax请求是post方式的；UpdateTargetId = “detailsID”说明了要更新的html块的Id标记元素；InsertionMode = InsertionMode.Replace说明是替换ID为detailsID的元素里边的内容。 实际应用：使用Ajax.ActionLink请求返回值为 Json格式的Controller方法 在Index.cshtml中使用ActionLink，如下： 12@Ajax.ActionLink(\"点击我\", \"JsonDetails\", new &#123; id = item.Id &#125;, new AjaxOptions &#123; HttpMethod = \"Post\", InsertionMode = InsertionMode.Replace, OnSuccess = \"Show\" &#125;) 相应的Controller： 12345public ActionResult JsonDetails(int id = 0) &#123; GuestbookEntry entry = _db.Entries.First(c =&gt; c.Id == id); return Json(entry, JsonRequestBehavior.AllowGet); &#125; 同时需要在Index.cshtml中添加请求成功的相应js函数Show，以便更新ID属性为detailsID的DIV内容： 12345&lt;script type=\"text/javascript\"&gt;function Show(data) &#123;$(\"#detailsID\").html(\"姓名：\" + data.Name + \" 消息：\" + data.Message);&#125;&lt;/script&gt; 使用Ajax.ActionLink 请求返回值为PartialView格式的Controller方法 在Index.cshtml中 12@Ajax.ActionLink(\"AjaxPartialView\", \"Details\", new &#123; id = item.Id &#125;, new AjaxOptions &#123; HttpMethod = \"Get\", UpdateTargetId = \"detailsID\" &#125;) 相应的Controller： 123456789public ActionResult Details(int id = 0) &#123; GuestbookEntry entry = _db.Entries.First(c =&gt; c.Id == id); if (Request.IsAjaxRequest()) &#123; return PartialView(entry); &#125; return View(entry); &#125; 在这里我们使用Request.IsAjaxRequest()来判断是否为Ajax请求，如果是则返回PartialView，否则返回View。最后，返回的内容会直接更新到ID属性为detailsID的DIV中。 Ajax.BeginForm 这个方法用于异步提交表单，比如一个新增信息的页面Create.cshtml，下面的代码会使表单以Ajax方式提交 1234567891011121314151617181920212223242526272829303132333435363738394041@model MvcApplication5.Models.GuestbookEntry&lt;script type=\"text/javascript\" src=\" @Url.Content(\"~/Scripts/jquery.unobtrusive-ajax.js\")\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; function success(data) &#123; alert(data); &#125;&lt;/script&gt;@&#123; ViewBag.Title = \"Create\";&#125;&lt;h2&gt;Create&lt;/h2&gt;@using (Ajax.BeginForm(new AjaxOptions &#123; HttpMethod=\"Post\", OnSuccess = \"success\"&#125;))&#123; @Html.ValidationSummary(true) &lt;fieldset&gt; &lt;legend&gt;GuestbookEntry&lt;/legend&gt; &lt;div class=\"editor-label\"&gt; @Html.LabelFor(model =&gt; model.Name) &lt;/div&gt; &lt;div class=\"editor-field\"&gt; @Html.EditorFor(model =&gt; model.Name) @Html.ValidationMessageFor(model =&gt; model.Name) &lt;/div&gt; &lt;div class=\"editor-label\"&gt; @Html.LabelFor(model =&gt; model.Message) &lt;/div&gt; &lt;div class=\"editor-field\"&gt; @Html.EditorFor(model =&gt; model.Message) @Html.ValidationMessageFor(model =&gt; model.Message) &lt;/div&gt; &lt;p&gt; &lt;input type=\"submit\" value=\"Create\" /&gt; &lt;/p&gt; &lt;/fieldset&gt;&#125; 控制器的代码如下： 1234567891011121314[HttpPost]public ActionResult Create(GuestbookEntry entry)&#123; if (ModelState.IsValid) &#123; entry.DateAdded = DateTime.Now; _db.Entries.Add(entry); _db.SaveChanges(); return Content(\"New Entry successfully added.\"); &#125; else &#123; return View(); &#125;&#125; 注： 貌似上面的Ajax方法很方便，但是它的工作原理可能大家不是很清楚，这里就大概说一下吧~ 当调用 Ajax.BeginForm 方法后，经由选项 AjaxOptions 对象设置的属性将会被转化成 form 表单的属性，这些属性以 data-ajax 开首，如本示例生成的 form 表单： 1&lt;form action=\"/GuestBook/Create\" data-ajax=\"true\" data-ajax-mode=\"replace\" data-ajax-=\"＃tableBody\" id=\"form0\" method=\"post\"&gt; 当 Create.cshtml 视图加载完成并浮现 Html 页面时，jquery.unobtrusive-ajax.js 库会寻找所有 data-ajax == true的元素，然后按照其它以 data-ajax 开头的属性值，jQuery 库中的函数将知道如何去执行 Ajax 请求。 基于JQuery的Ajax使用JQuery的Ajax请求返回值为 Json格式的Controller方法 原理就是用JQuery的Ajax方法请求Action方法，返回值设为JSON，然后对JSON数据进行处理，例如用js函数进行处理 举个栗子： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script type=\"text/javascript\" language=\"javascript\"&gt; $(function()&#123; GetRoomInfoList(); &#125;); function GetRoomInfoList() &#123; showDivLoading();//异步加载数据时的浮层 $.ajax(&#123; type: \"Post\", url: \"@Url.Content(\"~/Room/GetRoomInfoShipId\")\",//异步请求的URL,就是Room控制器方法GetRoomInfoShipId（long shipId） dataType: \"json\",//要求返回数据为JSON格式 data:&#123;shipId:$(\"#ShipIdForSearch\").val()&#125;,//异步请求的参数 success: function(data)&#123; $(\"#RoomInfoListTable\").empty(); //清空里面的所有内容 $.each(data, function(i, item)&#123; //用js拼字符串处理数据，这里是显示所有房型列表信息 var str=\"&lt;tr&gt;\"; str+=\" &lt;td&gt;\"; str+=\" &lt;span style=\\\" width:150px;display:block;white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\\\"&gt;\"; str+=item.BaseRoomId; str+=\" &lt;/span&gt;\" str+=\" &lt;/td&gt;\"; str+=\" &lt;td&gt;\"; str+=\" &lt;span style=\\\" width:150px;display:block;white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\\\"&gt;\"; str+=item.ShipId; str+=\" &lt;/span&gt;\" str+=\" &lt;/td&gt;\"; str+=\" &lt;td&gt;\"; str+=\" &lt;span style=\\\" width:150px;display:block;white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\\\"&gt;\"; str+=item.RoomType; str+=\" &lt;/span&gt;\" str+=\" &lt;/td&gt;\"; str+=\" &lt;td&gt;\"; str+=\" &lt;span style=\\\" width:150px;display:block;white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\\\"&gt;\"; str+=item.RoomName; str+=\" &lt;/span&gt;\" str+=\" &lt;/td&gt;\"; str+=\"&lt;/tr&gt;\"; $(\"#RoomInfoListTable\").append(str); &#125;); &#125; &#125;); &#125; 使用JQuery的Ajax 请求返回值为PartialView格式的Controller方法 假设有这样的一个Model: 12345678namespace MvcApplication1.Models&#123; public class Team &#123; public string Preletter &#123; get; set; &#125; public string Name &#123; get; set; &#125; &#125;&#125; 通过JQuery异步加载分部视图，Home/Index.cshtml： 123456789101112131415161718192021222324252627282930313233@&#123; ViewBag.Title = \"Index\"; Layout = \"~/Views/Shared/_Layout.cshtml\";&#125;&lt;h2&gt;Index&lt;/h2&gt;&lt;div&gt;&lt;a href=\"#\" id=\"a\"&gt;通过jQuery异步&lt;/a&gt; &lt;br/&gt;&lt;/div&gt;&lt;div id=\"result\"&gt;&lt;/div&gt;@section scripts&#123; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('#a').click(function() &#123; $.ajax(&#123; url: '@Url.Action(\"Index\",\"Home\")', data: &#123; pre: 'B' &#125;, type: 'POST', success: function(data) &#123; $('#result').empty().append(data); &#125; &#125;); return false; &#125;); &#125;); &lt;/script&gt;&#125; HomeController控制器中： 12345678910111213141516171819202122232425262728293031using System.Collections.Generic;using System.Linq;using System.Web.Mvc;using MvcApplication1.Models;namespace MvcApplication1.Controllers&#123; public class HomeController : Controller &#123; public ActionResult Index() &#123; return View(); &#125; [HttpPost] public ActionResult Index(string pre) &#123; var result = GetAllTeams().Where(t =&gt; t.Preletter == pre).ToList(); ViewBag.msg = \"通过jQuery异步方式到达这里~~\"; return PartialView(\"TeamY\", result); &#125; private List&lt;Team&gt; GetAllTeams() &#123; return new List&lt;Team&gt;() &#123; new Team()&#123;Name = \"巴西队\", Preletter = \"B\"&#125;, new Team()&#123;Name = \"克罗地亚队\", Preletter = \"K\"&#125;, new Team()&#123;Name = \"巴拉圭\", Preletter = \"B\"&#125;, new Team()&#123;Name = \"韩国\", Preletter = \"K\"&#125; &#125;; &#125; &#125;&#125; 分部视图TeamY.cshtml： 1234567891011@model IEnumerable&lt;MvcApplication1.Models.Team&gt; @&#123; var result = string.Empty; foreach (var item in Model) &#123; result += item.Name + \",\"; &#125;&#125;@ViewBag.msg.ToString()&lt;br/&gt;@result.Substring(0,result.Length - 1) 3、基于JQuery的表单异步提交 举个栗子吧： 12345678910111213141516&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; $(\"#form1\").submit(function (event) &#123; event.preventDefault();//阻止默认提交事件，改用JS处理提交事件 $.ajax(&#123; type:\"Post//表单提交类型 url: \"@Url.Content(\"~/User/Create\")\",//表单提交的Action方法 data:$(\"#form1\").serialize(), //序列化表单的值为字符串，前提是表单里边的输入标签都要有name属性才可以，序列化后的形式大概是这样的：a=1&amp;b=2&amp;c=3&amp;d=4&amp;e=5 success:function(msg)&#123; $(\"#result\").html(msg); &#125; &#125;); return false; &#125;); &#125;);&lt;/script&gt; 但是我觉得如果表单提交的数据少的话，可以用这种，如果多的话，就没有必要了，用MVC自带的更好 如何提高Ajax性能1、适当使用缓存机制 2、使用CDN内容分发来访问Jquery脚本： ​ （1）自己公司架设CDN服务器 ​ （2）使用第三方公司的，比如微软，谷歌等公司的CDN，但有时候不太靠谱 3、JS/CSS文件的打包合并（Bundling）及压缩（Minification） 将多个JS或CSS文件打包合并成一个文件，并在网站发布之后进行压缩，从而减少HTTP请求次数，提高网络加载速度和页面解析速度。压缩功能实现了对javascript脚本和CSS进行压缩的功能，它能够去除脚本或样式中不必要的空白和注释，同时能够优化脚本变量名的长度 例如在BundleConfig.cs里面配置捆绑js和css文件： 1234567891011121314151617using System.Web;using System.Web.Optimization;namespace MvcExample&#123; public class BundleConfig &#123; // For more information on Bundling, visit http://go.microsoft.com/fwlink/?LinkId=254725 public static void RegisterBundles(BundleCollection bundles) &#123; bundles.Add(new ScriptBundle(\"~/bundles/jquery\").Include( \"~/Scripts/jquery-&#123;version&#125;.js\")); bundles.Add(new StyleBundle(\"~/Content/css\").Include(\"~/Content/site.css\")); &#125; &#125;&#125; 记得在Global.asax中注册一下： 1BundleConfig.RegisterBundles(BundleTable.Bundles); 页面引用时可以这样引用: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;@ViewBag.Title&lt;/title&gt; @Styles.Render(\"~/Content/css\") @Scripts.Render(\"~/bundles/jquery\") @RenderSection(\"scripts\", required: false)&lt;/head&gt;&lt;body&gt; @RenderBody()&lt;/body&gt;&lt;/html&gt; 启用JS/CSS文件压缩合并： Web.config中配置 1&lt;compilation debug=\"false\" targetFramework=\"4.0\" /&gt; 在BundleConfig.cs或Global.asax中添加以下代码即可： 1BundleTable.EnableOptimizations = true; 4、最好将js脚本文件放在view页面下面一点 关于ASP.NET MVC和Ajax的故事，暂且讲到这里吧！","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"AjaxHelper","slug":"AjaxHelper","permalink":"https://luox78.github.io/tags/AjaxHelper/"},{"name":"Ajax","slug":"Ajax","permalink":"https://luox78.github.io/tags/Ajax/"}]},{"title":"【HTTP】HTTPS 原理详解","slug":"【HTTP】HTTPS 原理详解","date":"2018-02-26T14:34:46.893Z","updated":"2018-02-26T14:42:11.925Z","comments":true,"path":"2018/02/26/【HTTP】HTTPS 原理详解/","link":"","permalink":"https://luox78.github.io/2018/02/26/【HTTP】HTTPS 原理详解/","excerpt":"前言 HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer），其实 HTTPS 并不是一个新鲜协议，Google 很早就开始启用了，初衷是为了保证数据安全。 近两年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。","text":"前言 HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer），其实 HTTPS 并不是一个新鲜协议，Google 很早就开始启用了，初衷是为了保证数据安全。 近两年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。 为鼓励全球网站的 HTTPS 实现，一些互联网公司都提出了自己的要求： 1）Google 已调整搜索引擎算法，让采用 HTTPS 的网站在搜索中排名更靠前； 2）从 2017 年开始，Chrome 浏览器已把采用 HTTP 协议的网站标记为不安全网站； 3）苹果要求 2017 年App Store 中的所有应用都必须使用 HTTPS 加密连接； 4）当前国内炒的很火热的微信小程序也要求必须使用 HTTPS 协议； 5）新一代的 HTTP/2 协议的支持需以 HTTPS 为基础。 等等，因此想必在不久的将来，全网 HTTPS 势在必行。 概念 协议 1、HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。 2、HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。 如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。 TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。 加密算法： 据记载，公元前400年，古希腊人就发明了置换密码；在第二次世界大战期间，德国军方启用了“恩尼格玛”密码机，所以密码学在社会发展中有着广泛的用途。 1、对称加密 有流式、分组两种，加密和解密都是使用的同一个密钥。 例如：DES、AES-GCM、ChaCha20-Poly1305等 2、非对称加密 加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、 DH、ECDHE 3、哈希算法 将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 4、数字签名 签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 详解 一、HTTP访问过程 抓包如下： 如上图所示，HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下： 可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”，现象如下： 下面两图中，浏览器中填入的是相同的URL，左边是正确响应，而右边则是被劫持后的响应 所以 HTTP 传输面临的风险有： （1） 窃听风险：黑客可以获知通信内容。 （2） 篡改风险：黑客可以修改通信内容。 （3） 冒充风险：黑客可以冒充他人身份参与通信。 二、HTTP 向 HTTPS 演化的过程 第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解） 如上图所示，此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是： （1）不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高 （2）因每个客户端、服务器的安全级别不同，密钥极易泄露 第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试 如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点： （1）公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容 第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势 如上图所示 （1）第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器 （2）服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密 （3）后续两者之间信息的传输就可以使用对称加密的方式了 遇到的问题： （1）客户端如何获得公钥 （2）如何确认服务器是真实的而不是黑客 第四步：获取公钥与确认服务器身份 1、获取公钥 （1）提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦） （2）回话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥） 2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书（申购） 如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有： （1）证书的发布机构CA （2）证书的有效期 （3）公钥 （4）证书所有者 （5）签名 ……… 3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下： （1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验 （2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 （3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。 （4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密 （5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比 （6）对比结果一致，则证明服务器发来的证书合法，没有被冒充 （7）此时浏览器就可以读取证书中的公钥，用于后续加密了 4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成 所以相比HTTP，HTTPS 传输更加安全 （1） 所有信息都是加密传播，黑客无法窃听。 （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。 （3） 配备身份证书，防止身份被冒充。 总结 综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。 HTTPS 缺点： （1）SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐 （2）HTTPS 降低用户访问速度（多次握手） （3）网站改用HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用302跳转） （4）HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https访问过程需要加解密）","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"https","slug":"https","permalink":"https://luox78.github.io/tags/https/"}]},{"title":"ASP.NET MVC 视图","slug":"ASP.NET-MVC-视图","date":"2018-02-13T13:55:17.368Z","updated":"2018-03-03T15:12:31.128Z","comments":true,"path":"2018/02/13/ASP.NET-MVC-视图/","link":"","permalink":"https://luox78.github.io/2018/02/13/ASP.NET-MVC-视图/","excerpt":"设计并非外观怎样，感觉如何。设计是（解决）如何工作的问题 –Steve Jobs 视图引擎的结构与性能视图引擎是位浏览器生成html输出的组件 控制器—数据—&gt;视图模板—–&gt;html 视图引擎机制在asp.net mvc中，视图引擎只是一个实现固定接口（IViewEngine）的类。","text":"设计并非外观怎样，感觉如何。设计是（解决）如何工作的问题 –Steve Jobs 视图引擎的结构与性能视图引擎是位浏览器生成html输出的组件 控制器—数据—&gt;视图模板—–&gt;html 视图引擎机制在asp.net mvc中，视图引擎只是一个实现固定接口（IViewEngine）的类。 每个应用程序可以有一个或多个视图引擎。asp.net mvc5中默认两个Razor，Aspx 视图引擎类（检测已注册的试图引擎）ViewEngines类跟踪当前已安装的引擎的系统资源库 1234567891011121314151617181920212223242526namespace System.Web.Mvc&#123; /// &lt;summary&gt;表示对应用程序可用的视图引擎的集合。&lt;/summary&gt; public static class ViewEngines &#123; private static readonly ViewEngineCollection _engines; /// &lt;summary&gt;获取视图引擎。&lt;/summary&gt; /// &lt;returns&gt;视图引擎。&lt;/returns&gt; public static ViewEngineCollection Engines &#123; get &#123; return ViewEngines._engines; &#125; &#125; static ViewEngines() &#123; ViewEngineCollection engineCollection = new ViewEngineCollection(); engineCollection.Add((IViewEngine) new WebFormViewEngine()); engineCollection.Add((IViewEngine) new RazorViewEngine()); ViewEngines._engines = engineCollection; &#125; &#125;&#125; 引擎集合_engines中初始化两个默认视图引擎 解析视图引擎视图引擎是实现IViewEngine接口的类，引擎会以架构的名义检索视图对象（实际响应的所需所有信息的容器） 1234567891011121314151617181920212223/// &lt;summary&gt;定义视图引擎所需的方法。&lt;/summary&gt; public interface IViewEngine &#123; /// &lt;summary&gt;使用指定的控制器上下文来查找指定的部分视图。&lt;/summary&gt; /// &lt;returns&gt;部分视图。&lt;/returns&gt; /// &lt;param name=\"controllerContext\"&gt;控制器上下文。&lt;/param&gt; /// &lt;param name=\"partialViewName\"&gt;部分视图的名称。&lt;/param&gt; /// &lt;param name=\"useCache\"&gt;若指定视图引擎返回缓存的视图（如果存在缓存的视图），则为 true；否则为 false。&lt;/param&gt; ViewEngineResult FindPartialView(ControllerContext controllerContext, string partialViewName, bool useCache); /// &lt;summary&gt;使用指定的控制器上下文来查找指定的视图。&lt;/summary&gt; /// &lt;returns&gt;页视图。&lt;/returns&gt; /// &lt;param name=\"controllerContext\"&gt;控制器上下文。&lt;/param&gt; /// &lt;param name=\"viewName\"&gt;视图的名称。&lt;/param&gt; /// &lt;param name=\"masterName\"&gt;母版的名称。&lt;/param&gt; /// &lt;param name=\"useCache\"&gt;若指定视图引擎返回缓存的视图（如果存在缓存的视图），则为 true；否则为 false。&lt;/param&gt; ViewEngineResult FindView(ControllerContext controllerContext, string viewName, string masterName, bool useCache); /// &lt;summary&gt;使用指定的控制器上下文来释放指定的视图。&lt;/summary&gt; /// &lt;param name=\"controllerContext\"&gt;控制器上下文。&lt;/param&gt; /// &lt;param name=\"view\"&gt;视图。&lt;/param&gt; void ReleaseView(ControllerContext controllerContext, IView view); &#125; 视图引擎findview返回的ViewEngineResult包含三个元素：视图对象，对应的视图引擎，视图模板位置列表 12345678910111213141516public class ViewEngineResult &#123; 。。。 /// &lt;summary&gt;获取或设置搜索的位置。&lt;/summary&gt; /// &lt;returns&gt;搜索的位置。&lt;/returns&gt; public IEnumerable&lt;string&gt; SearchedLocations &#123; get; private set; &#125; /// &lt;summary&gt;获取或设置视图。&lt;/summary&gt; /// &lt;returns&gt;视图。&lt;/returns&gt; public IView View &#123; get; private set; &#125; /// &lt;summary&gt;获取或设置视图引擎。&lt;/summary&gt; /// &lt;returns&gt;视图引擎。&lt;/returns&gt; public IViewEngine ViewEngine &#123; get; private set; &#125; &#125; 视图引擎调用者是谁controller与viewengine一起工作明显是由mvc框架实现的，更细一步，控制器和视图引擎的活动是由一个外部管理器对象（操作调用程序）进行协调的。 操作调用程序由负责处理HTTP处理程序直接触发。 操作调用程序主要做两件事：1. 执行控制器的方法并保存操作结果 2. 处理操作结果。 12345678910ViewResult:ViewResultBasepublic ViewResult();public string MasterName &#123; get; set; &#125;protected override ViewEngineResult FindView(ControllerContext context);ViewResultBase:ActionResultprotected abstract ViewEngineResult FindView(ControllerContext context);public override void ExecuteResult(ControllerContext context); 操作调用程序调用ExecuteResult 1234567891011public override void ExecuteResult(ControllerContext context)&#123; 。。。 ViewEngineResult result = null; if (this.View == null) &#123; result = this.FindView(context); this.View = result.View; &#125; 。。。&#125; ExecuteResult会调用FindView 1234567891011121314protected override ViewEngineResult FindView(ControllerContext context)&#123; ViewEngineResult result = base.ViewEngineCollection.FindView(context, base.ViewName, this.MasterName); if (result.View != null) &#123; return result; &#125; StringBuilder builder = new StringBuilder(); foreach (string str in result.SearchedLocations) &#123; builder.AppendLine(); builder.Append(str); &#125; throw new InvalidOperationException(string.Format(CultureInfo.CurrentCulture, MvcResources.Common_ViewNotFound, new object[] &#123; base.ViewName, builder &#125;));&#125; FindView此时会调用ViewEngine里面的方法，遍历模板列表，没有抛出包含所有列表的信息的异常 ExecuteResult调用完FindView，执行this.View.Render(viewContext, output);将结果输出到响应流，这里viewContext中= new ViewContext(context, this.View, this.ViewData, this.TempData, output);包含了传入view里面的viewdata，同时强类型模型也是通过viewdata传入的 1234567public TModel Model &#123; get &#123; return this.ViewData.Model; &#125; &#125; 1234567891011121314151617181920212223242526272829public override void ExecuteResult(ControllerContext context)&#123; //判断 if (context == null) &#123; throw new ArgumentNullException(\"context\"); &#125; if (string.IsNullOrEmpty(this.ViewName)) &#123; this.ViewName = context.RouteData.GetRequiredString(\"action\"); &#125; //找视图 ViewEngineResult result = null; if (this.View == null) &#123; result = this.FindView(context); this.View = result.View; &#125; //输出 TextWriter output = context.HttpContext.Response.Output; ViewContext viewContext = new ViewContext(context, this.View, this.ViewData, this.TempData, output); this.View.Render(viewContext, output); if (result != null) &#123; result.ViewEngine.ReleaseView(context, this.View); &#125;&#125; 视图对象Viewpublic IView View { get; [CompilerGenerated] private set; } 视图对象是实现IView接口的实例，视图对象的唯一目的是编写一些HTML响应到文本编辑器 视图模板定义模板解析在任务处理结束时，控制器要找出呈现给用户的下一个视图的名称。但视图名称转换成对应的HTML还需要一些额外的步骤 1。确定使用哪个视图引擎可以成功处理该视图的请求 2。视图名称必须匹配到一个html布局，并基于该布局创建一个试图对象 3。从获取视图名称开始，ViewResult对象就会按照视图引擎出现在ViewEngines.Engines集合中顺序，对所有已经安装的视图引擎进行插叙 默认规则和文件夹默认情况下系统会在View文件夹下找，controller名对应的文件夹下action对应的后缀为cshtml、vbhtml的文件（Razor） 用于视图的模板aspx视图引擎与webform中aspx页面语法基本一致，最大的不同在于，mvc中aspx并不是公共资源，不通i过特殊设置不能直接访问，所有的请求都是有controller接受和回复，对应的aspx页面只不过是回复的模板 123456public ActionResult About()&#123; ViewBag.Message = \"Your application description page.\"; return View();&#125; About.cshtml，这里通过viewbag传递的值 1234567@&#123; ViewBag.Title = \"About\";&#125;&lt;h2&gt;@ViewBag.Title.&lt;/h2&gt;&lt;h3&gt;@ViewBag.Message&lt;/h3&gt; &lt;p&gt;Use this area to provide additional information.&lt;/p&gt; 母版视图 在 cshtml中直接指定 1234@&#123; Layout = \"Index.cshtml\"; ViewBag.Title = \"About\";&#125; 默认的layout在_ViewStart.cshtml中指定 HTML帮助器asp.net mvc中创建html视图使用的不是webform中的空间而是HTML帮助器。 HTML帮助器就是一个简单的HTML工厂，返回的是没mvchtmlstring，内部实现也是使用stringbuilder进行拼接，视图引擎解析 基础帮助器BeginForm,BeginRouteForm EndForm CheckBox,CheckBoxFor Hidden,HiddenFor Password,PasswordFor…. 用法是@Html.ActionLink(...) BeginForm,BeginRouteForm区别是带Route可以导航到任何已注册路由的任何位置，BeginForm只能使用控制器，action等属性 CheckBox,CheckBoxFor区别：带For参数只接受lamada表达式 注意：HTML帮助器是视图引擎的内置属性，所以不同的视图引擎帮助器是不同的，尽管默认的两个细节都是差不多的，但内部还是有些不同的 下面举一些例子 呈现HTML表单1234@using (Html.BeginForm(\"Index\", \"Home\"))&#123; &#125; BeginForm代表《form》，using中finally会添加《/form》，BeginForm当然还有很多重载 呈现输入元素再次说明，从功能的角度使用帮助器和直接编写HTML是一样的效果，下面的事例是复选框选中同时禁用 1@Html.CheckBox(\"wode\", true, htmlAttributes: new &#123; disabled = \"disabled\" &#125;) 操作链接1@Html.ActionLink(\"index\",\"Index\") 对应的html 1&lt;a href=\"/\"&gt;index&lt;/a&gt; RouteLink帮助器的工作方式差不多相同，可以使用任何已经注册的路由名称来确定生成的URL模式 1@Html.RouteLink(\"index\", \"Default\", new &#123; Controller = \"Home\", Action = \"Index\" &#125;) 如果想在a标签下嵌套其他标签，这时候可以使用UrlHelper来解决 123&lt;a href=\"@Url.Action(\"Index\")\"&gt; //添加其他标签&lt;/a&gt; 部分视图可以使用Partial和RenderPartial帮助器插入部分视图看。区别是，Partial返回的是字符串，RenderPartial会写入输出流，返回空，所以两者的用法略有不同 12@Html.Partial(\"_PartialForTest\")@&#123; Html.RenderPartial(\"_PartialForTest\");&#125; HtmlHelper其他的原生方法 AntiForgeryToken：创建一个包含口令的隐藏域，Post、Get到controller时添加[ValidateAntiForgeryToken]特性验证 Raw：返回未经编码的原始Html字符串 AttributeEncode：这个方法在效率上比HtmlEncode快很多。但这是有代价的付出的HtmlAttributeEncode只对 左引号（“），左括号（（），and符合（&amp;）转换为等效的字符实体。 “*HtmlAttributeEncode 方法的结果字符串只应当用于由双引号括起的属性。使用 HtmlAttributeEncode* 方法和用单引号括起的属性可能会引起安全问题。” 看大家的选择了，如果仅仅是担心输出HTML代码和JS方面的安全，可以使用HtmlAttributeEncode 方法，效率更高！ 12@Html.AttributeEncode(\"&lt;script&gt;alert(\\\"nihao\\\")&lt;/script&gt;\")html:&amp;lt;script&gt;alert(&amp;quot;nihao&amp;quot;)&amp;lt;/script&gt; 模板化帮助器一遍遍编写Html模板枯燥且容易出错，模板化帮助器可以很好的解决这一问题 在asp.net mvc中Editor，Display是两个基本的模板化帮助器 Display帮助器显示viewdata里面的值 12345@&#123; ViewData[\"Title\"] = \"nihao\";&#125;@Html.Display(\"Title\") 显示model对应属性的值 1@Html.DisplayFor(model =&gt; model.Title) 显示model中所有的值 1@Html.DisplayForModel() Editor帮助器Editor帮助器让你可以编辑指定的值 1@Html.EditorFor(model =&gt; model.Title) 模板化帮助器可以使用模板进行自定义编辑，比如对于Editor可以将模板文件放在对应的controller下面的EditorTemplates下或者公用的Views/Shared下 1@Html.EditorFor(model =&gt; model.date,\"DateTime\") 视图引擎会自己找对应文件夹下面的文件 自定义帮助器有时候mvc提供的帮助器下没有我们需要的，这时候可以编辑自定义帮助器 帮助器结构htmlhelper就是一个普通拓展方法 MvcHtmlString不只是字符串自定义帮助器返回对象最好是MvcHtmlString封装对象而不是普通的字符串，实际上，所有的原生的帮助器方法也都是通过stringbuilder然后构造的MvcHtmlString对象，可以通过以下代码轻松的创建MvcHtmlString对象 1MvcHtmlString.Create((string)str); 自定义帮助器样例添加引用并使用 123@using _02.Helper@Html.Title(\"自定义帮助器创建的title\") 简单的拓展方法 12345678910111213public static class TitleHelper &#123; public static MvcHtmlString Title(this HtmlHelper html, string title, string className) &#123; var h1Tag = new TagBuilder(\"h1\"); if (!string.IsNullOrEmpty(className)) &#123; h1Tag.Attributes[\"class\"] = className; &#125; h1Tag.SetInnerText(title); return MvcHtmlString.Create(h1Tag.ToString()); &#125; &#125; Razor视图引擎视图引擎内部机制搜索位置视图引擎的构造函数中定义了视图搜索位置的格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public RazorViewEngine(IViewPageActivator viewPageActivator) : base(viewPageActivator) &#123; this.AreaViewLocationFormats = new string[4] &#123; \"~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.cshtml\", \"~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.vbhtml\", \"~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.cshtml\", \"~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.vbhtml\" &#125;; this.AreaMasterLocationFormats = new string[4] &#123; \"~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.cshtml\", \"~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.vbhtml\", \"~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.cshtml\", \"~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.vbhtml\" &#125;; this.AreaPartialViewLocationFormats = new string[4] &#123; \"~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.cshtml\", \"~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.vbhtml\", \"~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.cshtml\", \"~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.vbhtml\" &#125;; this.ViewLocationFormats = new string[4] &#123; \"~/Views/&#123;1&#125;/&#123;0&#125;.cshtml\", \"~/Views/&#123;1&#125;/&#123;0&#125;.vbhtml\", \"~/Views/Shared/&#123;0&#125;.cshtml\", \"~/Views/Shared/&#123;0&#125;.vbhtml\" &#125;; this.MasterLocationFormats = new string[4] &#123; \"~/Views/&#123;1&#125;/&#123;0&#125;.cshtml\", \"~/Views/&#123;1&#125;/&#123;0&#125;.vbhtml\", \"~/Views/Shared/&#123;0&#125;.cshtml\", \"~/Views/Shared/&#123;0&#125;.vbhtml\" &#125;; this.PartialViewLocationFormats = new string[4] &#123; \"~/Views/&#123;1&#125;/&#123;0&#125;.cshtml\", \"~/Views/&#123;1&#125;/&#123;0&#125;.vbhtml\", \"~/Views/Shared/&#123;0&#125;.cshtml\", \"~/Views/Shared/&#123;0&#125;.vbhtml\" &#125;; this.FileExtensions = new string[2] &#123; \"cshtml\", \"vbhtml\" &#125;; &#125; 代码碎块1@&#123;//code&#125; 解析器会正确的识别标记 @{&lt;h1&gt;@Viewbag.Title&lt;/h1&gt;} 可以通过@（）插入字符 1&lt;p&gt;@(\"hello\" + Model.userName)&lt;/p&gt; 括号中同时可以 放置一个函数 12&lt;p&gt;@(Method())&lt;/p&gt;//等同于&lt;p&gt;@&#123;Method()；&#125;&lt;/p&gt; 注释使用@。。。@，使用@@表示@字符 Razor处理过的视图都是自动编码的，如果想保留原始格式使用 1@Html.Raw(...) 条件式代码碎块123&lt;div class=\"@Model.Css\"&gt; ....&lt;/div&gt; 当Model.Css为null时，解析器理论上会抛出异常，但mvc4之后，条件逻辑已经内置在Razor引擎中了 Razor视图对象Razor引擎生成视图对象可以通过反射dll看到继承自WebViewPage 1public class _Page_Views_Home_About_cshtml : WebViewPage&lt;object&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148namespace System.Web.Mvc&#123; using System; using System.Globalization; using System.IO; using System.Runtime.CompilerServices; using System.Web; using System.Web.Mvc.Properties; using System.Web.WebPages; public abstract class WebViewPage : WebPageBase, IViewDataContainer, IViewStartPageChild &#123; private AjaxHelper&lt;object&gt; _ajax; private HttpContextBase _context; private DynamicViewDataDictionary _dynamicViewData; private HtmlHelper&lt;object&gt; _html; private ViewDataDictionary _viewData; protected WebViewPage() &#123; &#125; protected override void ConfigurePage(WebPageBase parentPage) &#123; WebViewPage page = parentPage as WebViewPage; if (page == null) &#123; throw new InvalidOperationException(string.Format(CultureInfo.CurrentCulture, MvcResources.CshtmlView_WrongViewBase, new object[] &#123; parentPage.get_VirtualPath() &#125;)); &#125; this.ViewContext = page.ViewContext; this.ViewData = page.ViewData; this.InitHelpers(); &#125; public override void ExecutePageHierarchy() &#123; TextWriter writer = this.ViewContext.Writer; this.ViewContext.Writer = base.get_Output(); base.ExecutePageHierarchy(); if (!string.IsNullOrEmpty(this.OverridenLayoutPath)) &#123; this.set_Layout(this.OverridenLayoutPath); &#125; this.ViewContext.Writer = writer; &#125; public virtual void InitHelpers() &#123; this.Html = null; this.Ajax = null; this.Url = new UrlHelper(this.ViewContext.RequestContext); &#125; protected virtual void SetViewData(ViewDataDictionary viewData) &#123; this._viewData = viewData; &#125; public AjaxHelper&lt;object&gt; Ajax &#123; get &#123; if ((this._ajax == null) &amp;&amp; (this.ViewContext != null)) &#123; this._ajax = new AjaxHelper&lt;object&gt;(this.ViewContext, this); &#125; return this._ajax; &#125; set &#123; this._ajax = value; &#125; &#125; public override HttpContextBase Context &#123; get =&gt; (this._context ?? this.ViewContext.HttpContext); set &#123; this._context = value; &#125; &#125; public HtmlHelper&lt;object&gt; Html &#123; get &#123; if ((this._html == null) &amp;&amp; (this.ViewContext != null)) &#123; this._html = new HtmlHelper&lt;object&gt;(this.ViewContext, this); &#125; return this._html; &#125; set &#123; this._html = value; &#125; &#125; public object Model =&gt; this.ViewData.Model; internal string OverridenLayoutPath &#123; get; set; &#125; public TempDataDictionary TempData =&gt; this.ViewContext.TempData; public UrlHelper Url &#123; get; set; &#125; [Dynamic] public object ViewBag &#123; [return: Dynamic] get &#123; Func&lt;ViewDataDictionary&gt; viewDataThunk = null; if (this._dynamicViewData == null) &#123; if (viewDataThunk == null) &#123; viewDataThunk = () =&gt; this.ViewData; &#125; this._dynamicViewData = new DynamicViewDataDictionary(viewDataThunk); &#125; return this._dynamicViewData; &#125; &#125; public System.Web.Mvc.ViewContext ViewContext &#123; get; set; &#125; public ViewDataDictionary ViewData &#123; get &#123; if (this._viewData == null) &#123; this.SetViewData(new ViewDataDictionary()); &#125; return this._viewData; &#125; set &#123; this.SetViewData(value); &#125; &#125; &#125;&#125; 可以看到View可以使用的对象都在这里面 设计一个样例视图建立视图专用的Model1234567namespace _02.Models.Home&#123; public class HomeIndexViewModel &#123; public string Str &#123; get; set; &#125; &#125;&#125; 在视图中声明model类型 1@model _02.Models.Home.HomeIndexViewModel 使用Model 123&lt;div&gt; &lt;h1&gt;@Model.Str&lt;/h1&gt;&lt;/div&gt; controller中添加返回对象 1234567public ActionResult Index() &#123; return View(new HomeIndexViewModel() &#123; Str = \"传递的数据\" &#125;); &#125; 定义母版视图布局页就是一个普通的cshtml页面但是必须添加@RenderBody()告诉解析器在哪儿注入布局模板 layout可以使任意路径或设置条件，默认的layout在_VIewStart.cshtml中定义 123456@&#123; if (Request.Browser.IsMobileDevice) &#123; Layout = \"About.cshtml\"; &#125;&#125; 通过~返回根目录 1Layout = \"~/Views/Shared/_Layout.cshtml\"; 定义节RenderBody方法定义了布局注入的单个点，但你可能需要将内容注入到多个位置，在布局模板中，可以通过在希望出现内容的位置放置一个RenderSection的调用来定义注入点 默认的_Layout中就有关于scripts的节 1@RenderSection(\"scripts\", required: false) required: false指的是不是必须的，可以通过@section+名称进行节的编写 1234@section scripts&#123; &lt;script&gt;alert(\"nihao\");&lt;/script&gt;&#125; 节的默认内容webform中视图引擎中的母版页可以指定默认内容，Razor没有但是可以通过IsSectionDefined进行判断，添加默认的内容 1234567&lt;div id=\"footer\"&gt; @if(IsSectionDefined(\"name\"))&#123; @RenderSection(\"name\"); &#125;else&#123; &lt;span&gt;undefined&lt;/span&gt; &#125;&lt;/div&gt; 嵌套布局布局是可以嵌套的通过指定Layout实现嵌套 声明式Html帮助器通过HtmlHelper创建网页内容如果有很多元素就十分困难，这时候使用声明式Html帮助器就方便很多 首先在项目中添加App_Code，添加MyHelpers.cshtml，定义一个简单的方法，格式@helper+签名 1234@helper ShowTitle(string title)&#123; &lt;h1&gt;@title&lt;/h1&gt;&#125; 使用 1@MyHelpers.ShowTitle(\"nihao\") 注意在App_Code外编辑的帮助器不会被检测 视图编码视图建模ViewData，ViewBag通过这两个对象可以从controller中传值到view中，两个类型都是dynomic，用法： 123456ViewData[\"Title\"]=\"nihao\";ViewBag.Title=\"nihao\";view中：@ViewData[\"Title\"]@ViewBag.Title 强类型视图模型上面已经说过 应尽量减少viewbag，viewdata，因为使用viewmodel更易维护，同时注意的是这里的model是视图模型，应尽量减少直接将数据模型当做视图模型 高级功能更改视图引擎检索格式创建自己的检索格式，项目中只是用Razor就没必要检索aspx格式的视图，提高效率，同时可以将PartialViews放在不同的地方便于管理 123456789101112131415161718namespace _02.App_Start&#123; public class NewFormatViewEngine : RazorViewEngine &#123; public NewFormatViewEngine() &#123; this.MasterLocationFormats = base.MasterLocationFormats; this.ViewLocationFormats = new string[] &#123; \"~/Views/&#123;1&#125;/&#123;0&#125;.cshtml\" &#125;; this.PartialViewLocationFormats = new string[] &#123; \"~/PartialViews/&#123;1&#125;/&#123;0&#125;.cshtml\" &#125;; &#125; &#125;&#125; 我在App_Start中创建自己的新类继承自RazorViewEngine 在Global.asax中，清空原来的引擎，添加新的 123456789public class MvcApplication : System.Web.HttpApplication &#123; protected void Application_Start() &#123; 。。。 ViewEngines.Engines.Clear(); ViewEngines.Engines.Add(new NewFormatViewEngine()); &#125; &#125; 需要注意的是要添加Web.config配置对应的视图引擎，这里直接复制Views里面的即可 已经可以使用了，文件夹PartialViews ==&gt; Home ==&gt; Home_Contact_PartialView.cshtml 1@Html.Partial(\"Home_Contact_PartialView\") 呈现操作当需要呈现一个固定不变的视图或者需要控制器提供数据的视图的时候使用呈现操作即可 菜单例子：控制中添加返回PartialView的方法Menu 123456789public ActionResult Menu() &#123; return PartialView(new List&lt;string&gt;() &#123; \"menu1\", \"menu2\", \"menu3\" &#125;); &#125; 创建对应的视图 12345678@model IList&lt;string&gt; &lt;div&gt; @foreach (var str in Model) &#123; &lt;a&gt;@str&lt;/a&gt; &#125;&lt;/div&gt; 使用 1@Html.Action(\"Menu\") 与@Html.Partial一样ActionRender也是写入到响应流，Action直接返回html字符串","categories":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://luox78.github.io/categories/ASP-NET-MVC/"}],"tags":[{"name":"ASP.NET MVC5 编程实战","slug":"ASP-NET-MVC5-编程实战","permalink":"https://luox78.github.io/tags/ASP-NET-MVC5-编程实战/"}]},{"title":"ASP.NET06","slug":"ASP.NET06","date":"2018-02-10T11:13:43.949Z","updated":"2018-02-12T13:35:02.465Z","comments":true,"path":"2018/02/10/ASP.NET06/","link":"","permalink":"https://luox78.github.io/2018/02/10/ASP.NET06/","excerpt":"httprequest一些成员 Request.UrlReferrer获取请求该资源的原地址 用处：判断host是否为本站 123456789101112public void ProcessRequest(HttpContext context) &#123; var uri = context.Request.UrlReferrer; if (uri == null || uri.Host != \"localhost\") &#123; context.Response.ContentType = \"text/plain\"; context.Response.Write(\"forbid\"); context.Response.End(); &#125; context.Response.ContentType = \"image/jpg\"; context.Response.WriteFile(\"536896a693f71.jpg\"); &#125; 只有在img请求和localhost下才能访问 Request.UserHostAddress获得访问者的IP地址","text":"httprequest一些成员 Request.UrlReferrer获取请求该资源的原地址 用处：判断host是否为本站 123456789101112public void ProcessRequest(HttpContext context) &#123; var uri = context.Request.UrlReferrer; if (uri == null || uri.Host != \"localhost\") &#123; context.Response.ContentType = \"text/plain\"; context.Response.Write(\"forbid\"); context.Response.End(); &#125; context.Response.ContentType = \"image/jpg\"; context.Response.WriteFile(\"536896a693f71.jpg\"); &#125; 只有在img请求和localhost下才能访问 Request.UserHostAddress获得访问者的IP地址 context.Request.MapPath()将虚拟路径转换为磁盘上的物理路径 其他： 1、 （*）Request.AppRelativeCurrentExecutionFilePath，获取当前执行请求相对于应用根目录的虚拟路径，以~开头，比如“~/Handler.ashx”， 2、 （*）Request.PhysicalApplicationPath，获取当前应用的物理路径，比如D:\\我的文档\\VisualStudio 2008\\WebSites\\WebSite4\\ 3、 （*）Request.PhysicalPath，获取当前请求的物理路径，比如D:\\我的文档\\VisualStudio 2008\\WebSites\\WebSite4\\Handler.ashx 4、 （*） Request.RawUrl获得原始请求URL、Request.Url获得请求的URL，区别涉及到URL重写的问题 5、 （*） Request.UserLanguages获得访问者浏览器支持的语言，可以通过这个实现对不同语言的人显示不同语言的页面。 6、 Request.Url.GetComponents(UriComponents.HostAndPort,UriFormat.SafeUnescaped)获取当前请求的网站的域名和端口号 httpresponse一些成员 Response.Buffer、Response.BufferOutput 类型bool，设置response是否通过内部缓冲区进行输出，默认true Response.Flush() 将服务器缓冲区的数据直接返回到浏览器 123456789public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = \"text/html\"; for (int i = 0; i &lt; 10; i++) &#123; context.Response.Write(\"这是第\" + i + \"个输出&lt;br&gt;\"); System.Threading.Thread.Sleep(400); &#125; &#125; 循环里面添加一句context.Response.Flush();，实际上会连续发送，从监视工具可以看出，第一次全是等待时间，第二次全是接受时间，但浏览器自身会等待全部接受完成之后才显示 Response.Clear() 直接清空缓冲区，没有发送的数据会丢失 Response.ContentEncoding 输出流的编码 Response.OutputStream 输出流 123456public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = \"image/jpg\"; //以下载的方式 //context.Response.AppendHeader(\"Content-Disposition\", \"attachment;filename=\\\"\" + HttpUtility.UrlEncode(\"536896a693f71.jpg\", System.Text.Encoding.UTF8) + \"\\\"\"); context.Response.OutputStream.Write(File.ReadAllBytes(context.Request.MapPath(\"536896a693f71.jpg\")), 0, File.ReadAllBytes(context.Request.MapPath(\"536896a693f71.jpg\")).Length); &#125; Response.End() 终止响应，将之前缓存中的数据发给浏览器，End()之后的代码不会被继续执行,End方法里调用了Flush()方法。 Server属性(Type HttpServerUtility)注意：Server里面的方法基本上都是调用HttpUtility类中相应方法。推荐使用HttpUtility，因为有的地方很难拿到Server对象，而且Server的存在是为以前ASP程序员习惯而留的。 MapPath 取得文件的物理路径 Execute 方法和 Transfer方法 两个都是服务器里执行动态页面，跟重定向有本质区别，不能内部重定向到ashx，否则会报错“执行子请求出错” Transfer：第一个页面直接调用第二个页面，执行完第二个页面后不再返回第一个页面，立即响应到客户端浏览器。Execute：第一个页面直接调用第二个页面，执行完第二个页面后再返回第一个页面执行，最后响应到客户端浏览器。 HtmlEncode方法和HtmlDecode方法 HtmlEncode将string以html编码，即将html里面特殊的符号用&amp;XX替换 123456public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = \"text/html\"; string str = \"&lt;script&gt;alert('nihao')&lt;/script&gt;\"; context.Response.Write(str); &#125; 不加HtmlEncode会执行script代码，加上HttpUtility.HtmlEncode(str)之后源文件会变成 1&amp;lt;script&amp;gt;alert(&amp;#39;nihao&amp;#39;)&amp;lt;/script&amp;gt;gt; UrlEncode方法和UrlDecode方法 将url进行编码（解码）成http认识的格式（ASCII码），中文规定使用UTF-8，又称作百分号编码（percent encoding） 使用时应该对正确的位置进行编码，如参数位置，参数路由等 编码方式：字符对应的ASCII码 =&gt; 转成对应的16进制 =&gt; 前面加上百分号（%） 12string search = \"你好呀\";string url = \"https://www.baidu.com?search=\" + HttpUtility.UrlEncode(search); 结果 1https://www.baidu.com?search=%e4%bd%a0%e5%a5%bd%e5%91%80 ​","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"HttpRequest","slug":"HttpRequest","permalink":"https://luox78.github.io/tags/HttpRequest/"},{"name":"HttpResponse","slug":"HttpResponse","permalink":"https://luox78.github.io/tags/HttpResponse/"},{"name":"HttpUtility","slug":"HttpUtility","permalink":"https://luox78.github.io/tags/HttpUtility/"}]},{"title":"ASP.NET05","slug":"ASP.NET05","date":"2018-02-09T13:16:12.426Z","updated":"2018-02-09T16:21:17.569Z","comments":true,"path":"2018/02/09/ASP.NET05/","link":"","permalink":"https://luox78.github.io/2018/02/09/ASP.NET05/","excerpt":"创建缩略图1234567891011121314151617var file = context.Request.Files[0]; //从上传图片创建大图 using (var bigImage = Image.FromStream(file.InputStream)) &#123; //等比创建小图 using (var smallImage = new Bitmap(200, 200 * bigImage.Height / bigImage.Width)) &#123; //创建画布将大图画入小图 using (var graphics = Graphics.FromImage(smallImage)) &#123; graphics.DrawImage(bigImage, 0, 0, smallImage.Width, smallImage.Height); &#125; //保存 bigImage.Save(context.Server.MapPath(Guid.NewGuid() + \"_big.jpg\")); smallImage.Save(context.Server.MapPath(Guid.NewGuid() + \"_small.jpg\")); &#125; &#125;","text":"创建缩略图1234567891011121314151617var file = context.Request.Files[0]; //从上传图片创建大图 using (var bigImage = Image.FromStream(file.InputStream)) &#123; //等比创建小图 using (var smallImage = new Bitmap(200, 200 * bigImage.Height / bigImage.Width)) &#123; //创建画布将大图画入小图 using (var graphics = Graphics.FromImage(smallImage)) &#123; graphics.DrawImage(bigImage, 0, 0, smallImage.Width, smallImage.Height); &#125; //保存 bigImage.Save(context.Server.MapPath(Guid.NewGuid() + \"_big.jpg\")); smallImage.Save(context.Server.MapPath(Guid.NewGuid() + \"_small.jpg\")); &#125; &#125; WebForm介绍WebForm分为两个文件aspx和aspx.cs aspx是页面模板，是页面描述文件，就是html+js+css的内容，和aspx.cs结合的更好，不用像一般处理程序那样程序员自己去输出HTML字符串或读取填充模板，控件都是定义在aspx中，内联的JavaScript、CSS也是写在aspx中的 前台页面上的@Page指令集。 服务端的C#代码是定义在aspx.cs中。aspx控制页面长相，cs控制程序逻辑，这种“前aspx后cs”的方式就被称为CodeBehind(代码后置)。 强调：后台页面可以把Page_Load看成是WinForm里的Load事件(“最先运行”)。 1.直接在后台通过Response.Write(“内容”); aspx中也可以访问cs中定义的非私有的成员 缺点：全都输出在页面的最上面。 2.使用&lt;%%&gt;在前台页面指定输出。 可以编写复杂的C#代码， for等所有C#代码都可以写在aspx中 如： &lt;%=UserName %&gt; &lt;%=SayHello(); %&gt; &lt;%if (UserName == “aaa”) { UserName = “bbb”; } %&gt; 深入理解aspx创建一个webform，对应的aspx.cs： 1234567public partial class WebForm1 : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; &#125; &#125; 可以看到它集成System.Web.UI.Page，转到page元数据看到 1public class Page : TemplateControl, IHttpHandler Page继承自IHttpHandler，可以得出其实Page就是一个进一步封装的类，这时候我向class WebForm1中添加protected字段 1protected int _num = 10; aspx页面添加一句 1&lt;%=_num %&gt; 运行可以看到10出现在html页面，为什么aspx可以访问cs里面的内容呢，看aspx头部有一个Inherits=&quot;_43.WebForm1&quot;从字面上看，它是再说继承自_43.WebForm1，事实上aspx编译之后确实如此， 为了证明这一点，我向aspx里添加一句并拖一个控件进去，为了获取页面编译完成后dll的位置 12&lt;asp:Button ID=\"Button1\" runat=\"server\" Text=\"Button\" /&gt;&lt;%=System.Reflection.Assembly.GetExecutingAssembly().Location %&gt; 同时往pageload中添加 1234protected void Page_Load(object sender, EventArgs e) &#123; Response.Write(System.Reflection.Assembly.GetExecutingAssembly().Location); &#125; html显示的是 12C:\\Users\\luox78\\AppData\\Local\\Temp\\Temporary\\ASP.NET\\Files\\root\\2d000352\\67fdd243\\assembly\\dl3\\fd7cca4a\\cf2ad37e_aea1d301\\43.dll10 Button C:\\Users\\luox78\\AppData\\Local\\Temp\\Temporary\\ASP.NET\\Files\\root\\2d000352\\67fdd243\\App_Web_amvk3cjo.dll 分别用reflector打开，看到cs派生类里是ASP.webform1_aspx，而page页面程序集ASP命名空间下就是webform1_aspx，所以aspx页面可以访问cs里面的字段可以解释了，这时候打开ASP.webform1_aspx里面有一个方法 12345678[DebuggerNonUserCode]protected override void FrameworkInitialize()&#123; base.FrameworkInitialize(); this.__BuildControlTree(this); base.AddWrappedFileDependencies(__fileDependencies); base.Request.ValidateInput();&#125; this.__BuildControlTree(this);这句代表aspx里面的所有空间都被编译成了控件树，点开 12345678910111213141516[DebuggerNonUserCode]private void __BuildControlTree(webform1_aspx __ctrl)&#123; this.InitializeCulture(); LiteralControl control = this.__BuildControl__control2(); IParserAccessor accessor = __ctrl; accessor.AddParsedSubObject(control); HtmlHead head = this.__BuildControl__control3(); accessor.AddParsedSubObject(head); LiteralControl control2 = this.__BuildControl__control6(); accessor.AddParsedSubObject(control2); HtmlForm form = this.__BuildControlform1(); accessor.AddParsedSubObject(form); LiteralControl control3 = this.__BuildControl__control7(); accessor.AddParsedSubObject(control3);&#125; 貌似里面创建很多html元素对象，这里我们就知道，所有的aspx页面里面的东西都会被编译成对应的对象，这时候回顾一下aspx页面body里面的内容 12345678910&lt;body&gt; &lt;form id=\"form1\" runat=\"server\"&gt; &lt;div&gt; &lt;%=_num %&gt; &lt;asp:Button ID=\"Button1\" runat=\"server\" Text=\"Button\" /&gt; &lt;%=System.Reflection.Assembly.GetExecutingAssembly().Location %&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; 显示body，然后form，form里面有button，__BuildControlTree，里面也印证了这一点，我们打开创建form的方法 123456789101112131415161718[DebuggerNonUserCode]private HtmlForm __BuildControlform1()&#123; HtmlForm form = new HtmlForm(); base.form1 = form; form.ID = \"form1\"; Button button = this.__BuildControlButton1(); IParserAccessor accessor = form; accessor.AddParsedSubObject(button); form.SetRenderMethodDelegate(new RenderMethod(this.__Renderform1)); object[] parameters = new object[5]; parameters[0] = form; parameters[2] = 0x131; parameters[3] = 0x20; parameters[4] = false; this.__PageInspector_SetTraceData(parameters); return form;&#125; 里面设置了form的一些属性同时创建了button，此时我们往html添加新的代码 12345678910111213&lt;body&gt; &lt;% for (int i = 0; i &lt; 10; i++) &#123;%&gt; &lt;h1&gt;nihao&lt;/h1&gt; &lt;% &#125; %&gt; &lt;form id=\"form1\" runat=\"server\"&gt; &lt;div&gt; &lt;%=_num %&gt; &lt;asp:Button ID=\"Button1\" runat=\"server\" Text=\"Button\" /&gt; &lt;%=System.Reflection.Assembly.GetExecutingAssembly().Location %&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; 添加了一个循环以便我们查看dll里面如何处理C#代码的，编译之后发现__BuildControlTree里面多了一句 __ctrl.SetRenderMethodDelegate(new RenderMethod(this.__Render__control1)); 点开 _Render_control1 1234567891011121314151617181920212223242526272829303132333435363738private void __Render__control1(HtmlTextWriter __w, Control parameterContainer)&#123; int num2; object[] parameters = new object[] &#123; __w, \"/WebForm1.aspx\", 160, 0x44, true &#125;; this.__PageInspector_BeginRenderTracing(parameters); __w.Write(\"\\r\\n\\r\\n&lt;!DOCTYPE html&gt;\\r\\n\\r\\n&lt;html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"&gt;\\r\\n\"); object[] objArray2 = new object[] &#123; __w &#125;; this.__PageInspector_EndRenderTracing(objArray2); parameterContainer.Controls[0].RenderControl(__w); object[] objArray3 = new object[] &#123; __w, \"/WebForm1.aspx\", 0x162, 14, true &#125;; this.__PageInspector_BeginRenderTracing(objArray3); __w.Write(\"\\r\\n&lt;body&gt;\\r\\n \"); object[] objArray4 = new object[] &#123; __w &#125;; this.__PageInspector_EndRenderTracing(objArray4); object[] objArray5 = new object[] &#123; __w, \"/WebForm1.aspx\", 0x170, 0x2c, false &#125;; this.__PageInspector_BeginRenderTracing(objArray5); for (int i = 0; i &lt; 10; i = num2 + 1) &#123; object[] objArray6 = new object[] &#123; __w &#125;; this.__PageInspector_EndRenderTracing(objArray6); object[] objArray7 = new object[] &#123; __w, \"/WebForm1.aspx\", 0x19c, 0x1a, true &#125;; this.__PageInspector_BeginRenderTracing(objArray7); __w.Write(\"\\r\\n &lt;h1&gt;nihao&lt;/h1&gt;\\r\\n \"); object[] objArray8 = new object[] &#123; __w &#125;; this.__PageInspector_EndRenderTracing(objArray8); object[] objArray9 = new object[] &#123; __w, \"/WebForm1.aspx\", 0x1b6, 7, false &#125;; this.__PageInspector_BeginRenderTracing(objArray9); num2 = i; &#125; object[] objArray10 = new object[] &#123; __w &#125;; this.__PageInspector_EndRenderTracing(objArray10); parameterContainer.Controls[1].RenderControl(__w); object[] objArray11 = new object[] &#123; __w, \"/WebForm1.aspx\", 0x2c1, 20, true &#125;; this.__PageInspector_BeginRenderTracing(objArray11); __w.Write(\"\\r\\n&lt;/body&gt;\\r\\n&lt;/html&gt;\\r\\n\"); object[] objArray12 = new object[] &#123; __w &#125;; this.__PageInspector_EndRenderTracing(objArray12);&#125; 看到for循环直接在里面，原来C#是直接和html元素一起编译成方法，最后转换成元素对象的，这时候或许你会有疑问cs里面是如何访问这些控件的，查看cs的dll可以看到 1234567891011public class WebForm1 : Page &#123; protected int _num = 10; protected Button Button1; protected HtmlForm form1; protected void Page_Load(object sender, EventArgs e) &#123; base.Response.Write(Assembly.GetExecutingAssembly().Location); &#125; &#125; 一旦你在aspx中创建了控件，cs里面就会有对应的protected字段（在designer.cs中），cs里对控件属性的修改继承自他的aspx的那个类会进行相应的更改，并将它反应到最终生成的页面上 总结： IsPostBack用于判断是第一次get页面还是post回发 验证cs里pageload时 1234protected void Page_Load(object sender, EventArgs e) &#123; Response.Write(this.IsPostBack); &#125; aspx中（aspx中form里面的button控件只会生成submit不会生成button） 123&lt;form id=\"form1\" runat=\"server\"&gt; &lt;asp:Button ID=\"Button1\" runat=\"server\" Text=\"Button\" /&gt; &lt;/form&gt; 浏览会看到只有第一次get是false，回发的都是true 如何实现的既然服务器控件生成的是html form那我自己写一个 123&lt;form id=\"form1\" method=\"post\" action=\"WebForm3.aspx\"&gt; &lt;input type=\"submit\" name=\"name\" value=\"tijiao\" /&gt; &lt;/form&gt; cs里面跟上面一样，这时候运行会发现永远都是false，浏览器查看source我们就可以看出问题，runat serve的html里面多出了很多隐藏域，先将结果 IsPostBack是通过form中的隐藏域提交给服务器，如果没有接受到，那就是第一次请求，收到了肯定是回发。同时引出我们的下一部分viewstate 总结1.IsPostBack用来判断表单是否是回发。（不是第一次请求），是点击表单的提交按钮回发过来的。是否是回发与get请求还是Post请求无关。但是一般情况下回发都是Post请求。一般Get请求都是第一次加载。 2.只有当使用服务器端表单&lt;form runat=&quot;server&quot;&gt;IsPostBack才可以使用。如果使用客户端表单，则IsPostBack永远都是False.因为当使用服务器端表单的时候会自动生成一个隐藏域,才该隐藏域中，服务器写入了一些内容，通过这些内容就可以判断是否是回发。如果使用的是普通html表单，则需要自己写代码来判断是否是回发。 3.IsPostBack的使用方式，为什么要使用IsPostBack 4.用处：使用IsPostBack可以知道是不是第一次请求，通过viewstate可以将第一次加载的数据停留在页面中减少数据加载的次数。避免了每次点击按钮回发都重新加载一次数据。 ViewStateviewstate（视图状态），顾名思义就是view的aspx空间的值状态 pageload中添加 1ViewState[\"key\"] = \"nihao\"; 生成html里面有一个隐藏域为viewstate 1&lt;input type=\"hidden\" name=\"__VIEWSTATE\" id=\"__VIEWSTATE\" value=\"P2yIH8jxqJKNyRGQn/BloDXHiGVvbfXBTzveFGTePfqct88mOSTSDiAJmfi3kLBaX+RRjSBf0RgEBmgfYTh1nQOXlqCGoRY2ccoHhM5M+buITfYkgxbsmXLRjBckuKji\" /&gt; value里面的值中就包含了nihao，下次解析的时候，我们不需要再次向页面传值也会显示，cs中的事件里面的改值就是通过这样实现的 缺点： 加大网站的流量、降低访问速度、机密数据放到表单中会有数据欺骗等安全性问题。 禁用ViewState ：在asp顶部添加EnableViewState=”false” 1&lt;%@ Page Language=\"C#\" AutoEventWireup=\"true\" CodeBehind=\"WebForm2.aspx.cs\" Inherits=\"_43.WebForm2\" EnableViewState=\"false\"%&gt;","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"缩略图","slug":"缩略图","permalink":"https://luox78.github.io/tags/缩略图/"},{"name":"viewstate","slug":"viewstate","permalink":"https://luox78.github.io/tags/viewstate/"},{"name":"深入理解aspx","slug":"深入理解aspx","permalink":"https://luox78.github.io/tags/深入理解aspx/"}]},{"title":"ASP.NET MVC 控制器","slug":"ASP.NET MVC 控制器","date":"2018-02-07T12:43:32.626Z","updated":"2018-02-09T13:42:53.603Z","comments":true,"path":"2018/02/07/ASP.NET MVC 控制器/","link":"","permalink":"https://luox78.github.io/2018/02/07/ASP.NET MVC 控制器/","excerpt":"人么总说事件会改变一切，当实际上你必须自己动手去改变一切——Andy Warhol 对输入请求进行路由在软件中，URI（统一资源标识符）是指通过一个位置或者名称来引用资源。 当URI通过位置来识别资源是，就叫做URL（统一定位符） 当URI通过名称标志资源时，就叫做URN（统一资源名称） ASP.NET MVC 旨在处理更通用的URI，ASP.NET Web Forms只要处理位置感知的物理资源","text":"人么总说事件会改变一切，当实际上你必须自己动手去改变一切——Andy Warhol 对输入请求进行路由在软件中，URI（统一资源标识符）是指通过一个位置或者名称来引用资源。 当URI通过位置来识别资源是，就叫做URL（统一定位符） 当URI通过名称标志资源时，就叫做URN（统一资源名称） ASP.NET MVC 旨在处理更通用的URI，ASP.NET Web Forms只要处理位置感知的物理资源 模拟ASP.NET MVC运行时12345678910111213141516171819public void ProcessRequest(HttpContext context) &#123; //map对应的参数 var segments = context.Request.Url.Segments; var controller = segments[1].TrimEnd('/'); var action = segments[2].TrimEnd('/'); var param = segments[3].TrimEnd('/'); //通过反射实例化对应的controller var fullname = $\"&#123;this.GetType().Namespace&#125;.&#123;controller&#125;\"; var controllerType = Type.GetType(fullname); var instance = Activator.CreateInstance(controllerType); var methodInfo = controllerType.GetMethod(action, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); var res = methodInfo.Invoke(instance, null) as string;//假设没参数 //输出 context.Response.Write(res); &#125; controller类中 1234567891011namespace _0101&#123; public class HomeController &#123; public string Test() &#123; return \"hello world\"; &#125; &#125;&#125; 这个简单的例子模拟了ASP.NET MVC使用的基本机制，处理请求的组件是控制器类，通过request的url映射到专门的控制器类进行处理 应用程序路由url模式与路由路由：代表URL绝对路径的模式匹配字符串，即没有协议，IP地址，端口号的url字符串 比如：http://localhost:3462/home/test ==&gt; /home/test 路由可以是常量也可以是占位符，mvc系统默认的路由是{controller}/{action}/{id}，它可以匹配如Home/Index/1子类的路由 定义应用程序路由mvc中路由是在Global.asax下被注册 1234567public class MvcApplication : System.Web.HttpApplication &#123; protected void Application_Start() &#123; RouteConfig.RegisterRoutes(RouteTable.Routes); &#125; &#125; 对应的类在App_Start/RouteConfig.cs 12345678910111213public class RouteConfig &#123; public static void RegisterRoutes(RouteCollection routes) &#123; routes.IgnoreRoute(\"&#123;resource&#125;.axd/&#123;*pathInfo&#125;\"); routes.MapRoute( name: \"Default\", url: \"&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;\", defaults: new &#123; controller = \"Home\", action = \"Index\", id = UrlParameter.Optional &#125; ); &#125; &#125; 路由集合routes添加路由一般通过MapRoute进行配置，但如果你的路由有MapRoute不支持的参数可以使用 12var route = newRoute(..);RouteTable.Routes.Add(\"RouteName\",route); 进行添加，maproute里面的参数： name：路由名 url：url匹配模式 defaults：该url默认值对象 如http://localhost:3462/并没有输入controller/action但处理程序会匹配到默认值，导航到http://localhost:3462/Home/Index下 处理路由ASP.NET url路由模块总是根据注册的顺序进行匹配，所以前一项设置默认值会导致后一项永远得不到匹配 路由同时可以添加约束列表,MapRoute的一个重载 1public static Route MapRoute(this RouteCollection routes, string name, string url, object defaults, object constraints); 可以利用正则表达式将不正确的url拒之门外 123456routes.MapRoute( name: \"Product\", url: \"&#123;controller&#125;/&#123;productid&#125;/&#123;locale&#125;\", defaults: new &#123; controller = \"Home\", action = \"Index\", locale = \"cn-ch\" &#125;, constraints: new &#123; productid = @\"\\d&#123;4&#125;\", locale = \"[a-zA-Z]&#123;2&#125;-[a-zA-Z]&#123;2&#125;\" &#125; ); 路由处理程序路由处理程序实现了IRouteHandler的接口 1234public interface IRouteHandler &#123; IHttpHandler GetHttpHandler(RequestContext requestContext); &#125; RequestContext中封装了路由的相关信息，MVC框架并没有提供很对内置的路由处理程序，因为自定义路由的需求并不普遍 处理物理文件的请求在RouteConfig.cs下添加routes.RouteExistingFiles = true; 1234public static void RegisterRoutes(RouteCollection routes) &#123; routes.RouteExistingFiles = true; &#125; 阻止已定义的路由相同地方 1routes.IgnoreRoute(\"&#123;resource&#125;.axd/&#123;*pathInfo&#125;\"); 控制器类编写控制器类12345678910111213141516171819public class HomeController : Controller &#123; public ActionResult Index() &#123; return View(); &#125; [NonAction] public ActionResult About() &#123; 。。。 &#125; [ActionName(\"About\")] public ActionResult Qunimalegebi() &#123; .... &#125; &#125; [NonAction]阻止action绑定到About方法上 [ActionName(&quot;About&quot;)]指定Qunimalegebi方法的绑定action name 操作和http动词1234567[AcceptVerbs(HttpVerbs.Get|HttpVerbs.Post)] public ActionResult Contact() &#123; ViewBag.Message = \"Your contact page.\"; return View(); &#125; 通过AcceptVerbs特性绑定http请求方式，httpverbs枚举类型值 12345678910public enum HttpVerbs &#123; Get = 1, Post = 2, Put = 4, Delete = 8, Head = 16, Patch = 32, Options = 64 &#125; 利用“|”可以响应多个请求方式 处理输入数据获取request对象中的输入数据request中包含form，querystring，cookie，header等数据 从路由中获取输入数据路由和上面得一致，controller中 1var str = RouteData.Values[\"locale\"]; url：http://localhost:4426/home/1111/en-ed?data=11 str为en-ed，所以routedata捕获的是定义好的路由值，同时根据上述路由会匹配到第一个时直接结束，所以str2位null 1var str2 = RouteData.Values[\"id\"]; 利用valueprovider字典获取所有来源的值12var str6 = ValueProvider.GetValue(\"locale\").AttemptedValue;//路由的值var str7 = ValueProvider.GetValue(\"data\").AttemptedValue;//get值 ValueProvider.GetValue(&quot;data&quot;)会有两个属性 RawValue Object类型原始值 AttemptedValue string 强转成string类型的值 产生操作结果controller类中大部分方法返回的都是ActionResult类型，下面就看看ActionResult类是什么 actionresult构造12345public abstract class ActionResult&#123; protected ActionResult(); public abstract void ExecuteResult(ControllerContext context);&#125; actionresult类是抽象类，定义了一个方法为ExecuteResult。该方法为具体派生类执行时触发的一系列动作 一些派生类 ContentResult EmptyResult FileResult HttpUnauthorizedResult JavaScriptResult JsonResult RedirectResult RedirectToRouteResult ViewResultBase FileResult派生 FilePathResult: 直接将一个文件发送给客户端 可以通过更改报文头实现直接下载，不用浏览器解析 1234567public ActionResult GetFile() &#123; var image = new FilePathResult(\"~/多云.jpg\", \"image/jpg\"); Response.AddHeader(\"Content-Disposition\", $\"attachment;filename=\\\"&#123;HttpUtility.UrlDecode(\"多云.jpg\")&#125;\\\"\"); return image; &#125; FileContentResult: 返回byte字节给客户端（比如图片） FileStreamResult: 返回流 深入执行操作结果的机制控制器中我添加了以下方法 12345public ActionResult GetScript() &#123; string script = \"alert('hello')\"; return JavaScript(script); &#125; 可以看到返回的是JavaScript(script)；转到controller类定义可以看到 1234567protected internal virtual JavaScriptResult JavaScript(string script)&#123; return new JavaScriptResult() &#123; Script=script &#125;;&#125; 所以JavaScript(script)不过就是controller类的一个帮助方法而已，充当JavaScriptResult的对象工厂的角色，类似的如View(),大家都知道View参数默认值是View文件夹下面控制器名文件夹下面的index，所以不传参数并不代表没有参数，JavaScriptResult实现 123456789101112131415public class JavaScriptResult : ActionResult&#123; public string Script&#123;get;set;&#125; public override void ExecuteResult(ControllerContext context) &#123; if(context == null) throw new ArgumentNullException(nameof(context)); var response = context.HttpContext.Response; response.ContentType = \"application/x-javascript\"; if(Script != null) response.Write(Script); &#125;&#125; 可以看到JavaScriptResult里面仍然是调用的response.ContentType,response.write 注意： 如果控制器没有返回ActionResult，不会抛出异常，mvc框架会将return中的任何值封装成ContentResult对象序列化返回，没有返回值会映射成EmptyResult mvc中只dotNet 4.5 之后可以使用async/await语法执行异步操作响应界面","categories":[{"name":"ASP.NET MVC","slug":"ASP-NET-MVC","permalink":"https://luox78.github.io/categories/ASP-NET-MVC/"}],"tags":[{"name":"ASP.NET MVC5 编程实战","slug":"ASP-NET-MVC5-编程实战","permalink":"https://luox78.github.io/tags/ASP-NET-MVC5-编程实战/"}]},{"title":"CSharp高效编程摘记","slug":"CSharp高效编程摘记","date":"2018-02-07T12:10:04.134Z","updated":"2018-02-12T13:35:01.439Z","comments":true,"path":"2018/02/07/CSharp高效编程摘记/","link":"","permalink":"https://luox78.github.io/2018/02/07/CSharp高效编程摘记/","excerpt":"查询语法(query syntax)的一个用处循环创建集合|数组时，用查询语法(query syntax)会比普通控制流程的结构好点， 主要体现在： 命令式的版本有时非常难以理解，要是没有注释或文档，后续维护人员将要重读整段代码才能进行开发。 另外，查询语法比循环结构能提供更具组合性的API。查询语法将很自然的把代码分解成小块代码，每一块仅仅对序列中元素进行单一的操作。查询语法的延迟执行模型也让开发者能将这些单一的操作组合成多步操作，且在一次遍历序列时完整执行。","text":"查询语法(query syntax)的一个用处循环创建集合|数组时，用查询语法(query syntax)会比普通控制流程的结构好点， 主要体现在： 命令式的版本有时非常难以理解，要是没有注释或文档，后续维护人员将要重读整段代码才能进行开发。 另外，查询语法比循环结构能提供更具组合性的API。查询语法将很自然的把代码分解成小块代码，每一块仅仅对序列中元素进行单一的操作。查询语法的延迟执行模型也让开发者能将这些单一的操作组合成多步操作，且在一次遍历序列时完整执行。 例子：用二元组生成坐标，返回的二元组按照其离远点距离的逆序排列 12345678910111213141516171819202122232425private static IEnumerable&lt;Tuple&lt;int, int&gt;&gt; ProduceIndices()&#123; var storage = new List&lt;Tuple&lt;int, int&gt;&gt;(); for(int x = 0; x &lt; 100; x++) for(int y = 0; y &lt; 100; y++) if(x + y &lt; 100) storage.Add(Tuple.Create(x, y)); storage.Sort((point1, point2) =&gt; ( point2.Item1 * point2.Item1 + point2.Item2 * point2.Item2 ).CompareTo( point1.Item1 * point1.Item1 + point1.Item2 * point1.Item2 ));&#125;private static IEnumerable&lt;Tuple&lt;int, int&gt;&gt; QueryIndices()&#123; return from x in Enumerable.Range(0, 100) from y in Enumerable.Range(0, 100) where x + y &lt; 100 orderby (x*x + y*y) descending select Tuple.Create(x, y);&#125; 使用具名参数(named parameter)减少重载123456static void Test2(string firstName,string secondName)&#123; Console.WriteLine($\"&#123;firstName&#125;&#123;secondName&#125;\");&#125;Test2(secondName: \"78\", firstName: \"luox\");//luox78 理解几个等同性判断之间的关系当创建自定义类型时(无论是class还是struct)，应为类型定义”等同性”的含义。C#提供了4种不同的函数来判断两个对象是否”相等”： 1234public static bool ReferenceEquals(object left, object right);public static bool Equals(object left, object right);public virtual bool Equals(object right);public static bool operator ==(MyClass left, MyClass right); Object.ReferenceEquals()和Object.Equals()这两个系统提供的静态方法，永远都不需要重新定义。 Object.ReferenceEquals()判断的是对象引用，判断的是否拥有同样的对象标识(object identity)，所以若将一个值类型与它自身进行比较，方法返回的是false，因为值类型会进行装箱操作，造成引用地址不同。 Object.Equals()对于引用类型默认使用对象标识判断，即跟Object.ReferenceEquals()一样，但对于值类型，因为System.ValueType重写了Object.Equals()方法，所以比较的是值是否相等(主要是struct)，但System.ValueType是所有值类型的基类，故实现比较时，用的是反射，效率并不高。 综上所述，自定义类型实现自己的比较方法就比较重要了。 123456789101112131415161718192021222324252627public class Student : IEquatable&lt;Student&gt;&#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public override bool Equals(object obj) &#123; if (Object.ReferenceEquals(obj, null)) return false; if (Object.ReferenceEquals(this, obj)) return true; if (this.GetType() != obj.GetType()) return false; return this.Equals(obj as Student); &#125; public bool Equals(Student other) &#123; if (this.Id != other.Id) return false; if (this.Name != other.Name) return false; return true; &#125;&#125; 注意，重写Equals方法时，需要同时重写GetHashCode()方法，详细可查看条目7。 operator==()则相对简单。只要创建的是值类型，都必须重定义operator==()。理由和重写System.ValueType的Equals是一样的。而引用类型则应该避免重写operator==()。 运行时常量(readonly)和编译期常量(const)C#有两种类型的常量：编译期常量和运行时常量。两者有截然不同的行为，使用不当的话，会造成性能问题，如果没法确定，则使用慢点，但能保证正确的运行时常量。运行时常量使用readonly关键字声明，编译期常量则使用const关键字声明： 1234//声明编译期常量public const int Millennium = 2000;//声明运行时常量public static readonly int ThisYear = 2017; 二者最重要的区别在于,readonly值是运行时解析的，而const是在生成IL码就已经确定。 const声明的常量必须不能改变，若改变了，则需要重新编译所有引用的程序集。","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://luox78.github.io/tags/tips/"}]},{"title":"ASP.NET04","slug":"ASP.NET04","date":"2018-02-06T15:28:55.215Z","updated":"2018-02-07T12:42:43.475Z","comments":true,"path":"2018/02/06/ASP.NET04/","link":"","permalink":"https://luox78.github.io/2018/02/06/ASP.NET04/","excerpt":"文件上传html中添加表单1234&lt;form method=\"post\" enctype=\"multipart/form-data\" action=\"ProcessUpload.ashx\"&gt; &lt;input type=\"file\" name=\"file1\"/&gt; &lt;input type=\"submit\" value=\"upload\"/&gt;&lt;/form&gt; 文件上传注意点： 必须使用post form中enctype=&quot;multipart/form-data&quot;，使用表单快 添加文件域 &lt;input type=&quot;file&quot; name=&quot;file1&quot;/&gt;","text":"文件上传html中添加表单1234&lt;form method=\"post\" enctype=\"multipart/form-data\" action=\"ProcessUpload.ashx\"&gt; &lt;input type=\"file\" name=\"file1\"/&gt; &lt;input type=\"submit\" value=\"upload\"/&gt;&lt;/form&gt; 文件上传注意点： 必须使用post form中enctype=&quot;multipart/form-data&quot;，使用表单快 添加文件域 &lt;input type=&quot;file&quot; name=&quot;file1&quot;/&gt; enctype默认为application。。键值对形式，使用multipart/form-data后，request报文会生成分割符，将传输的数据进行块分割，以二进制形式发送到服务器 ProcessUpload.ashx中处理上传的文件1234var file = context.Request.Files[0];string filename = Path.GetFileName(file.FileName);string saveFilename = Guid.NewGuid().ToString() + \"_\" + filename;file.SaveAs(context.Server.MapPath(\"upload/\" + saveFilename)); context.Request.Files[0]获取上传的第一个文件 string filename = Path.GetFileName(file.FileName)因为上传时文件名为绝对路径 string saveFilename = Guid.NewGuid().ToString() + &quot;_&quot; + filename;保存文件的名字采用Guid加上原文件名字。 file.SaveAs(context.Server.MapPath(&quot;upload/&quot; + saveFilename));SaveAs中使用的是绝对路径，所以可以将上传的文件放入任意地方！ 此次我上传的是style.css，保存在\\upload\\689ea264-84b0-4124-989e-998f0ecb12e4_style.css下 大量数据存储解决方法当碰到大量图片等数据时，放在一个文件夹显然不合适，这时候应该拆分为多层文件夹，将文件名与对应的位置信息存储在数据库中 解决方法，可以取每次上传文件的hashcode（共32位）与0xf（1111）做&amp;运算得到0-15之间的一个数作为第一层文件夹的名字，第二层分层将hashcode右移四位再做与，为下一层目录，。。一共可以产生16^8次方个文件夹 12345678910111213141516171819public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = \"text/plain\"; if (context.Request.Files.Count == 0)//无文件退出 &#123; context.Response.Write(\"failed\"); context.Response.End(); &#125; var file = context.Request.Files[0]; string filename = System.IO.Path.GetFileName(file.FileName); string dir1 = (file.GetHashCode() &amp; 0xF).ToString();//第一层 string dir2 = (file.GetHashCode() &gt;&gt; 4 &amp; 0xF).ToString();//第二层 System.IO.Directory.CreateDirectory(context.Server.MapPath(\"upload\") + \"/\" + dir1 + \"/\" + dir2);//创建文件夹 file.SaveAs(context.Server.MapPath(\"Upload\") + \"/\" + dir1 + \"/\" + dir2 + \"/\" + Guid.NewGuid() + filename); context.Response.Write(\"success\"); &#125; 文件下载html： 1234567891011&lt;body&gt; &lt;p&gt; &lt;a href=\"ProcessDownload.ashx?id=BackButton.jpg\"&gt;BackButton.jpg&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href=\"ProcessDownload.ashx?id=Computer.png\"&gt;Computer.png&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href=\"ProcessDownload.ashx?id=Credentials_ENU.xml\"&gt;Credentials_ENU.xml&lt;/a&gt; &lt;/p&gt;&lt;/body&gt; ashx: 1234567public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = \"text/plain\"; string filename = context.Request[\"id\"]; context.Response.AddHeader(\"Content-Disposition\", \"attachment;filename=\" + \"\\\"\" + HttpUtility.UrlDecode(filename) + \"\\\"\"); context.Response.WriteFile(\"Download/\" + filename); &#125; context.Response.AddHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + &quot;\\&quot;&quot; + HttpUtility.UrlDecode(filename) + &quot;\\&quot;&quot;);添加回复报文头 ：这是一个附件不用解析，同时文件名使用HttpUtility.UrlDecode(filename)是将中文转换成 对应的编码，防止乱码 context.Response.WriteFile(&quot;Download/&quot; + filename);将文件以二进制直接返回","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"文件上传下载","slug":"文件上传下载","permalink":"https://luox78.github.io/tags/文件上传下载/"}]},{"title":"ASP.NET03","slug":"ASP.NET03","date":"2018-02-05T13:51:02.563Z","updated":"2018-02-05T15:37:06.434Z","comments":true,"path":"2018/02/05/ASP.NET03/","link":"","permalink":"https://luox78.github.io/2018/02/05/ASP.NET03/","excerpt":"ASP.NET简单三层步骤 建立好相应的文件夹 文件夹 用处 CURD.BLL CURD的业务逻辑层 CURD.DAL CURD的数据访问层 CURD.Model CURD的传输层模型（本次将数据库模型与dto混为一谈） CURD.UI CURD的网页端","text":"ASP.NET简单三层步骤 建立好相应的文件夹 文件夹 用处 CURD.BLL CURD的业务逻辑层 CURD.DAL CURD的数据访问层 CURD.Model CURD的传输层模型（本次将数据库模型与dto混为一谈） CURD.UI CURD的网页端 CURD.UI创建好模板Register.html 123456789101112&lt;form method=\"post\" action=\"Register.ashx\"&gt; &lt;label&gt;loginid&lt;/label&gt; &lt;input type=\"text\" name=\"id\"&gt; &lt;br&gt; &lt;label&gt;password&lt;/label&gt; &lt;input type=\"password\" name=\"password1\"&gt; &lt;br&gt; &lt;label&gt;comfirm&lt;/label&gt; &lt;input type=\"password\" name=\"password2\"&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"注册\"/&gt;&lt;/form&gt; 创建好Register的一般处理程序（请求页面） 1234567891011121314151617181920212223242526272829public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = \"text/html\"; string id = context.Request[\"id\"]; string password1 = context.Request[\"password1\"]; string password2 = context.Request[\"password2\"]; //读取模板 string html = File.ReadAllText(context.Server.MapPath(\"Template/Register.html\")); if (id == null || password1 == null || password2 == null) &#123; //第一次直接返回页面 context.Response.Write(html); return; &#125; if (password1 != password2) &#123; //密码不正确返回，并替换告知 html = html.Replace(\"&lt;input type=\\\"password\\\" name=\\\"password2\\\"&gt;\", \"&lt;input type=\\\"password\\\" name=\\\"password2\\\"&gt;两次密码不一致\"); context.Response.Write(html); &#125; else &#123; //todo 插入注册信息，返回成功还是失败 &#125; &#125; 创建对应的Model 123456789namespace CURD.Model&#123; public class User &#123; public int AutoId &#123; get; set; &#125; public string Id &#123; get; set; &#125; public string Password &#123; get; set; &#125; &#125;&#125; 只在dal层进行数据库操作 这里只添加一个方法，就是注册 1234567891011121314151617181920212223242526272829public int Add(User user) &#123; //可以设置成读取配置文件constr，返回成功1，失败-1 string constr = \"data source=”LUOX78“的WIN;initial catalog=school;integrated security=true\"; try &#123; using (var con = new SqlConnection(constr)) &#123; string sql = \"insert into Users(loginId,loginPwd) values(@id,@pwd)\"; var pms = new SqlParameter[] &#123; new SqlParameter(\"@id\",user.Id), new SqlParameter(\"@pwd\",user.Password) &#125;; using (var cmd = new SqlCommand(sql, con)) &#123; cmd.Parameters.AddRange(pms); con.Open(); cmd.ExecuteNonQuery(); &#125; &#125; &#125; catch (Exception e) &#123; Console.WriteLine(e); return -1; &#125; return 1; &#125; bll调用dal并返回成功还是失败 123456789101112namespace CURD.BLL&#123; public class UsersBll &#123; private UsersDal db=new UsersDal(); public bool Add(User user) &#123; return db.Add(user) == 1 ? true : false; &#125; &#125;&#125; UI层补全验证的步骤 123456789101112131415UsersBll userService = new UsersBll(); var res = userService.Add(new User() &#123; Id = id, Password = password1 &#125;); if (res) &#123; context.Response.Write(\"注册成功\"); &#125; else &#123; context.Response.Write(\"注册失败\"); &#125;","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"简单三层","slug":"简单三层","permalink":"https://luox78.github.io/tags/简单三层/"}]},{"title":"ASP.NET02","slug":"ASP.NET02","date":"2018-02-04T04:03:15.281Z","updated":"2018-02-04T12:04:27.466Z","comments":true,"path":"2018/02/04/ASP.NET02/","link":"","permalink":"https://luox78.github.io/2018/02/04/ASP.NET02/","excerpt":"搭建IIS本地服务器打开服务","text":"搭建IIS本地服务器打开服务 打开IIS管理器 新建网站 浏览新建立的网站 问题： 数据库访问用户权限问题：更改网站用户为netservice 目录浏览权限问题 dotnet版本问题 IIS处理用户请求与响应过程 URL封装报文 http.sys内核模块监听对某个端口的请求 读取注册表获取哪个进程可以处理该请求 inetinfo.exe处理请求启动w3wp.exe，分动态资源与静态资源 对于静态资源直接找到磁盘上的文件返回 对于动态资源，找到处理该动态页面的dll，对于aspx找到aspnet.isapi.dll(C++)寄宿在w3wp.exe运行 aspnet.isapi.dll开启dotnet运行时 获取一个实现了IISAPIRuntime接口的对象ISAPIRuntime，调用ProcessRequest方法(参数之一ecb是传入的数据句柄) ProcessRequest对请求报文进行简单的封装成ISAPIWorkerRequest（wk）对象 调用HttpRuntime.ProcessRequest(wk)对wk进行详细封装成HttpContext对象包含HttpRequest，HttpResponse 通过工厂模式【1】创建一个HttpApplication对象后调用ProcessRequest方法 。。。 【1】 为什么使用工厂模式： 初始化工作如果是很长一段代码，说明要做的工作很多，将很多工作装入一个方法中，相当于将很多鸡蛋放在一个篮子里，是很危险的，这也是有悖于Java面向对象的原则，面向对象的封装(Encapsulation)和分派(Delegation)告诉我们，尽量将长的代码分派“切割”成每段，将每段再“封装”起来(减少段和段之间耦合联系性)，这样，就会将风险分散，以后如果需要修改，只要更改每段，不会再发生牵一动百的事情 如何使用工厂模式： 使用接口派生实体类，通过工厂模式创建不同的对象 简单工厂： 12345678public class Factory&#123; public static ISample creator(int which)&#123; if (which==1) return new SampleA(); else if (which==2) return new SampleB(); &#125;&#125; 那么在你的程序中,如果要创建ISample的实列时候可以使用 ISample sampleA=Factory.creator(1); 抽象工厂： 工厂模式中有: 工厂方法(Factory Method) 抽象工厂(Abstract Factory). 这两个模式区别在于需要创建对象的复杂程度上。如果我们创建对象的方法变得复杂了,如上面工厂方法中是创建一个对象Sample,如果我们还有新的产品接口Sample2. 这里假设：Sample有两个实体类SampleA和SampleB，而Sample2也有两个实体类Sample2A和Sample2B 那么，我们就将上例中Factory变成抽象类,将共同部分封装在抽象类中,不同部分使用子类实现，下面就是将上例中的Factory拓展成抽象工厂: 12345678910111213141516171819202122232425public abstract class Factory&#123; public abstract Sample creator(); public abstract Sample2 creator(String name);&#125;public class SimpleFactory extends Factory&#123; public Sample creator()&#123; ......... return new SampleA &#125; public Sample2 creator(String name)&#123; ......... return new Sample2A &#125;&#125; public class BombFactory extends Factory&#123; public Sample creator()&#123; ...... return new SampleB &#125; public Sample2 creator(String name)&#123; ...... return new Sample2B &#125;&#125; https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/9852061?fr=aladdin 创建一个简单的ASP.NET新建html登录界面 123456789&lt;form method=\"post\" action=\"LoginHandler.ashx\"&gt; &lt;label&gt;loginid&lt;/label&gt; &lt;input type=\"text\" name=\"id\"&gt; &lt;br&gt; &lt;label&gt;password&lt;/label&gt; &lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"login\"/&gt;&lt;/form&gt; 编写LoginHandler.ashx 从页面获取值的方式： get：context.Request.QueryString[&quot;id&quot;] post：context.Request.Form[&quot;id&quot;] 通用：context.Request[&quot;id&quot;] || context.Request.Params[&quot;id&quot;] 这里我简单的连接数据库进行判断 12345678910111213141516171819202122string id = context.Request[\"id\"]; string password = context.Request[\"password\"]; string constr = \"data source=”LUOX78“的WIN;initial catalog=school;integrated security=true\"; int res = -1; using (var con = new SqlConnection(constr)) &#123; string sql = \"select count(*) from Users where loginId=@id and loginPwd=@pwd\"; var pms = new SqlParameter[] &#123; new SqlParameter(\"@id\",id), new SqlParameter(\"@pwd\",password) &#125;; using (var cmd = new SqlCommand(sql, con)) &#123; cmd.Parameters.AddRange(pms); con.Open(); res = (int)cmd.ExecuteScalar(); &#125; &#125; context.Response.Write(res &gt; 0 ? \"登陆成功\" : \"失败\"); 登录错误应该重定向，此时response返回的是302，浏览器重新get 1context.Response.Redirect(\"login.html\"); 有时一般处理程序会进行读取返回 获取页面绝对路径使用context.Server.MapPath(&quot;login.html&quot;); 123var html = File.ReadAllText(\"path\");//todo 添加处理context.Response.Write(html);","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"IIS请求流程","slug":"IIS请求流程","permalink":"https://luox78.github.io/tags/IIS请求流程/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://luox78.github.io/tags/工厂模式/"}]},{"title":"ASP.NET01","slug":"ASP.NET01","date":"2018-02-03T05:39:29.099Z","updated":"2018-02-03T07:58:48.406Z","comments":true,"path":"2018/02/03/ASP.NET01/","link":"","permalink":"https://luox78.github.io/2018/02/03/ASP.NET01/","excerpt":"输入域名发送过程 输入域名后，浏览器会先发送给DNS解析得到IP地址 浏览器封装http报文发送服务器 服务器根据报文，返回相对应的（静态，动态）网页 静态页面：在服务器就相当于直接读取文件字符串然后返回客户端浏览器；（任何时候访问看到的都是一样的界面。）","text":"输入域名发送过程 输入域名后，浏览器会先发送给DNS解析得到IP地址 浏览器封装http报文发送服务器 服务器根据报文，返回相对应的（静态，动态）网页 静态页面：在服务器就相当于直接读取文件字符串然后返回客户端浏览器；（任何时候访问看到的都是一样的界面。） 动态页面：在服务器是先交给某语言环境虚拟机编译运行，按照语法生成代码返回客户端浏览器。（不同条件和时候访问看到的都界面也不同。） （每次碰到新的资源都会触发新的请求，如css，js等文件） HTTP、Socket、TCP的区别这三个概念经常被谈到，也是比较容易被混掉的概念。在回顾之前我们先看一下这三者在TCP/IP协议族中的位置关系： 图4.1 层次关系.png HTTP是应用层的协议，更靠近用户端；TCP是传输层的协议；而socket是从传输层上抽象出来的一个抽象层，本质是接口。所以本质上三种还是很好区分的。尽管如此，有时候你可能会懵逼，HTTP连接、TCP连接、socket连接有什么区别？好吧，如果上面的图解释的还是不够清楚的话，我们继续往下看。 1、TCP连接与HTTP连接的区别 上文提过，HTTP是基于TCP的，客户端往服务端发送一个HTTP请求时第一步就是要建立与服务端的TCP连接，也就是先三次握手，“你好，你好，你好”。从HTTP 1.1开始支持持久连接，也就是一次TCP连接可以发送多次的HTTP请求。 小总结：HTTP基于TCP 2、TCP连接与Socket连接的区别 在图4.1中我们提到，socket层只是在TCP/UDP传输层上做的一个抽象接口层，因此一个socket连接可以基于连接，也有可能基于UDP。基于TCP协议的socket连接同样需要通过三次握手建立连接，是可靠的；基于UDP协议的socket连接不需要建立连接的过程，不过对方能不能收到都会发送过去，是不可靠的，大多数的即时通讯IM都是后者。 小总结：Socket也基于TCP 3、HTTP连接与Socket连接的区别 区分这两个概念是比较有意义的，毕竟TCP看不见摸不着，HTTP与Socket是实实在在能用到的。 HTTP是短连接，Socket(基于TCP协议的)是长连接。尽管HTTP1.1开始支持持久连接，但仍无法保证始终连接。而Socket连接一旦建立TCP三次握手，除非一方主动断开，否则连接状态一直保持。 HTTP连接服务端无法主动发消息，Socket连接双方请求的发送先后限制。这点就比较重要了，因为它将决定二者分别适合应用在什么场景下。HTTP采用“请求-响应”机制，在客户端还没发送消息给服务端前，服务端无法推送消息给客户端。必须满足客户端发送消息在前，服务端回复在后。Socket连接双方类似peer2peer的关系，一方随时可以向另一方喊话。 4、问题来了：什么时候该用HTTP，什么时候该用socket 这个问题的提出是很自然而然的。当你接到一个与另一方的网络通讯需求，自然会考虑用HTTP还是用Socket。 用HTTP的情况：双方不需要时刻保持连接在线，比如客户端资源的获取、文件上传等。 用Socket的情况：大部分即时通讯应用(QQ、微信)、聊天室、苹果APNs等 http报文详解 （sp空格 CRLF换行 http post数据会放入请求体） —–请求报文———– GET https://luox78.github.io/ HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cnAccept-Encoding: gzip, deflateUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0;Windows NT 5.1; SV1; .NET CLR 2.0.50727)Connection: Keep-Alive —–响应报文———— HTTP/1.1 200 OKConnection: keep-aliveDate: Thu, 26 Jul 2007 14:00:02 GMTServer: Microsoft-IIS/6.0X-Powered-By: ASP.NETContent-Length: 190Content-Type: text/htmlSet-Cookie: ASPSESSIONIDSAATTCSQ=JOPPKDCAMHHBEOICJPGPBJOB;path=/Cache-control: private http状态码1xx （临时响应）用于表示临时响应并需要请求者执行操作才能继续的状态代码。 代码** 说明** 100（继续） 请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。 101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备进行切换。 2xx （成功） 用于表示服务器已成功处理了请求的状态代码。 代码** 说明** 200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的服务器log日志文件显示为此状态，那么，这表示请求成功。 201（已创建） 请求成功且服务器已创建了新的资源。 202（已接受） 服务器已接受了请求，但尚未对其进行处理。 203（非授权信息） 服务器已成功处理了请求，但返回了可能来自另一来源的信息。 204（无内容） 服务器成功处理了请求，但未返回任何内容。 205（重置内容） 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。 206（部分内容） 服务器成功处理了部分 GET 请求。 3xx （已重定向）要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google建议：在每次请求时使用的重定向要少于5个。您可以使用网站管理员工具来查看Googlebot(google机器人程序)在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了Googlebot 由于重定向错误而无法抓取的网址。 代码** 说明** 300（多种选择） 服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。 301（永久移动） 请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302（临时移动） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。 303（查看其他位置） 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。 304（未修改） 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为If-Modified-Since HTTP 标头）。 305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 307（临时重定向） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知搜索引擎某个页面或网站已被移动。 4xx （请求错误）这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。 代码** 说明** 400（错误请求） 服务器不理解请求的语法。 401（未授权） 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。 403（已禁止） 服务器拒绝请求。如果在搜索引擎尝试抓取您网站上的有效网页时显示此状态代码，那么，这可能是您的服务器或主机拒绝搜索引擎对其进行访问。 404（未找到） 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。 如果您的网站上没有robots.txt 文件，而您在 Google 网站管理员工具”故障诊断”标签的”网络抓取”-“找不到”页上发现此状态。然而，如果您有robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。（该文件应当位于根目录下，且应当名为 robots.txt）。 如果您在Googlebot 尝试抓取的网址上发现此状态（位于”诊断”标签的 HTTP 错误页上），那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。 405（方法禁用） 禁用请求中所指定的方法。 406（不接受） 无法使用请求的内容特性来响应请求的网页。 407（需要代理授权） 此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。 408（请求超时） 服务器等候请求时超时。 409（冲突） 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。 410（已删除） 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。 411（需要有效长度） 服务器不会接受包含无效内容长度标头字段的请求。 412（未满足前提条） 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大） 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。 414（请求的 URI 过） 请求的 URI（通常为网址）过长，服务器无法进行处理。 415(不支持的媒体类型) 请求的格式不受请求页面的支持。 416(请求范围不符合要求) 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。 417（未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx （服务器错误）这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 代码** 说明** 500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到了无效的响应。 503（服务不可用） 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。 504（网关超时） 服务器作为网关或代理，未及时从上游服务器接收请求。 505（HTTP 版本不受支持） 服务器不支持请求中所使用的 HTTP 协议版本。 自己写一个IIS（静态） 写一个IIS服务端，接收用户的请求，并且把请求报文显示到文本框中。 把请求的报文封装到HttpContext中 HttpContext，添加Response与Request属性。 HttpRequest,解析报文，获取请求方法Method和请求路径RequestUrl HttpResponse,添加ResponseBody属性，和ResponseHeader属性（只读） 发送到用户浏览器","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"http协议","slug":"http协议","permalink":"https://luox78.github.io/tags/http协议/"},{"name":"模拟IIS","slug":"模拟IIS","permalink":"https://luox78.github.io/tags/模拟IIS/"}]},{"title":"多线程01","slug":"thread01","date":"2018-02-01T12:36:45.740Z","updated":"2018-02-03T05:40:43.478Z","comments":true,"path":"2018/02/01/thread01/","link":"","permalink":"https://luox78.github.io/2018/02/01/thread01/","excerpt":"进程线程应用程序域概念进程，线程略 应用程序域（AppDomain）：它提供安全而通用的处理单元，公共语言运行库可使用它来提供应用程序之间的隔离。您可以在具有同等隔离级别（存在于单独的进程中）的单个进程中运行几个应用程序域，而不会造成进程间调用或进程间切换等方面的额外开销。优势： 在一个应用程序中出现的错误不会影响其他应用程序。能够在不停止整个进程的情况下停止单个应用程序。应用程序域形成了托管代码的隔离、卸载和安全边界。在任意给定时间，每一线程都在一个应用程序域中执行。","text":"进程线程应用程序域概念进程，线程略 应用程序域（AppDomain）：它提供安全而通用的处理单元，公共语言运行库可使用它来提供应用程序之间的隔离。您可以在具有同等隔离级别（存在于单独的进程中）的单个进程中运行几个应用程序域，而不会造成进程间调用或进程间切换等方面的额外开销。优势： 在一个应用程序中出现的错误不会影响其他应用程序。能够在不停止整个进程的情况下停止单个应用程序。应用程序域形成了托管代码的隔离、卸载和安全边界。在任意给定时间，每一线程都在一个应用程序域中执行。 线程拥有自己的“程序计数器”用来记录下一条要执行的指令。 线程拥有自己的寄存器，保存着线程当前的工作变量 线程拥有自己的堆栈，用来记录执行历史其中每一帧记保存了一调用的但是还没有返回的过程 相关进程操作Process类在System.Diagnostics命名空间下 打印所有进程名 12345var processes = Process.GetProcesses(); foreach (var item in processes) &#123; Console.WriteLine(item.ProcessName); &#125; 启动关闭某进程 123var p = Process.Start(\"Notepad.exe\");Thread.Sleep(1000);p.Kill(); 通过AppDomain启动”新”进程(系统不会创建新的进程) 123Console.WriteLine(AppDomain.CurrentDomain.FriendlyName);var appDomain = AppDomain.CreateDomain(\"NewAppDomain\");appDomain.ExecuteAssembly(\"assemblyName\"); 线程操作见https://luox78.github.io/tags/thread/WinForm中跨线程访问控件1this.textBox.Invoke((delegate)method,params arguements); method可以为new Action&lt;string&gt;(methodName),根据传入的参数不同设置 案例：大文件拷贝显示进度条 new thread来进行拷贝，控件访问使用invoke Thread类的一些常用成员Start()启动线程，导致操作系统将当前实例的状态更改为 ThreadState.RunningAbort()终止线程,请求操作系统请终止该线程。Join()在继续执行之前，阻塞调用线程，直到某个线程终止为止。带参数的重载表示超时时间，如果超过超时时间，则线程不再阻塞继续执行。IsAlive如果此线程已启动并且尚未正常终止或中止，则为 true；否则为 false。IsBackground指示某个线程是否为后台线程。ManagedThreadId获取当前托管线程的唯一标识符。Priority获取或设置一个值，该值指示线程的调度优先级。ThreadState获取一个值，该值包含当前线程的状态。Name获取或设置线程的名称。","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://luox78.github.io/tags/线程/"}]},{"title":"细说 ASP.NET Cache 及其高级用法","slug":"cache","date":"2018-02-01T12:03:22.192Z","updated":"2018-02-03T05:40:45.773Z","comments":true,"path":"2018/02/01/cache/","link":"","permalink":"https://luox78.github.io/2018/02/01/cache/","excerpt":"许多做过程序性能优化的人，或者关注过程程序性能的人，应该都使用过各类缓存技术。 而我今天所说的Cache是专指ASP.NET的Cache，我们可以使用HttpRuntime.Cache访问到的那个Cache，而不是其它的缓存技术。 以前我在【我心目中的Asp.net核心对象】 这篇博客中简单地提过它，今天我打算为它写篇专题博客，专门来谈谈它，因为它实在是太重要了。在这篇博客中， 我不仅要介绍它的一些常见用法，还将介绍它的一些高级用法。 在上篇博客【在.net中读写config文件的各种方法】 的结尾处，我给大家留了一个问题，今天，我将在这篇博客中给出一个我认为较为完美的答案。 本文提到的【延迟操作】方法（如：延迟合并写入数据库）属于我的经验总结，希望大家能喜欢这个思路。","text":"许多做过程序性能优化的人，或者关注过程程序性能的人，应该都使用过各类缓存技术。 而我今天所说的Cache是专指ASP.NET的Cache，我们可以使用HttpRuntime.Cache访问到的那个Cache，而不是其它的缓存技术。 以前我在【我心目中的Asp.net核心对象】 这篇博客中简单地提过它，今天我打算为它写篇专题博客，专门来谈谈它，因为它实在是太重要了。在这篇博客中， 我不仅要介绍它的一些常见用法，还将介绍它的一些高级用法。 在上篇博客【在.net中读写config文件的各种方法】 的结尾处，我给大家留了一个问题，今天，我将在这篇博客中给出一个我认为较为完美的答案。 本文提到的【延迟操作】方法（如：延迟合并写入数据库）属于我的经验总结，希望大家能喜欢这个思路。回到顶部 Cache的基本用途提到Cache，不得不说说它的主要功能：改善程序性能。ASP.NET是一种动态页面技术，用ASP.NET技术做出来的网页几乎都是动态的，所谓动态是指：页面的内容会随着不同的用户或者持续更新的数据， 而呈现出不同的显示结果。既然是动态的，那么这些动态的内容是从哪里来的呢？我想绝大多数网站都有自己的数据源， 程序通过访问数据源获取页面所需的数据，然后根据一些业务规则的计算处理，最后变成适合页面展示的内容。 由于这种动态页面技术通常需要从数据源获取数据，并经过一些计算逻辑，最终变成一些HTML代码发给客户端显示。而这些计算过程显然也是有成本的。 这些处理成本最直接可表现为影响服务器的响应速度，尤其是当数据的处理过程变得复杂以及访问量变大时，会变得比较明显。 另一方面，有些数据并非时刻在发生变化，如果我们可以将一些变化不频繁的数据的最终计算结果（包括页面输出）缓存起来， 就可以非常明显地提升程序的性能，缓存的最常见且最重要的用途就体现在这个方面。 这也是为什么一说到性能优化时，一般都将缓存摆在第一位的原因。 我今天要说到的ASP.NET Cache也是可以实现这种缓存的一种技术。 不过，它还有其它的一些功能，有些是其它缓存技术所没有的。 回到顶部 Cache的定义在介绍Cache的用法前，我们先来看一下Cache的定义：（说明：我忽略了一些意义不大的成员） ;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 实现用于 Web 应用程序的缓存。无法继承此类。public sealed class Cache : IEnumerable&#123; // 用于 Cache.Insert(...) 方法调用中的 absoluteExpiration 参数中以指示项从不过期。 public static readonly DateTime NoAbsoluteExpiration; // 用作 Cache.Insert(...) 或 Cache.Add(...) // 方法调用中的 slidingExpiration 参数，以禁用可调过期。 public static readonly TimeSpan NoSlidingExpiration; // 获取或设置指定键处的缓存项。 public object this[string key] &#123; get; set; &#125; // 将指定项添加到 System.Web.Caching.Cache 对象，该对象具有依赖项、过期和优先级策略 // 以及一个委托（可用于在从 Cache 移除插入项时通知应用程序）。 public object Add(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration, CacheItemPriority priority, CacheItemRemovedCallback onRemoveCallback); // 从 System.Web.Caching.Cache 对象检索指定项。 // key: 要检索的缓存项的标识符。 // 返回结果: 检索到的缓存项，未找到该键时为 null。 public object Get(string key); public void Insert(string key, object value); public void Insert(string key, object value, CacheDependency dependencies); public void Insert(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration); // 摘要: // 向 System.Web.Caching.Cache 对象中插入对象，后者具有依赖项、过期和优先级策略 // 以及一个委托（可用于在从 Cache 移除插入项时通知应用程序）。 // // 参数: // key: // 用于引用该对象的缓存键。 // // value: // 要插入缓存中的对象。 // // dependencies: // 该项的文件依赖项或缓存键依赖项。当任何依赖项更改时，该对象即无效， // 并从缓存中移除。如果没有依赖项，则此参数包含 null。 // // absoluteExpiration: // 所插入对象将过期并被从缓存中移除的时间。 // 如果使用绝对过期，则 slidingExpiration 参数必须为 Cache.NoSlidingExpiration。 // // slidingExpiration: // 最后一次访问所插入对象时与该对象过期时之间的时间间隔。如果该值等效于 20 分钟， // 则对象在最后一次被访问 20 分钟之后将过期并被从缓存中移除。如果使用可调过期，则 // absoluteExpiration 参数必须为 System.Web.Caching.Cache.NoAbsoluteExpiration。 // // priority: // 该对象相对于缓存中存储的其他项的成本，由 System.Web.Caching.CacheItemPriority 枚举表示。 // 该值由缓存在退出对象时使用；具有较低成本的对象在具有较高成本的对象之前被从缓存移除。 // // onRemoveCallback: // 在从缓存中移除对象时将调用的委托（如果提供）。 // 当从缓存中删除应用程序的对象时，可使用它来通知应用程序。 // // 异常: // System.ArgumentException: // 为要添加到 Cache 中的项设置 absoluteExpiration 和 slidingExpiration 参数。 // // System.ArgumentNullException: // key 或 value 参数为 null。 // // System.ArgumentOutOfRangeException: // 将 slidingExpiration 参数设置为小于 TimeSpan.Zero 或大于一年的等效值。 public void Insert(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration, CacheItemPriority priority, CacheItemRemovedCallback onRemoveCallback); // 从应用程序的 System.Web.Caching.Cache 对象移除指定项。 public object Remove(string key); // 将对象与依赖项策略、到期策略和优先级策略 // 以及可用来在从缓存中移除项【之前】通知应用程序的委托一起插入到 Cache 对象中。 // 注意：此方法受以下版本支持：3.5 SP1、3.0 SP1、2.0 SP1 public void Insert(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration, CacheItemUpdateCallback onUpdateCallback);&#125; ASP.NET为了方便我们访问Cache，在HttpRuntime类中加了一个静态属性Cache，这样，我们就可以在任意地方使用Cache的功能。 而且，ASP.NET还给它增加了二个“快捷方式”：Page.Cache, HttpContext.Cache，我们通过这二个对象也可以访问到HttpRuntime.Cache， 注意：这三者是在访问同一个对象。Page.Cache访问了HttpContext.Cache，而HttpContext.Cache又直接访问HttpRuntime.Cache 回到顶部 Cache常见用法通常，我们使用Cache时，一般只有二个操作：读，写。要从Cache中获取一个缓存项，我们可以调用Cache.Get(key)方法，要将一个对象放入缓存，我们可以调用Add, Insert方法。 然而，Add, Insert方法都有许多参数，有时我们或许只是想简单地放入缓存，一切接受默认值，那么还可以调用它的默认索引器， 我们来看一下这个索引器是如何工作的： 1234567891011public object this[string key]&#123; get &#123; return this.Get(key); &#125; set &#123; this.Insert(key, value); &#125;&#125; 可以看到：读缓存，其实是在调用Get方法，而写缓存则是在调用Insert方法的最简单的那个重载版本。 注意了：Add方法也可以将一个对象放入缓存，这个方法有7个参数，而Insert也有一个签名类似的重载版本， 它们有着类似的功能：将指定项添加到 System.Web.Caching.Cache 对象，该对象具有依赖项、过期和优先级策略以及一个委托（可用于在从 Cache 移除插入项时通知应用程序）。 然而，它们有一点小的区别：当要加入的缓存项已经在Cache中存在时，Insert将会覆盖原有的缓存项目，而Add则不会修改原有缓存项。 也就是说：如果您希望某个缓存项目一旦放入缓存后，就不要再被修改，那么调用Add确实可以防止后来的修改操作。 而调用Insert方法，则永远会覆盖已存在项（哪怕以前是调用Add加入的）。 从另一个角度看，Add的效果更像是 static readonly 的行为，而Insert的效果则像 static 的行为。注意：我只是说【像】，事实上它们比一般的static成员有着更灵活的用法。 由于缓存项可以让我们随时访问，看起来确实有点static成员的味道，但它们有着更高级的特性，比如： 缓存过期（绝对过期，滑动过期），缓存依赖（依赖文件，依赖其它缓存项），移除优先级，缓存移除前后的通知等等。 后面我将会分别介绍这四大类特性。 回到顶部 Cache类的特点Cache类有一个很难得的优点，用MSDN上的说话就是： 此类型是线程安全的。 为什么这是个难得的优点呢？因为在.net中，绝大多数类在实现时，都只是保证静态类型的方法是线程安全， 而不考虑实例方法是线程安全。这也算是一条基本的.NET设计规范原则。对于那些类型，MSDN通常会用这样的话来描述： 此类型的公共静态（在 Visual Basic 中为 Shared）成员是线程安全的。但不能保证任何实例成员是线程安全的。 所以，这就意味着我们可以在任何地方读写Cache都不用担心Cache的数据在多线程环境下的数据同步问题。 多线程编程中，最复杂的问题就是数据的同步问题，而Cache已经为我们解决了这些问题。 不过我要提醒您：ASP.NET本身就是一个多线程的编程模型，所有的请求是由线程池的线程来处理的。 通常，我们在多线程环境中为了解决数据同步问题，一般是采用锁来保证数据同步， 自然地，ASP.NET也不例外，它为了解决数据的同步问题，内部也是采用了锁。 说到这里，或许有些人会想：既然只一个Cache的静态实例，那么这种锁会不会影响并发？答案是肯定的，有锁肯定会在一定程度上影响并发，这是没有办法的事情。然而，ASP.NET在实现Cache时，会根据CPU的个数创建多个缓存容器，尽量可能地减小冲突， 以下就是Cache创建的核心过程：;) 12345678910111213141516171819202122internal static CacheInternal Create()&#123; CacheInternal internal2; int numSingleCaches = 0; if( numSingleCaches == 0 ) &#123; uint numProcessCPUs = (uint)SystemInfo.GetNumProcessCPUs(); numSingleCaches = 1; for( numProcessCPUs -= 1; numProcessCPUs &gt; 0; numProcessCPUs = numProcessCPUs &gt;&gt; 1 ) &#123; numSingleCaches = numSingleCaches &lt;&lt; 1; &#125; &#125; CacheCommon cacheCommon = new CacheCommon(); if( numSingleCaches == 1 ) &#123; internal2 = new CacheSingle(cacheCommon, null, 0); &#125; else &#123; internal2 = new CacheMultiple(cacheCommon, numSingleCaches); &#125; cacheCommon.SetCacheInternal(internal2); cacheCommon.ResetFromConfigSettings(); return internal2;&#125; 说明：CacheInternal是个内部用的包装类，Cache的许多操作都要由它来完成。 在上面的代码中，numSingleCaches的计算过程很重要，如果上面代码不容易理解，那么请看我下面的示例代码： ;) 12345678910111213static void Main()&#123; for( uint i = 1; i &lt;= 20; i++ ) ShowCount(i); &#125;static void ShowCount(uint numProcessCPUs)&#123; int numSingleCaches = 1; for( numProcessCPUs -= 1; numProcessCPUs &gt; 0; numProcessCPUs = numProcessCPUs &gt;&gt; 1 ) &#123; numSingleCaches = numSingleCaches &lt;&lt; 1; &#125; Console.Write(numSingleCaches + \",\");&#125; 程序将会输出： 1,2,4,4,8,8,8,8,16,16,16,16,16,16,16,16,32,32,32,32 CacheMultiple的构造函数如下：;) 123456789internal CacheMultiple(CacheCommon cacheCommon, int numSingleCaches) : base(cacheCommon)&#123; this._cacheIndexMask = numSingleCaches - 1; this._caches = new CacheSingle[numSingleCaches]; for (int i = 0; i &lt; numSingleCaches; i++) &#123; this._caches[i] = new CacheSingle(cacheCommon, this, i); &#125;&#125; 现在您应该明白了吧：CacheSingle其实是ASP.NET内部使用的缓存容器，多个CPU时，它会创建多个缓存容器。在写入时，它是如何定位这些容器的呢？请继续看代码：;) 123456internal CacheSingle GetCacheSingle(int hashCode)&#123; hashCode = Math.Abs(hashCode); int index = hashCode &amp; this._cacheIndexMask; return this._caches[index];&#125; 说明：参数中的hashCode是直接调用我们传的key.GetHashCode() ，GetHashCode是由Object类定义的。 所以，从这个角度看，虽然ASP.NET的Cache只有一个HttpRuntime.Cache静态成员，但它的内部却可能会包含多个缓存容器， 这种设计可以在一定程度上减少并发的影响。 不管如何设计，在多线程环境下，共用一个容器，冲突是免不了的。如果您只是希望简单的缓存一些数据， 不需要Cache的许多高级特性，那么，可以考虑不用Cache 。 比如：可以创建一个Dictionary或者Hashtable的静态实例，它也可以完成一些基本的缓存工作， 不过，我要提醒您：您要自己处理多线程访问数据时的数据同步问题。顺便说一句：Hashtable.Synchronized(new Hashtable())也是一个线程安全的集合，如果想简单点，可以考虑它。 接下来，我们来看一下Cache的高级特性，这些都是Dictionary或者Hashtable不能完成的。 回到顶部 缓存项的过期时间ASP.NET支持二种缓存项的过期策略：绝对过期和滑动过期。\\1. 绝对过期，这个容易理解：就是在缓存放入Cache时，指定一个具体的时间。当时间到达指定的时间的时，缓存项自动从Cache中移除。\\2. 滑动过期：某些缓存项，我们可能只希望在有用户在访问时，就尽量保留在缓存中，只有当一段时间内用户不再访问该缓存项时，才移除它， 这样可以优化内存的使用，因为这种策略可以保证缓存的内容都是【很热门】的。 操作系统的内存以及磁盘的缓存不都是这样设计的吗？而这一非常有用的特性，Cache也为我们准备好了，只要在将缓存项放入缓存时， 指定一个滑动过期时间就可以实现了。 以上二个选项分别对应Add, Insert方法中的DateTime absoluteExpiration, TimeSpan slidingExpiration这二个参数。注意：这二个参数都是成对使用的，但不能同时指定它们为一个【有效】值，最多只能一个参数值有效。 当不使用另一个参数项时，请用Cache类定义二个static readonly字段赋值。 这二个参数比较简单，我就不多说了，只说一句：如果都使用Noxxxxx这二个选项，那么缓存项就一直保存在缓存中。（或许也会被移除） 回到顶部 缓存项的依赖关系 - 依赖其它缓存项ASP.NET Cache有个很强大的功能，那就是缓存依赖。一个缓存项可以依赖于另一个缓存项。 以下示例代码创建了二个缓存项，且它们间有依赖关系。首先请看页面代码： ;) 123456789&lt;body&gt; &lt;p&gt;Key1 的缓存内容：&lt;%= HttpRuntime.Cache[\"key1\"] %&gt;&lt;/p&gt; &lt;hr /&gt; &lt;form action=\"CacheDependencyDemo.aspx\" method=\"post\"&gt; &lt;input type=\"submit\" name=\"SetKey1Cache\" value=\"设置Key1的值\" /&gt; &lt;input type=\"submit\" name=\"SetKey2Cache\" value=\"设置Key2的值\" /&gt; &lt;/form&gt;&lt;/body&gt; 页面后台代码：;) 123456789101112131415161718public partial class CacheDependencyDemo : System.Web.UI.Page&#123; [SubmitMethod(AutoRedirect=true)] private void SetKey1Cache() &#123; SetKey2Cache(); CacheDependency dep = new CacheDependency(null, new string[] &#123; \"key2\" &#125;); HttpRuntime.Cache.Insert(\"key1\", DateTime.Now.ToString(), dep, Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration); &#125; [SubmitMethod(AutoRedirect=true)] private void SetKey2Cache() &#123; HttpRuntime.Cache.Insert(\"key2\", Guid.NewGuid().ToString()); &#125;&#125; 当运行这个示例页面时，运行结果如下图所示， 点击按钮【设置Key1的值】时，将会出现缓存项的内容（左图）。点击按钮【设置Key2的值】时，此时将获取不到缓存项的内容（右图）。 根据结果并分析代码，我们可以看出，在创建Key1的缓存项时，我们使用了这种缓存依赖关系： 1CacheDependency dep = new CacheDependency(null, new string[] &#123; \"key2\" &#125;); 所以，当我们更新Key2的缓存项时，Key1的缓存就失效了（不存在）。 不要小看了这个示例。的确，仅看这几行示例代码，或许它们实在是没有什么意义。 那么，我就举个实际的使用场景来说明它的使用价值。 上面这幅图是我写的一个小工具。在示意图中，左下角是一个缓存表CacheTable，它由一个叫Table1BLL的类来维护。 CacheTable的数据来源于Table1，由Table1.aspx页面显示出来。 同时，ReportA, ReportB的数据也主要来源于Table1，由于Table1的访问几乎绝大多数都是读多写少，所以，我将Table1的数据缓存起来了。 而且，ReportA, ReportB这二个报表采用GDI直接画出（由报表模块生成，可认是Table1BLL的上层类），鉴于这二个报表的浏览次数较多且数据源是读多写少， 因此，这二个报表的输出结果，我也将它们缓存起来。 在这个场景中，我们可以想像一下：如果希望在Table1的数据发生修改后，如何让二个报表的缓存结果失效？让Table1BLL去通知那二个报表模块，还是Table1BLL去直接删除二个报表的缓存？其实，不管是选择前者还是后者，当以后还需要在Table1的CacheTable上做其它的缓存实现时（可能是其它的新报表）， 那么，势必都要修改Table1BLL，那绝对是个失败的设计。 这也算是模块间耦合的所带来的恶果。 幸好，ASP.NET Cache支持一种叫做缓存依赖的特性，我们只需要让Table1BLL公开它缓存CacheTable的KEY就可以了（假设KEY为 CacheTableKey）， 然后，其它的缓存结果如果要基于CacheTable，设置一下对【CacheTableKey】的依赖就可以实现这样的效果： 当CacheTable更新后，被依赖的缓存结果将会自动清除。这样就彻底地解决了模块间的缓存数据依赖问题。 回到顶部 缓存项的依赖关系 - 文件依赖在上篇博客【在.net中读写config文件的各种方法】的结尾， 我给大家留了一个问题：我希望在用户修改了配置文件后，程序能立刻以最新的参数运行，而且不用重启网站。今天我就来回答这个问题，并给出所需的全部实现代码。 首先，我要说明一点：上次博客的问题，虽然解决方案与Cache的文件依赖有关，但还需与缓存的移除通知配合使用才能完美的解决问题。 为了便于内容的安排，我先使用Cache的文件依赖来简单的实现一个粗糙的版本，在本文的后续部分再来完善这个实现。 先来看个粗糙的版本。假如我的网站中有这样一个配置参数类型： ;) 12345678/// &lt;summary&gt;/// 模拟网站所需的运行参数/// &lt;/summary&gt;public class RunOptions&#123; public string WebSiteUrl; public string UserName;&#125; 我可以将它配置在这样一个XML文件中： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RunOptions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"&gt; &lt;WebSiteUrl&gt;http://www.cnblogs.com/fish-li&lt;/WebSiteUrl&gt; &lt;UserName&gt;fish li&lt;/UserName&gt;&lt;/RunOptions&gt; 再来一个用于显示运行参数的页面： ;) 1234&lt;body&gt; &lt;p&gt;WebSiteUrl: &lt;%= WebSiteApp.RunOptions.WebSiteUrl %&gt;&lt;/p&gt; &lt;p&gt;UserName: &lt;%= WebSiteApp.RunOptions.UserName %&gt;&lt;/p&gt;&lt;/body&gt; 下面的代码就可以实现：在XML修改后，浏览页面就能立即看到最新的参数值： ;) 12345678910111213141516171819202122232425public static class WebSiteApp&#123; private static readonly string RunOptionsCacheKey = Guid.NewGuid().ToString(); public static RunOptions RunOptions &#123; get &#123; // 首先尝试从缓存中获取运行参数 RunOptions options = HttpRuntime.Cache[RunOptionsCacheKey] as RunOptions; if( options == null ) &#123; // 缓存中没有，则从文件中加载 string path = HttpContext.Current.Server.MapPath(\"~/App_Data/RunOptions.xml\"); options = RwConfigDemo.XmlHelper.XmlDeserializeFromFile&lt;RunOptions&gt;(path, Encoding.UTF8); // 把从文件中读到的结果放入缓存，并设置与文件的依赖关系。 CacheDependency dep = new CacheDependency(path); // 如果您的参数较复杂，与多个文件相关，那么也可以使用下面的方式，传递多个文件路径。 //CacheDependency dep = new CacheDependency(new string[] &#123; path &#125;); HttpRuntime.Cache.Insert(RunOptionsCacheKey, options, dep); &#125; return options; &#125; &#125;&#125; 注意：这里仍然是在使用CacheDependency，只是我们现在是给它的构造函数的第一个参数传递要依赖的文件名。 在即将结束对缓存的依赖介绍之前，还要补充二点：\\1. CacheDependency还支持【嵌套】，即：CacheDependency的构造函数中支持传入其它的CacheDependency实例，这样可以构成一种非常复杂的树状依赖关系。\\2. 缓存依赖的对象还可以是SQL SERVER，具体可参考SqlCacheDependency 回到顶部 缓存项的移除优先级缓存的做法有很多种，一个静态变量也可以称为是一个缓存。一个静态的集合就是一个缓存的容器了。 我想很多人都用Dictionary，List，或者Hashtable做过缓存容器，我们可以使用它们来保存各种数据，改善程序的性能。 一般情况下，如果我们直接使用这类集合去缓存各类数据，那么，那些数据所占用的内存将不会被回收，哪怕它们的使用机会并不是很多。 当缓存数据越来越多时，它们所消耗的内存自然也会越来越多。那么，能不能在内存不充足时，释放掉一些访问不频繁的缓存项呢？ 这个问题也确实是个较现实的问题。虽然，使用缓存会使用程序运行更快，但是，我们数据会无限大，不可能统统缓存起来， 毕竟，内存空间是有限的。因此，我们可以使用前面所说的基于一段时间内不再访问就删除的策略来解决这个问题。 然而，在我们编码时，根本不知道我们的程序会运行在什么配置标准的计算机上，因此，根本不可能会对内存的大小作出任何假设， 此时，我们可能会希望当缓存占用过多的内存时，且当内存不够时，能自动移除一些不太重要的缓存项，这或许也比较有意义。 对于这个需求，在.net framework提供了二种解决办法，一种是使用WeakReference类，另一种是使用Cache 。 不过，既然我们是在使用ASP.NET，选择Cache当然会更方便。 在Cache的Add, Insert方法的某些重载版本中，可以指定缓存项的保存优先级策略，由参数CacheItemPriority priority来传入。 其中，CacheItemPriority是一个枚举类型，它包含了如下枚举值： ;) 1234567891011121314151617181920212223242526272829// 指定 Cache 对象中存储的项的相对优先级。public enum CacheItemPriority&#123; // 在服务器释放系统内存时，具有该优先级级别的缓存项最有可能被从缓存删除。 Low = 1, // 在服务器释放系统内存时，具有该优先级级别的缓存项比分配了 CacheItemPriority.Normal // 优先级的项更有可能被从缓存删除。 BelowNormal = 2, // 在服务器释放系统内存时，具有该优先级级别的缓存项很有可能被从缓存删除， // 其被删除的可能性仅次于具有 CacheItemPriority.Low // 或 CacheItemPriority.BelowNormal 优先级的那些项。这是默认选项。 Normal = 3, // 缓存项优先级的默认值为 CacheItemPriority.Normal。 Default = 3, // 在服务器释放系统内存时，具有该优先级级别的缓存项被删除的可能性 // 比分配了 CacheItemPriority.Normal 优先级的项要小。 AboveNormal = 4, // 在服务器释放系统内存时，具有该优先级级别的缓存项最不可能被从缓存删除。 High = 5, // 在服务器释放系统内存时，具有该优先级级别的缓存项将不会被自动从缓存删除。 // 但是，具有该优先级级别的项会根据项的绝对到期时间或可调整到期时间与其他项一起被移除。 NotRemovable = 6,&#125; 说明：当我们调用Cache的Add, Insert方法时，如果不指定CacheItemPriority选项，最终使用Normal所代表的优先级。 如果我们希望将某个可能不太重要的数据放入缓存时，可以指定优先级为Low或者BelowNormal。 如果想让缓存项在内存不足时，也不会被移除（除非到期或者依赖项有改变），可使用NotRemovable。 显然，我们可以使用这个特性来控制缓存对内存压力的影响。 其它的缓存方案，如static Collection + WeakReference也较难实现这样灵活的控制。 回到顶部 缓存项的移除通知ASP.NET Cache与一些static变量所实现的缓存效果并不相同，它的缓存项是可以根据一些特定的条件失效的，那些失效的缓存将会从内存中移除。 虽然，某些移除条件并不是由我们的代码直接解发的，但ASP.NET还是提供一种方法让我们可以在缓存项在移除时，能通知我们的代码。 注意哦：ASP.NET Cache支持移除【前】通知 和 移除【后】通知二种通知方式。 我们可以在调用Add, Insert方法时，通过参数onRemoveCallback传递一个CacheItemRemovedCallback类型的委托，以便在移除指定的缓存项时， 能够通知我们。这个委托的定义如下： ;) 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 定义在从 System.Web.Caching.Cache 移除缓存项时通知应用程序的回调方法。/// &lt;/summary&gt;/// &lt;param name=\"key\"&gt;从缓存中移除的键（当初由Add, Insert传入的）。&lt;/param&gt;/// &lt;param name=\"value\"&gt;与从缓存中移除的键关联的缓存项（当初由Add, Insert传入的）。&lt;/param&gt;/// &lt;param name=\"reason\"&gt;从缓存移除项的原因。 &lt;/param&gt;public delegate void CacheItemRemovedCallback(string key, object value, CacheItemRemovedReason reason);// 指定从 System.Web.Caching.Cache 对象移除项的原因。public enum CacheItemRemovedReason&#123; // 该项是通过指定相同键的 Cache.Insert(System.String,System.Object) // 方法调用或 Cache.Remove(System.String) 方法调用从缓存中移除的。 Removed = 1, // 从缓存移除该项的原因是它已过期。 Expired = 2, // 之所以从缓存中移除该项，是因为系统要通过移除该项来释放内存。 Underused = 3, // 从缓存移除该项的原因是与之关联的缓存依赖项已更改。 DependencyChanged = 4,&#125; 委托的各个参数的含义以及移除原因，在注释中都有明确的解释，我也不再重复了。我想：有很多人知道Cache的Add, Insert方法有这个参数，也知道有这个委托，但是，它们有什么用呢？ 在后面的二个小节中，我将提供二个示例来演示这一强大的功能。 通常，我们会以下面这种方式从Cache中获取结果： 12345678RunOptions options = HttpRuntime.Cache[RunOptionsCacheKey] as RunOptions;if( options == null ) &#123; // 缓存中没有，则从文件中加载 // .................................. HttpRuntime.Cache.Insert(RunOptionsCacheKey, options, dep);&#125;return options; 这其实也是一个惯用法了：先尝试从缓存中获取，如果没有，则从数据源中加载，并再次放入缓存。 为什么会在访问Cache时返回null呢？答案无非就是二种原因：1. 根本没有放入Cache，2. 缓存项失效被移除了。这种写法本身是没有问题，可是，如果从数据源中加载数据的时间较长，情况会怎样呢？显然，会影响后面第一次的访问请求。您有没有想过，如果缓存项能一直放在Cache中，那不就可以了嘛。 是的，通常来说，只要您在将一个对象放入Cache时，不指定过期时间，不指定缓存依赖，且设置为永不移除，那么对象确实会一直在Cache中， 可是，过期时间和缓存依赖也很有用哦。如何能二者兼得呢？ 为了解决这个问题，微软在.net framework的3.5 SP1、3.0 SP1、2.0 SP1版本中，加入了【移除前通知】功能，不过，这个方法仅受Insert支持， 随之而来的还有一个委托和一个移除原因的枚举定义： ;) 1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 定义一个回调方法，用于在从缓存中移除缓存项之前通知应用程序。/// &lt;/summary&gt;/// &lt;param name=\"key\"&gt;要从缓存中移除的项的标识符。&lt;/param&gt;/// &lt;param name=\"reason\"&gt;要从缓存中移除项的原因。&lt;/param&gt;/// &lt;param name=\"expensiveObject\"&gt;此方法返回时，包含含有更新的缓存项对象。&lt;/param&gt;/// &lt;param name=\"dependency\"&gt;此方法返回时，包含新的依赖项的对象。&lt;/param&gt;/// &lt;param name=\"absoluteExpiration\"&gt;此方法返回时，包含对象的到期时间。&lt;/param&gt;/// &lt;param name=\"slidingExpiration\"&gt;此方法返回时，包含对象的上次访问时间和对象的到期时间之间的时间间隔。&lt;/param&gt;public delegate void CacheItemUpdateCallback(string key, CacheItemUpdateReason reason, out object expensiveObject, out CacheDependency dependency, out DateTime absoluteExpiration, out TimeSpan slidingExpiration);/// &lt;summary&gt;/// 指定要从 Cache 对象中移除缓存项的原因。/// &lt;/summary&gt;public enum CacheItemUpdateReason&#123; /// &lt;summary&gt; /// 指定要从缓存中移除项的原因是绝对到期或可调到期时间间隔已到期。 /// &lt;/summary&gt; Expired = 1, /// &lt;summary&gt; /// 指定要从缓存中移除项的原因是关联的 CacheDependency 对象发生了更改。 /// &lt;/summary&gt; DependencyChanged = 2,&#125; 注意：CacheItemUpdateReason这个枚举只有二项。原因请看MSDN的解释： 与 CacheItemRemovedReason 枚举不同，此枚举不包含 Removed 或 Underused 值。可更新的缓存项是不可移除的，因而绝不会被 ASP.NET 自动移除，即使需要释放内存也是如此。 再一次提醒：有时我们确实需要缓存失效这个特性，但是，缓存失效后会被移除。 虽然我们可以让后续的请求在获取不到缓存数据时，从数据源中加载，也可以在CacheItemRemovedCallback回调委托中， 重新加载缓存数据到Cache中，但是在数据的加载过程中，Cache并不包含我们所期望的缓存数据，如果加载时间越长，这种【空缺】效果也会越明显。 这样会影响（后续的）其它请求的访问。为了保证让我们所期望的缓存数据能够一直存在于Cahce中，且仍有失效机制，我们可以使用【移除前通知】功能。 回到顶部 巧用缓存项的移除通知 实现【延迟操作】我看过一些ASP.NET的书，也看过一些人写的关于Cache方面的文章，基本上，要么是一带而过，要么只是举个毫无实际意义的示例。 可惜啊，这么强大的特性，我很少见到有人把它用起来。 今天，我就举个有实际意义的示例，再现Cache的强大功能！ 我有这样一个页面，可以让用户调整（上下移动）某个项目分支记录的上线顺序： 当用户需要调整某条记录的位置时，页面会弹出一个对话框，要求输入一个调整原因，并会发邮件通知所有相关人员。 由于界面的限制，一次操作（点击上下键头）只是将一条记录移动一个位置，当要对某条记录执行跨越多行移动时，必须进行多次移动。 考虑到操作的方便性以及不受重复邮件的影响，程序需要实现这样一个需求： 页面只要求输入一次原因便可以对一条记录执行多次移动操作，并且不要多次发重复邮件，而且要求将最后的移动结果在邮件中发出来。 这个需求很合理，毕竟谁都希望操作简单。 那么如何实现这个需求呢？这里要从二个方面来实现，首先，在页面上我们应该要完成这个功能，对一条记录只弹一次对话框。 由于页面与服务端的交互全部采用Ajax方式进行（不刷新），状态可以采用JS变量来维持，所以这个功能在页面中是很容易实现。 再来看一下服务端，由于服务端并没有任何状态，当然也可以由页面把它的状态传给服务端，但是，哪次操作是最后一次呢？ 显然，这是无法知道的，最后只能修改需求，如果用户在2分钟之内不再操作某条记录时，便将最近一次操作视为最后一次操作。 基于新的需求，程序必须记录用户的最近一次操作，以便在2分钟不操作后，发出一次邮件，但要包含第一次输入的原因， 还应包含最后的修改结果哦。 该怎么实现这个需求呢？ 我立即就想到了ASP.NET Cache，因为我了解它，知道它能帮我完成这个功能。下面我来说说在服务端是如何实现的。 整个实现的思路是：\\1. 客户端页面还是每次将记录的RowGuid, 调整方向，调整原因，这三个参数发到服务端。\\2. 服务端在处理完顺序调整操作后，将要发送的邮件信息Insert到Cache中，同时提供slidingExpiration和onRemoveCallback参数。\\3. 在CacheItemRemovedCallback回调委托中，忽略CacheItemRemovedReason.Removed的通知，如果是其它的通知，则发邮件。 为了便于理解，我特意为大家准备了一个示例。整个示例由三部分组成：一个页面，一个JS文件，服务端代码。先来看页面代码： ;) 1234567891011&lt;body&gt; &lt;p&gt; 为了简单，示例页面只处理一条记录，且将记录的RowGuid直接显示出来。&lt;br /&gt; 实际场景中，这个RowGuid应该可以从一个表格的【当前选择行】中获取到。 &lt;/p&gt; &lt;p&gt; 当前选择行的 RowGuid = &lt;span id=\"spanRowGuid\"&gt;&lt;%= Guid.NewGuid().ToString() %&gt;&lt;/span&gt;&lt;br /&gt; 当前选择行的 Sequence= &lt;span id=\"spanSequence\"&gt;0&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btnMoveUp\" value=\"上移\" /&gt; &lt;input type=\"button\" id=\"btnMoveDown\" value=\"下移\" /&gt; &lt;/p&gt;&lt;/body&gt; 页面的显示效果如下： 处理页面中二个按钮的JS代码如下： ;) 12345678910111213141516171819202122232425262728293031// 用户输入的调整记录的原因var g_reason = null;$(function()&#123; $(\"#btnMoveUp\").click( function() &#123; MoveRec(-1); &#125; ); $(\"#btnMoveDown\").click( function() &#123; MoveRec(1); &#125; );&#125;);function MoveRec(direction)&#123; if( ~~($(\"#spanSequence\").text()) + direction &lt; 0 )&#123; alert(\"已经不能上移了。\"); return; &#125; if( g_reason == null )&#123; g_reason = prompt(\"请输入调整记录顺序的原因：\", \"由于什么什么原因，我要调整...\"); if( g_reason == null ) return; &#125; $.ajax(&#123; url: \"/AjaxDelaySendMail/MoveRec.fish\", data: &#123; RowGuid: $(\"#spanRowGuid\").text(), Direction: direction, Reason: g_reason &#125;, type: \"POST\", dataType: \"text\", success: function(responseText)&#123; $(\"#spanSequence\").text(responseText); &#125; &#125;);&#125; 说明：在服务端，我使用了我在【用Asp.net写自己的服务框架】那篇博客中提供的服务框架， 服务端的全部代码是这个样子的：（注意代码中的注释） ;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/// &lt;summary&gt;/// 移动记录的相关信息。/// &lt;/summary&gt;public class MoveRecInfo&#123; public string RowGuid; public int Direction; public string Reason;&#125;[MyService]public class AjaxDelaySendMail&#123; [MyServiceMethod] public int MoveRec(MoveRecInfo info) &#123; // 这里就不验证从客户端传入的参数了。实际开发中这个是必须的。 // 先来调整记录的顺序，示例程序没有数据库，就用Cache来代替。 int sequence = 0; int.TryParse(HttpRuntime.Cache[info.RowGuid] as string, out sequence); // 简单地示例一下调整顺序。 sequence += info.Direction; HttpRuntime.Cache[info.RowGuid] = sequence.ToString(); string key = info.RowGuid +\"_DelaySendMail\"; // 这里我不直接发邮件，而是把这个信息放入Cache中，并设置2秒的滑过过期时间，并指定移除通知委托 // 将操作信息放在缓存，并且以覆盖形式放入，这样便可以实现保存最后状态。 // 注意：这里我用Insert方法。 HttpRuntime.Cache.Insert(key, info, null, Cache.NoAbsoluteExpiration, TimeSpan.FromMinutes(2.0), CacheItemPriority.NotRemovable, MoveRecInfoRemovedCallback); return sequence; &#125; private void MoveRecInfoRemovedCallback(string key, object value, CacheItemRemovedReason reason) &#123; if( reason == CacheItemRemovedReason.Removed ) return; // 忽略后续调用HttpRuntime.Cache.Insert()所触发的操作 // 能运行到这里，就表示是肯定是缓存过期了。 // 换句话说就是：用户2分钟再也没操作过了。 // 从参数value取回操作信息 MoveRecInfo info = (MoveRecInfo)value; // 这里可以对info做其它的处理。 // 最后发一次邮件。整个延迟发邮件的过程就处理完了。 MailSender.SendMail(info); &#125;&#125; 为了能让JavaScript能直接调用C#中的方法，还需要在web.config中加入如下配置： 123&lt;httpHandlers&gt; &lt;add path=\"*.fish\" verb=\"*\" validate=\"false\" type=\"MySimpleServiceFramework.AjaxServiceHandler\"/&gt;&lt;/httpHandlers&gt; 好了，示例代码就是这些。如果您有兴趣，可以在本文的结尾处下载这些示例代码，自己亲自感受一下利用Cache实现的【延迟处理】的功能。 其实这种【延迟处理】的功能是很有用的，比如还有一种适用场景：有些数据记录可能需要频繁更新，如果每次更新都去写数据库，肯定会对数据库造成一定的压力， 但由于这些数据也不是特别重要，因此，我们可以利用这种【延迟处理】来将写数据库的时机进行合并处理， 最终我们可以实现：将多次的写入变成一次或者少量的写入操作，我称这样效果为：延迟合并写入 这里我就对数据库的延迟合并写入提供一个思路：将需要写入的数据记录放入Cache，调用Insert方法并提供slidingExpiration和onRemoveCallback参数， 然后在CacheItemRemovedCallback回调委托中，模仿我前面的示例代码，将多次变成一次。不过，这样可能会有一个问题：如果数据是一直在修改，那么就一直不会写入数据库。 最后如果网站重启了，数据可能会丢失。如果担心这个问题，那么，可以在回调委托中，遇到CacheItemRemovedReason.Removed时，使用计数累加的方式，当到达一定数量后， 再写入数据库。比如：遇到10次CacheItemRemovedReason.Removed我就写一次数据库，这样就会将原来需要写10次的数据库操作变成一次了。 当然了，如果是其它移除原因，写数据库总是必要的。注意：对于金额这类敏感的数据，绝对不要使用这种方法。 再补充二点：\\1. 当CacheItemRemovedCallback回调委托被调用时，缓存项已经不在Cache中了。\\2. 在CacheItemRemovedCallback回调委托中，我们还可以将缓存项重新放入缓存。有没有想过：这种设计可以构成一个循环？如果再结合参数slidingExpiration便可实现一个定时器的效果。 关于缓存的失效时间，我要再提醒一点：通过absoluteExpiration, slidingExpiration参数所传入的时间，当缓存时间生效时，缓存对象并不会立即移除， ASP.NET Cache大约以20秒的频率去检查这些已过时的缓存项。 回到顶部 巧用缓存项的移除通知 实现【自动加载配置文件】在本文的前部分的【文件依赖】小节中，有一个示例演示了：当配置文件更新后，页面可以显示最新的修改结果。 在那个示例中，为了简单，我直接将配置参数放在Cache中，每次使用时再从Cache中获取。 如果配置参数较多，这种做法或许也会影响性能，毕竟配置参数并不会经常修改，如果能直接访问一个静态变量就能获取到，应该会更快。 通常，我们可能会这样做： ;) 12345678910111213private static RunOptions s_RunOptions;public static RunOptions RunOptions&#123; // s_RunOptions 的初始化放在Init方法中了，会在Global.asax的Application_Start事件中调用。 get &#123; return s_RunOptions; &#125;&#125;public static RunOptions LoadRunOptions()&#123; string path = Path.Combine(AppDataPath, \"RunOptions.xml\"); return RwConfigDemo.XmlHelper.XmlDeserializeFromFile&lt;RunOptions&gt;(path, Encoding.UTF8);&#125; 但是，这种做法有一缺点就是：不能在配置文件更新后，自动加载最新的配置结果。 为了解决这个问题，我们可以使用Cache提供的文件依赖以及移除通知功能。 前面的示例演示了移除后通知功能，这里我再演示一下移除前通知功能。说明：事实上，完成这个功能，可以仍然使用移除后通知，只是移除前通知我还没有演示，然而，这里使用移除前通知并没有显示它的独有的功能。 下面的代码演示了在配置文件修改后，自动更新运行参数的实现方式：（注意代码中的注释） ;) 123456789101112131415161718192021222324252627282930313233343536373839404142private static int s_RunOptionsCacheDependencyFlag = 0;public static RunOptions LoadRunOptions()&#123; string path = Path.Combine(AppDataPath, \"RunOptions.xml\"); // 注意啦：访问文件是可能会出现异常。不要学我，我写的是示例代码。 RunOptions options = RwConfigDemo.XmlHelper.XmlDeserializeFromFile&lt;RunOptions&gt;(path, Encoding.UTF8); int flag = System.Threading.Interlocked.CompareExchange(ref s_RunOptionsCacheDependencyFlag, 1, 0); // 确保只调用一次就可以了。 if( flag == 0 ) &#123; // 让Cache帮我们盯住这个配置文件。 CacheDependency dep = new CacheDependency(path); HttpRuntime.Cache.Insert(RunOptionsCacheKey, \"Fish Li\", dep, Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration, RunOptionsUpdateCallback); &#125; return options;&#125;public static void RunOptionsUpdateCallback( string key, CacheItemUpdateReason reason, out object expensiveObject, out CacheDependency dependency, out DateTime absoluteExpiration, out TimeSpan slidingExpiration)&#123; // 注意哦：在这个方法中，不要出现【未处理异常】，否则缓存对象将被移除。 // 说明：这里我并不关心参数reason，因为我根本就没有使用过期时间 // 所以，只有一种原因：依赖的文件发生了改变。 // 参数key我也不关心，因为这个方法是【专用】的。 expensiveObject = \"http://www.cnblogs.com/fish-li/\"; dependency = new CacheDependency(Path.Combine(AppDataPath, \"RunOptions.xml\")); absoluteExpiration = Cache.NoAbsoluteExpiration; slidingExpiration = Cache.NoSlidingExpiration; // 重新加载配置参数 s_RunOptions = LoadRunOptions();&#125; 改动很小，只是LoadRunOptions方法做了修改了而已，但是效果却很酷。 还记得我在上篇博客【在.net中读写config文件的各种方法】的结尾处留下来的问题吗？ 这个示例就是我的解决方案。 回到顶部 文件监视技术的选择对于文件监视，我想有人或许会想到FileSystemWatcher。正好我就来说说关于【文件监视技术】的选择问题。说明，本文所有结论均为我个人的观点，仅供参考。 这个组件，早在做WinForm开发时就用过了，对它也是印象比较深的。它有一个包装不好的地方是：事件会重复发出。比如：一次文件的保存操作，它却引发了二次事件。什么，你不信？ 正好，我还准备了一个示例程序。 说明：图片中显示了发生过二次事件，但我只是在修改了文件后，做了一次保存操作而已。 本文的结尾处有我的示例程序，您可以自己去试一下。这里为了方便，还是贴出相关代码： ;) 12345678910111213private void Form1_Shown(object sender, EventArgs e)&#123; this.fileSystemWatcher1.Path = Environment.CurrentDirectory; this.fileSystemWatcher1.Filter = \"RunOptions.xml\"; this.fileSystemWatcher1.NotifyFilter = System.IO.NotifyFilters.LastWrite; this.fileSystemWatcher1.EnableRaisingEvents = true; &#125;private void fileSystemWatcher1_Changed(object sender, System.IO.FileSystemEventArgs e)&#123; string message = string.Format(\"&#123;0&#125; &#123;1&#125;.\", e.Name, e.ChangeType); this.listBox1.Items.Add(message);&#125; 对于这个类的使用，只想说一点：会引发的事件很多，因此一定要注意过滤。以下引用MSDN的一段说明： Windows 操作系统在 FileSystemWatcher 创建的缓冲区中通知组件文件发生更改。如果短时间内有很多更改，则缓冲区可能会溢出。这将导致组件失去对目录更改的跟踪，并且它将只提供一般性通知。使用 InternalBufferSize 属性来增加缓冲区大小的开销较大，因为它来自无法换出到磁盘的非页面内存，所以应确保缓冲区大小适中（尽量小，但也要有足够大小以便不会丢失任何文件更改事件）。若要避免缓冲区溢出，请使用 NotifyFilter 和 IncludeSubdirectories 属性，以便可以筛选掉不想要的更改通知。 幸运的是，ASP.NET Cache并没有使用这个组件，我们不用担心文件依赖而引发的重复操作问题。 它直接依赖于webengine.dll所提供的API，因此，建议在ASP.NET应用程序中，优先使用Cache所提供的文件依赖功能。 回到顶部 各种缓存方案的共存ASP.NET Cache是一种缓存技术，然而，我们在ASP.NET程序中还可以使用其它的缓存技术， 这些不同的缓存也各有各自的长处。由于ASP.NET Cache不能提供对外访问能力，因此，它不可能取代以memcached为代表的分布式缓存技术， 但它由于是不需要跨进程访问，效率也比分布式缓存的速度更快。如果将ASP.NET Cache设计成【一级缓存】， 分布式缓存设计成【二级缓存】，就像CPU的缓存那样，那么将能同时利用二者的所有的优点，实现更完美的功能以及速度。 其实缓存是没有一个明确定义的技术，一个static变量也是一个缓存，一个static集合就是一个缓存容器了。 这种缓存与ASP.NET Cache相比起来，显然static变量的访问速度会更快，如果static集合不是设计得很差的话， 并发的冲突也可能会比ASP.NET Cache小，也正是因为这一点，static集合也有着广泛的使用。 然而，ASP.NET Cache的一些高级功能，如：过期时间，缓存依赖（包含文件依赖），移除通知，也是static集合不具备的。 因此，合理地同时使用它们，会让程序有着最好的性能，也同时拥有更强大的功能。 原文http://www.cnblogs.com/fish-li/archive/2011/12/27/2304063.html","categories":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"https://luox78.github.io/categories/ASP-NET/"}],"tags":[{"name":"cache","slug":"cache","permalink":"https://luox78.github.io/tags/cache/"}]},{"title":"CSharp中的集合接口，类之间的关系","slug":"IEnumerableECT","date":"2018-01-29T14:33:38.573Z","updated":"2018-01-29T14:41:43.048Z","comments":true,"path":"2018/01/29/IEnumerableECT/","link":"","permalink":"https://luox78.github.io/2018/01/29/IEnumerableECT/","excerpt":"今天看到了一句话the Where() LINQ extension method is used to filter for a particular set of URLs. Where(), like most LINQ methods, returns an IEnumerable value让我好奇IEnumerable Icollection Ilist list之间到底是什么关系顺带IEnumerable可以直接调用ToList变成list","text":"今天看到了一句话the Where() LINQ extension method is used to filter for a particular set of URLs. Where(), like most LINQ methods, returns an IEnumerable value让我好奇IEnumerable Icollection Ilist list之间到底是什么关系顺带IEnumerable可以直接调用ToList变成list 首先我看看 IEnumerable：1 // 摘要:2 // 公开枚举器，该枚举器支持在指定类型的集合上进行简单迭代。3 //4 // 类型参数:5 // T:6 // 要枚举的对象的类型。7 [TypeDependency(“System.SZArrayHelper”)]8 public interface IEnumerable : IEnumerable9 {10 // 摘要:11 // 返回一个循环访问集合的枚举器。12 //13 // 返回结果:14 // 可用于循环访问集合的 System.Collections.Generic.IEnumerator。15 IEnumerator GetEnumerator();16 }IEnumerable 实现IEnumerable接口方法，那IEnumberable做什么的，其实就提高可以循环访问的集合。说白了就是一个迭代。 再来看看ICollection:1 // 摘要:2 // 定义操作泛型集合的方法。3 //4 // 类型参数:5 // T:6 // 集合中元素的类型。7 [TypeDependency(“System.SZArrayHelper”)]8 public interface ICollection : IEnumerable, IEnumerable原来ICollection 同时继承IEnumerable和IEnumerable两个接口，按我的理解就是，ICollection继续它们2个接口而且扩展了方法，功能强多了。由原来的步枪变成半自动步枪我们继续看IList: public interface IList : ICollection, IEnumerable, IEnumerable靠 IList 继承它们三个接口，怪不得功能这么多啊，那应该属于全自动步枪了最后来看看List: public class List : IList, ICollection, IEnumerable, IList, ICollection, IEnumerable这个时候大家仔细看看，它们都是接口，只有List 是类，不仅实现它们的接口，而且还扩展了太多的方法给我利用。哇靠，几乎所有功能都能实现了，简直是激光步枪 总结：IEnumerable接口就是规定了可以使用foreach遍历的集合，C#中几乎？所有集合都实现了该接口，linq查询出来的可以直接用IEnumerable引用 101个linq例子https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b 关于linq to entity一个注意点 今天通过linq查询发现linq使用时 1234select new XXclass&#123; XX = \"1\" + \"2\"&#125; 会报错，原因是linq to entity 转成tolist时并不支持C#里面string.format方法，所以查询的时候并不能使用字符串拼接","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"LINQ","slug":"LINQ","permalink":"https://luox78.github.io/tags/LINQ/"}]},{"title":"三层02","slug":"sanchen02","date":"2018-01-25T12:49:20.132Z","updated":"2018-01-31T12:43:00.775Z","comments":true,"path":"2018/01/25/sanchen02/","link":"","permalink":"https://luox78.github.io/2018/01/25/sanchen02/","excerpt":"ado.net使用事务1234567891011121314151617181920string constr = \"\"; using (SqlConnection con = new SqlConnection(constr)) &#123; con.Open(); using (SqlTransaction tran = con.BeginTransaction()) &#123; using (SqlCommand cmd = new SqlCommand(\"sql\", con)) &#123; cmd.Transaction = tran; cmd.ExecuteNonQuery(); cmd.CommandText = \"sql\"; cmd.Parameters.Clear(); cmd.Parameters.AddRange(null); cmd.ExecuteNonQuery(); &#125; //tran.Commit();无异常提交 tran.Rollback();//异常回滚 &#125; &#125;","text":"ado.net使用事务1234567891011121314151617181920string constr = \"\"; using (SqlConnection con = new SqlConnection(constr)) &#123; con.Open(); using (SqlTransaction tran = con.BeginTransaction()) &#123; using (SqlCommand cmd = new SqlCommand(\"sql\", con)) &#123; cmd.Transaction = tran; cmd.ExecuteNonQuery(); cmd.CommandText = \"sql\"; cmd.Parameters.Clear(); cmd.Parameters.AddRange(null); cmd.ExecuteNonQuery(); &#125; //tran.Commit();无异常提交 tran.Rollback();//异常回滚 &#125; &#125; 分层理解分层：逻辑分层N-Layer​ 逻辑上将系统中的不同功能模块、不同子系统等进行分层​ 好的逻辑分层可以让后续选择物理架构更灵活，选择性更大​ 我们学习的”三层架构”属于逻辑分层（three-layer）物理分层N-Tier​ 物理部署时将系统的不同模块部署在不同的服务器上 三层架构 ​ 界面层UI；​ 数据访问层DAL（Data Access Layer）；​ 业务逻辑层BLL（business logic layer ） 三层结构的程序不是说把项目分成DAL,BLL,WebUI三个模块就叫三层了，下面几个问题在你的项目里面：⒈ UILayer里面只有少量（或者没有）SQL语句或者存储过程调用，并且这些语句保证不会修改数据?⒉ 如果把UILayer拿掉，你的项目还能在Interface/API的层次上提供所有功能吗?⒊ 你的DAL可以移植到其他类似环境的项目吗?⒋ 三个模块，可以分别运行于不同的服务器吗?如果不是所有答案都为YES，那么你的项目还不能算是严格意义上的三层程序. 三层程序有一些需要约定遵守的规则：⒈ 最关键的，UI层只能作为一个外壳，不能包含任何业务逻辑(BizLogic)的处理过程⒉ 设计时应该从BLL出发，而不是UI出发. BLL层在API上应该实现所有BizLogic，以面向对象的方式⒊ 不管数据层是一个简单的SqlHelper也好，还是带有Mapping过的Classes也好，应该在一定的抽象程度上做到系统无关⒋ 不管使用COM+(Enterprise Service），还是Remoting，还是WebService之类的远程对象技术，不管部署的时候是不是真的分别部署到不同的服务器上，最起码在设计的时候要做这样的考虑，更远的，还得考虑多台服务器通过负载均衡作集群所以考虑一个项目是不是应该应用三层/多层设计时，先得考虑下是不是真的需要? 实际上大部分程序就开个WebApplication就足够了，完全没必要作的这么复杂. 而多层结构，是用于解决真正复杂的项目需求的。 单例模式构造函数变私有，通过静态方法只创建同一个对象，本质控制该类对象的创建 123456789101112131415161718192021222324252627public class Singleton &#123; private static Singleton _instance; private static readonly object syn = new object(); //1.当把类的构造函数设置为private的以后，则该类不能在外界被new了。 private Singleton() &#123; &#125; //2.在当前类型中创建一个静态方法，用该静态方法来返回一个对象 public static Singleton CreateInstance() &#123; lock (syn) &#123; if (_instance==null) &#123; _instance = new Singleton(); &#125; &#125; return _instance; &#125; &#125; 通过dotnet发送邮件创建mail对象 123var mail = new MailMessage();mail.From=new MailAddress(\"1023354041@qq.com\", \"luox78\");mail.To.Add(new MailAddress(\"1023354041@qq.com\", \"luox78\")); 创建正文，主题等 123mail.Subject = \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$4关于一些问题$$$$$$$$$$$$$$$$$$$$$$4\";mail.SubjectEncoding = Encoding.UTF8;mail.Body = \"&lt;h1&gt;hello&lt;/h1&gt;&lt;font color=\\\"red\\\"&gt;^_^&lt;/font&gt;\"; 登录 1234SmtpClient client = new SmtpClient(\"smtp.qq.com\",587);//腾讯邮箱client.EnableSsl = true;//启用SSL加密 //发件人邮箱账号，授权码(注意此处，是授权码你需要到qq邮箱里点设置开启Smtp服务，然后会提示你第三方登录时密码处填写授权码)client.Credentials = new System.Net.NetworkCredential(\"1023354041@qq.com\", \"授权码\"); 发送 1client.Send(mail); 加附件 1234MailMessage msg=new MailMessage();msg.Attachments.Add(attach1);msg.Attachments.Add(attach2);msg.Attachments.Add(attach3); 加图片 123456789AlternateView av = AlternateView.CreateAlternateViewFromString(\"&lt;img src=\\\"cid:neirongid\\\"/&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;font color=\\”red\\“&gt;^_^&lt;/font&gt;”, Encoding.UTF8, \"text/html\");//【这里需要注意：src=\"cid:neirongid\"】LinkedResource lr = new LinkedResource(@\"c:\\a.jpg\", \"image/gif\");lr.ContentId = “neirongid”;【这里需要注意设置ContentId=“neirongid”】av.LinkedResources.Add(lr);MailMessage msg = new MailMessage();msg.AlternateViews.Add(av);","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"三层","slug":"三层","permalink":"https://luox78.github.io/tags/三层/"},{"name":"单例模式","slug":"单例模式","permalink":"https://luox78.github.io/tags/单例模式/"},{"name":"发邮件","slug":"发邮件","permalink":"https://luox78.github.io/tags/发邮件/"}]},{"title":"动态创建分页","slug":"paginginfo","date":"2018-01-22T13:48:40.513Z","updated":"2018-01-22T17:14:35.967Z","comments":true,"path":"2018/01/22/paginginfo/","link":"","permalink":"https://luox78.github.io/2018/01/22/paginginfo/","excerpt":"接着上一个demo现在controller中创建一个新的action 先添加两个私有字段分别表示每页条数，和整个一组多少个，为了方便演示，设置小点 12private int PageSize = 3;private int PageGroupSize = 2;","text":"接着上一个demo现在controller中创建一个新的action 先添加两个私有字段分别表示每页条数，和整个一组多少个，为了方便演示，设置小点 12private int PageSize = 3;private int PageGroupSize = 2; 创建page页的model12345678910111213141516171819202122232425262728293031323334353637383940414243public class PagingInfo &#123; public int CurrentPage &#123; get; set; &#125; public int PageSize &#123; get; set; &#125; public int TotalItems &#123; get; set; &#125; public int CurrentDividePage &#123; get &#123; if (CurrentPage % PageGroupSize == 0) return (int)CurrentPage / PageGroupSize; return (int)CurrentPage / PageGroupSize + 1; &#125; &#125; public int TotalDividePages &#123; get &#123; return (int)Math.Ceiling((decimal)TotalItems / PageSize / PageGroupSize); &#125; &#125; public int TotalPages &#123; get &#123; return (int)Math.Ceiling((decimal)TotalItems / PageSize); &#125; &#125; public int PageGroupSize &#123; get; set; &#125;//底端呈现多少页 public bool HasPre &#123; get &#123; return CurrentDividePage == 1 ? false : true; &#125; &#125; public bool HasNext &#123; get &#123; return CurrentDividePage == TotalDividePages ? false : true; &#125; &#125; &#125; 编写page action 分一下步骤 想取得对应页的list 1234var products = productService.Products .OrderBy(m =&gt; m.ProductID) .Skip((page - 1) * PageSize) .Take(PageSize); 创建对应的pageinfo 1234567var pageinfo = new PagingInfo() &#123; CurrentPage = page, PageSize = this.PageSize, TotalItems = productService.Products.Count(), PageGroupSize = PageGroupSize &#125;; 此时需要创建创建对应的page页view model 添加实体中的项目方便model操作 12345678910111213public class ProductViewModel &#123; [DisplayName(\"编号\")] public int ProductID &#123; get; set; &#125; [DisplayName(\"商品名\")] public string Name &#123; get; set; &#125; [DisplayName(\"描述\")] public string Description &#123; get; set; &#125; [DisplayName(\"价格\")] public decimal Price &#123; get; set; &#125; public IEnumerable&lt;Product&gt; Products &#123; get; set; &#125; public PagingInfo PageInfo &#123; get; set; &#125; &#125; 创建view对象，返回view（model）完成action 1234567var model=new ProductViewModel() &#123; Products = products, PageInfo = pageinfo &#125;; return View(model); 创建对应的视图 1234567891011121314151617181920212223242526272829303132333435&lt;table class=\"striped responsive-table\"&gt; &lt;tr&gt; &lt;th&gt; @Html.DisplayNameFor(model =&gt; model.ProductID) &lt;/th&gt; &lt;th&gt; @Html.DisplayNameFor(model =&gt; model.Name) &lt;/th&gt; &lt;th&gt; @Html.DisplayNameFor(model =&gt; model.Description) &lt;/th&gt; &lt;th&gt; @Html.DisplayNameFor(model =&gt; model.Price) &lt;/th&gt; &lt;/tr&gt; @foreach (var item in Model.Products) &#123; &lt;tr&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.ProductID) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.Name) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.Description) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.Price) &lt;/td&gt; &lt;/tr&gt; &#125; &lt;/table&gt; 创建page navigation创建pagehelper用来动态创建page navigation ，委托用来传pageindex对应的url，可以用方法代替 1234567public static class PageHelper &#123; public static MvcHtmlString PageLink(this HtmlHelper htmlHelper, PagingInfo pageinfo，Func&lt;int, string&gt; pageUrl) &#123; &#125; &#125; 先创建一个为htmlhelper拓展方法的静态方法，方便在razor视图里面操作 此时创建的会根据你使用的界面有所不同 先根据传入的pageinfo.CurrentPage 方法中主要是对尾页跟每个页组最后一位进行特殊处理， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public static MvcHtmlString PageLink(this HtmlHelper htmlHelper, PagingInfo pageinfo, Func&lt;int, string&gt; pageUrl) &#123; StringBuilder sb = new StringBuilder(); int length; if (pageinfo.TotalPages &lt; pageinfo.PageGroupSize) length = pageinfo.TotalPages; else if (pageinfo.CurrentDividePage == pageinfo.TotalDividePages) &#123; length = pageinfo.TotalPages - (pageinfo.CurrentDividePage - 1) * pageinfo.PageGroupSize; &#125; else length = pageinfo.PageGroupSize; TagBuilder ul = new TagBuilder(\"ul\"); ul.MergeAttribute(\"class\", \"pagination\"); var pre = new TagBuilder(\"li\"); var pre_a = new TagBuilder(\"a\"); var i_pre = new TagBuilder(\"i\"); i_pre.MergeAttribute(\"class\", \"material-icons\"); i_pre.SetInnerText(\"chevron_left\"); pre_a.InnerHtml = i_pre.ToString(); if (!pageinfo.HasPre) pre.MergeAttribute(\"class\", \"disabled\"); else pre_a.MergeAttribute(\"href\", pageUrl((pageinfo.CurrentDividePage - 2) * pageinfo.PageGroupSize + 1)); pre.InnerHtml = pre_a.ToString(); sb.Append(pre.ToString()); for (int i = 1; i &lt;= length; i++) &#123; TagBuilder liTag = new TagBuilder(\"li\"); TagBuilder tag = new TagBuilder(\"a\"); if (pageinfo.CurrentPage % pageinfo.PageGroupSize != i) &#123; if (pageinfo.CurrentPage % pageinfo.PageGroupSize == 0 &amp;&amp; i == length) &#123; liTag.MergeAttribute(\"class\", \"active\"); &#125; else &#123; liTag.MergeAttribute(\"class\", \"waves-effect\"); tag.MergeAttribute(\"href\", pageUrl((pageinfo.CurrentDividePage - 1) * pageinfo.PageGroupSize + i)); &#125; &#125; else &#123; liTag.MergeAttribute(\"class\", \"active\"); &#125; tag.SetInnerText(i.ToString()); liTag.InnerHtml = tag.ToString(); sb.Append(liTag.ToString()); &#125; var next = new TagBuilder(\"li\"); var next_i = new TagBuilder(\"i\"); next_i.MergeAttribute(\"class\", \"material-icons\"); next_i.SetInnerText(\"chevron_right\"); var next_a = new TagBuilder(\"a\"); next_a.InnerHtml = next_i.ToString(); if (!pageinfo.HasNext) next.MergeAttribute(\"class\", \"disabled\"); else next_a.MergeAttribute(\"href\", pageUrl(pageinfo.CurrentDividePage * pageinfo.PageGroupSize + 1)); next.InnerHtml = next_a.ToString(); sb.Append(next.ToString()); ul.InnerHtml = sb.ToString(); return MvcHtmlString.Create(ul.ToString()); &#125; view文件夹下面web.config添加配置 12345678&lt;system.web.webPages.razor&gt; &lt;host factoryType=\"System.Web.Mvc.MvcWebRazorHostFactory, System.Web.Mvc, Version=5.2.3.0, Culture=neutral, PublicKeyToken=31BF3856AD364E35\" /&gt; &lt;pages pageBaseType=\"System.Web.Mvc.WebViewPage\"&gt; &lt;namespaces&gt; &lt;add namespace=\"luox78.GraduationProject.WebDemo.Helper\" /&gt; &lt;/namespaces&gt; &lt;/pages&gt;&lt;/system.web.webPages.razor&gt; view页面添加，生成块 1@Html.PageLink(Model.PageInfo,m=&gt;Url.Action(\"Page\",\"Product\",new &#123; page = m &#125;))","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"分页","slug":"分页","permalink":"https://luox78.github.io/tags/分页/"},{"name":"asp.net mvc","slug":"asp-net-mvc","permalink":"https://luox78.github.io/tags/asp-net-mvc/"},{"name":"HtmlHelper拓展","slug":"HtmlHelper拓展","permalink":"https://luox78.github.io/tags/HtmlHelper拓展/"}]},{"title":"autofac依赖注入","slug":"Autofac_IOC","date":"2018-01-22T13:39:05.652Z","updated":"2018-01-22T13:39:35.102Z","comments":true,"path":"2018/01/22/Autofac_IOC/","link":"","permalink":"https://luox78.github.io/2018/01/22/Autofac_IOC/","excerpt":"C# Asp.net autofac依赖注入service类创建实体，接口，具体实现类1234567891011public class Product &#123; public int ProductID &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Description &#123; get; set; &#125; public decimal Price &#123; get; set; &#125; &#125;","text":"C# Asp.net autofac依赖注入service类创建实体，接口，具体实现类1234567891011public class Product &#123; public int ProductID &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Description &#123; get; set; &#125; public decimal Price &#123; get; set; &#125; &#125; 1234public interface IProductService &#123; IEnumerable&lt;Product&gt; Products &#123; get; &#125; &#125; 123456789101112131415161718192021222324252627282930public class ProductService:IProductService &#123; public IEnumerable&lt;Product&gt; Products &#123; get &#123; //仅作演示 return new List&lt;Product&gt; &#123; new Product &#123;ProductID = 1, Name = \"Football\", Description = \"Football description\", Price = 25&#125;, new Product &#123;ProductID = 2, Name = \"Stuff board\", Description = \"Stuff board description\", Price = 179 &#125;, new Product &#123;ProductID = 3, Name = \"Running shoes\", Description = \"Running shoes description\", Price = 95 &#125;, new Product &#123;ProductID = 4, Name = \"Basketball\", Description = \"Basketball description\", Price = 125&#125;, new Product &#123;ProductID = 5, Name = \"Volleyball\", Description = \"Volleyball description\", Price = 59 &#125;, new Product &#123;ProductID = 6, Name = \"Basketball shoes\", Description = \"Basketball shoes description\", Price = 195 &#125;, new Product &#123;ProductID = 7, Name = \"Volleyball shoes\", Description = \"Volleyball shoes description\", Price = 205&#125;, new Product &#123;ProductID = 8, Name = \"Swimming clothes\", Description = \"Swimming clothes description\", Price = 199 &#125;, new Product &#123;ProductID = 9, Name = \"Climbing boot\", Description = \"Climbing boot description\", Price = 900 &#125;, new Product &#123;ProductID = 10, Name = \"Football\", Description = \"Football description\", Price = 25&#125;, new Product &#123;ProductID = 11, Name = \"Stuff board\", Description = \"Stuff board description\", Price = 179 &#125;, new Product &#123;ProductID = 12, Name = \"Running shoes\", Description = \"Running shoes description\", Price = 95 &#125;, new Product &#123;ProductID = 13, Name = \"Basketball\", Description = \"Basketball description\", Price = 125&#125;, new Product &#123;ProductID = 14, Name = \"Volleyball\", Description = \"Volleyball description\", Price = 59 &#125;, new Product &#123;ProductID = 15, Name = \"Basketball shoes\", Description = \"Basketball shoes description\", Price = 195 &#125;, new Product &#123;ProductID = 16, Name = \"Volleyball shoes\", Description = \"Volleyball shoes description\", Price = 205&#125;, new Product &#123;ProductID = 17, Name = \"Swimming clothes\", Description = \"Swimming clothes description\", Price = 199 &#125;, new Product &#123;ProductID = 18, Name = \"Climbing boot\", Description = \"Climbing boot description\", Price = 900 &#125; &#125;; &#125; &#125; &#125; mvc 引用中添加autofac mvc5引用，再App_Start里面添加AutofacConfig.cs配置文件1234567891011121314151617181920212223public static class AutoFacConfig &#123; public static void Initialize() &#123; //初始化容器 var builder = new ContainerBuilder(); //注册每个对象实例 var container = RegisterServices(builder); DependencyResolver.SetResolver(new AutofacDependencyResolver(container)); &#125; private static IContainer RegisterServices(ContainerBuilder builder) &#123; //注册controller builder.RegisterControllers(typeof(MvcApplication).Assembly); builder.RegisterInstance(new ProductService()).As&lt;IProductService&gt;(); return builder.Build(); &#125; &#125; Application_Start初始化123456789protected void Application_Start() &#123; AreaRegistration.RegisterAllAreas(); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); AutoFacConfig.Initialize(); &#125; 添加product控制器控制器中index返回整个list 先往控制器中添加传输层数据私有字段 1private IProductService productService; 初始化 1234public ProductController(IProductService productService) &#123; this.productService = productService; &#125; 当程序需要productService时，会通过container自动获取对象 添加对应视图选list模板，暂时用entities里面的模型类，自己调整layout 123456789101112131415161718192021222324252627&lt;table class=\"striped responsive-table\"&gt; &lt;tr&gt; &lt;th&gt; @Html.DisplayNameFor(model =&gt; model.Name) &lt;/th&gt; &lt;th&gt; @Html.DisplayNameFor(model =&gt; model.Description) &lt;/th&gt; &lt;th&gt; @Html.DisplayNameFor(model =&gt; model.Price) &lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; @foreach (var item in Model) &#123; &lt;tr&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.Name) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.Description) &lt;/td&gt; &lt;td&gt; @Html.DisplayFor(modelItem =&gt; item.Price) &lt;/td&gt; &lt;/tr&gt;&#125; 启动调试，此时通过autofac创建的对象已经可以呈现出来了。","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"autofac","slug":"autofac","permalink":"https://luox78.github.io/tags/autofac/"},{"name":"IOC","slug":"IOC","permalink":"https://luox78.github.io/tags/IOC/"}]},{"title":"控制反转与依赖注入","slug":"IOC","date":"2018-01-22T11:47:29.334Z","updated":"2018-02-12T13:38:21.370Z","comments":true,"path":"2018/01/22/IOC/","link":"","permalink":"https://luox78.github.io/2018/01/22/IOC/","excerpt":"一、分享Iteye的开涛对Ioc的精彩讲解 首先要分享的是Iteye的开涛这位技术牛人对Spring框架的IOC的理解，写得非常通俗易懂，以下内容全部来自原文，原文地址：http://jinnianshilongnian.iteye.com/blog/1413846","text":"一、分享Iteye的开涛对Ioc的精彩讲解 首先要分享的是Iteye的开涛这位技术牛人对Spring框架的IOC的理解，写得非常通俗易懂，以下内容全部来自原文，原文地址：http://jinnianshilongnian.iteye.com/blog/1413846 1.1、IoC是什么 Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来： 图1-1 传统应用程序示意图 当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示: 图1-2有IoC/DI容器后程序结构示意图 1.2、IoC能做什么 IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 1.3、IoC和DI DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：**应用程序需要IoC容器来提供对象需要的外部资源**； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“**依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。** 看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。 二、分享Bromon的blog上对IoC与DI浅显易懂的讲解2.1、IoC(控制反转) 首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 2.2、DI(依赖注入) IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"IOC","slug":"IOC","permalink":"https://luox78.github.io/tags/IOC/"},{"name":"DI","slug":"DI","permalink":"https://luox78.github.io/tags/DI/"}]},{"title":"三层01","slug":"sanchen01","date":"2018-01-21T04:39:30.895Z","updated":"2018-01-21T13:11:56.519Z","comments":true,"path":"2018/01/21/sanchen01/","link":"","permalink":"https://luox78.github.io/2018/01/21/sanchen01/","excerpt":"SqlHelper实现 往app.config中添加connectionstrings 123&lt;connectionStrings&gt; &lt;add name=\"constr\" connectionString=\"data source=”LUOX78“的WIN;initial catalog=school;integrated security=true\"/&gt; &lt;/connectionStrings&gt; 创建SqlHelper类","text":"SqlHelper实现 往app.config中添加connectionstrings 123&lt;connectionStrings&gt; &lt;add name=\"constr\" connectionString=\"data source=”LUOX78“的WIN;initial catalog=school;integrated security=true\"/&gt; &lt;/connectionStrings&gt; 创建SqlHelper类 1234public class SqlHelper&#123; private string constr；&#125; 添加引用给constr赋值 123using System.Configuration;private string constr = ConfigurationManager.ConnectionStrings[\"constr\"].ConnectionString; 编写无返回值，有一行返回值，返回多行，返回datatable的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static int ExecuteNoQuery(string sql, CommandType type = CommandType.Text,params SqlParameter[] sqlParameters) &#123; using (var con = new SqlConnection(constr)) &#123; using (var cmd = new SqlCommand(sql, con)) &#123; if (sqlParameters == null) return 0; cmd.Parameters.AddRange(sqlParameters); cmd.CommandType = type; con.Open(); return cmd.ExecuteNonQuery(); &#125; &#125; &#125; public static SqlDataReader ExecuteReader(string sql, CommandType type = CommandType.Text, params SqlParameter[] sqlParameters) &#123; using (var con = new SqlConnection(constr)) &#123; using (var cmd = new SqlCommand(sql, con)) &#123; if (sqlParameters == null) return null; cmd.CommandType = type; cmd.Parameters.AddRange(sqlParameters); try &#123; con.Open(); return cmd.ExecuteReader(CommandBehavior.CloseConnection); &#125; catch (Exception e) &#123; con.Close(); Console.WriteLine(e); throw; &#125; &#125; &#125; &#125; public static DataTable ExecuteDataTable(string sql, CommandType type = CommandType.Text, params SqlParameter[] sqlParameters) &#123; var dt=new DataTable(); using (var adapter = new SqlDataAdapter(sql, constr)) &#123; if (sqlParameters != null) &#123; adapter.SelectCommand.Parameters.AddRange(sqlParameters); &#125; adapter.SelectCommand.CommandType = type; adapter.Fill(dt); &#125; return dt; &#125; md5MD5算法是一种散列（hash）算法（摘要算法，指纹算法），不是一种加密算法（易错）。任何长度的任意内容都可以用MD5计算出散列值。介绍工具：CalcMD5.zip。主要作用就是【验明“真身”】，字符串与文件均可。 MD5长度一般是32位的16进制数字符串（比如71f396e4134a1160d90bb1439876df31），MD5值的个数是有限的，但是源数据是无限的，因此存在着不同的内容产生相同MD5值的概率。因此MD5算法不可逆，也就是只能得到内容对应的MD5值，无法由MD5值反推内容。但是对不同的内容产生相同MD5值的概率非常非常非常低！ 同一个字符串或文件生成的MD5都是一样的 用处：登录密码存入数据库使用MD5，检验文件是否被修改过 .NET下MD5使用 string的MD5 12345678910111213141516//创建MD5对象MD5 obj=MD5.Create();//转换//编码的不同会导致获取MD5值不一样var md5Bytes = obj.ComputeHash(Encoding.UTF8.GetBytes(str));var sb=new StringBuilder(32);foreach (byte md5Byte in md5Bytes)&#123; sb.Append(md5Byte.ToString(\"x2\"));&#125;//或者直接使用bitconvertBitConverter.ToString(md5Bytes).Replace(\"-\", \"\");//释放资源obj.Clear(); 文件的MD5(向ComputeHash传入流即可) 12345byte[] md5Bytes;using (var reader = File.OpenRead(path))&#123; md5Bytes = obj.ComputeHash(reader);&#125; 其他的散列算法：SHA512或SHA256，用法与MD5一样 1SHA512 obj = SHA512.Create(); 使用NPOI操作Excel Excel组成：workbook（工作簿），sheet [ʃit] （工作表），row行，cell单元格 先添加NOPI引用 1. 写入excel表单 12345678910111213141516171819202122//创建excel对象(workbook)IWorkbook wk=new HSSFWorkbook();//workbook中创建sheetISheet sheet = wk.CreateSheet(\"工作表1\");//创建10行for (int i = 0; i &lt; 10; i++)&#123; IRow row = sheet.CreateRow(i); var cell = row.CreateCell(0); cell.SetCellValue(\"luox78\"); var cell2 = row.CreateCell(1); cell2.SetCellValue(i);&#125;//保存using (var writer=File.OpenWrite(\"wk1.xls\"))&#123; wk.Write(writer);&#125; 2. 读取excel 1234567891011121314151617181920212223242526private static void ReadFromXls() &#123; //创建excel对象(workbook) using (var reader=File.OpenRead(\"ReadExcel.xls\")) &#123; IWorkbook wk = new HSSFWorkbook(reader); for (int i = 0; i &lt; wk.NumberOfSheets; i++) &#123; //获取每个sheet var sheet = wk.GetSheetAt(i); Console.WriteLine($\"sheet&#123;i&#125;:&#123;sheet.SheetName&#125;\"); for (int j = 0; j &lt;= sheet.LastRowNum; j++) &#123; //获取每个row var row = sheet.GetRow(j); Console.WriteLine($\"row&#123;j&#125;:\"); for (int k = 0; k &lt; row.LastCellNum; k++) &#123; //输出每个cell的内容 Console.WriteLine(row.GetCell(k).ToString()); &#125; &#125; &#125; &#125; 从数据库中导出excel 两步和之前一样 从数据库中读取数据 调用WriteToExcel(IWorkbook wk,Dictionary&lt;ISheet,List&lt;IRow&gt;&gt; sheets ) 对于空处理：从数据库读取为unknown，模型的值类型修改成可空值类型 1reader.IsDBNull(column)?null:(int?)reader.GetInt32(column); 写入到excel时 12345ICell cell = row.CreateCell(colomn);if(read == null) cell.SetCellType(CellType.BLANK);//设置创建的单元格为空单元格else cell.SetCellValue((Type)read);//将Type类型的数据放入cell ​","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"三层","slug":"三层","permalink":"https://luox78.github.io/tags/三层/"},{"name":"MD5","slug":"MD5","permalink":"https://luox78.github.io/tags/MD5/"},{"name":"NOPI","slug":"NOPI","permalink":"https://luox78.github.io/tags/NOPI/"},{"name":"SqlHelper","slug":"SqlHelper","permalink":"https://luox78.github.io/tags/SqlHelper/"}]},{"title":"Entity Framework02-code first修改模型，迁移数据库","slug":"Entity Framework Code First to a Update model and migrate","date":"2018-01-18T14:24:01.824Z","updated":"2018-01-19T15:39:15.091Z","comments":true,"path":"2018/01/18/Entity Framework Code First to a Update model and migrate/","link":"","permalink":"https://luox78.github.io/2018/01/18/Entity Framework Code First to a Update model and migrate/","excerpt":"本文以asp.net mvc自己提供的身份验证为例 添加属性在Models\\IdentityModels.cs 里 ApplicationUser类下添加你想添加的属性，比如生日 1public DateTime BirthDate &#123; get; set; &#125;","text":"本文以asp.net mvc自己提供的身份验证为例 添加属性在Models\\IdentityModels.cs 里 ApplicationUser类下添加你想添加的属性，比如生日 1public DateTime BirthDate &#123; get; set; &#125; 使用Migrations修改数据库 由于已经改变了model的属性所以应该修改之前的数据库 前往工具/NUGET/程序包管理器控制台 输入Enable-Migrations初始化迁移 Add-Migration &quot;Birthdate&quot; 添加名为Birthdate的迁移文件进你的工程 Update-Database执行你的迁移文件更新数据库 修改你的view对应的model在 Models\\AccountViewModels.cs中找到RegisterViewModel类添加属性，当然也可以添加你想要的特性 1public DateTime BirthDate &#123; get; set; &#125; 修改对应的view展示12345&lt;div class=\"input-field col s12 m3 l3\"&gt; &lt;i class=\"material-icons prefix\"&gt;date_range&lt;/i&gt; @Html.LabelFor(m =&gt; m.BirthDate) @Html.TextBoxFor(m =&gt; m.BirthDate, new &#123; @class = \"datepicker\" &#125;)&lt;/div&gt; 运行就能看到修改后的结果了 如何展示新的信息 得到 UserId, 可以通过 ASP.NET Identity system 1var currentUserId = User.Identity.GetUserId(); 实例化UserManager在ASP.Identity system命名空间下 1var manager = new UserManager&lt;MyUser&gt;(new UserStore&lt;MyUser&gt;(new MyDbContext())); 得到当前用户实例 1var currentUser = manager.FindById(User.Identity.GetUserId()); 通过实例展现修改的信息 1var birthdate = currentUser.BirthDate 自己创建新的model，展示想显示的信息123456789101112131415161718public class MyUser : IdentityUser &#123; public virtual MyUserInfo MyUserInfo &#123; get; set; &#125; &#125; public class MyUserInfo&#123; public int Id &#123; get; set; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; &#125; public class MyDbContext : IdentityDbContext&lt;MyUser&gt; &#123; public MyDbContext() : base(\"DefaultConnection\") &#123; &#125; public System.Data.Entity.DbSet&lt;MyUserInfo&gt; MyUserInfo &#123; get; set; &#125; &#125; Getting Profile information When the User Logs in, you can display the profile information by doing the following Get the current logged in UserId, so you can look the user up in ASP.NET Identity system var currentUserId = User.Identity.GetUserId(); Instantiate the UserManager in ASP.Identity system so you can look up the user in the system var manager = new UserManager(new UserStore(new MyDbContext())); Get the User object var currentUser = manager.FindById(User.Identity.GetUserId()); Get the profile information about the user currentUser.MyUserInfo.FirstName","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://luox78.github.io/tags/Entity-Framework/"}]},{"title":"初始JQuery03","slug":"JQuery03","date":"2018-01-17T11:49:11.642Z","updated":"2018-01-20T15:28:50.499Z","comments":true,"path":"2018/01/17/JQuery03/","link":"","permalink":"https://luox78.github.io/2018/01/17/JQuery03/","excerpt":"RadioButton|checkbox123&lt;input id=\"Radio2\" checked=\"checked\" name=\"gender\" type=\"radio\" value=\"男\" /&gt;男&lt;input id=\"Radio1\" checked=\"checked\" name=\"gender\" type=\"radio\" value=\"女\" /&gt;女&lt;input id=\"Radio3\"checked=\"checked\" name=\"gender\" type=\"radio\" value=\"未知\" /&gt;未知","text":"RadioButton|checkbox123&lt;input id=\"Radio2\" checked=\"checked\" name=\"gender\" type=\"radio\" value=\"男\" /&gt;男&lt;input id=\"Radio1\" checked=\"checked\" name=\"gender\" type=\"radio\" value=\"女\" /&gt;女&lt;input id=\"Radio3\"checked=\"checked\" name=\"gender\" type=\"radio\" value=\"未知\" /&gt;未知 如何取选中的值1$(\"input[name=gender]:checked\").val() 设置RadioButton的选中值 1.attr(‘checked’,true); $(&quot;input[name=gender]&quot;).val([&quot;女&quot;]);也可以直接设置，注意val中参数的[]不能省略,val()的参数必须是一个数组。 RadioButton的选择技巧对于CheckBox和Select列表框也适用 12$(‘#selOne’).val([‘1’,’2’,’3’]);//同时设置多个下拉菜单选中$(\"#btn1\").attr(\"checked\",true) 实现全选部不选 123456$(\"#btn1\").click(function () &#123; $(\"input:checkbox\").prop(\"checked\",true); &#125;); $(\"#btn2\").click(function () &#123; $(\"input:checkbox\").prop(&#123; checked: false &#125;); &#125;); 一些事件$(&quot;#btn&quot;).bind(&quot;click&quot;,function(){})事件绑定 hover(entern,leavefn)当鼠标放在元素上时调用enterfn方法，当鼠标离开元素的时候调用leavefn方法。相当于mouseover与mouseout事件的结合。 $(&#39;#bt&#39;).toggle(funtion) 相互切换 事件冒泡事件冒泡：jQuery中也像JavaScript一样是事件冒泡window.event.cancelBubble=true,ie取消 如果想获得事件相关的信息，只要给响应的匿名函数增加一个参数：e， e就是事件对象。调用事件对象的stopPropagation()方法终止冒泡。 e. stopPropagation();标准js方式：e.stopPropagation();IE下：e.cancelBubble = true； 1234$(\"tr\").click(function(e) &#123; alert(\"tr被点击\"); e.stopPropagation(); &#125;);//注意函数的参数是e 重写移动图片案例1234567891011&lt;body&gt; &lt;img src=\"office.jpg\" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; $(function() &#123; $(document).mousemove(function(e) &#123; $(\"img\").offset(&#123; left: e.pageX, top: e.pageY &#125;); &#125;); &#125;);&lt;/script&gt; jQuery的事件对象：event对象 属性：pageX、pageY、target(指事件源) e.which如果是鼠标事件获得按键（1左键，2中键，3右键） keydown则获取的是keyCode unbind()方法即可移除元素上所有绑定的事件，如果unbind(“click”)则只移除click事件的绑定。bind:+=；unbind:-= one()方法进行事件绑定,值执行一次 jquery animateshow()、hide()方法会显示、隐藏元素。用toggle(speed)方法在显示、隐藏之间切换 滑动效果slideDown()、slideUp()、slideToggle()隐藏就显示,显示就隐藏 淡入淡出（透明）fadeIn()、fadeOut()、fadeToggle()同上、fadeTo()到达透明度多少2000，0.1 自定义动画animate({样式},speed)部分样式不支持：backgroundColor、color、borderStyle、……使用animate设置对象位置的时候要确保position的值为absolute或relative.停止动画正在执行动画的元素.stop()(*),带参数的stop(true,false); 1234$(function () &#123; $('#im').animate(&#123; 'height': '20px', 'width': '20px', 'left': '10px', 'top': '500px' &#125;, 3000).animate(&#123; 'height': '+=200px', 'width': '+=200px', 'left': '500px', 'top': '50px' &#125;, 2000); &#125;);$(`#im`).stop(true);//带参数继续当前动画,后面动画清空 cookie什么是cookie：Cookie就是保存在浏览器上的内容，用户在这次浏览页面的时候向Cookie中保存文本内容，下次再访问页面的时候就可以取出来上次保存的内容，这样就可以得到上次“记忆”的内容。Cookie不是jQuery特有的概念，只不过jQueryCookie把它简化的更好用而已。Cookie就是存储在浏览器里的一些数据。 Cookie需要浏览器的支持，浏览器的Cookie是可以禁用的，如果禁用了Cookie就不能使用了，不过一般不用考虑禁用Cookie的情况。Cookie的几个特征：Cookie是与域名相关的，所以163.com不能读取baidu.com记录的Cookie，正因为如此读取、设置Cookie的时候不用担心不同域名cookie的冲突；一个域名能写入的Cookie总尺寸是有限制的，一般是是几千字节，能写入的Cookie总条数一般是几十条，超过以后浏览器自己会根据自己的策略移除一些Cookie；Cookie不是写入以后一定下次能读出来，浏览器可能会定期清除、用户也可能会手动清除。写到Cookie中的数据一定是可有可无的数据，像防止投票作弊就不能用Cookie。","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://luox78.github.io/categories/JQuery/"}],"tags":[{"name":"jQueryfoundation","slug":"jQueryfoundation","permalink":"https://luox78.github.io/tags/jQueryfoundation/"},{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"Entity Framework01-code first建立一个新数据库","slug":"Entity Framework Code First to a New Database","date":"2018-01-16T12:24:50.695Z","updated":"2018-01-16T12:42:21.729Z","comments":true,"path":"2018/01/16/Entity Framework Code First to a New Database/","link":"","permalink":"https://luox78.github.io/2018/01/16/Entity Framework Code First to a New Database/","excerpt":"建立model编写.net class建立model","text":"建立model编写.net class建立model 1234567891011121314151617public class Blog &#123; public int BlogId &#123; get; set; &#125; public string Name &#123; get; set; &#125; public virtual List&lt;Post&gt; Posts &#123; get; set; &#125; &#125; public class Post &#123; public int PostId &#123; get; set; &#125; public string Title &#123; get; set; &#125; public string Content &#123; get; set; &#125; public int BlogId &#123; get; set; &#125; public virtual Blog Blog &#123; get; set; &#125; &#125; 类中带id的会自动标志成主键 两个导航属性 (Blog.Posts and Post.Blog) virtual，这是entity framework懒加载（ Lazy Loading ）的特征，懒加载值得是这些属性内容会自动从数据库中加载出来 建立上下文（Context）添加引用 1using System.Data.Entity; 建立数据库上下文，继承自DbContext 12345public class BloggingContext : DbContext&#123; public DbSet&lt;Blog&gt; Blogs &#123; get; set; &#125; public DbSet&lt;Post&gt; Posts &#123; get; set; &#125;&#125; DbSet代表数据库中的表，上下文中存储就是关系表 读取 存入数据存入 1234var tmpBlog = new Blog() &#123; Name = \"luox78's blog\" &#125;;var db = new BloggingContext();db.Blogs.Add(tmpBlog);db.SaveChanges(); 读取 123456var obj = db.Blogs.Where(blog =&gt; blog.BlogId == 1);foreach (var blog in obj)&#123; Console.WriteLine(blog.Name);&#125;//luox78's blog 数据在哪儿？ Visual Studio 2010数据库一般建在 local SQL Express Visual Studio 2012以上一般在 LocalDb.aspx) 数据库命名是项目名加上建立的上下文名字 执行完写入之后数据已经进入数据库 接下来我会分别介绍各个部分 原文：Entity Framework Code First to a New Database.aspx) 翻译：luox78","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://luox78.github.io/tags/Entity-Framework/"}]},{"title":"初始JQuery02","slug":"JQuery02","date":"2018-01-15T11:48:34.839Z","updated":"2018-01-15T15:20:34.568Z","comments":true,"path":"2018/01/15/JQuery02/","link":"","permalink":"https://luox78.github.io/2018/01/15/JQuery02/","excerpt":"selector相对定位不仅可以使用选择器进行进行绝对定位，还可以进行相对定位，只要在$()指定第二个参数，第二个参数为相对的元素. 1234//$(this) 代表tr，在tr下面找td$(\"tr\").click(function() &#123; $(\"td:even\", $(this)).css(\"backgroundColor\", \"red\"); &#125;);","text":"selector相对定位不仅可以使用选择器进行进行绝对定位，还可以进行相对定位，只要在$()指定第二个参数，第二个参数为相对的元素. 1234//$(this) 代表tr，在tr下面找td$(\"tr\").click(function() &#123; $(\"td:even\", $(this)).css(\"backgroundColor\", \"red\"); &#125;); 属性过滤选择器 $(&quot;div[id]&quot;)选取有id属性的&lt;div&gt; $(&quot;div[title=test]&quot;)选取title属性为“test”的&lt;div&gt;，jQuery中没有对getElementsByName进行封装，用$(&quot;input[name=abc]&quot;) $(&quot;div[title!=test]&quot;)选取title属性不为“test”的&lt;div&gt; 还可以选择开头[name^=值]、结束[] name$=值]、包含[ name*=值]等，条件还可以复合。【[属性1=a][属性2=b]…】 表单对象属性选择器（过滤器） $(&quot;#form1:enabled&quot;)选取id为form1的表单内所有启用的元素 $(&quot;#form1:disabled&quot;)选取id为form1的表单内所有禁用的元素 $(“input:checked”)选取所有选中的元素（Radio、CheckBox）,这个中间不能加空格. $(&quot;select:selected&quot;)选取所有选中的选项元素（下拉列表） 注意：$(&#39;&#39;:input&quot;)选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;和&lt;button&gt;元素。和$(&quot;input&quot;)不一样， $(&quot;input&quot;)只获得&lt;input&gt; $(&quot;:text&quot;)选取所有单行文本框，等价于$(&quot;input[type=text]&quot;),$(‘input[type=text]’),$(‘:text’); 同理还有:radio、:checkbox、:submit、:image、:reset、:button、:file、:hidden。 jQuery的Dom操作 使用html()方法读取或者设置元素的innerHTML 使用text()方法读取或者设置元素的innerText： 使用attr()方法读取或者设置元素的属性，对于jQuery没有封装的属性（所有浏览器没有差异的属性）用attr进行操作。 1234//获取alert($(\"a:first\").attr(\"href\"));//设置$(\"a:first\").attr(\"href\", \"http://www.luox78.com\"); 使用removeAttr删除属性。删除的属性在源代码中看不到，这是和清空属性的区别。attr(‘name’,’’) 动态创建Dom节点先创建jquery dom对象var obj=$(&quot;&lt;div style=&quot;background-color:blue;&quot; /&gt;&quot;); 再动态添加$(&quot;body&quot;).append(obj);或者obj.appendTo($(&quot;body&quot;)) append方法用来在元素的末尾追加元素（最后一个子节点）。增加元素末尾(儿子) prepend，在元素的开始添加元素（第一个子节点）。增加元素开始(儿子) after，在元素之后添加元素（添加兄弟）增加元素后面(兄弟) before：在元素之前添加元素（添加兄弟）增加元素前面(兄弟) 子元素.appendTo(父元素);//主动巴结!到最后一个 子元素.prependTo(父元素);//主动巴结到第一个。 (*)A.insertBefore(B);将A加到到B的前面，等同于B.before(A); (*)X.insertAfter(Y);将X加到到Y的后面，等同于Y.after(X); 删除节点empty();清空某元素下的所有子节点 remove(selector)删除当前元素，返回值为被删除的元素。还可以继续使用被删除的节点。比如重新添加到其他节点下： 12var lis = $(\"#ulSite li\").remove();$(\"#ulSite2\").append(lis); clone()克隆节点，只复制节点，没事件 节点操作 替换节点： $(&quot;br&quot;).replaceWith(&quot;&lt;hr/&gt;&quot;);用&lt;hr/&gt;替换br$(‘&lt;br/’).replaceAll(‘hr’); //调用者也得是选择器选择到 的元素。用&lt;br/&gt;元素替换所有的hr 包裹节点 wrap()方法用来将所有元素逐个用指定标签包裹：[wrapAll()]$(“b”).wrap(“&lt;font color=‘red’&gt;&lt;/font&gt;”)将所粗体字红色显示结果：&lt;font color=‘red’&gt;&lt;b&gt;&lt;/b&gt;&lt;/font&gt;wrapInner()//在内部围绕","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://luox78.github.io/categories/JQuery/"}],"tags":[{"name":"jQueryfoundation","slug":"jQueryfoundation","permalink":"https://luox78.github.io/tags/jQueryfoundation/"},{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"GET，POST，PUT，DELETE的区别","slug":"get_post","date":"2018-01-15T11:46:57.475Z","updated":"2018-01-15T11:52:23.430Z","comments":true,"path":"2018/01/15/get_post/","link":"","permalink":"https://luox78.github.io/2018/01/15/get_post/","excerpt":"Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。","text":"Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 (1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 注意：这里安全的含义仅仅是指是非修改信息。 (2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念： 幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。 幂等有一下几种定义： 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a) = abs(abs(a))。 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。 看完上述解释后，应该可以理解GET幂等的含义了。 但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。 2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。 上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说： 1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。 2.对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。 3.另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。 简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。 以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现REST(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。 说完原理性的问题，我们再从表面现像上面看看GET和POST的区别： 1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST把提交的数据则放置在是HTTP包的包体中。 2.”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！ 以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的： (1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5] (2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。 对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。 由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意： 1).IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。 2).IIS 6.0默认上传文件的最大大小是4MB。 3).IIS 6.0默认最大请求头是16KB。 IIS 6.0之前没有这些限制。[见参考资料5] 所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。 3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\\”XXXX\\”)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&amp;password=hyddd，用request.getQueryString()得到的是：name=hyddd&amp;password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。 4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。 总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！ 纯属hyddd个人总结，如有错漏请指出。:&gt; 参考资料： [1].http://hi.baidu.com/liuzd003/blog/item/7bfecbfa6ea94ed8b58f318c.html [2].http://www.blogjava.net/onlykeke/archive/2006/08/23/65285.aspx [3].http://baike.baidu.com/view/2067025.htm [4].http://www.chxwei.com/article.asp?id=373 [5].http://blog.csdn.net/somat/archive/2004/10/29/158707.aspx 转载请说明出处，谢谢[hyddd(http://www.cnblogs.com/hyddd/)]","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"request","slug":"request","permalink":"https://luox78.github.io/tags/request/"}]},{"title":"Swagger - 前后端分离后的契约","slug":"swagger","date":"2018-01-15T11:39:51.811Z","updated":"2018-01-15T11:52:05.404Z","comments":true,"path":"2018/01/15/swagger/","link":"","permalink":"https://luox78.github.io/2018/01/15/swagger/","excerpt":"前后端分离按照现在的趋势，前后端分离几乎已经是业界对开发和部署方式所达成的一种共识。所谓的前后端分离，并不是传统行业中的按部门划分，一部分人只做前端（HTML/CSS/JavaScript等等），另一部分人只做后端（或者叫服务端），因为这种方式是不工作的：比如很多团队采取了后端的模板技术（JSP, FreeMarker, ERB等等），前端的开发和调试需要一个后台Web容器的支持，从而无法将前后端开发和部署做到真正的分离。","text":"前后端分离按照现在的趋势，前后端分离几乎已经是业界对开发和部署方式所达成的一种共识。所谓的前后端分离，并不是传统行业中的按部门划分，一部分人只做前端（HTML/CSS/JavaScript等等），另一部分人只做后端（或者叫服务端），因为这种方式是不工作的：比如很多团队采取了后端的模板技术（JSP, FreeMarker, ERB等等），前端的开发和调试需要一个后台Web容器的支持，从而无法将前后端开发和部署做到真正的分离。 通常，前后端分别有着自己的开发流程，构建工具，测试等。做前端的谁也不会想要用Maven或者Gradle作为构建工具，同样的道理，做后端的谁也不会想要用Grunt或者Gulp作为构建工具。前后端仅仅通过接口来协作，这个接口可能是JSON格式的RESTFul的接口，也可能是XML的，重点是后台只负责数据的提供和计算，而完全不处理展现。而前端则负责拿到数据，组织数据并展现的工作。这样结构清晰，关注点分离，前后端会变得相对独立并松耦合。但是这种想法依然还是很理想化，前后端集成往往还是一个很头痛的问题。比如在最后需要集成的时候，我们才发现最开始商量好的数据结构发生了变化，而且这种变化往往是在所难免的，这样就会增加大量的集成时间。 归根结底，还是前端或者后端感知到变化的时间周期太长，不能“及时协商，尽早解决”，最终导致集中爆发。怎么解决这个问题呢？我们需要提前协商好一些契约，并将这些契约作为可以被测试的中间产品，然后前后端都通过自动化测试来检验这些契约，一旦契约发生变化，测试就会失败。这样，每个失败的测试都会驱动双方再次协商，有效的缩短了反馈周期，并且降低集成风险。具体的实践方式，请参加我同事的一篇博文，“前后端分离了，然后呢？”http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/。 不过，仅仅靠纪律是不够的，还需要通过工具的辅助来提高效率。下面，我们就来看一下，一个API设计工具——Swagger，将如何帮助我们更好的实现“前后端分离”。 SwaggerSwagger包括库、编辑器、代码生成器等很多部分，这里我们主要讲一下Swagger Editor。这是一个完全开源的项目，并且它也是一个基于Angular的成功案例，我们可以下载源码并自己部署它，也可以修改它或集成到我们自己的软件中。 在Swagger Editor中，我们可以基于YAML语法定义我们的RESTful API，然后它会自动生成一篇排版优美的API文档，并且提供实时预览。相信大多数朋友都遇到过这样一个场景：明明调用的是之前约定好的API，拿到的结果却不是想要的。可能因为是有人修改了API的接口，却忘了更新文档；或者是文档更新的不及时；又或者是文档写的有歧义，大家的理解各不相同。总之，让API文档总是与API定义同步更新，是一件非常有价值的事。下面我们通过一个例子来感受一下Swagger给我们带来的好处。 首先我们需要安装一个Swagger Editor，或者也可以直接使用在线版本http://editor.swagger.io/。如果需要在本地启动编辑器，执行以下三行命令即可（前提是已经安装好了Node.js）： 123git clone https://github.com/swagger-api/swagger-editor.gitcd swagger-editornpm start 当我们修改了API的定义之后，在编辑器右侧就可以看到相应的API文档了，而且永远是最新的。 不仅如此，它还能够自动生成Mock server所需要的代码，这样一来前端开发就再也不用等着后端API 的实现了。除此之外，它还有一个更强大的功能，甚至能够帮助我们自动生成不同语言的客户端的代码。Swagger是基于插件来实现各种不同的语言的，所以，如果已经提供的语言中没有你正在用的，你也可以自己实现相应的插件，甚至是从源代码级别进行定制化。 契约测试谈到了前后端分离，那么在所难免，会遇到一些集成的问题：一拨人在全心全意的进行前端开发，另一拨人在心无旁骛的做后端开发，那么谁应该为集成买单呢？在现在这个持续集成、持续交付的年代里，我们应该如何去保证双方不会分道扬镳、越走越远呢？ 所以，在一开始就定一个契约就成了迫在眉睫的事情，双方就API相关的内容，包括路径、参数、类型等达成一致，当然，这份契约并不是一旦创建就不能修改的，而且，如果一开始没有设计好，很有可能会频繁的修改。这个时候，要让双方都能够实时的跟踪最新的API就成了一个难题。还好，在总结了前人的经验和教训之后，我们早已有了应对之策，那就是契约测试。 老马（Martin Fowler）早在2011年的时候就发表了一篇博客http://martinfowler.com/bliki/IntegrationContractTest.html，专门讨论了如何做契约测试。 首先，我们先假设我们已经有了一份契约，可能是基于JSON格式的，有可能是基于XML格式的，这都不重要。然后，前端会根据这份契约建立一个Mock server，所有的测试都发往这个Mock server。有两方面的原因：一是这个时候可能后台的API还没有开发完成；二是有可能因为网络等其他方面的原因导致直接调用真实的后台API会很不稳定或者很耗时。到这里，可能有人就要说了，如果后台的API实现和之前约定的并不一样，怎么能保证到了集成的时候双方还能很顺利的集成呢？其实这个问题并不难，只需要让前端的测试定期连接真实的API执行一遍就能尽早的发现差异性。比方说，在我们平常的build pipeline上添加一个job，让这些测试每天在午夜里连着真实的API执行。如果，第二天发现这些测试有的失败了，那么就需要和开发后台API的人员进行一次沟通了，很有可能由于真实的业务逻辑发生了变化，API在实现的时候，已经和之前的契约不一致了，如果是这样，那么相应的测试和契约定义就需要更新以满足最新的业务需求。 总之，进行契约测试的目的就是尽早的发现差异性，并作出调整，将最后集成的风险降到最低。 原文 http://www.cnblogs.com/whitewolf/","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"https://luox78.github.io/tags/swagger/"}]},{"title":"初始JQuery01","slug":"JQuery01","date":"2018-01-14T07:30:29.287Z","updated":"2018-01-14T14:00:04.329Z","comments":true,"path":"2018/01/14/JQuery01/","link":"","permalink":"https://luox78.github.io/2018/01/14/JQuery01/","excerpt":"常见的JavaScript框架库为什么使用JavaScript框架库？ 普通JavaScript的缺点：每种控件的操作方式不统一，不同浏览器下有区别，要编写跨浏览器的程序非常麻烦。因此出现了很多对JavaScript的封装库","text":"常见的JavaScript框架库为什么使用JavaScript框架库？ 普通JavaScript的缺点：每种控件的操作方式不统一，不同浏览器下有区别，要编写跨浏览器的程序非常麻烦。因此出现了很多对JavaScript的封装库 jQuery: jQuery就是JavaScript语法写的一些函数类，内部仍然是调用JavaScript实现的，所以并不是代替JavaScript的。使用jQuery的代码、编写jQuery的扩展插件等仍然需要JavaScript的技术，jQuery本身就是一堆JavaScript函数。 jQuery是最火的JavaScript库，已经被集成到VS2010了，得到了MS的支持，MS的Ajax toolkit和jQuery结合也是最方便，jQuery的扩展插件也是非常多 jQuery简介什么是jQuery？ jQuery就是一个JavaScript函数库 jQuery能做什么？jQuery是做什么的？ jQuery本身就是一堆JavaScript函数，JavaScript是做什么的，jQuery也一样。毕竟jQuery只是用JavaScript编写的函数库而已，有些功能jQuery没有封装，则还需要通过自己写JavaScript来实现。 jQuery中的顶级对象$$jQuery中最常用的对象即对象，要想使用jQuery的方法必须通过对象。只有将普通的Dom对象封装成jQuery对象，然后才能调用jQuery中的各种方法。 $是jQuery简写，在代码中可以使用jQuery代替，但一般为了方便大家都直接使用。 jquery里面的几个函数 $.map(array,callback(element,index));element 为元素 ，index 为遍历的索引 一个数组中的元素转换到另一个数组中。 作为参数的转换函数会为每个数组元素调用，而且会给这个转换函数传递一个表示被转换的元素作为参数。转换函数可以返回转换后的值、null（删除数组中的项目）或一个包含值的数组，并扩展至原始数组中。 1234567891011 var arr = [1, 2, 3, 4, 5, 6]; $.map(arr, function() &#123; console.log(arguments[0] * 2); &#125;); var data = &#123; \"luox78\": \"shuai\", \"age\": 18 &#125;; $.map(data, function () &#123; console.log(arguments[0]); &#125;); return false 演示 1234567$.map(arr, function() &#123; if (arguments[1] &gt; 3) return false; console.log(arguments[0]); &#125;); //1, 2, 3, 4 each(callback) 以每一个匹配的元素作为上下文来执行一个函数。 意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。返回 ‘false’ 将停止循环 (就像在普通的循环中使用 ‘break’)。返回 ‘true’ 跳至下一个循环(就像在普通的循环中使用’continue’)。 HTML 代码: 1&lt;img/&gt;&lt;img/&gt; jQuery 代码: 123$(\"img\").each(function(i)&#123; this.src = \"test\" + i + \".jpg\"; &#125;); jQuery.each(object, [callback]) 123$.each( [0,1,2], function(i, n)&#123; alert( \"Item #\" + i + \": \" + n );&#125;); jQuery.trim(str) 去掉字符串起始和结尾的空格。 jQuery 代码: 1$.trim(\" hello, how are you? \"); 结果: 1\"hello, how are you?\" JQuery选择器js dom 转换成JQuery对象 12var div = document.getElementById(\"div\");$(div).css(\"backgroundColor\", \"black\"); JQuery转换成dom对象 1$(div).get[0];//$(div)[0]; 问题 Array（数组）对象有没有对应的jQuery对象？ 数组本身就不是Dom对象。不存在与jQuery对象之间的转换。使用jQuery语句可以直接使用数组，就像jquery.each()或jquery.map() 链式编程什么是 链式编程 1$(\"#btn\").click(function()).css(XXX).text(); 说明 Jquery对象中的方法，一般带参数的返回jquery对象本身，不带参数的返回要的值，使用带参数的方法就实现了所谓的 链式编程，注意：返回的jquery对象有可能是一个集合 selector常见的 12345$('#id')、Id选择器$('span')、标签选择器$('.cls')，类选择器$('*[name=gender]')或$('[name=gender]')，属性过滤选择器：$('div.cls') 标签类选择器 多条件选择器 1$(“p,div,span.menuitem”)，同时选择p标签、div标签和拥有menuitem样式的span标签元素 层次选择器 后代，$(“div li”)获取div下的所有li元素（后代，子、子的子……） 子元素，$(“div &gt; li”)获取div下的直接li子元素 【必须是直接子元素】 相邻元素1：jquery(“.menuitem + div”)获取样式名为menuitem之后的相邻的（紧接着的）第一个div元素（不常用）等同于jquery(‘.menuitem’).next(‘div’);如果相邻的那个元素不是div,则不会继续向后找。 相邻元素2：jquery(“.menuitem ~ div”)获取样式名为menuitem之后所有的兄弟div元素，等同于jquery(‘. menuitem ’).nextAll(‘div’)。【nextAll(‘*’)或nextAll()表示后面的所有元素。】 获得兄弟元素的几个方法 next();//当前元素之后的紧邻着的第一个兄弟元素（下一个） nextAll();//当前元素之后的所有兄弟元素 prev();//当前元素之前的紧邻着的兄弟元素（上一个） prevAll();//当前元素之前的所有兄弟元素 siblings();//当前元素的所有兄弟元素 html 1234&lt;div&gt; &lt;input type=\"button\" value=\"使第一个层变色\" id=\"btn1\" /&gt; &lt;input type=\"button\" value=\"使第三个层变色\" id=\"btn2\" /&gt; &lt;/div&gt; js 123$(\"#btn1\").click(function() &#123; $(\"#div\").prev().css('backgroundColor', \"red\"); &#125;); 注意方法括号中可以加筛选的表达式，限制查找的元素 12345678910HTML 代码:&lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt;&lt;p class=\"selected\"&gt;Hello Again&lt;/p&gt;&lt;p&gt;And Again&lt;/p&gt;jQuery 代码:$(\"p\").prev(\".selected\")结果:[ &lt;p class=\"selected\"&gt;Hello Again&lt;/p&gt; ] 基本过滤选择器:first选取第一个元素。$(“div:first”)选取第一个&lt;div&gt; :last选取最后一个元素。$(“div:last”)选取最后一个&lt;div&gt; :not(选择器) 选取不满足“选择器”条件的元素，$(“input:not(.myClass)”)选取样式名不是myClass的&lt;input&gt; :even、:odd，选取索引是偶数、奇数的元素：$(“input:even”)选取索引是奇数的&lt;input&gt; :eq(索引序号)、gt(索引序号)、:lt(索引序号) 选取索引等于、大于、小于索引序号的元素，比如$(“input:lt(5)”)选取索引小于5的&lt;input&gt; $(“:header”)选取所有的h1……h6元素（*） $(“div:animated”)选取正在执行动画的&lt;div&gt;元素。 （*） 12//大于索引2的又小于后面索引2的,每次筛选都是上次筛选,即每次筛选后索引都清零$('div:gt(2):lt(2)').css('backgroundColor', 'yellow'); 一些问题如何判断对象是否存在 jQuery选择器返回的是一个对象数组，调用text()、html()、click()之类方法的时候其实是对数组中每个元素迭代调用每个方法，因此即使通过id选择的元素不存在也不会报错，如果需要判断指定的id是否存在，应该写 123if ($(\"#btn1\").length &lt;= 0) &#123; alert(\"id为btn1的元素不存在！\"); &#125; 样式操作addClass(class|fn) 概述 为每个匹配的元素添加指定的类名。 参数 class StringV1.0 一个或多个要添加到元素中的CSS类名，请用空格分开 function(index, class) FunctionV1.4 此函数必须返回一个或多个空格分隔的class名。接受两个参数，index参数为对象在这个集合中的索引值，class参数为这个对象原先的class属性值。 示例 参数class 描述: 为匹配的元素加上 ‘selected’ 类 jQuery 代码: 12$(\"p\").addClass(\"selected\");$(\"p\").addClass(\"selected1 selected2\"); removeClass([class|fn]) 概述 从所有匹配的元素中删除全部或者指定的类。 参数 classStringV1.0 一个或多个要删除的CSS类名，请用空格分开 function(index, class)FunctionV1.4 此函数必须返回一个或多个空格分隔的class名。接受两个参数，index参数为对象在这个集合中的索引值，class参数为这个对象原先的class属性值。 示例 参数class 描述: 从匹配的元素中删除 ‘selected’ 类 jQuery 代码: 1$(\"p\").removeClass(\"selected\"); 参数class 描述: 删除匹配元素的所有类 jQuery 代码: 1$(\"p\").removeClass(); 回调函数描述: 删除最后一个元素上与前面重复的class jQuery 代码: 123$('li:last').removeClass(function() &#123; return $(this).prev().attr('class');&#125;); toggleClass (class|fn[,sw]) 概述 如果存在（不存在）就删除（添加）一个类。 参数 classStringV1.0 CSS类名 class,switchString,BooleanV1.3 1:要切换的CSS类名. 2:用于决定元素是否包含class的布尔值。 switchBooleanV1.4 用于决定元素是否包含class的布尔值。 function(index, class,switch)[, switch]Function,BooleanV1.4 1:用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数。 2: 一个用来判断样式类添加还是移除的 boolean 值。 示例 参数class 描述: 为匹配的元素切换 ‘selected’ 类 jQuery 代码: 1$(\"p\").toggleClass(\"selected\"); 参数class,switch 描述: 每点击三下加上一次 ‘highlight’ 类 HTML 代码: 1&lt;strong&gt;jQuery 代码:&lt;/strong&gt; jQuery 代码: 1234var count = 0;$(\"p\").click(function()&#123; $(this).toggleClass(\"highlight\", count++ % 3 == 0);&#125;); 回调函数 描述: 根据父元素来设置class属性 jQuery 代码: 1234567$('div.foo').toggleClass(function() &#123; if ($(this).parent().is('.bar') &#123; return 'happy'; &#125; else &#123; return 'sad'; &#125;&#125;); hasClass(class) 概述 检查当前的元素是否含有某个特定的类，如果有，则返回true。 这其实就是 is(“.” + class)。 参数 classStringV1.2 用于匹配的类名","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://luox78.github.io/categories/JQuery/"}],"tags":[{"name":"jQueryfoundation","slug":"jQueryfoundation","permalink":"https://luox78.github.io/tags/jQueryfoundation/"},{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"初识JavaScript06","slug":"JavaScript06","date":"2018-01-13T11:39:26.030Z","updated":"2018-01-13T14:09:01.936Z","comments":true,"path":"2018/01/13/JavaScript06/","link":"","permalink":"https://luox78.github.io/2018/01/13/JavaScript06/","excerpt":"一些问题 window.event.keyCode实现对键盘的获取 回车的keyCode为13，Tab的keyCode为9,只有少数的键才能被替换，大部分是不行的，有权限问题 checkbox &lt;input type=&quot;checkbox&quot; id=&quot;check&quot;/&gt;&lt;label for=&quot;check&quot;&gt;11111&lt;/label&gt;让标签指向checkbox，","text":"一些问题 window.event.keyCode实现对键盘的获取 回车的keyCode为13，Tab的keyCode为9,只有少数的键才能被替换，大部分是不行的，有权限问题 checkbox &lt;input type=&quot;checkbox&quot; id=&quot;check&quot;/&gt;&lt;label for=&quot;check&quot;&gt;11111&lt;/label&gt;让标签指向checkbox， checkbox属性checked=“checked”|true为选中，=false为未选中,=false只在js中使用 JS中操作select 清空options 12while (document.getElementById(\"shi\").firstChild) &#123; document.getElementById(\"shi\").removeChild(document.getElementById(\"shi\").firstChild); &#125; 根据数据添加 12345for (var key in datas) &#123; var opt = document.createElement(\"option\"); opt.innerText = key; document.getElementById(\"shen\").appendChild(opt); &#125; 如何获取选择项 1var shis = datas[this[this.selectedIndex].text];//this指select对象 ​","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"Newtonsoft.Json介绍","slug":"Newtonsoft_Json","date":"2018-01-12T15:43:30.908Z","updated":"2018-01-12T16:31:33.467Z","comments":true,"path":"2018/01/12/Newtonsoft_Json/","link":"","permalink":"https://luox78.github.io/2018/01/12/Newtonsoft_Json/","excerpt":"在做开发的时候，很多数据交换都是以json格式传输的。而使用Json的时候，我们很多时候会涉及到几个序列化对象的使用：DataContractJsonSerializer,JavaScriptSerializer","text":"在做开发的时候，很多数据交换都是以json格式传输的。而使用Json的时候，我们很多时候会涉及到几个序列化对象的使用：DataContractJsonSerializer,JavaScriptSerializer 和 Json.NET即Newtonsoft.Json。大多数人都会选择性能以及通用性较好Json.NET，这个不是微软的类库，但是一个开源的世界级的Json操作类库，从下面的性能对比就可以看到它的其中之一的性能优点。 齐全的API介绍，使用方式简单 常见用法JsonConvert Json.Net是支持序列化和反序列化DataTable,DataSet,Entity Framework和Entity的。下面分别举例说明序列化和反序列化。 DataTable： 12345678910111213141516//序列化DataTableDataTable dt = new DataTable();dt.Columns.Add(\"Age\", Type.GetType(\"System.Int32\"));dt.Columns.Add(\"Name\", Type.GetType(\"System.String\"));dt.Columns.Add(\"Sex\", Type.GetType(\"System.String\"));dt.Columns.Add(\"IsMarry\", Type.GetType(\"System.Boolean\"));for (int i = 0; i &lt; 4; i++)&#123; DataRow dr = dt.NewRow(); dr[\"Age\"] = i + 1; dr[\"Name\"] = \"Name\" + i; dr[\"Sex\"] = i % 2 == 0 ? \"男\" : \"女\"; dr[\"IsMarry\"] = i % 2 &gt; 0 ? true : false; dt.Rows.Add(dr);&#125;Console.WriteLine(JsonConvert.SerializeObject(dt)); 利用上面字符串进行反序列化 123456string json = JsonConvert.SerializeObject(dt);dt=JsonConvert.DeserializeObject&lt;DataTable&gt;(json);foreach (DataRow dr in dt.Rows)&#123; Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\\t&#123;3&#125;\\t\", dr[0], dr[1], dr[2], dr[3]);&#125; Entity序列化和DataTable一样，就不过多介绍了。 JsonSerializer12345678910111213Product product = new Product();product.ExpiryDate = new DateTime(2008, 12, 28);JsonSerializer serializer = new JsonSerializer();serializer.Converters.Add(new JavaScriptDateTimeConverter());serializer.NullValueHandling = NullValueHandling.Ignore;using (StreamWriter sw = new StreamWriter(@\"c:\\json.txt\"))using (JsonWriter writer = new JsonTextWriter(sw))&#123; serializer.Serialize(writer, product); // &#123;\"ExpiryDate\":new Date(1230375600000),\"Price\":0&#125;&#125; LINQ to JSON1234567891011121314151617JObject o = JObject.Parse(@\"&#123; 'CPU': 'Intel', 'Drives': [ 'DVD read/writer', '500 gigabyte hard drive' ]&#125;\");string cpu = (string)o[\"CPU\"];// Intelstring firstDrive = (string)o[\"Drives\"][0];// DVD read/writerIList&lt;string&gt; allDrives = o[\"Drives\"].Select(t =&gt; (string)t).ToList();// DVD read/writer// 500 gigabyte hard drive Parsing JSON textParsing a JSON Object from text 123456789string json = @\"&#123; CPU: 'Intel', Drives: [ 'DVD read/writer', '500 gigabyte hard drive' ]&#125;\";JObject o = JObject.Parse(json); Parsing a JSON Array from text 1234567string json = @\"[ 'Small', 'Medium', 'Large']\";JArray a = JArray.Parse(json); Loading JSON from a fileReading JSON from a file 12345using (StreamReader reader = File.OpenText(@\"c:\\person.json\"))&#123; JObject o = (JObject)JToken.ReadFrom(new JsonTextReader(reader)); // do stuff&#125; Querying JSON with LINQ123456789101112131415161718192021222324252627282930313233343536373839404142string json = @\"&#123; 'channel': &#123; 'title': 'James Newton-King', 'link': 'http://james.newtonking.com', 'description': 'James Newton-King\\'s blog.', 'item': [ &#123; 'title': 'Json.NET 1.3 + New license + Now on CodePlex', 'description': 'Annoucing the release of Json.NET 1.3, the MIT license and the source on CodePlex', 'link': 'http://james.newtonking.com/projects/json-net.aspx', 'categories': [ 'Json.NET', 'CodePlex' ] &#125;, &#123; 'title': 'LINQ to JSON beta', 'description': 'Annoucing LINQ to JSON', 'link': 'http://james.newtonking.com/projects/json-net.aspx', 'categories': [ 'Json.NET', 'LINQ' ] &#125; ] &#125; &#125;\"; JObject rss = JObject.Parse(json); string rssTitle = (string)rss[\"channel\"][\"title\"]; // James Newton-King string itemTitle = (string)rss[\"channel\"][\"item\"][0][\"title\"]; // Json.NET 1.3 + New license + Now on CodePlex JArray categories = (JArray)rss[\"channel\"][\"item\"][0][\"categories\"]; // [\"Json.NET\", \"CodePlex\"] IList&lt;string&gt; categoriesText = categories.Select(c =&gt; (string)c).ToList(); // Json.NET // CodePlex Convert JSON to XML1XNode node = JsonConvert.DeserializeXNode(json, \"Root\"); Convert XML to JSON1234567891011121314151617181920212223242526272829303132333435363738 1string xml = @\"&lt;?xml version='1.0' standalone='no'?&gt; 2&lt;root&gt; 3 &lt;person id='1'&gt; 4 &lt;name&gt;Alan&lt;/name&gt; 5 &lt;url&gt;http://www.google.com&lt;/url&gt; 6 &lt;/person&gt; 7 &lt;person id='2'&gt; 8 &lt;name&gt;Louis&lt;/name&gt; 9 &lt;url&gt;http://www.yahoo.com&lt;/url&gt;10 &lt;/person&gt;11&lt;/root&gt;\";1213XmlDocument doc = new XmlDocument();14doc.LoadXml(xml);1516string json = JsonConvert.SerializeXmlNode(doc);1718Console.WriteLine(json);19// &#123;20// \"?xml\": &#123;21// \"@version\": \"1.0\",22// \"@standalone\": \"no\"23// &#125;,24// \"root\": &#123;25// \"person\": [26// &#123;27// \"@id\": \"1\",28// \"name\": \"Alan\",29// \"url\": \"http://www.google.com\"30// &#125;,31// &#123;32// \"@id\": \"2\",33// \"name\": \"Louis\",34// \"url\": \"http://www.yahoo.com\"35// &#125;36// ]37// &#125;38// &#125; Convert XML to JSON and force array12345678910111213141516171819202122232425262728293031323334353637383940414243 1string xml = @\"&lt;person id='1'&gt; 2 &lt;name&gt;Alan&lt;/name&gt; 3 &lt;url&gt;http://www.google.com&lt;/url&gt; 4 &lt;role&gt;Admin1&lt;/role&gt; 5&lt;/person&gt;\"; 6 7XmlDocument doc = new XmlDocument(); 8doc.LoadXml(xml); 910string json = JsonConvert.SerializeXmlNode(doc);1112Console.WriteLine(json);13// &#123;14// \"person\": &#123;15// \"@id\": \"1\",16// \"name\": \"Alan\",17// \"url\": \"http://www.google.com\",18// \"role\": \"Admin1\"19// &#125;20// &#125;2122xml = @\"&lt;person xmlns:json='http://james.newtonking.com/projects/json' id='1'&gt;23 &lt;name&gt;Alan&lt;/name&gt;24 &lt;url&gt;http://www.google.com&lt;/url&gt;25 &lt;role json:Array='true'&gt;Admin&lt;/role&gt;26&lt;/person&gt;\";2728doc = new XmlDocument();29doc.LoadXml(xml);3031json = JsonConvert.SerializeXmlNode(doc);3233Console.WriteLine(json);34// &#123;35// \"person\": &#123;36// \"@id\": \"1\",37// \"name\": \"Alan\",38// \"url\": \"http://www.google.com\",39// \"role\": [40// \"Admin\"41// ]42// &#125;43// &#125; 类转换用法​ 1.忽略某些属性 ​ 2.默认值的处理 ​ 3.空值的处理 ​ 4.支持非公共成员 ​ 5.日期处理 ​ 6.自定义序列化的字段名称 7.动态决定属性是否序列化 ​ 8.枚举值的自定义格式化问题 9.自定义类型转换 10.全局序列化设置 一.忽略某些属性 类似本问开头介绍的接口优化，实体中有些属性不需要序列化返回，可以使用该特性。首先介绍Json.Net序列化的模式:OptOut 和 OptIn options 说明 OptIn 默认情况下,所有的成员不会被序列化,类中的成员只有标有特性JsonProperty的才会被序列化,当类的成员很多,但客户端仅仅需要一部分数据时,很有用 OptOut 默认值,类中所有公有成员会被序列化,如果不想被序列化,可以用特性JsonIgnore 仅需要姓名属性 1234567891011121314[JsonObject(MemberSerialization.OptIn)]public class Person&#123; public int Age &#123; get; set; &#125; [JsonProperty] public string Name &#123; get; set; &#125; public string Sex &#123; get; set; &#125; public bool IsMarry &#123; get; set; &#125; public DateTime Birthday &#123; get; set; &#125;&#125; 不需要是否结婚属性 1234567891011121314[JsonObject(MemberSerialization.OptOut)]public class Person&#123; public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Sex &#123; get; set; &#125; [JsonIgnore] public bool IsMarry &#123; get; set; &#125; public DateTime Birthday &#123; get; set; &#125;&#125; 通过上面的例子可以看到，要实现不返回某些属性的需求很简单。1.在实体类上加上[JsonObject(MemberSerialization.OptOut)] 2.在不需要返回的属性上加上 [JsonIgnore]说明。 二.默认值处理​ 序列化时想忽略默认值属性可以通过JsonSerializerSettings.DefaultValueHandling来确定，该值为枚举值 DefaultValueHandling.Ignore 序列化和反序列化时,忽略默认值 DefaultValueHandling.Include 序列化和反序列化时,包含默认值 12[DefaultValue(10)]public int Age &#123; get; set; &#125; 1234Person p = new Person &#123; Age = 10, Name = \"张三丰\", Sex = \"男\", IsMarry = false, Birthday = new DateTime(1991, 1, 2) &#125;;JsonSerializerSettings jsetting=new JsonSerializerSettings();jsetting.DefaultValueHandling=DefaultValueHandling.Ignore;Console.WriteLine(JsonConvert.SerializeObject(p, Formatting.Indented, jsetting)); 最终结果如下： 三.空值的处理序列化时需要忽略值为NULL的属性，可以通过JsonSerializerSettings.NullValueHandling来确定，另外通过JsonSerializerSettings设置属性是对序列化过程中所有属性生效的，想单独对某一个属性生效可以使用JsonProperty，下面将分别展示两个方式 1.JsonSerializerSettings 1234Person p = new Person &#123; room=null,Age = 10, Name = \"张三丰\", Sex = \"男\", IsMarry = false, Birthday = new DateTime(1991, 1, 2) &#125;;JsonSerializerSettings jsetting=new JsonSerializerSettings();jsetting.NullValueHandling = NullValueHandling.Ignore;Console.WriteLine(JsonConvert.SerializeObject(p, Formatting.Indented, jsetting)); 2.JsonProperty 通过JsonProperty属性设置的方法，可以实现某一属性特别处理的需求，如默认值处理，空值处理，自定义属性名处理，格式化处理。上面空值处理实现 12[JsonProperty(NullValueHandling=NullValueHandling.Ignore)]public Room room &#123; get; set; &#125; 四.支持非公共成员 序列化时默认都是处理公共成员，如果需要处理非公共成员，就要在该成员上加特性”JsonProperty” 12[JsonProperty]private int Height &#123; get; set; &#125; 五.日期处理 对于Dateime类型日期的格式化就比较麻烦了，系统自带的会格式化成iso日期标准，但是实际使用过程中大多数使用的可能是yyyy-MM-dd 或者yyyy-MM-dd HH:mm:ss两种格式的日期，解决办法是可以将DateTime类型改成string类型自己格式化好，然后在序列化。如果不想修改代码，可以采用下面方案实现。 ​ Json.Net提供了IsoDateTimeConverter日期转换这个类，可以通过JsnConverter实现相应的日期转换 12[JsonConverter(typeof(IsoDateTimeConverter))]public DateTime Birthday &#123; get; set; &#125; 但是IsoDateTimeConverter日期格式不是我们想要的，我们可以继承该类实现自己的日期 1234567891011121314public class ChinaDateTimeConverter : DateTimeConverterBase&#123; private static IsoDateTimeConverter dtConverter = new IsoDateTimeConverter &#123; DateTimeFormat = \"yyyy-MM-dd\" &#125;; public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) &#123; return dtConverter.ReadJson(reader, objectType, existingValue, serializer); &#125; public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) &#123; dtConverter.WriteJson(writer, value, serializer); &#125;&#125; ​ 自己实现了一个yyyy-MM-dd格式化转换类，可以看到只是初始化IsoDateTimeConverter时给的日期格式为yyyy-MM-dd即可，下面看下效果 12[JsonConverter(typeof(ChinaDateTimeConverter))]public DateTime Birthday &#123; get; set; &#125; 可以根据自己需求实现不同的转换类 六.自定义序列化的字段名称 实体中定义的属性名可能不是自己想要的名称，但是又不能更改实体定义，这个时候可以自定义序列化字段名称。 12[JsonProperty(PropertyName = \"CName\")]public string Name &#123; get; set; &#125; 七.动态决定属性是否序列化 这个是为了实现@米粒儿提的需求特别增加的，根据某些场景，可能A场景输出A，B，C三个属性，B场景输出E，F属性。虽然实际中不一定存在这种需求，但是json.net依然可以支持该特性。 继承默认的DefaultContractResolver类，传入需要输出的属性 ​ 重写修改了一下，大多数情况下应该是要排除的字段少于要保留的字段, 为了方便书写这里修改了构造函数加入retain表示props是需要保留的字段还是要排除的字段 12345678910111213141516171819202122232425262728293031323334353637public class LimitPropsContractResolver : DefaultContractResolver &#123; string[] props = null; bool retain; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=\"props\"&gt;传入的属性数组&lt;/param&gt; /// &lt;param name=\"retain\"&gt;true:表示props是需要保留的字段 false：表示props是要排除的字段&lt;/param&gt; public LimitPropsContractResolver(string[] props, bool retain=true) &#123; //指定要序列化属性的清单 this.props = props; this.retain = retain; &#125; protected override IList&lt;JsonProperty&gt; CreateProperties(Type type, MemberSerialization memberSerialization) &#123; IList&lt;JsonProperty&gt; list = base.CreateProperties(type, memberSerialization); //只保留清单有列出的属性 return list.Where(p =&gt; &#123; if (retain) &#123; return props.Contains(p.PropertyName); &#125; else &#123; return !props.Contains(p.PropertyName); &#125; &#125;).ToList(); &#125; 123456public int Age &#123; get; set; &#125;[JsonIgnore]public bool IsMarry &#123; get; set; &#125;public string Sex &#123; get; set; &#125; 123JsonSerializerSettings jsetting=new JsonSerializerSettings();jsetting.ContractResolver = new LimitPropsContractResolver(new string[] &#123; \"Age\", \"IsMarry\" &#125;);Console.WriteLine(JsonConvert.SerializeObject(p, Formatting.Indented, jsetting)); 使用自定义的解析类，只输出”Age”, “IsMarry”两个属性，看下最终结果.只输出了Age属性，为什么IsMarry属性没有输出呢，因为标注了JsonIgnore 看到上面的结果想要实现pc端序列化一部分，手机端序列化另一部分就很简单了吧，我们改下代码实现一下 1234567891011string[] propNames = null;if (p.Age &gt; 10)&#123; propNames = new string[] &#123; \"Age\", \"IsMarry\" &#125;;&#125;else&#123; propNames = new string[] &#123; \"Age\", \"Sex\" &#125;;&#125;jsetting.ContractResolver = new LimitPropsContractResolver(propNames);Console.WriteLine(JsonConvert.SerializeObject(p, Formatting.Indented, jsetting)); 八.枚举值的自定义格式化问题 默认情况下对于实体里面的枚举类型系统是格式化成改枚举对应的整型数值,那如果需要格式化成枚举对应的字符怎么处理呢？Newtonsoft.Json也帮我们想到了这点，下面看实例 123456789101112131415161718192021public enum NotifyType&#123; /// &lt;summary&gt; /// Emil发送 /// &lt;/summary&gt; Mail=0, /// &lt;summary&gt; /// 短信发送 /// &lt;/summary&gt; SMS=1&#125;public class TestEnmu&#123; /// &lt;summary&gt; /// 消息发送类型 /// &lt;/summary&gt; public NotifyType Type &#123; get; set; &#125;&#125;JsonConvert.SerializeObject(new TestEnmu()); 输出结果： 现在改造一下，输出”Type”:”Mail” 12345678public class TestEnmu&#123; /// &lt;summary&gt; /// 消息发送类型 /// &lt;/summary&gt; [JsonConverter(typeof(StringEnumConverter))] public NotifyType Type &#123; get; set; &#125;&#125; 其它的都不变，在Type属性上加上了JsonConverter(typeof(StringEnumConverter))表示将枚举值转换成对应的字符串,而StringEnumConverter是Newtonsoft.Json内置的转换类型,最终输出结果 九.自定义类型转换默认情况下对于实体里面的Boolean系统是格式化成true或者false,对于true转成”是” false转成”否”这种需求改怎么实现了？我们可以自定义类型转换实现该需求，下面看实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class BoolConvert : JsonConverter &#123; private string[] arrBString &#123; get; set; &#125; public BoolConvert() &#123; arrBString = \"是,否\".Split(','); &#125; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=\"BooleanString\"&gt;将bool值转换成的字符串值&lt;/param&gt; public BoolConvert(string BooleanString) &#123; if (string.IsNullOrEmpty(BooleanString)) &#123; throw new ArgumentNullException(); &#125; arrBString = BooleanString.Split(','); if (arrBString.Length != 2) &#123; throw new ArgumentException(\"BooleanString格式不符合规定\"); &#125; &#125; public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) &#123; bool isNullable = IsNullableType(objectType); Type t = isNullable ? Nullable.GetUnderlyingType(objectType) : objectType; if (reader.TokenType == JsonToken.Null) &#123; if (!IsNullableType(objectType)) &#123; throw new Exception(string.Format(\"不能转换null value to &#123;0&#125;.\", objectType)); &#125; return null; &#125; try &#123; if (reader.TokenType == JsonToken.String) &#123; string boolText = reader.Value.ToString(); if (boolText.Equals(arrBString[0], StringComparison.OrdinalIgnoreCase)) &#123; return true; &#125; else if (boolText.Equals(arrBString[1], StringComparison.OrdinalIgnoreCase)) &#123; return false; &#125; &#125; if (reader.TokenType == JsonToken.Integer) &#123; //数值 return Convert.ToInt32(reader.Value) == 1; &#125; &#125; catch (Exception ex) &#123; throw new Exception(string.Format(\"Error converting value &#123;0&#125; to type '&#123;1&#125;'\", reader.Value, objectType)); &#125; throw new Exception(string.Format(\"Unexpected token &#123;0&#125; when parsing enum\", reader.TokenType)); &#125; /// &lt;summary&gt; /// 判断是否为Bool类型 /// &lt;/summary&gt; /// &lt;param name=\"objectType\"&gt;类型&lt;/param&gt; /// &lt;returns&gt;为bool类型则可以进行转换&lt;/returns&gt; public override bool CanConvert(Type objectType) &#123; return true; &#125; public bool IsNullableType(Type t) &#123; if (t == null) &#123; throw new ArgumentNullException(\"t\"); &#125; return (t.BaseType.FullName==\"System.ValueType\" &amp;&amp; t.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;)); &#125; public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) &#123; if (value == null) &#123; writer.WriteNull(); return; &#125; bool bValue = (bool)value; if (bValue) &#123; writer.WriteValue(arrBString[0]); &#125; else &#123; writer.WriteValue(arrBString[1]); &#125; &#125; &#125; 自定义了BoolConvert类型，继承自JsonConverter。构造函数参数BooleanString可以让我们自定义将true false转换成相应字符串。下面看实体里面怎么使用这个自定义转换类型 12345public class Person&#123; [JsonConverter(typeof(BoolConvert))] public bool IsMarry &#123; get; set; &#125;&#125; ‘ 相应的有什么个性化的转换需求，都可以使用自定义转换类型的方式实现。 十.全局序列化设置文章开头提出了Null值字段怎么不返回的问题，相应的在高级用法也给出了相应的解决方案使用jsetting.NullValueHandling = NullValueHandling.Ignore; 来设置不返回空值。这样有个麻烦的地方，每个不想返回空值的序列化都需设置一下。可以对序列化设置一些默认值方式么？下面将解答 123456789101112131415 Newtonsoft.Json.JsonSerializerSettings setting = new Newtonsoft.Json.JsonSerializerSettings();JsonConvert.DefaultSettings = new Func&lt;JsonSerializerSettings&gt;(() =&gt;&#123; //日期类型默认格式化处理 setting.DateFormatHandling = Newtonsoft.Json.DateFormatHandling.MicrosoftDateFormat; setting.DateFormatString = \"yyyy-MM-dd HH:mm:ss\"; //空值处理 setting.NullValueHandling = NullValueHandling.Ignore; //高级用法九中的Bool类型转换 设置 setting.Converters.Add(new BoolConvert(\"是,否\")); return setting;&#125;); 这样设置以后，以后使用序列化的地方就不需要单独设置了，个人最喜欢设置的是空值处理这一块。 本文来源https://www.cnblogs.com/yanweidie/p/4605212.html https://www.newtonsoft.com/json/help/html/Introduction.htm","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://luox78.github.io/tags/Json/"}]},{"title":"C#路径","slug":"CS_path","date":"2018-01-11T14:11:08.831Z","updated":"2018-01-11T15:04:34.328Z","comments":true,"path":"2018/01/11/CS_path/","link":"","permalink":"https://luox78.github.io/2018/01/11/CS_path/","excerpt":"获取当前文件的路径string str1=Process.GetCurrentProcess().MainModule.FileName;//可获得当前执行的exe的文件名。string str2=Environment.CurrentDirectory;//获取和设置当前目录（即该进程从中启动的目录）的完全限定路径。","text":"获取当前文件的路径string str1=Process.GetCurrentProcess().MainModule.FileName;//可获得当前执行的exe的文件名。string str2=Environment.CurrentDirectory;//获取和设置当前目录（即该进程从中启动的目录）的完全限定路径。(备注:按照定义，如果该进程在本地或网络驱动器的根目录中启动，则此属性的值为驱动器名称后跟一个尾部反斜杠（如“C:\\”）。如果该进程在子目录中启动，则此属性的值为不带尾部反斜杠的驱动器和子目录路径[如“C:\\mySubDirectory”])。string str3=Directory.GetCurrentDirectory(); //获取应用程序的当前工作目录。string str4=AppDomain.CurrentDomain.BaseDirectory;//获取基目录，它由程序集冲突解决程序用来探测程序集。string str5=Application.StartupPath;//获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。string str6=Application.ExecutablePath;//获取启动了应用程序的可执行文件的路径，包括可执行文件的名称。string str7=AppDomain.CurrentDomain.SetupInformation.ApplicationBase;//获取或设置包含该应用程序的目录的名称。 System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName获取模块的完整路径。 System.Environment.CurrentDirectory获取和设置当前目录(该进程从中启动的目录)的完全限定目录。 System.IO.Directory.GetCurrentDirectory()获取应用程序的当前工作目录。这个不一定是程序从中启动的目录啊，有可能程序放在C:\\www里,这个函数有可能返回C:\\Documents and Settings\\ZYB\\,或者C:\\Program Files\\Adobe\\,有时不一定返回什么东东，这是任何应用程序最后一次操作过的目录，比如你用Word打开了E:\\doc\\my.doc这个文件，此时执行这个方法就返回了E:\\doc了。 System.AppDomain.CurrentDomain.BaseDirectory获取程序的基目录。 System.Windows.Forms.Application.StartupPath获取启动了应用程序的可执行文件的路径。效果和2、5一样。只是5返回的字符串后面多了一个&quot;\\&quot;而已。 System.Windows.Forms.Application.ExecutablePath获取启动了应用程序的可执行文件的路径及文件名，效果和1一样。 System.AppDomain.CurrentDomain.SetupInformation.ApplicationBase获取和设置包括该应用程序的目录的名称。 操作环境变量 利用System.Environment.GetEnvironmentVariable()方法可以很方便地取得系统环境变量，如： System.Environment.GetEnvironmentVariable(&quot;windir&quot;)就可以取得windows系统目录的路径。以下是一些常用的环境变量取值： System.Environment.GetEnvironmentVariable(“windir”); System.Environment.GetEnvironmentVariable(“INCLUDE”); System.Environment.GetEnvironmentVariable(“TMP”); System.Environment.GetEnvironmentVariable(“TEMP”); System.Environment.GetEnvironmentVariable(“Path”); 获取上级目录本文实例讲述了C#的path.GetFullPath 获取上级目录实现方法，分享给大家供大家参考。具体实现方法如下： string path = new directoryinfo(&quot;../&quot;).fullname;//当前应用程序路径的上级目录 获取当前目录可以使用 appdomain.currentdomain.basedirectory 获取当前目录的上级目录 path.getfullpath(&quot;..&quot;) asp就比.net简单了，直接../就行了 如果是asp.net直接用server.mappath(&quot;~/bg/&quot;)就可以了。","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"path","slug":"path","permalink":"https://luox78.github.io/tags/path/"}]},{"title":"位操作","slug":"Bitwise_operations","date":"2018-01-09T14:30:38.481Z","updated":"2018-01-12T16:30:46.083Z","comments":true,"path":"2018/01/09/Bitwise_operations/","link":"","permalink":"https://luox78.github.io/2018/01/09/Bitwise_operations/","excerpt":"位操作 符号 名称 演示 &amp; 与 1 &amp; 1 = 11 &amp; 0 = 00 &amp; 0 = 0 ｜ 或 1｜1 = 11｜0 = 10｜0 = 0 ^ 异或 1 ^ 1 = 01 ^ 0 = 10 ^ 0 = 0 ~ 非 ~1 = 0~0 = 1 &lt;&lt; 左移 10101 &lt;&lt; 2 =10100(相当于乘2) &gt;&gt; 右移 10101 &gt;&gt; 2 =00101(相当于除2)","text":"位操作 符号 名称 演示 &amp; 与 1 &amp; 1 = 11 &amp; 0 = 00 &amp; 0 = 0 ｜ 或 1｜1 = 11｜0 = 10｜0 = 0 ^ 异或 1 ^ 1 = 01 ^ 0 = 10 ^ 0 = 0 ~ 非 ~1 = 0~0 = 1 &lt;&lt; 左移 10101 &lt;&lt; 2 =10100(相当于乘2) &gt;&gt; 右移 10101 &gt;&gt; 2 =00101(相当于除2) 常见函数set_bit12345// 给position位设置为1static int set_bit(int i,int position)&#123; return i | 1 &lt;&lt; position;&#125; clear_bit12345//给position位设置为0static int clear_bit(int i,int position)&#123; return i &amp; ~(1 &lt;&lt; position);&#125; flip_bit12345 //翻转position位的值static int flip_bit(int i,int position)&#123; return i ^ (1 &lt;&lt; position);&#125; is_bit_set12345//判断position位是否为bit（1）static int is_bit_set(int i,int position)&#123; return i &gt;&gt; position &amp; 1;&#125; modify_bit(见补码)12345//state 为 1 是set_bit ；state 为 0 时clear_bit static int modify_bit(int i,int position,int state)&#123; return (i &amp; ~(1 &lt;&lt; position)) | (-state &amp; 1 &lt;&lt; position);&#125; 补码（二补数） 补码用来表示负数的 https://zh.wikipedia.org/wiki/二補數 表示 补码使用有符号第一位表示正负，1为负 0为正，所以8有符号位数范围+-127，无符号位数255-0，无符号位数在C#中UInt32代表无符号32位 十进制值 二进制（二进制补码表示） 二补（2 - n）2 0 0000 0000 0000 0000 1 0000 0001 1111 1111 2 0000 0010 1111 1110 126 0111 1110 1000 0010 127 0111 1111 1000 0001 -128 1000 0000 1000 0000 -127 1000 0001 0111 1111 -126 1000 0010 0111 1110 -2 1111 1110 0000 0010 -1 1111 1111 0000 0001 为什么使用补码 二补数系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的二补数来表示，因此只要有加法电路及二补数电路即可完成各种有号数加法及减法，在电路设计上相当方便。 如何进行表示 ​ -1 原码：0000 0001 反码：1111 1110 补码=反码+1：1111 1111 一种简易的方式，可以找出二进位数字的二补数 先由最低位元开始找。 若该位元为0，将二补数对应位元填0，继续找下一位元（较高的位元）。 若找到第一个为1的位元，将二补数对应位元填1。 将其馀未转换的位元进行位元反相，将结果填入对应的二补数。 以0011 1100为例（图中的^表示目前转换的数字，-表示还不确定的位数）： 原数字 补码 0011 1100 —- —0（此位元为0） ​ ^ 0011 1100 —- –00（此位元为0） ​ ^ 0011 1100 —- -100（找到第1个为1的位元） ​ ^ 0011 1100 1100 0100（其馀位元直接反相） ^ 因此其结果为1100 0100 一些位操作一些提示 C#中不能直接将一串二进制数赋值给int32，可以用一下转换 Convert.ToInt32(&quot;1111&quot;,2)1111的二进制，即15 int32类型 Convert.ToString(15,2)15的二进制字符串，”1111“ 是否为偶数1234static bool is_even(int i)&#123; return (i &amp; 1) == 0;&#125; 返回有多少位不同1234static int diff_bit(int a,int b)&#123; return Convert.ToString(a ^ b, 2).Where(m =&gt; m == '1').Count();&#125; 四舍五入2的幂数123456789101112static int roundUpToNextPowerOfTwo(int x)&#123; x--; x |= x &gt;&gt; 1; // handle 2 bit x |= x &gt;&gt; 2; // handle 4 bit numbers x |= x &gt;&gt; 4; // handle 8 bit numbers x |= x &gt;&gt; 8; // handle 16 bit numbers x |= x &gt;&gt; 16; // handle 32 bit numbers x++; return x;&#125; 交换两个数,效率比附tmp值低123456static void swapXor(ref int a,ref int b)&#123; a ^= b; b ^= a; a ^= b;&#125; 取绝对值12345static int myabs(int a)&#123; int bit31 = a &gt;&gt; 31; return (a ^ bit31) - bit31;&#125;","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"bitwiseOperations","slug":"bitwiseOperations","permalink":"https://luox78.github.io/tags/bitwiseOperations/"}]},{"title":"初识JavaScript05","slug":"JavaScript05","date":"2018-01-06T15:22:04.269Z","updated":"2018-01-09T15:47:31.898Z","comments":true,"path":"2018/01/06/JavaScript05/","link":"","permalink":"https://luox78.github.io/2018/01/06/JavaScript05/","excerpt":"练习通过document.getElementById(&quot;XXX&quot;).style.display隐藏的是真正的使层消失 通过document.getElementById(&quot;div1&quot;).style.visibility实现的隐藏位置仍然占着，不过没有显示 以下演示了这一过程","text":"练习通过document.getElementById(&quot;XXX&quot;).style.display隐藏的是真正的使层消失 通过document.getElementById(&quot;div1&quot;).style.visibility实现的隐藏位置仍然占着，不过没有显示 以下演示了这一过程1234567891011121314151617181920212223&lt;body&gt; &lt;input id=\"btn1\" type=\"button\" value=\"hide div via display\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"hide div via visibility\" /&gt; &lt;div id=\"div1\" style=\"background-color: black;height: 200px\"&gt;&lt;/div&gt; &lt;input type=\"text\" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById(\"btn1\").onclick = function () &#123; if (document.getElementById(\"div1\").style.display !== \"none\") &#123; document.getElementById(\"div1\").style.display = \"none\"; &#125; else &#123; document.getElementById(\"div1\").style.display = \"block\"; &#125; &#125; document.getElementById(\"btn2\").onclick = function () &#123; if (document.getElementById(\"div1\").style.visibility !== \"hidden\") &#123; document.getElementById(\"div1\").style.visibility = \"hidden\"; &#125; else &#123; document.getElementById(\"div1\").style.visibility = \"visible\"; &#125; &#125;&lt;/script&gt; 动态添加层 1234567891011121314&lt;a id=\"a1\" href=\"javascript:void(0)\"&gt;luox78&lt;/a&gt; document.getElementById(\"a1\").onmouseover= function() &#123; var divObj = document.createElement(\"div\"); divObj.style.height = \"200px\"; divObj.style.backgroundColor = \"blue\"; divObj.style.positon = \"absolute\"; divObj.style.left = this.offsetLeft + 'px'; document.body.appendChild(divObj); //删除才创建的层 document.getElementById(\"a1\").onmouseleave = function() &#123; document.body.removeChild(divObj); &#125; &#125; 动态隐藏层 123456789101112131415161718192021222324252627&lt;div id=\"div1\" style=\"height: 1000px; border: black 3px solid\"&gt;？？？？？？？？？？？？、、、、、、、、、、、、、&lt;/div&gt; &lt;script&gt; var height = document.getElementById(\"div1\").style.height;//记录一开始的高度 document.getElementById(\"btn1\").onclick = function () &#123; var div = document.getElementById(\"div1\"); div.style.overflow = \"hidden\"; //点击时先判断是否隐藏 if (div.style.display === \"none\") &#123; div.style.display = \"block\"; div.style.height = height; return; &#125; var setId = window.setInterval(function () &#123; if (parseInt(div.style.height) &lt; 100) &#123; window.clearInterval(setId); //document.body.removeChild(div); div.style.display = \"none\";//隐藏 console.log(\"div has been removed\"); &#125; div.style.height = (div.offsetHeight - 100) + \"px\";//高度减100px &#125;, 100); &#125;&lt;/script&gt; 案例：图片跟着鼠标移动 12345678&lt;img id=\"img\" src=\"TIM截图20180108210345.png\"/&gt;document.onmousemove= function() &#123; var img = document.getElementById(\"img\"); img.style.position = \"absolute\"; img.style.left = window.event.clientX - img.width/2 + \"px\"; img.style.top = window.event.clientY - img.height/2 + \"px\"; &#125; 问题给标签设置属性值 label.setAttribute(&quot;属性名&quot;,&quot;属性值&quot;);设置属性值 this.getAttribute(&quot;属性名&quot;)获取属性值 123456789101112131415161718192021222324&lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt; var tds = document.getElementsByTagName(\"td\"); for (var i = 0; i &lt; tds.length; i++) &#123; tds[i].setAttribute(\"innerText\", tds[i].innerText); tds[i].onclick = function () &#123; alert(this.getAttribute(\"innerText\")); &#125; &#125;&lt;/script&gt; 显示浏览器型号 1alert(window.navigator.userAgent);//检测浏览器 文本显示 word-break: break-all;实现自动换行 overflow: hidden;超出边框隐藏 123&lt;div style=\"height: 100px; width: 100px; border: black 2px solid; word-break: break-all;overflow: hidden\"&gt;luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78&lt;/div&gt; JS中的正则表达式 var reg = new RegExp(/Pattern/);先创建正则对象 reg.test(&quot;string&quot;)判断string是否满足pattern 123var reg = new RegExp(/^[0-9]&#123;3&#125;$/);console.log(reg.test(\"122\"));//trueconsole.log(reg.test(\"1221\"));//false var reg=/pattern/(/pattern/g)全局模式 var result=reg.exec(&quot;string&quot;) 12345var msg=\"cmcc 10086;union 10010\";var pattern=/\\d+/;while(var res=pattern.exec(msg))&#123; alert(res);//10086 10010&#125; match(regexp)，非全局模式下相当于调用exec(),全局模式下相当于调用c#的matches()，返回数组中是所有的匹配结果（不包含提取组的信息） 1234var s = \"aaa@163.com\";var regex = /(.+)@(.+)/;var match = s.match(regex);alert(RegExp.$1 + “，服务器：” + RegExp.$2);（$1…$9） 字符串.replace(/pattern/g,”要替换的字符串$1”); 模拟Trim()方法 12345var str = ' aaaaaaaaaaa ';alert('---' + exTrim(str) + '-----');function exTrim(s) &#123; return s.replace(/(^\\s+)|(\\s+$)/g, '');&#125; 密码强度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;body&gt; &lt;input type=\"text\" name=\"name\" value=\"\" id=\"txt\" /&gt; &lt;table border=\"1\" id=\"tb\"&gt; &lt;tr&gt; &lt;td&gt; 弱 &lt;/td&gt; &lt;td&gt; 中 &lt;/td&gt; &lt;td&gt; 强 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; document.getElementById('txt').onkeyup = function () &#123; //获取td var tds = document.getElementById('tb').getElementsByTagName('td'); for (var i = 0; i &lt; tds.length; i++) &#123; tds[i].style.backgroundColor = '#E6E6E6'; &#125; //获取密码 var pwd = this.value; if (pwd.length &gt; 0) &#123; //根据密码验证强度 var result = getPassWord(pwd); //强度设置颜色 if (result &lt;= 1) &#123; //弱 tds[0].style.backgroundColor = 'red'; &#125; else if (result == 2) &#123; //中 tds[0].style.backgroundColor = 'orange'; tds[1].style.backgroundColor = 'orange'; &#125; else if (result == 3) &#123; //强 tds[0].style.backgroundColor = 'green'; tds[1].style.backgroundColor = 'green'; tds[2].style.backgroundColor = 'green'; &#125; &#125; &#125;; &#125;; function getPassWord(pwdMsg) &#123; var lvl = 0; //密码中有数字lvl+1 if (pwdMsg.match(/\\d/)) &#123; lvl++; //这么写简单 &#125; //密码中有字母lvl+1 if (pwdMsg.match(/[a-zA-Z]/)) &#123; lvl++; &#125; //密码中有其他符号lvl+1 if (pwdMsg.match(/[^0-9a-zA-Z]/)) &#123; lvl++; &#125; //密码小于6位lvl-1 if (pwdMsg.length &lt;= 6) &#123; lvl--; &#125; return lvl; &#125;&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"05JavaScript深入之作用域链","slug":"JavaScript深入之作用域链","date":"2018-01-04T12:12:50.527Z","updated":"2018-01-04T12:47:19.899Z","comments":true,"path":"2018/01/04/JavaScript深入之作用域链/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之作用域链/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言 在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲作用域链。 作用域链在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建在《JavaScript深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 举个例子： 123456 function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为： 123456789foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 12Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 捋一捋以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = \"global scope\";function checkscope()&#123; var scope2 = 'local scope'; return scope2;&#125;checkscope(); 执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = &#123; Scope: checkscope.[[scope]],&#125; 4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 12345678checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;&#125; 5.第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: [AO, [[Scope]]]&#125; 6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: 'local scope' &#125;, Scope: [AO, [[Scope]]]&#125; 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 下一篇文章《JavaScript深入之从ECMAScript规范解读this》 本文相关链接《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"03JavaScript深入之执行上下文栈","slug":"JavaScript深入之执行上下文栈","date":"2018-01-04T12:12:50.525Z","updated":"2018-01-04T12:47:14.515Z","comments":true,"path":"2018/01/04/JavaScript深入之执行上下文栈/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之执行上下文栈/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第三篇，讲解执行上下文栈的是如何执行的，也回答了第二篇中的略难的思考题。 顺序执行？","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第三篇，讲解执行上下文栈的是如何执行的，也回答了第二篇中的略难的思考题。 顺序执行？ 如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟： 123456789101112131415var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 然而去看这段代码： 12345678910111213141516function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 打印的结果却是两个 foo2。 刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 执行上下文栈接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 1ECStack = []; 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext： 123ECStack = [ globalContext]; 现在 JavaScript 遇到下面的这段代码了： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码： 123456789101112131415161718192021// 伪代码// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 解答思考题好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript深入之词法作用域和动态作用域》最后的问题： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 让我们模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 让我们模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。 下一篇文章《JavaScript深入之变量对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"07JavaScript深入之执行上下文","slug":"JavaScript深入之执行上下文","date":"2018-01-04T12:12:50.523Z","updated":"2018-01-04T12:47:09.114Z","comments":true,"path":"2018/01/04/JavaScript深入之执行上下文/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之执行上下文/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言 在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析我们分析第一段代码： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 123ECStack = [ globalContext]; 2.全局上下文初始化 12345globalContext = &#123; VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO&#125; 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 12345ECStack = [ fContext, checkscopeContext, globalContext]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1234ECStack = [ checkscopeContext, globalContext]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 第二段代码就留给大家去尝试模拟它的执行过程。 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。 下一篇文章《JavaScript深入之闭包》 相关链接《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 《JavaScript深入之作用域链》 《JavaScript深入之从ECMAScript规范解读this》 重要参考《一道js面试题引发的思考》 本文写的太好，给了我很多启发。感激不尽！ 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"12JavaScript深入之new的模拟实现","slug":"JavaScript深入之new的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-08T07:04:32.670Z","comments":true,"path":"2018/01/04/JavaScript深入之new的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之new的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十二篇，通过new的模拟实现，带大家揭开使用new获得构造函数实例的真相 new","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十二篇，通过new的模拟实现，带大家揭开使用new获得构造函数实例的真相 new 一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。 举个例子： 12345678910111213141516171819202122// Otaku 御宅族，简称宅function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;// 因为缺乏锻炼的缘故，身体强度让人担忧Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin 从这个例子中，我们可以看到，实例 person 可以： 访问到 Otaku 构造函数里的属性 访问到 Otaku.prototype 中的属性 接下来，我们可以尝试着模拟一下了。 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的： 12345678function Otaku () &#123; ……&#125;// 使用 newvar person = new Otaku(……);// 使用 objectFactoryvar person = objectFactory(Otaku, ……) 初步实现分析： 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。 现在，我们可以尝试着写第一版了： 1234567891011121314// 第一版代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;; 在这一版中，我们： 用new Object() 的方式新建了一个对象 obj 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 返回 obj 更多关于： 原型与原型链，可以看《JavaScript深入之从原型到原型链》 apply，可以看《JavaScript深入之call和apply的模拟实现》 经典继承，可以看《JavaScript深入之继承》 复制以下的代码，到浏览器中，我们可以做一下测试： 12345678910111213141516171819202122232425262728function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;;var person = objectFactory(Otaku, 'Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin []~(￣▽￣)~** 返回值效果实现接下来我们再来看一种情况，假如构造函数有返回值，举个例子： 12345678910111213141516function Otaku (name, age) &#123; this.strength = 60; this.age = age; return &#123; name: name, habit: 'Games' &#125;&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。 而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？ 再举个例子： 12345678910111213function Otaku (name, age) &#123; this.strength = 60; this.age = age; return 'handsome boy';&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 再来看第二版的代码，也是最后一版的代码： 1234567891011121314// 第二版的代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === 'object' ? ret : obj;&#125;; 下一篇文章JavaScript深入之类数组对象与arguments 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之继承》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"10JavaScript深入之call和apply的模拟实现","slug":"JavaScript深入之call和apply的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:45:55.246Z","comments":true,"path":"2018/01/04/JavaScript深入之call和apply的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之call和apply的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十篇，通过call和apply的模拟实现，带你揭开call和apply改变this的真相 call一句话介绍 call：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十篇，通过call和apply的模拟实现，带你揭开call和apply改变this的真相 call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： 123456// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call2(foo); // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： 1234567891011121314var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call(foo, 'kevin', 18);// kevin// 18// 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： 1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = &#123;// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// &#125;// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']');&#125;// 执行后 args为 [\"arguments[1]\", \"arguments[2]\", \"arguments[3]\"] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 1234567891011121314151617181920212223242526// 第二版Function.prototype.call2 = function(context) &#123; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; eval('context.fn(' + args +')'); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call2(foo, 'kevin', 18); // kevin// 18// 1 (๑•̀ㅂ•́)و✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： 1.this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： 12345678var value = 1;function bar() &#123; console.log(this.value);&#125;bar.call(null); // 1 虽然这个例子本身不使用 call，结果依然一样。 2.函数是可以有返回值的！ 举个例子： 12345678910111213141516171819var obj = &#123; value: 1&#125;function bar(name, age) &#123; return &#123; value: this.value, name: name, age: age &#125;&#125;console.log(bar.call(obj, 'kevin', 18));// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 第三版Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ apply的模拟实现apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现： 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; 下一篇文章JavaScript深入之bind的模拟实现 重要参考知乎问题 不能使用call、apply、bind，如何用 js 实现 call 或者 apply 的功能？ 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"11JavaScript深入之bind的模拟实现","slug":"JavaScript深入之bind的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:45:47.438Z","comments":true,"path":"2018/01/04/JavaScript深入之bind的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之bind的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十一篇，通过bind函数的模拟实现，带大家真正了解bind的特性 bind一句话介绍 bind:","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十一篇，通过bind函数的模拟实现，带大家真正了解bind的特性 bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 返回函数的模拟实现从第一个特点开始，我们举个例子： 123456789101112var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;// 返回了一个函数var bindFoo = bar.bind(foo); bindFoo(); // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看《JavaScript深入之call和apply的模拟实现》。我们来写第一版的代码： 12345678// 第一版Function.prototype.bind2 = function (context) &#123; var self = this; return function () &#123; return self.apply(context); &#125;&#125; 此外，之所以 return self.apply(context)，是考虑到绑定函数可能是有返回值的，依然是这个例子： 1234567891011var foo = &#123; value: 1&#125;;function bar() &#123; return this.value;&#125;var bindFoo = bar.bind(foo);console.log(bindFoo()); // 1 传参的模拟实现接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： 12345678910111213141516var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(this.value); console.log(name); console.log(age);&#125;var bindFoo = bar.bind(foo, 'daisy');bindFoo('18');// 1// daisy// 18 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 这可咋办？不急，我们用 arguments 进行处理： 1234567891011121314// 第二版Function.prototype.bind2 = function (context) &#123; var self = this; // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1); return function () &#123; // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); &#125;&#125; 构造函数效果的模拟实现完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： 12345678910111213141516171819202122232425var value = 2;var foo = &#123; value: 1&#125;;function bar(name, age) &#123; this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age);&#125;bar.prototype.friend = 'kevin';var bindFoo = bar.bind(foo, 'daisy');var obj = new bindFoo('18');// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 (哈哈，我这是为我的下一篇文章《JavaScript深入系列之new的模拟实现》打广告)。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： 12345678910111213141516// 第三版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); &#125; // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound;&#125; 如果对原型链稍有困惑，可以查看《JavaScript深入之从原型到原型链》。 构造函数效果的优化实现但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： 1234567891011121314151617// 第四版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ 三个小问题接下来处理些小问题: 1.apply 这段代码跟 MDN 上的稍有不同 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是： 12self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于 context 是否存在的判断，然而这个是错误的！ 举个例子： 1234567891011var value = 2;var foo = &#123; value: 1, bar: bar.bind(null)&#125;;function bar() &#123; console.log(this.value);&#125;foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ 2.调用 bind 的不是函数咋办？ 不行，我们要报错！ 123if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");&#125; 3.我要在线上用 那别忘了做个兼容： 123Function.prototype.bind = Function.prototype.bind || function () &#123; ……&#125;; 当然最好是用 es5-shim 啦。 最终代码所以最最后的代码就是： 1234567891011121314151617181920Function.prototype.bind2 = function (context) &#123; if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 下一篇文章《JavaScript深入系列之new的模拟实现》 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入系列之new的模拟实现》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"14JavaScript深入之创建对象的多种方式以及优缺点","slug":"JavaScript深入之创建对象的多种方式以及优缺点","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:36.114Z","comments":true,"path":"2018/01/04/JavaScript深入之创建对象的多种方式以及优缺点/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之创建对象的多种方式以及优缺点/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面这篇文章讲解创建对象的各种方式，以及优缺点。","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面这篇文章讲解创建对象的各种方式，以及优缺点。但是注意： 这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！ 1. 工厂模式1234567891011function createPerson(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson('kevin'); 缺点：对象无法识别，因为所有的实例都指向一个原型 2. 构造函数模式12345678function Person(name) &#123; this.name = name; this.getName = function () &#123; console.log(this.name); &#125;;&#125;var person1 = new Person('kevin'); 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次 2.1 构造函数模式优化12345678910function Person(name) &#123; this.name = name; this.getName = getName;&#125;function getName() &#123; console.log(this.name);&#125;var person1 = new Person('kevin'); 优点：解决了每个方法都要被重新创建的问题 缺点：这叫啥封装…… 3. 原型模式12345678910function Person(name) &#123;&#125;Person.prototype.name = 'keivn';Person.prototype.getName = function () &#123; console.log(this.name);&#125;;var person1 = new Person(); 优点：方法不会重新创建 缺点：1. 所有的属性和方法都共享 2. 不能初始化参数 3.1 原型模式优化123456789101112function Person(name) &#123;&#125;Person.prototype = &#123; name: 'kevin', getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：封装性好了一点 缺点：重写了原型，丢失了constructor属性 3.2 原型模式优化12345678910111213function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'kevin', getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：实例可以通过constructor属性找到所属构造函数 缺点：原型模式该有的缺点还是有 4. 组合模式构造函数模式与原型模式双剑合璧。 123456789101112function Person(name) &#123; this.name = name;&#125;Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：该共享的共享，该私有的私有，使用最广泛的方式 缺点：有的人就是希望全部都写在一起，即更好的封装性 4.1 动态原型模式12345678910function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype.getName = function () &#123; console.log(this.name); &#125; &#125;&#125;var person1 = new Person(); 注意：使用动态原型模式时，不能用对象字面量重写原型 解释下为什么： 1234567891011121314151617181920function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125; &#125; &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');// 报错 并没有该方法person1.getName();// 注释掉上面的代码，这句是可以执行的。person2.getName(); 为了解释这个问题，假设开始执行var person1 = new Person(&#39;kevin&#39;)。 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。 我们回顾下 new 的实现步骤： 首先新建一个对象 然后将对象的原型指向 Person.prototype 然后 Person.apply(obj) 返回这个对象 注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！ 如果你就是想用字面量方式写代码，可以尝试下这种： 12345678910111213141516171819function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125; &#125; return new Person(name); &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');person1.getName(); // kevinperson2.getName(); // daisy 5.1 寄生构造函数模式123456789101112131415function Person(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = new Person('kevin');console.log(person1 instanceof Person) // falseconsole.log(person1 instanceof Object) // true 寄生构造函数模式，我个人认为应该这样读： 寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。 也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！ 这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写： 12345678910111213141516171819202122function SpecialArray() &#123; var values = new Array(); for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]); &#125; values.toPipedString = function () &#123; return this.join(\"|\"); &#125;; return values;&#125;var colors = new SpecialArray('red', 'blue', 'green');var colors2 = SpecialArray('red2', 'blue2', 'green2');console.log(colors);console.log(colors.toPipedString()); // red|blue|greenconsole.log(colors2);console.log(colors2.toPipedString()); // red2|blue2|green2 你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。 但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。 在可以使用其他模式的情况下，不要使用这种模式。 但是值得一提的是，上面例子中的循环： 123for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]);&#125; 可以替换成： 1values.push.apply(values, arguments); 5.2 稳妥构造函数模式1234567891011121314151617function person(name)&#123; var o = new Object(); o.sayName = function()&#123; console.log(name); &#125;; return o;&#125;var person1 = person('kevin');person1.sayName(); // kevinperson1.name = \"daisy\";person1.sayName(); // kevinconsole.log(person1.name); // daisy 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 与寄生构造函数模式有两点不同： 新创建的实例方法不引用 this 不使用 new 操作符调用构造函数 稳妥对象最适合在一些安全的环境中。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。 下一篇文章JavaScript深入之继承的多种方式和优缺点 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之new的模拟实现》 《JavaScript深入之call和apply的模拟实现》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"15JavaScript深入之继承的多种方式和优缺点","slug":"JavaScript深入之继承的多种方式和优缺点","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:58.484Z","comments":true,"path":"2018/01/04/JavaScript深入之继承的多种方式和优缺点/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之继承的多种方式和优缺点/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十五篇，讲解JavaScript各种继承方式和优缺点。 写在前面","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十五篇，讲解JavaScript各种继承方式和优缺点。 写在前面 本文讲解JavaScript各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！ 1.原型链继承1234567891011121314151617function Parent () &#123; this.name = 'kevin';&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 12345678910111213141516171819function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向Parent传参 2.借用构造函数(经典继承)1234567891011121314151617function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child('kevin');console.log(child1.name); // kevinvar child2 = new Child('daisy');console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 3.组合继承原型链继承和经典继承双剑合璧。 1234567891011121314151617181920212223242526272829303132function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [\"red\", \"blue\", \"green\"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 4.原型式继承12345function createObj(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 5. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj (o) &#123; var clone = object.create(o); clone.sayName = function () &#123; console.log('hi'); &#125; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6. 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18'); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122232425function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin', '18');console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候：prototype(Child, Parent); 引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之new的模拟实现》 《JavaScript深入之创建对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"02JavaScript深入之词法作用域和动态作用域","slug":"JavaScript深入之词法作用域和动态作用域","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:41.534Z","comments":true,"path":"2018/01/04/JavaScript深入之词法作用域和动态作用域/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之词法作用域和动态作用域/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第二篇，JavaScript采用词法作用域，什么语言采用了动态作用域？两者的区别又是什么？还有一个略难的思考题，快来看看吧。 作用域","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第二篇，JavaScript采用词法作用域，什么语言采用了动态作用域？两者的区别又是什么？还有一个略难的思考题，快来看看吧。 作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设JavaScript采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 动态作用域也许你会好奇什么语言是动态作用域？ bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。 123456789value=1function foo () &#123; echo $value;&#125;function bar () &#123; local value=2; foo;&#125;bar 这个文件也可以在github博客仓库中找到。 思考题最后，让我们看一个《JavaScript权威指南》中的例子： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 但是在这里真正想让大家思考的是： 虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下一篇文章————《JavaScript深入之执行上下文栈》。 下一篇文章JavaScript深入之执行上下文栈 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"13JavaScript深入之类数组对象与arguments","slug":"JavaScript深入之类数组对象与arguments","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:47:03.392Z","comments":true,"path":"2018/01/04/JavaScript深入之类数组对象与arguments/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之类数组对象与arguments/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十三篇，讲解类数组对象与对象的相似与差异以及arguments的注意要点 类数组对象","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十三篇，讲解类数组对象与对象的相似与差异以及arguments的注意要点 类数组对象 所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象 举个例子： 12345678var array = ['name', 'age', 'sex'];var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125; 即便如此，为什么叫做类数组对象呢？ 那让我们从读写、获取长度、遍历三个方面看看这两个对象。 读写12345console.log(array[0]); // nameconsole.log(arrayLike[0]); // namearray[0] = 'new name';arrayLike[0] = 'new name'; 长度12console.log(array.length); // 3console.log(arrayLike.length); // 3 遍历123456for(var i = 0, len = array.length; i &lt; len; i++) &#123; ……&#125;for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; ……&#125; 是不是很像？ 那类数组对象可以使用数组的方法吗？比如： 1arrayLike.push('4'); 然而上述代码会报错: arrayLike.push is not a function 所以终归还是类数组呐…… 调用数组方法如果类数组就是任性的想用数组的方法怎么办呢？ 既然无法直接调用，我们可以用 Function.call 间接调用： 1234567891011var arrayLike = &#123;0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;Array.prototype.join.call(arrayLike, '&amp;'); // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item)&#123; return item.toUpperCase();&#125;); // [\"NAME\", \"AGE\", \"SEX\"] 类数组转对象在上面的例子中已经提到了一种类数组转数组的方法，再补充三个： 123456789var arrayLike = &#123;0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;// 1. sliceArray.prototype.slice.call(arrayLike); // [\"name\", \"age\", \"sex\"] // 2. spliceArray.prototype.splice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"] // 3. ES6 Array.fromArray.from(arrayLike); // [\"name\", \"age\", \"sex\"] // 4. applyArray.prototype.concat.apply([], arrayLike) 那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？ 要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。 Arguments对象接下来重点讲讲 Arguments 对象。 Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。 举个例子： 12345function foo(name, age, sex) &#123; console.log(arguments);&#125;foo('name', 'age', 'sex') 打印结果如下： 我们可以看到除了类数组的索引属性和length属性之外，还有一个callee属性，接下来我们一个一个介绍。 length属性Arguments对象的length属性，表示实参的长度，举个例子： 12345678910function foo(b, c, d)&#123; console.log(\"实参的长度为：\" + arguments.length)&#125;console.log(\"形参的长度为：\" + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1 callee属性Arguments 对象的 callee 属性，通过它可以调用函数自身。 讲个闭包经典面试题使用 callee 的解决方法： 123456789101112131415var data = [];for (var i = 0; i &lt; 3; i++) &#123; (data[i] = function () &#123; console.log(arguments.callee.i) &#125;).i = i;&#125;data[0]();data[1]();data[2]();// 0// 1// 2 接下来讲讲 arguments 对象的几个注意要点： arguments 和对应参数的绑定12345678910111213141516171819202122232425262728function foo(name, age, sex, hobbit) &#123; console.log(name, arguments[0]); // name name // 改变形参 name = 'new name'; console.log(name, arguments[0]); // new name new name // 改变arguments arguments[1] = 'new age'; console.log(age, arguments[1]); // new age new age // 测试未传入的是否会绑定 console.log(sex); // undefined sex = 'new sex'; console.log(sex, arguments[2]); // new sex undefined arguments[3] = 'new hobbit'; console.log(hobbit, arguments[3]); // undefined new hobbit&#125;foo('name', 'age') 传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享 除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。 传递参数将参数从一个函数传递到另一个函数 123456789// 使用 apply 将 foo 的参数传递给 barfunction foo() &#123; bar.apply(this, arguments);&#125;function bar(a, b, c) &#123; console.log(a, b, c);&#125;foo(1, 2, 3) 强大的ES6使用ES6的 … 运算符，我们可以轻松转成数组。 12345function func(...arguments) &#123; console.log(arguments); // [1, 2, 3]&#125;func(1, 2, 3); 应用arguments的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。 如果要总结这些场景的话，暂时能想到的包括： 参数不定长 函数柯里化 递归调用 函数重载… 欢迎留言回复。 下一篇文章JavaScript深入之创建对象的多种方式以及优缺点 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"08JavaScript深入之闭包","slug":"JavaScript深入之闭包","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:16.025Z","comments":true,"path":"2018/01/04/JavaScript深入之闭包/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之闭包/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第八篇，介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第八篇，介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： 1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动： 1234567891011var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125; 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 下一篇文章JavaScript深入之参数按值传递 相关链接如果想了解执行上下文的具体变化，不妨循序渐进，阅读这六篇： 《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 《JavaScript深入之作用域链》 《JavaScript深入之从ECMAScript规范解读this》 《JavaScript深入之执行上下文》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"01JavaScript深入之从原型到原型链","slug":"JavaScript深入之从原型到原型链","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:53.275Z","comments":true,"path":"2018/01/04/JavaScript深入之从原型到原型链/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之从原型到原型链/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象 我们先使用构造函数创建一个对象： 123456function Person() &#123;&#125;var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'Kevin';var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor ，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() &#123;&#125;Person.prototype.name = 'Kevin';var person = new Person();person.name = 'Daisy';console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = 'Kevin'console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？ null，我们可以打印： 1console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子： 12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor __proto__其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 下一篇文章JavaScript深入之词法作用域和动态作用域 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"09JavaScript深入之参数按值传递","slug":"JavaScript深入之参数按值传递","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:30.018Z","comments":true,"path":"2018/01/04/JavaScript深入之参数按值传递/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之参数按值传递/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 按值传递举个简单的例子： 1234567var value = 1;function foo(v) &#123; v = 2; console.log(v); //2&#125;foo(value);console.log(value) // 1 很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，函数中修改的都是 _value 的值，而不会影响原来的 value 值。 引用传递拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题。 所以还有另一种传递方式叫做按引用传递。 所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。 举个例子： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o.value = 2; console.log(o.value); //2&#125;foo(obj);console.log(obj.value) // 2 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按引用传递成功呢？ 而这究竟是不是引用传递呢？ 第三种传递方式不急，让我们再看个例子： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o = 2; console.log(o); //2&#125;foo(obj);console.log(obj.value) // 1 如果 JavaScript 采用的是引用传递，外层的值也会被修改呐，这怎么又没被改呢？所以真的不是引用传递吗？ 这就要讲到其实还有第三种传递方式，叫按共享传递。 而共享传递是指，在传递对象的时候，传递对象的引用的副本。 注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！ 所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。 最后，你可以这样理解： 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。 所以，高程，谁叫你是红宝书嘞！ 下一篇文章JavaScript深入之call和apply的模拟实现 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"06JavaScript深入之从ECMAScript规范解读this","slug":"JavaScript深入之从ECMAScript规范解读this","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:47.643Z","comments":true,"path":"2018/01/04/JavaScript深入之从ECMAScript规范解读this/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之从ECMAScript规范解读this/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第六篇，本篇我们追根溯源，从ECMAScript5规范解读this在函数调用时到底是如何确定的。 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第六篇，本篇我们追根溯源，从ECMAScript5规范解读this在函数调用时到底是如何确定的。 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲 this，然而不好讲。 …… 因为我们要从 ECMASciript5 规范开始讲起。 先奉上 ECMAScript 5.1 规范地址： 英文版：http://es5.github.io/#x15.1 中文版：http://yanhaijing.com/es5/#115 让我们开始了解规范吧！ Types首先是第 8 章 Types： Types are further subclassified into ECMAScript language types and specification types. An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object. A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. 我们简单的翻译一下： ECMAScript 的类型分为语言类型和规范类型。 ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。 而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。 没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。 今天我们要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。 Reference那什么又是 Reference ？ 让我们看 8.7 章 The Reference Specification Type： The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators. 所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。 抄袭尤雨溪大大的话，就是： 这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。 再看接下来的这段具体介绍 Reference 的内容： A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String. 这段讲述了 Reference 的构成，由三个组成部分，分别是： base value referenced name strict reference 可是这些到底是什么呢？ 我们简单的理解的话： base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。 referenced name 就是属性的名称。 举个例子： 12345678var foo = 1;// 对应的Reference是：var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 再举个例子： 1234567891011121314var foo = &#123; bar: function () &#123; return this; &#125;&#125;; foo.bar(); // foo// bar对应的Reference是：var BarReference = &#123; base: foo, propertyName: 'bar', strict: false&#125;; 而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。 这两个方法很简单，简单看一看： 1.GetBase GetBase(V). Returns the base value component of the reference V. 返回 reference 的 base value。 2.IsPropertyReference IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false. 简单的理解：如果 base value 是一个对象，就返回true。 GetValue除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。 简单模拟 GetValue 的使用： 123456789var foo = 1;var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;;GetValue(fooReference) // 1; GetValue 返回对象属性真正的值，但是要注意： 调用 GetValue，返回的将是具体的值，而不再是一个 Reference 这个很重要，这个很重要，这个很重要。 如何确定this的值关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段： 看规范 11.2.3 Function Calls： 这里讲了当函数调用的时候，如何确定 this 的取值。 只看第一步、第六步、第七步： 1.Let ref be the result of evaluating MemberExpression. 6.If Type(ref) is Reference, then a.If IsPropertyReference(ref) is true, then i.Let thisValue be GetBase(ref). b.Else, the base of ref is an Environment Record i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). 7.Else, Type(ref) is not Reference. a. Let thisValue be undefined. 让我们描述一下： 1.计算 MemberExpression 的结果赋值给 ref 2.判断 ref 是不是一个 Reference 类型 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) 2.3 如果 ref 不是 Reference，那么 this 的值为 undefined 具体分析让我们一步一步看： 计算 MemberExpression 的结果赋值给 ref 什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions： MemberExpression : PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》 FunctionExpression // 函数定义表达式 MemberExpression [ Expression ] // 属性访问表达式 MemberExpression . IdentifierName // 属性访问表达式 new MemberExpression Arguments // 对象创建表达式 举个例子： 123456789101112131415161718192021function foo() &#123; console.log(this)&#125;foo(); // MemberExpression 是 foofunction foo() &#123; return function() &#123; console.log(this) &#125;&#125;foo()(); // MemberExpression 是 foo()var foo = &#123; bar: function () &#123; return this; &#125;&#125;foo.bar(); // MemberExpression 是 foo.bar 所以简单理解 MemberExpression 其实就是()左边的部分。 2.判断 ref 是不是一个 Reference 类型。 关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。 举最后一个例子： 12345678910111213141516171819var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar());//示例2console.log((foo.bar)());//示例3console.log((foo.bar = foo.bar)());//示例4console.log((false || foo.bar)());//示例5console.log((foo.bar, foo.bar)()); foo.bar()在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？ 查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步： Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 我们得知该表达式返回了一个 Reference 类型！ 根据之前的内容，我们知道该值为： 12345var Reference = &#123; base: foo, name: 'bar', strict: false&#125;; 接下来按照 2.1 的判断流程走： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？ 前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。 base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。 这个时候我们就可以确定 this 的值了： 1this = GetBase(ref)， GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！ 唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。 (foo.bar)()看示例2： 1console.log((foo.bar)()); foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator 直接看结果部分： Return the result of evaluating Expression. This may be of type Reference. NOTE This algorithm does not apply GetValue to the result of evaluating Expression. 实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。 (foo.bar = foo.bar)()看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ): 计算的第三步： 3.Let rval be GetValue(rref). 因为使用了 GetValue，所以返回的值不是 Reference 类型， 按照之前讲的判断逻辑： 2.3 如果 ref 不是Reference，那么 this 的值为 undefined this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。 (false || foo.bar)()看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators： 计算第二步： 2.Let lval be GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined (foo.bar, foo.bar)()看示例5，逗号操作符，查看规范11.14 Comma Operator ( , ) 计算第二步： 2.Call GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined 揭晓结果所以最后一个例子的结果是： 1234567891011121314151617181920var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar()); // 2//示例2console.log((foo.bar)()); // 2//示例3console.log((foo.bar = foo.bar)()); // 1//示例4console.log((false || foo.bar)()); // 1//示例5console.log((foo.bar, foo.bar)()); // 1 注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。 补充最最后，忘记了一个最最普通的情况： 12345function foo() &#123; console.log(this)&#125;foo(); MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值： 12345var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 接下来进行判断： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。 IsPropertyReference(ref) 的结果为 false，进入下个判断： 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref) 查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。 所以最后 this 的值就是 undefined。 多说一句尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？ 123456789var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;console.log((false || foo.bar)()); // 1 此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。 此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。 下一篇文章《JavaScript深入之执行上下文》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"04JavaScript深入之变量对象","slug":"JavaScript深入之变量对象","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:23.366Z","comments":true,"path":"2018/01/04/JavaScript深入之变量对象/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之变量对象/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第四篇，具体讲解执行上下文中的变量对象与活动对象。全局上下文下的变量对象是什么？函数上下文下的活动对象是如何分析和执行的？还有两个思考题帮你加深印象，快来看看吧！ 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第四篇，具体讲解执行上下文中的变量对象与活动对象。全局上下文下的变量对象是什么？函数上下文下的活动对象是如何分析和执行的？还有两个思考题帮你加深印象，快来看看吧！ 前言 在上篇《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。 全局上下文我们先了解一个概念，叫全局对象。在 W3School 中也有介绍： 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 如果看的不是很懂的话，容我再来介绍下全局对象: 1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。 1console.log(this); 2.全局对象是由 Object 构造函数实例化的一个对象。 1console.log(this instanceof Object); 3.预定义了一堆，嗯，一大堆函数和属性。 123// 都能生效console.log(Math.random());console.log(this.Math.random()); 4.作为全局变量的宿主。 12var a = 1;console.log(this.a); 5.客户端 JavaScript 中，全局对象有 window 属性指向自身。 12345var a = 1;console.log(window.a);this.window.b = 2;console.log(this.b); 花了一个大篇幅介绍全局对象，其实就想说： 全局上下文中的变量对象就是全局对象呐！ 函数上下文在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码， 变量对象会包括： 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 举个例子： 12345678910function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 在进入执行上下文后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c()&#123;&#125;, d: undefined&#125; 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 还是上面的例子，当代码执行完后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression \"d\"&#125; 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 思考题最后让我们看几个例子： 1.第一题 123456789101112function foo() &#123; console.log(a); a = 1;&#125;foo(); // ???function bar() &#123; a = 1; console.log(a);&#125;bar(); // ??? 第一段会报错：Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是： 12345AO = &#123; arguments: &#123; length: 0 &#125;&#125; 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。 2.第二题 1234567console.log(foo);function foo()&#123; console.log(\"foo\");&#125;var foo = 1; 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 下一篇文章《JavaScript深入之作用域链》 本文相关链接《JavaScript深入之执行上下文栈》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"初识JavaScript04","slug":"JavaScript04","date":"2018-01-03T13:46:51.448Z","updated":"2018-01-06T14:51:14.361Z","comments":true,"path":"2018/01/03/JavaScript04/","link":"","permalink":"https://luox78.github.io/2018/01/03/JavaScript04/","excerpt":"window对象的属性 document.write()会覆盖原有的全部内容","text":"window对象的属性 document.write()会覆盖原有的全部内容 123456789&lt;body&gt; 你是谁&lt;input type=\"button\" id=\"btn\" value=\"click\" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById(\"btn\").onclick = function () &#123; document.write('&lt;font size=\"7\"&gt;luox78&lt;/font&gt;'); &#125;&lt;/script&gt; document.getElementById(),getElementsByName(),`getElementsByTagName, 1234567891011&lt;body&gt; &lt;input type=\"text\" name=\"txt\" /&gt; &lt;input type=\"text\" name=\"txt\" /&gt; &lt;input type=\"text\" name=\"txt\"/&gt;&lt;/body&gt;&lt;script&gt; var inputs = document.getElementsByName(\"txt\"); for (var i = 0; i &lt; inputs.length; i++) &#123; inputs[i].value = \"luox78\"; &#125;&lt;/script&gt; 注意循环中使用this,javascript执行上下文 12345678910111213141516171819202122232425&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;script&gt;&gt; //点击一个按钮，被点击的按钮显示“呜呜”，其他按钮显示“哈哈”&gt; var inputs = document.getElementsByName('btn');&gt; for (var i = 0; i &lt; inputs.length; i++) &#123;&gt; if (inputs[i].type == 'button') &#123;&gt; inputs[i].onclick = function() &#123;&gt; for (var j = 0; j &lt; inputs.length; j++) &#123;&gt; if (inputs[j].type == 'button') &#123;&gt; inputs[j].value = \"哈哈\";&gt; &#125;&gt; &#125;&gt; this.value = \"呜呜\";&gt; //inputs[i].value = \"呜呜\"; 这样写不能达到预期的效果&gt; &#125;;&gt; &#125;&gt; &#125;&gt; &lt;/script&gt;&gt; 事件冒泡演示 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=\"div1\" style=\"height: 200px; background-color: aquamarine\"&gt; &lt;div id=\"div2\" style=\"background-color: black; width: 600px;height: 200px;\"&gt; &lt;div id=\"div3\" style=\"background-color: blue; height: 200px;width: 300px\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById(\"div1\").onclick= function() &#123; console.log(this.id); &#125; document.getElementById(\"div2\").onclick = function () &#123; console.log(this.id); &#125; document.getElementById(\"div3\").onclick = function () &#123; console.log(this.id); &#125;&lt;/script&gt;结果（分别点击div1，div2，div3）： div1 div2 div1 div3 div2 div1 将div3中console.log(this.id)改成console.log(window.event.srcElement.id)，效果一致，但window.event.srcElement.id为事件源 如何取消事件冒泡呢？使用window.event.cancelBubble=true，在div3 onclick中加入window.event.cancelBubble=true，console中只输出了div3 动态添加元素演示点击按钮添加td 123456789101112131415161718192021222324&lt;body&gt; &lt;input id=\"txt\" type=\"text\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"add remark\" /&gt; &lt;br /&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;评论&lt;/th&gt; &lt;/thead&gt; &lt;tbody id=\"tbody\"&gt;&lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(\"btn2\").onclick = function () &#123; var txt = document.getElementById(\"txt\").value; var tbody = document.getElementById(\"tbody\"); if (txt != null &amp;&amp; txt.length != 0) &#123; var tr = document.createElement(\"tr\"); var td = document.createElement(\"td\"); tr.appendChild(td); td.textContent = txt; tbody.appendChild(tr); &#125; &#125;&lt;/script&gt; document.XXX方法： createElement(&#39;element&#39;);创建一个节点 appendChild(node); 追加一个节点 removeChild(node);移除一个节点 replaceChild(new,old);替换一个节点 insertBefore(new,参照);把节点加到前面（插到某个节点前面） 属性： firstChild lastChild 动态设置styledocument.getElementById(&quot;XXX&quot;).style或document.getElementById(&quot;XXX&quot;)下","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"同步基础","slug":"CS_Thread02","date":"2018-01-02T13:19:59.458Z","updated":"2018-01-03T11:46:34.983Z","comments":true,"path":"2018/01/02/CS_Thread02/","link":"","permalink":"https://luox78.github.io/2018/01/02/CS_Thread02/","excerpt":"1同步概要在第 1 部分：基础知识中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。 下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。","text":"1同步概要在第 1 部分：基础知识中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。 下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。 同步构造可以分为以下四类： 简单的阻塞方法 这些方法会使当前线程等待另一个线程结束或是自己等待一段时间。Sleep、Join与Task.Wait都是简单的阻塞方法。 锁构造 锁构造能够限制每次可以执行某些动作或是执行某段代码的线程数量。排它锁构造是最常见的，它每次只允许一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。标准的排它锁构造是lock（Monitor.Enter/Monitor.Exit）、Mutex与 SpinLock。非排它锁构造是Semaphore、SemaphoreSlim以及读写锁。 信号构造 信号构造可以使一个线程暂停，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：事件等待句柄（event wait handle ）和Monitor类的Wait / Pluse方法。Framework 4.0 加入了CountdownEvent与Barrier类。 非阻塞同步构造 非阻塞同步构造通过调用处理器指令来保护对公共字段的访问。CLR 与 C# 提供了下列非阻塞构造：Thread.MemoryBarrier 、Thread.VolatileRead、Thread.VolatileWrite、volatile关键字以及Interlocked类。 阻塞这个概念对于前三类来说都非常重要，接下来我们简要的剖析下它。 1.1阻塞当线程的执行由于某些原因被暂停，比如调用Sleep等待一段时间，或者通过Join或EndInvoke方法等待其它线程结束时，则认为此线程被阻塞（blocked）。被阻塞的线程会立即出让（yields）其处理器时间片，之后不再消耗处理器时间，直到阻塞条件被满足。可以通过线程的ThreadState属性来检查一个线程是否被阻塞： 1bool blocked = (someThread.ThreadState &amp; ThreadState.WaitSleepJoin) != 0; （上面例子中线程状态可能在进行状态判断和依据状态进行操作之间发生改变，因此这段代码仅可用于调试诊断的场景。） 当一个线程被阻塞或是解除阻塞时，操作系统会进行上下文切换（context switch），这会带来几微秒的额外时间开销。 阻塞会在以下 4 种情况下解除（电源按钮可不能算╮(╯▽╰)╭）： 阻塞条件被满足 操作超时（如果指定了超时时间） 通过Thread.Interrupt中断 通过Thread.Abort中止 通过Suspend方法（已过时，不应该再使用）暂停线程的执行不被认为是阻塞。 1.2阻塞 vs 自旋有时线程必须暂停，直到特定条件被满足。信号构造和锁构造可以通过在条件被满足前阻塞线程来实现。但是还有一种更为简单的方法：线程可以通过自旋（spinning）来等待条件被满足。例如： 123while (!proceed);// 或者：while (DateTime.Now &lt; nextStartTime); 一般来说，这会非常浪费处理器时间：因为对 CLR 和操作系统来说，这个线程正在执行重要的计算，就给它分配了相应的资源。 有时会组合使用阻塞与自旋： 1while (!proceed) Thread.Sleep (10); 尽管并不优雅，但是这比仅使用自旋更高效（一般来说）。然而这样也可能会出现问题，这是由proceed标识上的并发问题引起的。正确的使用和锁构造和信号构造可以避免这个问题。 自旋在等待的条件很快（大致几微秒）就能被满足的情况下更高效，因为它避免了上下文切换带来的额外开销。.NET Framework 提供了专门的方法和类型来辅助实现自旋，在第 5 部分会讲到。 1.3线程状态可以通过线程的ThreadState属性来查询线程状态，它会返回一个ThreadState类型的按位方式组合的枚举值，其中包含了三“层”信息。然而大多数值都是冗余的、无用的或者过时不建议使用的。下图是其中一“层”信息： 下面的代码可以提取线程状态中最有用的 4 个值: Unstarted、Running、WaitSleepJoin和Stopped： 123456public static ThreadState SimpleThreadState (ThreadState ts)&#123; return ts &amp; (ThreadState.Unstarted | ThreadState.WaitSleepJoin | ThreadState.Stopped);&#125; ThreadState属性在进行调试诊断时有用，但不适合用来进行同步，因为线程状态可能在判断状态和依据状态进行操作之间发生改变。 2锁排它锁用于确保同一时间只允许一个线程执行指定的代码段。主要的两个排它锁构造是lock和Mutex（互斥体）。其中lock更快，使用也更方便。而Mutex的优势是它可以跨进程的使用。 在这一节里，我们从介绍lock构造开始，然后介绍Mutex和信号量（semaphore）（用于非排它场景）。稍后在第 4 部分会介绍读写锁（reader / writer lock）。 Framework 4.0 加入了SpinLock结构体，可以用于高并发场景。 让我们从下边这个类开始： 12345678910class ThreadUnsafe&#123; static int _val1 = 1, _val2 = 1; static void Go() &#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0; &#125;&#125; 这个类不是线程安全的：如果Go方法同时被两个线程调用，可能会产生除数为零错误，因为可能在一个线程刚好执行完if的判断语句但还没执行Console.WriteLine语句时，_val2就被另一个线程设置为零。 下边使用lock解决这个问题： 1234567891011121314class ThreadSafe&#123; static readonly object _locker = new object(); static int _val1, _val2; static void Go() &#123; lock (_locker) &#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0; &#125; &#125;&#125; 同一时间只有一个线程可以锁定同步对象（这里指_locker），并且其它竞争锁的线程会被阻塞，直到锁被释放。如果有多个线程在竞争锁，它们会在一个“就绪队列（ready queue）”中排队，并且遵循先到先得的规则（需要说明的是，Windows 系统和 CLR 的差别可能导致这个队列在有时会不遵循这个规则）。因为一个线程的访问不能与另一个线程相重叠，排它锁有时也被这样描述：它强制对锁保护的内容进行顺序（serialized）访问。在这个例子中，我们保护的是Go方法的内部逻辑，还有_val1与_val2字段。 在竞争锁时被阻塞的线程，它的线程状态是WaitSleepJoin。在中断与中止中，我们会描述如何通过其它线程强制释放被阻塞的线程，这是一种可以用于结束线程的重型技术（译者注：这里指它们应该被作为在没有其它更为优雅的办法时的最后手段）。 锁构造比较 构造 用途 跨进程 开销* lock（Monitor.Enter/Monitor.Exit） 确保同一时间只有一个线程可以访问资源或代码 - 20ns Mutex yes 1000ns SemaphoreSlim（Framework 4.0 中加入） 确保只有不超过指定数量的线程可以并发访问资源或代码 - 200ns Semaphore yes 1000ns ReaderWriterLockSlim（Framework 3.5 中加入） 允许多个读线程和一个写线程共存 - 40ns ReaderWriterLock（已过时） - 100ns * 时间代表在同一线程上一次进行加锁和释放锁（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。 2.1Monitor.Enter 与 Monitor.ExitC# 的lock语句是一个语法糖，它其实就是使用了try / finally来调用Monitor.Enter与Monitor.Exit方法。下面是在之前示例中的Go方法内部所发生的事情（简化的版本）： 1234567Monitor.Enter (_locker);try&#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0;&#125;finally &#123; Monitor.Exit (_locker); &#125; 如果在同一个对象上没有先调用Monitor.Enter就调用Monitor.Exit会抛出一个异常。 lockTaken 重载刚刚所描述的就是 C# 1.0、2.0 和 3.0 的编译器翻译lock语句产生的代码。 然而它有一个潜在的缺陷。考虑这样的情况：在Monitor.Enter的实现内部或者在Monitor.Enter与try中间有异常被抛出（可能是因为在线程上调用了Abort，或者有OutOfMemoryException异常被抛出），这时不一定能够获得锁。如果获得了锁，那么该锁就不会被释放，因为不可能执行到try / finally内，这会导致锁泄漏。 为了避免这种危险，CLR 4.0 的设计者为Monitor.Enter添加了下面的重载： 1public static void Enter (object obj, ref bool lockTaken); 当（且仅当）Enter方法抛出异常，锁没有能够获得时，lockTaken为false。 下边是正确的使用方式（这就是 C# 4.0 对于lock语句的翻译）： 1234567bool lockTaken = false;try&#123; Monitor.Enter (_locker, ref lockTaken); // 你的代码...&#125;finally &#123; if (lockTaken) Monitor.Exit (_locker); &#125; TryEnterMonitor还提供了一个TryEnter方法，允许以毫秒或是TimeSpan方式指定超时时间。如果获得了锁，该方法会返回true，而如果由于超时没有获得锁，则会返回false。TryEnter也可以以无参数的形式进行调用，这是对锁进行“测试”，如果不能立即获得锁就会立即返回false。 类似于Enter方法，该方法在 CLR 4.0 中也被重载来接受lockTaken参数。 2.2选择同步对象对所有参与同步的线程可见的任何对象都可以被当作同步对象使用，但有一个硬性规定：同步对象必须为引用类型。同步对象一般是私有的（因为这有助于封装锁逻辑），并且一般是一个实例或静态字段。同步对象也可以就是其要保护的对象，如下面例子中的_list字段： 12345678910class ThreadSafe&#123; List &lt;string&gt; _list = new List &lt;string&gt;(); void Test() &#123; lock (_list) &#123; _list.Add (\"Item 1\"); // ... 一个只被用来加锁的字段（例如前面例子中的_locker）可以精确控制锁的作用域与粒度。对象自己（this），甚至是其类型都可以被当作同步对象来使用： 123lock (this) &#123; ... &#125;// 或者：lock (typeof (Widget)) &#123; ... &#125; // 保护对静态资源的访问 这种方式的缺点在于并没有对锁逻辑进行封装，从而很难避免死锁与过多的阻塞。同时类型上的锁也可能会跨越应用程序域（application domain）边界（在同一进程内）。 你也可以在被 lambda 表达式或匿名方法所捕获的局部变量上加锁。 锁在任何情况下都不会限制对同步对象本身的访问。换句话说，x.ToString()不会因为其它线程调用lock(x)而阻塞，两个线程都要调用lock(x)才能使阻塞发生。 2.3何时加锁简单的原则是，需要在访问任意可写的共享字段（any writable shared field）时加锁。即使是最简单的操作，例如对一个字段的赋值操作，都必须考虑同步。在下面的类中，Increment与Assign方法都不是线程安全的： 123456class ThreadUnsafe&#123; static int _x; static void Increment() &#123; _x++; &#125; static void Assign() &#123; _x = 123; &#125;&#125; 以下是线程安全的版本： 12345678class ThreadSafe&#123; static readonly object _locker = new object(); static int _x; static void Increment() &#123; lock (_locker) _x++; &#125; static void Assign() &#123; lock (_locker) _x = 123; &#125;&#125; 在非阻塞同步（nonblocking synchronization）中，我们会解释这种需求是如何产生的，以及在这些场景下内存屏障（memory barrier，内存栅栏，内存栅障）和Interlocked类如何提供替代方法进行锁定。 2.4锁与原子性如果一组变量总是在相同的锁内进行读写，就可以称为原子的（atomically）读写。假定字段x与y总是在对locker对象的lock内进行读取与赋值： 1lock (locker) &#123; if (x != 0) y /= x; &#125; 可以说x和y是被原子的访问的，因为上面的代码块无法被其它的线程分割或抢占。如果被其它线程分割或抢占，x和y就可能被别的线程修改导致计算结果无效。而现在 x和y总是在相同的排它锁中进行访问，因此不会出现除数为零的错误。 在lock锁内抛出异常将打破锁的原子性，考虑如下代码： 12345678910decimal _savingsBalance, _checkBalance;void Transfer (decimal amount)&#123; lock (_locker) &#123; _savingsBalance += amount; _checkBalance -= amount + GetBankFee(); &#125;&#125; 如果GetBankFee()方法内抛出异常，银行可能就要损失钱财了。在这个例子中，我们可以通过更早的调用GetBankFee()来避免这个问题。对于更复杂情况，解决方案是在catch或finally中实现“回滚（rollback）”逻辑。 指令原子性是一个相似但不同的概念： 如果一条指令可以在 CPU 上不可分割地执行，那么它就是原子的。（见非阻塞同步） 2.5嵌套锁线程可以用嵌套（重入）的方式重对相同的对象进行加锁： 123456lock (locker) lock (locker) lock (locker) &#123; // ... &#125; 或者： 123Monitor.Enter (locker); Monitor.Enter (locker); Monitor.Enter (locker);// ...Monitor.Exit (locker); Monitor.Exit (locker); Monitor.Exit (locker); 在这样的场景中，只有当最外层的lock语句退出或是执行了匹配数目的Monitor.Exit语句时，对象才会被解锁。 嵌套锁可以用于在锁中调用另一个方法（也使用了同一对象来锁定）： 123456789101112131415static readonly object _locker = new object();static void Main()&#123; lock (_locker) &#123; AnotherMethod(); // 这里依然拥有锁，因为锁是可重入的 &#125;&#125;static void AnotherMethod()&#123; lock (_locker) &#123; Console.WriteLine (\"Another method\"); &#125;&#125; 线程只会在第一个（最外层）lock处阻塞。 2.6死锁当两个线程等待的资源都被对方占用时，它们都无法执行，这就产生了死锁。演示死锁最简单的方法就是使用两个锁： 123456789101112131415object locker1 = new object();object locker2 = new object();new Thread (() =&gt; &#123; lock (locker1) &#123; Thread.Sleep (1000); lock (locker2); // 死锁 &#125; &#125;).Start();lock (locker2)&#123; Thread.Sleep (1000); lock (locker1); // 死锁&#125; 更复杂的死锁链可能由三个或更多的线程创建。 在标准环境下，CLR 不会像SQL Server一样自动检测和解决死锁。除非你指定了锁定的超时时间，否则死锁会造成参与的线程无限阻塞。（在SQL CLR 集成宿主环境中，死锁能够被自动检测，并在其中一个线程上抛出可捕获的异常。） 死锁是多线程中最难解决的问题之一，尤其是在有很多关联对象的时候。这个困难在根本上在于无法确定调用方（caller）已经拥有了哪些锁。 你可能会锁定类x中的私有字段a，而并不知道调用方（或者调用方的调用方）已经锁住了类y中的字段b。同时，另一个线程正在执行顺序相反的操作，这样就创建了死锁。讽刺的是，这个问题会由于（良好的）面向对象的设计模式而加剧，因为这类模式建立的调用链直到运行时才能确定。 流行的建议：“以一致的顺序对对象加锁以避免死锁”，尽管它对于我们最初的例子有帮助，但是很难应用到刚才所描述的场景。更好的策略是：如果发现在锁区域中的对其它类的方法调用最终会引用回当前对象，就应该小心，同时考虑是否真的需要对其它类的方法调用加锁（往往是需要的，但是有时也会有其它选择）。更多的依靠声明方式（declarative）与数据并行（data parallelism）、不可变类型（immutable types）与非阻塞同步构造（ nonblocking synchronization constructs），可以减少对锁的需要。 有另一种思路来帮助理解这个问题：当你在拥有锁的情况下访问其它类的代码，对于锁的封装就存在潜在的泄露。这不是 CLR 或 .NET Framework 的问题，而是因为锁本身的局限性。锁的问题在许多研究项目中被分析，包括软件事务内存（Software Transactional Memory）。 另一个死锁的场景是：如果已拥有一个锁，在调用Dispatcher.Invoke（在 WPF 程序中）或是Control.Invoke（在 Windows Forms 程序中）时，如果 UI 恰好要运行等待同一个锁的另一个方法，就会在这里发生死锁。这通常可以通过调用BeginInvoke而不是Invoke来简单的修复。或者，可以在调用Invoke之前释放锁，但是如果是调用方获得的锁，那么这种方法可能并不会起作用。我们在富客户端应用与线程亲和中来解释Invoke和BeginInvoke。 2.7性能锁是非常快的，在一个 2010 时代的计算机上，没有竞争的情况下获取并释放锁一般只需 20 纳秒。如果存在竞争，产生的上下文切换会把开销增加到微秒的级别，并且线程被重新调度前可能还会等待更久的时间。如果需要锁定的时间很短，那么可以使用自旋锁（SpinLock）来避免上下文切换的开销。 如果获取锁后保持的时间太长而不释放，就会降低并发度，同时也会加大死锁的风险。 2.8互斥体（Mutex）互斥体类似于 C# 的lock，不同在于它是可以跨越多个进程工作。换句话说，Mutex可以是机器范围（computer-wide）的，也可以是程序范围（application-wide）的。 没有竞争的情况下，获取并释放Mutex需要几微秒的时间，大约比lock慢 50 倍。 使用Mutex类时，可以调用WaitOne方法来加锁，调用ReleaseMutex方法来解锁。关闭或销毁Mutex会自动释放锁。与lock语句一样，Mutex只能被获得该锁的线程释放。 跨进程Mutex的一种常见的应用就是确保只运行一个程序实例。下面演示了这是如何实现的： 12345678910111213141516171819202122232425class OneAtATimePlease&#123; static void Main() &#123; // 命名的 Mutex 是机器范围的，它的名称需要是唯一的 // 比如使用公司名+程序名，或者也可以用 URL using (var mutex = new Mutex (false, \"oreilly.com OneAtATimeDemo\")) &#123; // 可能其它程序实例正在关闭，所以可以等待几秒来让其它实例完成关闭 if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false)) &#123; Console.WriteLine (\"Another app instance is running. Bye!\"); return; &#125; RunProgram(); &#125; &#125; static void RunProgram() &#123; Console.WriteLine (\"Running. Press Enter to exit\"); Console.ReadLine(); &#125;&#125; 如果在终端服务（Terminal Services）下运行，机器范围的Mutex默认仅对于运行在相同终端服务器会话的应用程序可见。要使其对所有终端服务器会话可见，需要在其名字前加上Global\\。 2.9信号量（Semaphore）信号量类似于一个夜总会：它具有一定的容量，并且有保安把守。一旦满员，就不允许其他人进入，这些人将在外面排队。当有一个人离开时，排在最前头的人便可以进入。这种构造最少需要两个参数：夜总会中当前的空位数以及夜总会的总容量。 容量为 1 的信号量与Mutex和lock类似，所不同的是信号量没有“所有者”，它是线程无关（thread-agnostic）的。任何线程都可以在调用Semaphore上的Release方法，而对于Mutex和lock，只有获得锁的线程才可以释放。 SemaphoreSlim是 Framework 4.0 加入的轻量级的信号量，功能与Semaphore相似，不同之处是它对于并行编程的低延迟需求做了优化。在传统的多线程方式中也有用，因为它支持在等待时指定取消标记 （cancellation token）。但它不能跨进程使用。 在Semaphore上调用WaitOne或Release会产生大概 1 微秒的开销，而SemaphoreSlim产生的开销约是其四分之一。 信号量在有限并发的需求中有用，它可以阻止过多的线程同时执行特定的代码段。在下面的例子中，五个线程尝试进入一个只允许三个线程进入的夜总会： 12345678910111213141516171819class TheClub&#123; static SemaphoreSlim _sem = new SemaphoreSlim (3); // 容量为 3 static void Main() &#123; for (int i = 1; i &lt;= 5; i++) new Thread (Enter).Start (i); &#125; static void Enter (object id) &#123; Console.WriteLine (id + \" wants to enter\"); _sem.Wait(); Console.WriteLine (id + \" is in!\"); // 同时只能有 Thread.Sleep (1000 * (int) id); // 3个线程 Console.WriteLine (id + \" is leaving\"); // 执行这里 _sem.Release(); &#125;&#125; 输出结果： 1234567891011121 wants to enter1 is in!2 wants to enter2 is in!3 wants to enter3 is in!4 wants to enter5 wants to enter1 is leaving4 is in!2 is leaving5 is in! 如果Sleep语句被替换为密集的磁盘 I/O 操作，由于Semaphore限制了过多的并发硬盘活动，就可能改善整体性能。 类似于Mutex，命名的Semaphore也可以跨进程使用。 3线程安全说一个程序或方法是线程安全（ thread-safe）的，是指它在任意的多线程场景中都不存在不确定性。线程安全主要是通过锁以及减少线程交互来实现。 一般的类型很少有完全线程安全的，原因如下： 完全线程安全的开发负担很重，特别是如果一个类型有很多字段的情况（在任意多线程并发的情况下每个字段都有交互的潜在可能）。 线程安全可能会损失性能（某种程度上，无论类型是否实际被用于多线程都会增加损耗）。 线程安全的类型并不能确保使用该类型的程序也是线程安全的，为了实现程序线程安全所涉及的工作经常会使得类型线程安全成为多余。 因此线程安全通常只会在需要时再实现，只为了处理特定的多线程场景。 然而，有些方法可以用来“作弊” ，使庞大和复杂的类在多线程环境中安全运行。一种方法是牺牲粒度，将大段代码甚至是访问的整个对象封装在一个排它锁内，从而保证在高层上能进行顺序访问。事实上，如果我们希望在多线程环境中使用线程不安全的第三方代码（或大多数 Framework 的类型）时，这种策略是十分有用的。它仅仅是简单的使用了相同的排它锁，来保护对非线程安全对象上所有属性、方法和字段的访问。这种解决方案适用于对象的方法都能够快速执行的场景（否则会导致大量的阻塞）。 除基本类型外，很少有 .NET Framework 的类型能在比并发读取更高的需求下保证其实例成员是线程安全的。实现线程安全的责任就落在了开发人员身上，一般就是使用排它锁。（命名空间System.Collections.Concurrent中的类型是个例外，它们是线程安全的数据结构。） 另一种“作弊”的方法是通过最小化共享数据来减少线程交互。这是一种优秀的方法，隐式的用于“ 无状态（stateless）”的中间层程序和网页服务器中。由于多个客户端请求可以同时到达，服务端方法就必须是线程安全的。无状态设计（因可伸缩性（scalability）好而流行）在本质上限制了交互的可能性，因为类并不需要持久化请求之间的数据。线程交互仅限于静态字段，比如在内存中缓存通用数据，或者提供认证和审计这样的基础服务时需要考虑。 实现线程安全的最后一种方式是使用自动锁机制（automatic locking regime）。如果继承 ContextBoundObject 类并使用 Synchronization 特性，.NET Framework 就可以实现这种机制。当该对象上的方法或属性被调用时，一个对象范围（object-wide）的锁就会自动作用于整个方法或属性的调用。尽管这样降低了实现线程安全的负担，但是也有它的问题：它很可能造成死锁、降低并发度并引起并非有意的重入。正是由于这些原因，手动加锁通常是更好的选择（直到有更好用的自动锁机制出现）。 3.1线程安全与 .NET Framework 类型锁可以用来将线程不安全的代码转换为线程安全的代码。.NET Framework 就是一个好例子：几乎所有的非基本类型的实例成员都不是线程安全的（对于比只读访问更高的需求），然而如果对指定对象的所有访问都通过锁进行保护，它们就可以被用于多线程代码中。例如，两个线程同时向同一个List中添加对象，然后枚举它： 12345678910111213141516171819class ThreadSafe&#123; static List &lt;string&gt; _list = new List &lt;string&gt;(); static void Main() &#123; new Thread (AddItem).Start(); new Thread (AddItem).Start(); &#125; static void AddItem() &#123; lock (_list) _list.Add (\"Item \" + _list.Count); string[] items; lock (_list) items = _list.ToArray(); foreach (string s in items) Console.WriteLine (s); &#125;&#125; 在这个例子中，我们使用_list对象本身来加锁。如果有两个关联的List，就需要选择一个公共对象来加锁（可以使用其中一个List对象，然而更好的方式是使用一个独立的字段）。 枚举 .NET 的集合也不是线程安全的，因为如果在枚举的过程中集合被修改则会抛出异常。在这个例子中，我们并没有将整个枚举过程加锁，而是首先将其中的对象复制到一个数组中。如果我们要进行的枚举可能很耗时，那么可以通过上述方式避免过长时间锁定。（另一种解决方案是使用读写锁（reader / writer lock）） 对线程安全的对象加锁有时也需要对线程安全的对象加锁，为了举例说明，假设 Framework 的List类是线程安全的，我们要给它添加一个条目： 1if (!_list.Contains (newItem)) _list.Add (newItem); 无论List本身是否线程安全，上面的语句都不是线程安全的！为了防止if条件判断执行后，在实际添加条目之前，被其它线程抢占修改了_list，整个if所包含的代码都需要封装在一个锁中。并且在所有要修改_list的地方都要使用这个锁。例如，下面的语句也需要封装在相同的锁中： 1_list.Clear(); 这也是为了确保了它不会在前面语句的执行过程中抢先执行。换句话说，我们不得不像对于非线程安全的集合一样锁定线程安全的集合（这使得对于List类是线程安全的假设变得多余）。 在高并发的环境下，对集合的访问加锁可能会产生大量阻塞，为此 Framework 4.0 提供了线程安全的队列、栈和字典。 静态成员将对对象的访问封装在一个自定义锁中的方式，只有当所有参与并发的线程都知道并使用这个锁时才能起作用。然而如果需要加锁的逻辑有更大范围那就不是这么简单了。最糟糕的情况就是public类型中的静态成员。比如，我们假设DateTime结构体上的静态属性DateTime.Now不是线程安全的，即两个并发线程调用会导致错误的输出或是异常。使用外部加锁进行修正的唯一方法就是在调用DateTime.Now之前对类型本身加锁：lock(typeof(DateTime))。这仅适用于所有的程序员都接受这样做（这不太可能）。此外，对类型加锁也有其自身的问题。 因此，DateTime结构体的静态成员都经过细致的处理，来保证它是线程安全的。这在 .NET Framework 中是一个通用模式：静态成员是线程安全的，而实例成员则不是。编写类型让别人使用时，遵守这种模式就不会令别人感到困惑和遇到难以解决的线程安全问题。换句话说，保证静态成员的线程安全，就不会妨碍你的类型的使用者实现线程安全。 静态方法的线程安全是必须由明确的编码实现的，不是说把方法写成静态的就能自动实现线程安全！ 只读线程安全使类型对于并发只读访问是线程安全的会很有益，这意味着使用者可以避免使用排它锁。许多 .NET Framework 类型都遵循这一原则：例如集合对于并发读是线程安全的。 自己遵循这一愿则也很简单：如果我们希望一个类型对于并发只读访问是线程安全的，那么不要在使用者期望是只读的方法内修改字段（也不要加锁后修改）。例如，在集合的ToArray()方法的实现中，也许会从压紧（compacting）集合的内部结构开始。然而，这会导致使用者认为是只读的操作并非线程安全。 只读线程安全也是枚举器与可枚举类型分离的原因之一：两个线程可以在一个集合上同时进行枚举，因为它们会分别获得单独的枚举器。 如果缺乏文档，在认为一个方法是只读前一定要谨慎。一个很好的例子是Random类：当调用Random.Next()时，它会更新私有的种子（seed）值。因此，或者对Random类的使用加锁，或者每个线程使用单独的实例。 3.2应用服务器中的线程安全应用服务器需要使用多线程来处理多个客户端的同时请求。WCF、ASP.NET 以及 Web Services 应用都是隐式多线程的。使用 TCP 或 HTTP 之类网络通道的远程（Remoting）服务应用程序也是如此。这意味着服务端编程必须考虑线程安全，考虑在处理客户端请求的线程间是否存在交互的可能。幸运的是，这种交互的可能性不大，一般服务端类要不然是无状态的（无字段），要不然就有为每个客户端或每个请求创建单独对象实例的激活模型。交互通常仅在静态字段上出现，有时是用于在内存中缓存数据库数据来提高性能。 例如，有一个查询数据库的RetrieveUser方法： 12// User 是一个自定义类型，包含用户数据的字段internal User RetrieveUser (int id) &#123; ... &#125; 如果对这个方法的调用很频繁，可以通过在一个静态Dictionary中缓存查询结果来提高性能。下边是一个考虑了线程安全的方案： 1234567891011121314151617static class UserCache&#123; static Dictionary &lt;int, User&gt; _users = new Dictionary &lt;int, User&gt;(); internal static User GetUser (int id) &#123; User u = null; lock (_users) if (_users.TryGetValue (id, out u)) return u; u = RetrieveUser (id); // 从数据库获取数据 lock (_users) _users [id] = u; return u; &#125;&#125; 至少必须要在读取和更新字典时加锁来保证线程安全。在这个例子中，在加锁的便捷和性能之间进行了平衡。我们的设计略有一些效率问题：如果两个线程同时使用未缓存过数据的id调用这个方法，RetrieveUser就可能被调用两次，并且其中一次对字典的更新是不必要的。对整个方法加锁可以避免这一问题，但会导致更糟的效率：整个缓存在调用RetrieveUser的期间都会被加锁，在这段时间内，其它需要这样获取用户信息的线程都会被阻塞。 3.3富客户端应用与线程亲和（译者注：这里的 thread affinity 译为线程亲和，是指 UI 控件与线程的一种“绑定”关系，而不是通常理解中的线程与 CPU 核心的绑定关系。） WPF 与 Windows Forms 库都遵循基于线程亲和的模型。尽管它们有各自的实现，但是原理非常相似。 富客户端的构成主要基于DependencyObject（WPF 中）或是Control（Windows Forms 中）。这些对象具有线程亲和性（thread affinity），意思是只有创建它们的线程才能访问其成员。违反这一原则会引起不可预料的行为，或是抛出异常。 这样的好处是访问 UI 对象时并不需要加锁。而坏处是，如果希望调用在另一线程 Y 上创建的对象 X 的成员，就必须将请求封送（marshal）到线程 Y 。通过下列方法显式实现： WPF 中：在其Dispatcher对象上调用Invoke或BeginInvoke。 Windows Forms 中：调用Control对象上的Invoke或BeginInvoke。 Invoke和BeginInvoke都接受一个委托，代表我们希望在目标控件上运行的的方法。Invoke是同步工作的：调用方在封送的委托执行完成前会被阻塞；BeginInvoke是异步工作的：调用方立即返回，封送请求被加入队列（使用与处理键盘、鼠标、定时器事件相同的消息队列）。 假定窗体包含一个名为txtMessage的文本框，我们希望使用一个工作线程更新其内容，下面是 WPF 的示例： 1234567891011121314151617181920public partial class MyWindow : Window&#123; public MyWindow() &#123; InitializeComponent(); new Thread (Work).Start(); &#125; void Work() &#123; Thread.Sleep (5000); // 模拟耗时任务 UpdateMessage (\"The answer\"); &#125; void UpdateMessage (string message) &#123; Action action = () =&gt; txtMessage.Text = message; Dispatcher.Invoke (action); &#125;&#125; Windows Forms 的代码类似，所不同的是我们调用Form的Invoke方法： 12345void UpdateMessage (string message)&#123; Action action = () =&gt; txtMessage.Text = message; this.Invoke (action);&#125; Framework 提供了两个构造来简化这个过程： BackgroundWorker 任务延续（Task continuations） 工作线程 vs UI 线程我们可以认为富客户端应用程序中有两种不同的线程类别：UI 线程和工作线程。UI 线程创建（并“占有”） UI 元素，工作线程则不会；工作线程通常执行长时间任务，例如获取数据。 大多数的富客户端应用只有一个 UI 线程（它也是应用程序的主线程），它再去根据需要创建工作线程，可以直接创建或者使用BackgroundWorker。这些工作线程可以将代码封送回主 UI 线程来更新控件或报告工作进度。 那么，应用程序何时会需要多个 UI 线程呢？主要的应用场景是：如果应用具有多个顶级窗口，每个顶级窗口都是被称为单文档界面（Single Document Interface，SDI）的程序，例如 Microsoft Word。每个 SDI 窗口通常会在任务栏上显示为独立的应用程序，并且与其它的 SDI 窗口在功能上基本隔离。通过为每一个这样的窗口设置独立的 UI 线程，可以使应用程序有更好的响应。 3.4不可变对象不可变对象的状态不能被修改，无论通过外部还是内部。不可变对象的字段通常被声明为只读的，并且在构造过程中就会被初始化好。 不变性（immutability ）是函数式编程的一个标志：不是修改对象，而是使用不同的属性创建一个新的对象。LINQ 就遵循这种模式。不变性在多线程中也很有价值，它可以通过消除（或是最小化）写入的可能来避免共享可写状态的问题。 使用不可变对象的一个模式是：封装一组相关的字段来最小化锁定的时长。下面的例子中，假设有两个字段： 12int _percentComplete;string _statusMessage; 我们希望对其进行原子的读 / 写操作。除了加锁之外，也可以定义如下的不可变类： 12345678910111213class ProgressStatus // 代表某活动进度&#123; public readonly int PercentComplete; public readonly string StatusMessage; // 这个类可能还有其它很多字段... public ProgressStatus (int percentComplete, string statusMessage) &#123; PercentComplete = percentComplete; StatusMessage = statusMessage; &#125;&#125; 然后，我们可以定义一个该类型的字段，以及一个用于加锁的对象： 12readonly object _statusLocker = new object();ProgressStatus _status; 现在，我们就可以读 / 写该类型的值，而仅需要为一次赋值加锁： 1234var status = new ProgressStatus (50, \"Working on it\");// 想象一下我们曾经在这要处理多少个字段 ...// ...lock (_statusLocker) _status = status; // 非常短暂的锁 要读取该对象，首先获取该对象的一个副本（在锁内），然后就可以读取其值而不需要继续占有锁： 12345ProgressStatus statusCopy;lock (_locker ProgressStatus) statusCopy = _status; // 也是一个短暂的锁int pc = statusCopy.PercentComplete;string msg = statusCopy.StatusMessage;// ... （译者注：上面代码有误，lock中应该是_statusLocker。这里的statusCopy也不是真正的副本，而仅仅相当于_status的别名，这么做是为了通过刷新处理器缓存，获取_status当前的一致状态。） 技术上讲，最后两行代码的线程安全，是因为之前的lock进行了隐式的内存屏障（memory barrier）。 需要注意的是，这种无锁（译者注：这里不是说完全没有用到锁，而是指锁非常短暂）的方法可以避免一组相关字段出现不一致的情况。但它无法阻止后续的操作修改数据，因此，通常需要使用锁。在第 5 部分中，将会看到使用不变性来简化多线程的更多示例，包括PLINQ。 可以根据先前的值安全的创建一个新的ProgressStatus对象（例如：在其上可以“增加”PercentComplete的值），而仅需锁定一行代码。实际上不使用锁都可以，我们可以显式使用内存屏障、Interlocked.CompareExchange还有自旋等待。这种高级技术将在稍后的并行编程中讲解。 4使用事件等待句柄进行信号同步（译者注：signal / signalling 直译是信号 / 发信号，一般在通讯领域用于控制的信号称为信令，但是计算机领域一般还是称之为信号。这里的 signaling 指使用信号进行线程同步，翻译成信号或者信号同步。） 事件等待句柄（event wait handle）用于信号同步。信号同步就是一个线程进行等待，直到它收到其它线程的通知的过程。事件等待句柄是最简单的信号构造，与 C# 的事件（译者注：指基于event关键字的事件模式）无关。它们有三个成员：AutoResetEvent、ManualResetEvent以及CountdownEvent( Framework 4.0 中加入)。前两个的功能基本都是在它们的基类EventWaitHandle上实现的。 信号构造比较 构造 用途 跨进程 开销* AutoResetEvent 使线程在收到其它线程信号时解除阻塞一次 yes 1000ns ManualResetEvent 使线程在收到其它线程信号时解除阻塞，并且不继续阻塞直到被复位 yes 1000ns ManualResetEventSlim（Framework 4.0 中加入） - 40ns CountdownEvent（Framework 4.0 中加入） 使线程在收到预定数量的信号时解除阻塞 - 40ns Barrier（Framework 4.0 中加入） 实现线程执行屏障 - 80ns Wait 和 Pulse 使线程阻塞，直到自定义条件被满足 - 120ns每个Pulse * 时间代表在同一线程上进行发信号并等待（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。 4.1AutoResetEventAutoResetEvent就像验票闸机：插入一张票，就只允许一个人通过。类名字里的 “ auto “ 是指打开的闸门可以自动关闭，或着说在有人通过后 “reset （复位）”。在闸机处调用WaitOne方法（等待这 “one（一个）” 闸机打开），线程就会进入等待或者说阻塞。票的插入则通过调用Set方法。如果有多个线程调用WaitOne，便会在闸机前排队（与锁同样，由于操作系统的差异，这个等待队列的先入先出顺序有时可能被破坏）。票可以来自任意线程，换句话说，任何能够访问这个AutoResetEvent对象的（非阻塞）线程都可以调用Set方法来放行一个被阻塞的线程。 有两种方式可以创建AutoResetEvent对象，第一种是通过构造方法： 1var auto = new AutoResetEvent (false); （如果传递ture给构造方法则相当于在创建后立即调用Set方法。） 第二种方式是像下边的代码这样创建AutoResetEvent： 1var auto = new EventWaitHandle (false, EventResetMode.AutoReset); 在接下来的例子中，一个线程开始等待直到收到另一个线程的信号。 1234567891011121314151617class BasicWaitHandle&#123; static EventWaitHandle _waitHandle = new AutoResetEvent (false); static void Main() &#123; new Thread (Waiter).Start(); Thread.Sleep (1000); // 暂停 1 秒 _waitHandle.Set(); // 唤醒 Waiter &#125; static void Waiter() &#123; Console.WriteLine (\"Waiting...\"); _waitHandle.WaitOne(); // 等待通知 Console.WriteLine (\"Notified\"); &#125; 输出结果： 1Waiting... (pause) Notified. 如果在没有线程等待的时候调用Set，该事件等待句柄会保持“打开”状态直到有线程调用WaitOne。这个行为可以帮助避免一个前往闸机的线程和一个正在插入票的线程之间的配合问题（“糟糕，票早插入了 1 微秒，真不幸，你要永远等下去了！”）。然而，在一个没有任何线程在等待的闸机上反复调用Set并不会允许一堆线程通过：仅仅允许下一个通过，多出来的票被“浪费”了。 在AutoResetEvent上调用Reset可以关闭闸机（应该是开启状态的），这个调用不会等待或阻塞。 WaitOne接受一个可选的timeout参数，如果等待不是由于收到了信号，而是超时结束则返回false。 调用WaitOne并给定一个为 0 的超时时间，可以用来测试等待句柄是否是“打开”的，并且不会阻塞调用方。但是要记住，如果AutoResetEvent是打开的则会复位（关闭）它。 销毁等待句柄（译者注：这里把 dispose 翻译为销毁。） 一旦等待句柄使用完成，可以调用它的Close方法来释放操作系统资源。或者，也可以简单地丢弃所有对等待句柄的引用，让垃圾回收器在稍后处理它（等待句柄实现了销毁模式，会在析构方法中调用Close）。这是少数几个能被接受的（有争论）依赖这种备用机制的场景之一，因为等待句柄对操作系统而言是轻量级资源（异步委托（asynchronous delegates）就是这样来释放其IAsyncResult的等待句柄的 ）。 等待句柄在应用程序域被卸载时会自动地释放。 双向信号我们设定一种场景：主线程需要连续向工作线程发 3 次信号。如果主线程只是在等待句柄上快速的多次调用Set，第 2 个和第 3 个信号可能会丢失，这是由于工作线程可能要花时间去处理每个信号。 解决方案是：主线程需要在发信号前等待工作线程就绪。这可以再用一个AutoResetEvent做到，例如： 12345678910111213141516171819202122232425262728293031323334353637class TwoWaySignaling&#123; static EventWaitHandle _ready = new AutoResetEvent (false); static EventWaitHandle _go = new AutoResetEvent (false); static readonly object _locker = new object(); static string _message; static void Main() &#123; new Thread (Work).Start(); _ready.WaitOne(); // 首先等待工作线程就绪 lock (_locker) _message = \"ooo\"; _go.Set(); // 通知工作线程执行 _ready.WaitOne(); lock (_locker) _message = \"ahhh\"; // 给工作线程其它信息 _go.Set(); _ready.WaitOne(); lock (_locker) _message = null; // 发信号通知工作线程退出 _go.Set(); &#125; static void Work() &#123; while (true) &#123; _ready.Set(); // 表示我们准备好了 _go.WaitOne(); // 等待开始 lock (_locker) &#123; if (_message == null) return; // 优雅地退出 Console.WriteLine (_message); &#125; &#125; &#125;&#125; 输出结果： 12oooahhh 这里我们使用了一个为null的消息来指示工作线程结束。对于无限运行（译者注：指类似这里的while (true)方式无限循环）的线程，退出机制是非常重要的！ 生产者 / 消费者队列生产者 / 消费者队列是一个在多线程中常见的需求，它是这样工作的： 建立一个队列，用于描述需要执行的工作项，或需要处理的数据。 当有任务需要执行时，把它加入队列中，这样调用方就可以继续处理其它事情。 一个或多个工作线程在后台工作，它们从队列中取出工作项并执行。 这种模型的好处是，可以精确控制工作线程的数量，使你能够限制 CPU 和其它资源的消耗。比如，如果任务执行密集的磁盘 I/O 操作，可以仅使用一个工作线程来执行工作，这样能够避免操作系统和其它应用出现饥饿。其它类型的应用也许就可以使用 20 个工作线程。也可以在队列生命周期内动态添加和移除工作线程。CLR 的线程池本身就是一种生产者 / 消费者队列。 生产者 / 消费者队列一般只是存放需要任务处理的数据项，例如数据项可能是文件名，而任务是加密这些文件。 下边的例子，使用一个AutoResetEvent发信号给工作线程，工作线程在所有任务都已完成时（或者说队列为空时）会处于等待状态。通过加入null任务来通知工作线程结束： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Threading;using System.Collections.Generic;class ProducerConsumerQueue : IDisposable&#123; EventWaitHandle _wh = new AutoResetEvent (false); Thread _worker; readonly object _locker = new object(); Queue&lt;string&gt; _tasks = new Queue&lt;string&gt;(); public ProducerConsumerQueue() &#123; _worker = new Thread (Work); _worker.Start(); &#125; public void EnqueueTask (string task) &#123; lock (_locker) _tasks.Enqueue (task); _wh.Set(); &#125; public void Dispose() &#123; EnqueueTask (null); // 通知消费者退出 _worker.Join(); // 等待消费者线程完成执行 _wh.Close(); // 释放所有系统资源 &#125; void Work() &#123; while (true) &#123; string task = null; lock (_locker) if (_tasks.Count &gt; 0) &#123; task = _tasks.Dequeue(); if (task == null) return; &#125; if (task != null) &#123; Console.WriteLine (\"Performing task: \" + task); Thread.Sleep (1000); // 模拟执行工作... &#125; else _wh.WaitOne(); // 没有任务了，等待信号 &#125; &#125;&#125; 为保证线程安全，我们使用了一个锁来保护对Queue&lt;string&gt;的访问。在Dispose方法中，我们也显式关闭了等待句柄，因为在程序生命周期中，有可能会创建和销毁许多这个类的实例。 下边是测试这个队列的主方法： 123456789101112static void Main()&#123; using (ProducerConsumerQueue q = new ProducerConsumerQueue()) &#123; q.EnqueueTask (\"Hello\"); for (int i = 0; i &lt; 10; i++) q.EnqueueTask (\"Say \" + i); q.EnqueueTask (\"Goodbye!\"); &#125; // 使用 using 语句结束时会调用 q 的 Dispose 方法 // 该方法向队列中插入一个 null 的任务，并等待消费者完成退出。&#125; 输出结果： 12345678Performing task: HelloPerforming task: Say 1Performing task: Say 2Performing task: Say 3......Performing task: Say 9Goodbye! Framework 4.0 提供了一个新的类型BlockingCollection，它实现了生产者 / 消费者队列的功能。 前面我们自己写的生产者 / 消费者队列还是有价值的，它不仅仅为了举例说明AutoResetEvent和线程安全，也是更多其它复杂构造的基础。例如，如果想要实现有界阻塞队列（bounded blocking queue）（可以限制队列中任务的个数），并且希望支持取消（和移除）队列中工作项，我们的代码就是一个很好的起点。之后在讨论Wait 和 Pulse时会让这个的生产者 / 消费者队列的例子更进一步。 4.2ManualResetEventManualResetEvent就像一个普通的门。调用Set方法打开门，允许任意数量的线程调用WaitOne方法来通过。调用Reset方法关闭门。如果线程在一个关闭的门上调用WaitOne方法将会被阻塞，当门下次打开时，会被立即放行。除这些不同以外，ManualResetEvent就和AutoResetEvent差不多了。 与AutoResetEvent类似，可以使用两种方式构造ManualResetEvent: 12var manual1 = new ManualResetEvent (false);var manual2 = new EventWaitHandle (false, EventResetMode.ManualReset); 从 Framework 4.0 开始，提供了另一个版本的ManualResetEvent，名为ManualResetEventSlim。后者为短等待时间做了优化，它提供了进行一定次数迭代自旋的能力，也实现了一种更有效的管理机制，允许通过CancellationToken取消Wait等待。但它不能用于跨进程的信号同步。ManualResetEventSlim不是WaitHandle的子类，但它提供一个WaitHandle的属性，会返回一个基于WaitHandle的对象（使用它的性能和一般的等待句柄相同）。 信号构造与性能对于AutoResetEvent和ManualResetEvent，使用它们等待或者发信号需要大概 1 微秒时间（假设没有阻塞）。 ManualResetEventSlim和CountdownEvent在等待时间很短的情况下可以比上面两个快 50 倍。这是因为它们不依赖操作系统，并能择机使用自旋构造。 然而大多数情况下，信号构造自身的开销并不会造成瓶颈，所以很少需要去考虑。高度并发的场景是个例外，我们将在第 5 部分进行讨论。 ManualResetEvent在需要让一个线程解除其它多个线程的阻塞时有用。如果是相反的需求，可以使用CountdownEvent。 4.3CountdownEventCountdownEvent 可以让你等待 1 个以上的线程。这个类型是 Framework 4.0 加入的，并且是一个高效的纯托管实现。 如果在使用较早版本的 .NET Framework，也不是没有办法。稍后我们会介绍如何使用Wait 和 Pulse来实现CountdownEvent。 使用CountdownEvent时，需要指定一个计数器数值，也就是你希望等待的线程数量： 1var countdown = new CountdownEvent (3); // 初始计数为 3 调用Signal方法会将计数减 1，调用Wait会阻塞直到计数为 0。例如： 123456789101112131415161718static CountdownEvent _countdown = new CountdownEvent (3);static void Main()&#123; new Thread (SaySomething).Start (\"I am thread 1\"); new Thread (SaySomething).Start (\"I am thread 2\"); new Thread (SaySomething).Start (\"I am thread 3\"); _countdown.Wait(); // 阻塞直到收到 3 次信号 Console.WriteLine (\"All threads have finished speaking!\");&#125;static void SaySomething (object thing)&#123; Thread.Sleep (1000); Console.WriteLine (thing); _countdown.Signal();&#125; 有时通过使用结构化并行（structured parallelism）构造会比CountdownEvent更容易解决问题。我们将在第 5 部分来说明（PLINQ 和 Parallel类）。 调用AddCount，可以增加CountdownEvent的计数。然而，如果计数已经为 0，就会抛出一个异常：是无法通过调用AddCount来复位（unsignal）的。为避免异常，可以用TryAddCount替代，它在当前计数为 0 时会返回false。 想要复位，可以调用Reset：把构造复位到初始状态，计数恢复原值。 像ManualResetEventSlim一样，CountdownEvent也提供WaitHandle属性，可以在其它类或方法希望得到一个基于WaitHandle的对象时使用。 4.4创建跨进程的 EventWaitHandleEventWaitHandle的构造方法允许以命名的方式进行创建，这样它就可以跨进程使用。名称就是一个字符串，可以随意起名，但是注意不要和别人的命名冲突！如果名字在计算机上已存在，你就会获取一个它对应的EventWaitHandle的引用，否则操作系统会创建一个新的。例如： 12EventWaitHandle wh = new EventWaitHandle (false, EventResetMode.AutoReset, \"MyCompany.MyApp.SomeName\"); 如果两个应用程序分别执行这个代码，它们就可以进行信号同步：这个等待句柄可以在跨这两个进程内的所有线程中使用。 4.5等待句柄和线程池如果你的应用有很多线程，这些线程大部分时间都在阻塞，那么可以通过调用ThreadPool.RegisterWaitForSingleObject来减少资源消耗。这个方法接受一个委托，它会在向等待句柄发信号时执行。当处于等待状态时，它不会浪费线程资源： 123456789101112131415161718static ManualResetEvent _starter = new ManualResetEvent (false);public static void Main()&#123; RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject (_starter, Go, \"Some Data\", -1, true); Thread.Sleep (5000); Console.WriteLine (\"Signaling worker...\"); _starter.Set(); Console.ReadLine(); reg.Unregister (_starter); // 完成后的清理&#125;public static void Go (object data, bool timedOut)&#123; Console.WriteLine (\"Started - \" + data); // 执行任务 ....&#125; 输出结果： 123(5 second delay)Signaling worker...Started - Some Data 当向等待句柄发信号时（或者已超时），委托会在一个线程池线程运行。 除等待句柄和委托外，RegisterWaitForSingleObject还接受一个“黑盒”对象，它会被传递给委托的目标方法（像ParameterizedThreadStart一样）；还有一个以毫秒为单位的超时时间（-1 代表没有超时时间）；和一个布尔值用来设置请求是一次性的还是可重复的。 RegisterWaitForSingleObject在需要处理很多并发请求的应用服务器中非常有用。假如你需要在ManualResetEvent上阻塞，调用WaitOne就可以了： 12345void AppServerMethod()&#123; _wh.WaitOne(); // ... 继续执行&#125; 如果 100 个客户端调用这个方法，就会有 100 个服务端线程被浪费在阻塞上。把_wh.WaitOne换成RegisterWaitForSingleObject可以让方法立即返回，就不会浪费线程资源： 1234567891011void AppServerMethod&#123; RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject (_wh, Resume, null, -1, true); // ...&#125;static void Resume (object data, bool timedOut)&#123; // ... 继续执行&#125; 传递给Resume的data对象可以用来传递和暂存一些瞬态数据。 4.6WaitAny、WaitAll 和 SignalAndWait除了Set、WaitOne和Reset方法外，在WaitHandle类上还有一些静态方法用来解决更复杂的同步问题。 WaitAny、WaitAll和SignalAndWait方法可以向多个等待句柄发信号和进行等待操作。等待句柄可以是不同的类型（包括Mutex和Semaphore，因为它们都派生自抽象类WaitHandle）。对于ManualResetEventSlim和CountdownEvent，也可以通过它们的WaitHandle属性来让这些方法使用。 WaitAll和SignalAndWait与旧有的 COM 架构有古怪的联系：这些方法要求调用方必须在多线程套间（multithreaded apartment）中，这个模式最不适合交互操作。比如 WPF 或 Windows 应用程序的主线程就不能在这种模式下操作剪贴板。我们稍后会讨论到它们的替代方案。 WaitHandle.WaitAny等待一组等待句柄中任意一个，WaitHandle.WaitAll等待给定的所有等待句柄。这个等待是原子的，就是说如果在等待两个AutoResetEvent： WaitAny当任意一个事件处于“打开”状态时就能结束等待。 WaitAll当两个事件同时处于“打开”状态时才能结束等待。 （译者注：见前文，AutoResetEvent在被Set时，如果没有线程在等待，会保持“打开”状态，直到有线程等待它，会放行一个线程，并“关闭”或者说“复位”。这里用WaitAny等待两个AutoResetEvent，那么它只会触发其中一个的复位，另一个如果也被Set，会继续保持“打开”；而如果是WaitAll，则必须两个都处于“打开”状态才能结束等待，同时触发两个事件的复位。） SignalAndWait会调用一个WaitHandle的Set方法，然后调用另一个WaitHandle的WaitOne方法。在向第一个句柄发信号后，会（让当前线程）跳到第二个句柄的等待队列的最前位置。你可以把它看作是“交换”两个信号，在一对EventWaitHandle上调用这个方法来设定两个线程的会合点（rendezvous），或者说是让它们在某一个时间点“相遇”。不管是AutoResetEvent还是ManualResetEvent都可以用来实现这个技巧。第一个线程执行： 1WaitHandle.SignalAndWait (wh1, wh2); 而第二个线程相反： 1WaitHandle.SignalAndWait (wh2, wh1); WaitAll 和 SignalAndWait 的替代方案WaitAll和SignalAndWait不能运行在单线程套间（single-threaded apartment）中。幸运的是，还有替代方案。对于SignalAndWait，其实很少需要它的插队机制：例如在上边的会合例子中，如果等待句柄完全只是为了会合使用，那么就可以在第一个句柄上调用Set，然后在第二个句柄上调用WaitOne。在Barrier类中，我们将探索实现线程会合的另外一个方法。 对于WaitAll，有时可以使用Parallel 类的 Invoke 方法来替代，这个我们将在第 5 部分讨论。（我们也会讨论Task和任务延续（continuations），以及如何使用TaskFactory的ContinueWhenAny作为WaitAny的替代。） 对于其它情况，答案是使用底层的方法来解决所有信号同步问题：见Wait 和 Pulse。 5同步上下文（译者注：这里的同步上下文（synchronization context）并不是指System.Threading.SynchronizationContext类。而是指 CLR 的自动锁机制中的同步域或者说加锁的范围。） 对于手动锁定，另一种实现方案是使用声明方式（declaratively）来锁定。通过从ContextBoundObject类派生并添加Synchronization特性，可以指示 CLR 自动加锁。例如： 12345678910111213141516171819202122232425using System;using System.Threading;using System.Runtime.Remoting.Contexts;[Synchronization]public class AutoLock : ContextBoundObject&#123; public void Demo() &#123; Console.Write (\"Start...\"); Thread.Sleep (1000); // 这里我们无法抢占 Console.WriteLine (\"end\"); // 感谢自动锁 &#125;&#125;public class Test&#123; public static void Main() &#123; AutoLock safeInstance = new AutoLock(); new Thread (safeInstance.Demo).Start(); new Thread (safeInstance.Demo).Start(); safeInstance.Demo(); //并发调用 Demo 3 次 &#125;&#125; 输出结果： 123Start... endStart... endStart... end CLR 确保了同一时刻只有一个线程可以执行 safeInstance中的代码。它通过创建了一个同步对象，并在每次调用safeInstance的方法和属性时进行锁定来实现。锁的作用范围，在这里是指safeInstance对象，被称为同步上下文（synchronization context）。 那么，它是如何工作的呢？一个线索是Synchronization特性的命名空间：System.Runtime.Remoting.Contexts。ContextBoundObject可以被认为是一个“远程（remote）”对象，这意味着所有方法的调用都是会被拦截。为了实现这种拦截，当我们实例化AutoLock时，CLR 自动返回了一个具有相同方法和属性的AutoLock的代理对象，它扮演着中间人角色。自动锁定就是在中间人上进行的。总的来说，这种拦截会在每次方法调用时增加大概 1 微秒的开销。 自动同步不能用于保护静态成员，也不能用于非派生自 ContextBoundObject的类。（例如：Windows Forms 窗体） 锁在内部以相同的方式运作，可以期待下面的例子与之前的有一样的结果： 1234567891011121314151617181920212223[Synchronization]public class AutoLock : ContextBoundObject&#123; public void Demo() &#123; Console.Write (\"Start...\"); Thread.Sleep (1000); Console.WriteLine (\"end\"); &#125; public void Test() &#123; new Thread (Demo).Start(); new Thread (Demo).Start(); new Thread (Demo).Start(); Console.ReadLine(); &#125; public static void Main() &#123; new AutoLock().Test(); &#125;&#125; （注意我们偷偷加了Console.ReadLine语句。）因为这个类的对象在同一时间只有一个线程可以执行代码，三个新线程将阻塞在Demo方法处，直到Test 方法完成，也就是要等待ReadLine完成。因此只有在按了回车键之后，才会得到和之前一样的结果。这种线程安全的重型武器足以阻碍所有类内部的多线程！ 此外，我们仍未解决之前描述的一个问题：如果AutoLock是一个集合类，如果在其它类中执行下面的代码，那么仍然需要加锁： 1if (safeInstance.Count &gt; 0) safeInstance.RemoveAt (0); 除非执行这段代码的类本身也是一个同步的ContextBoundObject！ 同步上下文的作用域可以扩展到超过单一对象的范围。默认情况下，如果一个同步对象在另一个类中被实例化，它们会共享同一个同步上下文（换言之，就是一个巨大的锁！）。这个行为可以通过在Synchronization特性构造方法中使用一个整型标识来改变，可以使用下列SynchronizationAttribute类中定义的常量之一： 常量 作用 NOT_SUPPORTED 相当于不使用Synchronized特性 SUPPORTED 如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则保持非同步状态 REQUIRED（默认值） 如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则创建新的同步上下文 REQUIRES_NEW 始终创建新的同步上下文 所以如果SynchronizedA在SynchronizedB中被实例化，而SynchronizedB使用下面这种声明的话，它们就有各自的同步上下文： 12[Synchronization (SynchronizationAttribute.REQUIRES_NEW)]public class SynchronizedB : ContextBoundObject &#123; // ... 越大的同步上下文越容易管理，但是并发的可能性就越低。另一方面，分离的同步上下文则容易造成死锁，例如： 1234567891011121314151617181920[Synchronization]public class Deadlock : ContextBoundObject&#123; public Deadlock Other; public void Demo() &#123; Thread.Sleep (1000); Other.Hello(); &#125; void Hello() &#123; Console.WriteLine (\"hello\"); &#125;&#125;public class Test&#123; static void Main() &#123; Deadlock dead1 = new Deadlock(); Deadlock dead2 = new Deadlock(); dead1.Other = dead2; dead2.Other = dead1; new Thread (dead1.Demo).Start(); dead2.Demo(); &#125;&#125; 因为两个Deadlock的实例都是在Test中创建的，而Test是非同步类，所以这两个实例会拥有它自己的同步上下文，因此有它自己的锁。当它们互相调用的时候，用不了多久就会死锁（确切的说是一秒！）。如果Deadlock和 Test是由不同的开发团队写的，这个问题会藏的很深。别指望负责Test的团队能意识到他们犯了什么错，更别指望能知道如何解决了。而对于显式的加锁，死锁的原因通常更容易被发现。 5.1重入（译者注：在单线程场景下，方法没有退出前自身再被调用也是重入，比如显式的递归调用，或者隐式的通过消息队列机制等等，这种重入和作者讨论的多线程场景下的重入并不是完全相同的概念。） 线程安全方法有时也被称为可重入的（reentrant），因为它可能在执行中途被抢占，然后在另外的线程再被调用也不会有问题。在一般意义上，线程安全和可重入是同义词或者是密切相关的。 然而，在自动锁机制下，重入有另一个更危险的潜在问题。如果Synchronization特性的reentrant参数为true： 1[Synchronization(true)] 那么在执行离开上下文时，同步上下文的锁会被临时释放。在之前的例子中，这可以防止死锁的发生，当然是符合我们期望的。但是，一个副作用是，在过渡期间，任何线程都可以自由的调用原对象上的任何方法（重新进入（re-entering）同步上下文），这会导致多线程编程异常复杂，应该极力避免它。这就是可重入的问题。 因为[Synchronization(true)]作用于类上，就导致了类中所有会离开同步上下文的方法调用都会带来可重入的副作用问题。 虽然可重入可能是危险的，但有些时候几乎没有其它选择。例如，在一个同步类内部实现了多线程，方法是通过委托把逻辑交给运行在其它同步上下文中的工作线程。如果没有重入，那么工作线程就可能会导致彼此之间或是原线程的阻塞。 这凸显了自动同步的一个基本缺点：范围过大的锁定作用域将制造出巨大的麻烦：死锁、可重入以及降低并发度。这使得手动锁定在任何场景都显得更为合适，而并不仅仅只在简单的场景下。 原文：http://www.albahari.com/threading/part2.aspx翻译：https://blog.gkarch.com/threading/part2.html","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://luox78.github.io/tags/thread/"}]},{"title":"初识JavaScript03","slug":"JavaScript03","date":"2017-12-31T11:50:33.903Z","updated":"2018-01-04T13:54:33.153Z","comments":true,"path":"2017/12/31/JavaScript03/","link":"","permalink":"https://luox78.github.io/2017/12/31/JavaScript03/","excerpt":"Array对象 js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组 赋值","text":"Array对象 js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组 赋值 123456789101112131415//1var arr = new Array(3); arr[0] = 0; arr[1] = 1; arr[2] = 2; alert(arr);//0,1,2 arr[3] = 3;//0,1,2,3 alert(arr); //2 for(var i=0;i&lt;5;i++)&#123; arr[i]=i; &#125; //3 var arr=[1,2,3,\"string\"]; var arr=new Array(1,2,3,\"string\"); Json(键值对)12345var arr=&#123;\"gender\":\"male\",\"name\":\"luox78\",\"age\":18&#125;;for(var key in arr)&#123; alert(key+arr[key]); //取值的另一种方式 arr.key&#125; 原型 相当于C#拓展方法 注意：不能跨script标签使用 123456//简易的邮箱判断String.prototype.checkEmail=function()&#123; return this.indexOf(\"@\")&gt;0?true:false;&#125;;var str=\"111@163.com\";alert(str.checkEmail());//true; DOM DOM document object model 为什么要有dom为了更方便的操作html。DOM就是把Html页面模拟成一个对象，就像XDocument一样，把Xml模拟成了一个对象，提供了操作各个节点的方法，直接调用就可以了。 window，document对象 window代表浏览器整个窗口，alert等操作只能用window操作(window可以省略) document代表整个页面，只能操作页面元素 ，及内置方法 1234window.alert(\"hello\");var n=90;window.alert(window.n);//90document.getElementById('btn').id; 但通过window获取元素时会碰到一个问题，就是元素嵌套必须一层一层访问，如访问form中的buttonwindow.form1.btn.id，此时应该使用document对象简化操作,document.getElementById(&#39;btn&#39;).id document演示1234567//当click时先弹出body area 然后才是html body 涉及事件冒泡document.body.onmousedown=function()&#123; alert(\"body area\");&#125;document.onmousedown=function()&#123; alert(\"html area\");&#125; window常见方法 window.alert(&#39;大家好!&#39;);//弹出警告对话框 window.confirm(&#39;确定要删除吗？&#39;);//确定、取消对话框，返回true或false; 123456789101112&lt;body&gt; &lt;input type=\"button\" id=\"btn3\"/&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(\"btn3\").onclick= function() &#123; if (window.confirm(\"Are you sure to delete?\")) &#123; alert(\"delete success\"); &#125; else &#123; alert(\"delete failed\"); &#125; &#125;&lt;/script&gt; window.navigate(url);//将网页重新导航到url,只支持IE、Opera11.6,建议使用window.location.href=&#39;url&#39;;//支持大多数浏览器 123456window.onload = function() &#123; window.navigate(\"https://luox78.github.io\"); &#125;//基本上都不行window.onload = function () &#123; window.location.href = \"https://luox78.github.io\"; &#125;//推荐使用 window.setInterval(function,delay)每个delay ms执行一次 setTimeout(function,delay)只会执行一次，clearTimeout(setId)是为了清理占用的内存 1234567891011//botton value自增例子&lt;script&gt; var num = parseInt(document.getElementById(\"btn\").value); var setId = setInterval(function () &#123; document.getElementById(\"btn\").value = num++; &#125;, 1); document.getElementById(\"btn\").onclick= function() &#123; clearInterval(setId);//计时器一旦被销毁不能再创建 &#125;&lt;/script&gt; 事件 跟C#中事件，委托差不多 注意点： 事件=函数名，等于给事件赋值不会调用 事件=函数名（），会执行一次函数，这种赋值其实并不正确，事件应该不能等于函数返回值 &lt;body&gt;中 123456&lt;body&gt; &lt;input type=\"button\" id=\"btn\"/&gt; &lt;input type=\"button\" onclick=\"f1();\" /&gt; &lt;input type=\"button\" onclick=f1 /&gt; &lt;input type=\"button\" id=\"btn2\" value=\"change method\"/&gt;&lt;/body&gt; onclick=f1;的意思就是说onclick触发的方法就是f1. onclick=“f1();”的意思就是说onclick直接调用window.f1(); &lt;script&gt;中 12345678910111213&lt;script&gt; function f1() &#123; alert(\"f1\"); &#125; function f3() &#123; alert(\"f3\"); &#125; document.getElementById(\"btn\").onclick = f1; document.getElementById(\"btn2\").onclick = function() &#123; document.getElementById(\"btn\").onclick = f3; alert(\"change completed\"); &#125;&lt;/script&gt; body、document对象的事件 window.onload 网页加载完毕时触发，浏览器是一边下载文档、一边解析执行，可能会出现JavaScript执行时需要操作某个元素，这个元素还没有加载，如果这样就要把操作的代码放到body的onload事件中，或者可以把JavaScript放到元素之后。元素的onload事件是元素自己加载完毕时触发，body onload才是全部加载完成 window.控件Id（不建议使用),document.getElementById(“控件Id”);(推荐) onunload（页面卸载后触发） 网页关闭（或者离开）后触发。//刷新页面的时候、关闭选项卡的时候（多个选项卡） onbeforeunload（页面卸载前触发） 在网页准备关闭（或者离开）前触发。//注意浏览器缓存 &lt;bodyonbeforeunload=“return ‘真的要放弃发帖退出吗?’; ”&gt;。显示的文字随浏览器版本而有差异。// =“window.event.returnValue=‘’只兼容IE 除了属性之外，当然还有通用的HTML元素的事件：onclick（单击）、ondblclick（双击）、onkeydown（按键按下）、onkeypress（点击按键）、onkeyup（按键释放）、onmousedown（鼠标按下）、onmousemove（鼠标移动）、onmouseout（鼠标离开元素范围）、onmouseover（鼠标移动到元素范围）、onmouseup（鼠标按键释放）、oncontextmenu（在浏览器中单击鼠标右键显示”右键菜单”时触发）等。 window对象事件,属性 window.location window.location.href=‘’;//重新导航到新页面,可以取值，也可以赋值。 window.location.reload();//刷新当前页 window.event 123456789&lt;script&gt; document.getElementById(\"dv\").onmousedown= function() &#123; if (window.event.shiftKey) &#123; alert(\"you have pressed the shift\"); &#125; else &#123; alert(\"only mouse click\"); &#125; &#125;&lt;/script&gt; window.event.shiftKey .ctrlKey .altKey etc 获取是否按下某键 clientX、clientY发生事件时鼠标在客户区域的坐标(指显示html区域)； screenX、screenY发生事件时鼠标在屏幕上的坐标； offsetX、offsetY发生事件时鼠标相对于事件源（比如点击按钮时触发onclick）的坐标。当页面中有&lt;!DOCTYPE（文档定义）时，对offsetX和offsetY单击时的解析不同(使用onmousedown的时候与onclick测试结果不同)（单击按钮中文字的时候。） (window.event.returnValue)returnValue属性，如果将returnValue设置为false，就会取消默认事件的处理。在超链接的onclick里面禁止访问href的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。(onsubmit=&quot;window.event.returnValue=false;&quot;) •window.event.returnValue不兼容火狐浏览器 •FireFox:e. preventDefault();取消事件的默认动作。 •直接写return false;IE、FF、Chrome都可以。 window.event.button，发生事件时鼠标按键，IE:1为左键，2为右键，4中滑轮,3左右键同时按下//要测试event.button的值的时候，请在onmousedown事件中测试 ​ window.screen对象，获取屏幕的信息 1234window.onload= function() &#123; alert(screen.width); alert(screen.height); &#125; clipboardData 对象，对粘贴板的操作 onpaste,oncopy事件 12345678910&lt;script&gt; document.body.oncopy = function () &#123; alert(\"forbid copy\"); return false; &#125; document.body.onpaste= function() &#123; alert(\"forbid paste\"); return false; &#125;&lt;/script&gt; window.clipboardData.getData``window.clipboardData.setData已弃用，新的粘贴复制方法下面介绍 ​ js实现各种复制到剪贴板的方法一、实现点击按钮，复制文本框中的的内容 12345678&lt;script type=\"text/javascript\"&gt; function copyUrl2() &#123; var Url2 = document.getElementById(\"biao1\"); Url2.select(); // 选择对象 document.execCommand(\"Copy\"); // 执行浏览器复制命令 alert(\"已复制好，可贴粘。\"); &#125;&lt;/script&gt; 二、点击文本框时，复制文本框里面的内容 123456789&lt;input onclick=\"oCopy(this)\" value=\"你好.要copy的内容!\"&gt;&lt;script language=\"javascript\"&gt; function oCopy(obj) &#123; obj.select(); js = obj.createTextRange(); js.execCommand(\"Copy\") alert(\"复制成功!\"); &#125;&lt;/script&gt; 三、复制文本框或者隐藏域中的内容 12345678910111213141516&lt;script language=\"javascript\"&gt; function CopyUrl(target) &#123; target.value = myimg.value; target.select(); js = myimg.createTextRange(); js.execCommand(\"Copy\"); alert(\"复制成功!\"); &#125; function AddImg(target) &#123; target.value = \"[IMG]\" + myimg.value + \"[/ img]\"; target.select(); js = target.createTextRange(); js.execCommand(\"Copy\"); alert(\"复制成功!\"); &#125;&lt;/script&gt; 四、复制 span 标记中的内容 123456789101112&lt;script type=\"text/javascript\"&gt; function copyText(obj) &#123; var rng = document.body.createTextRange(); rng.moveToElementText(obj); rng.scrollIntoView(); rng.select(); rng.execCommand(\"Copy\"); rng.collapse(false); alert(\"复制成功!\"); &#125;&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"初识JavaScript02","slug":"JavaScript02","date":"2017-12-28T13:39:52.479Z","updated":"2017-12-31T14:26:24.140Z","comments":true,"path":"2017/12/28/JavaScript02/","link":"","permalink":"https://luox78.github.io/2017/12/28/JavaScript02/","excerpt":"js中的事件1 通过调用方法名或在“”内部写2 通过id，使用document.getElementById实现事件","text":"js中的事件1 通过调用方法名或在“”内部写2 通过id，使用document.getElementById实现事件 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;input id=\"btn\" type=\"button\" value=\"show time\" onclick=\"alert(new Date().toLocaleString());\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"show time\" onclick=\"f1();\" /&gt; &lt;input id=\"btn3\" type=\"button\" value=\"show time\" /&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"#\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"javascript:void(0);\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"javascript:alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //alert(new Date().toLocaleString()); function f1() &#123; alert(new Date().toLocaleDateString()); &#125; document.getElementById('btn3').onclick = function f2() &#123; alert(new Date().toLocaleDateString()); &#125; //script 写在上面要加一个窗体以加载事件以防止报错 window.onload = function () &#123; document.getElementById('btn3').onclick = function f2() &#123; alert(new Date().toLocaleDateString()); &#125; &#125;&lt;/script&gt; js调试1 直接在vs中点调试，下断点2 直接在浏览器中调试，按f12-调试 js中的函数1 JavaScript中声明函数的方式：（无需声明返回值类型） 1234567function add(i1, i2) &#123; return i1 + i2; //如果不写return返回的是undefined &#125;int add(int i1,int i2)//C#写法 2 不需要声明返回值类型、参数类型。函数定义以function开头。 1234567var r = add(1, 2);alert(r);r = add(\"你好\", \"tom\");alert(r); 3 JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。 4 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectAll、focus等函数名不要用。//不要与系统函数重名。(在单击事件中调用自己定义的focus方法，有问题。与系统的focus()方法重名了) 注意点1 js方法小写开头 2 js中定义名字的方法没有返回值接受到的是undefined 3 js不支持方法重载，只认最后一个 12345678function add(n1,n2) &#123; return n1 + n2; &#125; function add(n1, n2, n3) &#123; return n1 + n2 + n3; &#125; alert(add(1, 2));//NaN,此时调用的三个参数的add，n3位undefined，导致最后结果为NaN 12345678function add(n1, n2, n3) &#123; return n1 + n2 + n3; &#125; function add(n1, n2) &#123; return n1 + n2; &#125; alert(add(1, 2, 3));//3 通过arguments实现传入多个值123456789function add() &#123; var sum = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum; &#125; alert(add(10, 20, 30));//60 4 return写成return {Name:’yzk’,Age:18};而不要写成： 12345return&#123; Name:’yzk’, Age:18&#125; 原因是js会在语句末尾自动增加”分号”，如果将大括号另起一行，则return语句后自动增加“分号”后，返回值就变成了undefined了。 5 12345var x = 10;function add(n) &#123; n = n + 1; return n &#125;alert(add(x));//4 js搜索的是整个页面的方法，当出现重名的方法，js会使用最后一个（一般是同一个script标签中，涉及加载问题）function add(n) &#123; n = n + 3; return n; &#125;alert(add(x));//4 匿名函数 为了解决方法名冲突（主要是导入文件） 1 写法一 123456//js为动态类型，只有运行时才知道方法有没有返回值，所以f此时代表的是方法 var f = function (n) &#123; return n + 1; &#125; var n = f(10); alert(n);//11 2 写法二 1234//跟第一种一个意思，没有接受方法而已(function(n) &#123; return n + 1; &#125;)(10); 3 写法三 创建一个方法对象，参数传入：方法的参数和方法体，浏览器解析成正常方法所以效率低，不推荐 12var m = new Function(\"m\", \"n\", \"return m+n\");alert(m(10, 20)); js的闭包 定义：在一定函数里面再定义一个函数，•内部函数函数能访问外部函数作用域范围内的变量，这时这个内部函数就叫做闭包。 无论这个内部函数在哪里被调用都能访问的到外部函数作用域中的那些变量。12345678910function f1() &#123; var n = 100; function f2() &#123; alert(n); &#125; return f2(); &#125; var res = f1(); res(); 闭包的目的： ​ * 通过闭包实现访问闭包外方法的局部变量（解决在匿名函数中调用局部变量相关的问题） ​ * 这样使得局部变量一直保存在内存中，模拟面向对象 闭包如何实现的： ​ * 通过作用域链（使用变量先搜索自己作用域里面的数，没有再往上搜索）​ 闭包模拟面向对象 闭包获取数据会长时间占用内存，尽量减少使用js中利用函数可以模拟面向对象123456789101112131415&lt;script&gt; //类名首字母大写以示区分 function Person()&#123; &#125; var per=new Person(); per.name=\"luox78\"; per.age=18; per.say=function ()&#123; alert(\"hello\"); &#125; alert(per.name); per.say();&lt;/script&gt; 123456789&lt;script&gt; function Person(name)&#123; this.name=name; &#125; var per=new Person(\"luo78\"); //访问里面变量的两种方法 alert(per.name); alert(per[\"name\"]);&lt;/script&gt; js里面string的常用方法length 返回字符串长度charAt(index) 返回index位置的字符split(&quot;分隔符&quot;,limit) 多个分隔符使用正则表达式，limit代表返回个数js中数组可以直接显示，中间是逗号隔开1234var str = \"1|2|3|4#6\";alert(str.split(\"|\"));//1,2,3,4//js中split使用正则，且使用直接//转义特殊字符alert(str.split(\\☆|#\\)); substr(startindex,len) 返回截取start位置后len长度的字符串123var str=\"luox78\";alert(str.substr(2));//ox78alert(str.substr(2,2));//ox substring(startindex,stopindex) 返回截取start位置到stop位置的字符串1alert(str.substring(0,3));//luo toUpperCase() toLowerCase() 返回大写，小写match() replace() search() 后面dom部分涉及indexOf(&quot;str&quot;,position) 返回str的索引位置， str指想找的字符串，position指想找的第几个","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"C#中的多线程 - 01基础知识","slug":"CS_Thread01","date":"2017-12-28T12:50:03.698Z","updated":"2017-12-31T12:44:41.774Z","comments":true,"path":"2017/12/28/CS_Thread01/","link":"","permalink":"https://luox78.github.io/2017/12/28/CS_Thread01/","excerpt":"1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：","text":"1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子： 所有示例都假定已经引用了以下命名空间： 12using System;using System.Threading; 12345678910111213141516class ThreadTest&#123; static void Main() &#123; Thread t = new Thread (WriteY); // 创建新线程 t.Start(); // 启动新线程，执行WriteY() // 同时，在主线程做其它事情 for (int i = 0; i &lt; 1000; i++) Console.Write (\"x\"); &#125; static void WriteY() &#123; for (int i = 0; i &lt; 1000; i++) Console.Write (\"y\"); &#125;&#125; 输出结果： 1234xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx... 主线程创建了一个新线程t来不断打印字母 “ y “，与此同时，主线程在不停打印字母 “ x “。 线程一旦启动，线程的IsAlive属性值就会为true，直到线程结束。当传递给Thread的构造方法的委托执行完成时，线程就会结束。一旦结束，该线程不能再重新启动。 CLR 为每个线程分配各自独立的栈空间，因此局部变量是独立的。在下面的例子中，我们定义一个拥有局部变量的方法，然后在主线程和新创建的线程中同时执行该方法。 1234567891011static void Main()&#123; new Thread (Go).Start(); // 在新线程执行Go() Go(); // 在主线程执行Go()&#125;static void Go()&#123; // 定义和使用局部变量 - 'cycles' for (int cycles = 0; cycles &lt; 5; cycles++) Console.Write ('?');&#125; 输出结果：?????????? 变量cycles的副本是分别在各自的栈中创建的，因此才会输出 10 个问号。 线程可以通过对同一对象的引用来共享数据。例如： 1234567891011121314151617class ThreadTest&#123; bool done; static void Main() &#123; ThreadTest tt = new ThreadTest(); // 创建一个公共的实例 new Thread (tt.Go).Start(); tt.Go(); &#125; // 注意： Go现在是一个实例方法 void Go() &#123; if (!done) &#123; done = true; Console.WriteLine (\"Done\"); &#125; &#125;&#125; 由于两个线程是调用了同一个的ThreadTest实例上的Go()，它们共享了done字段，因此输出结果是一次 “ Done “，而不是两次。 输出结果：Done 静态字段提供了另一种在线程间共享数据的方式，以下是一个静态的done字段的例子： 123456789101112131415class ThreadTest&#123; static bool done; // 静态字段在所有线程中共享 static void Main() &#123; new Thread (Go).Start(); Go(); &#125; static void Go() &#123; if (!done) &#123; done = true; Console.WriteLine (\"Done\"); &#125; &#125;&#125; 以上两个例子引出了一个关键概念[线程安全（thread safety）]。上述两个例子的输出实际上是不确定的：” Done “ 有可能会被打印两次。如果在Go方法里调换指令的顺序，” Done “ 被打印两次的几率会大幅提高： 1234static void Go()&#123; if (!done) &#123; Console.WriteLine (\"Done\"); done = true; &#125;&#125; 输出结果： 12DoneDone (很可能!) 这个问题是因为一个线程对if中的语句估值的时候，另一个线程正在执行WriteLine语句，这时done还没有被设置为true。 修复这个问题需要在读写公共字段时，获得一个[排它锁（互斥锁，exclusive lock ）]。C# 提供了[lock]来达到这个目的： 12345678910111213141516171819class ThreadSafe&#123; static bool done; static readonly object locker = new object(); static void Main() &#123; new Thread (Go).Start(); Go(); &#125; static void Go() &#123; lock (locker) &#123; if (!done) &#123; Console.WriteLine (\"Done\"); done = true; &#125; &#125; &#125;&#125; 当两个线程同时争夺一个锁的时候（例子中的locker），一个线程等待，或者说[阻塞]，直到锁变为可用。这样就确保了在同一时刻只有一个线程能进入临界区（critical section，不允许并发执行的代码），所以 “ Done “ 只被打印了一次。像这种用来避免在多线程下的不确定性的方式被称为[线程安全（thread-safe）]。 在线程间共享数据是造成多线程复杂、难以定位的错误的主要原因。尽管这通常是必须的，但应该尽可能保持简单。 一个线程被阻塞时，不会消耗 CPU 资源。 1.1Join 和 Sleep可以通过调用Join方法来等待另一个线程结束，例如： 123456789101112static void Main()&#123; Thread t = new Thread (Go); t.Start(); t.Join(); Console.WriteLine (\"Thread t has ended!\");&#125;static void Go()&#123; for (int i = 0; i &lt; 1000; i++) Console.Write (\"y\");&#125; 输出 “ y “ 1,000 次之后，紧接着会输出 “ Thread t has ended! “。当调用Join时可以使用一个超时参数，以毫秒或是TimeSpan形式。如果线程正常结束则返回true，如果超时则返回false。 Thread.Sleep会将当前的线程阻塞一段时间： 12Thread.Sleep (TimeSpan.FromHours (1)); // 阻塞 1小时Thread.Sleep (500); // 阻塞 500 毫秒 当使用Sleep或Join等待时，线程是[阻塞（blocked）]状态，因此不会消耗 CPU 资源。 Thread.Sleep(0)会立即释放当前的时间片，将 CPU 资源出让给其它线程。Framework 4.0 新的Thread.Yield()方法与其相同，除了它只会出让给运行在相同处理器核心上的其它线程。 Sleep(0)和Yield在调整代码性能时偶尔有用，它也是一个很好的诊断工具，可以用于找出[线程安全（thread safety）]的问题。如果在你代码的任意位置插入Thread.Yield()会影响到程序，基本可以确定存在 bug。 1.2线程是如何工作的线程在内部由一个线程调度器（thread scheduler）管理，一般 CLR 会把这个任务交给操作系统完成。线程调度器确保所有活动的线程能够分配到适当的执行时间，并且保证那些处于等待或阻塞状态（例如，等待排它锁或者用户输入）的线程不消耗CPU时间。 在单核计算机上，线程调度器会进行时间切片（time-slicing），快速的在活动线程中切换执行。在 Windows 操作系统上，一个时间片通常在十几毫秒（译者注：默认 15.625ms），远大于 CPU 在线程间进行上下文切换的开销（通常在几微秒区间）。 在多核计算机上，多线程的实现是混合了时间切片和真实的并发，不同的线程同时运行在不同的 CPU 核心上。几乎可以肯定仍然会使用到时间切片，因为操作系统除了要调度其它的应用，还需要调度自身的线程。 线程的执行由于外部因素（比如时间切片）被中断称为被抢占（preempted）。在大多数情况下，线程无法控制其在何时及在什么代码处被抢占。 1.3线程 vs 进程好比多个进程并行在计算机上执行，多个线程是在一个进程中并行执行。进程是完全隔离的，而线程是在一定程度上隔离。一般的，线程与运行在相同程序中的其它线程共享堆内存。这就是线程为何有用的部分原因，一个线程可以在后台获取数据，而另一个线程可以同时显示已获取到的数据。 1.4线程的使用与误用多线程有许多用处，下面是通常的应用场景： 维持用户界面的响应 使用工作线程并行运行时间消耗大的任务，这样主UI线程就仍然可以响应键盘、鼠标的事件。 有效利用 CPU 多线程在一个线程等待其它计算机或硬件设备响应时非常有用。当一个线程在执行任务时被阻塞，其它线程就可以利用这个空闲出来的CPU核心。 并行计算 在多核心或多处理器的计算机上，计算密集型的代码如果通过分治策略（divide-and-conquer，见[第 5 部分]）将工作量分摊到多个线程，就可以提高计算速度。 推测执行（speculative execution） 在多核心的计算机上，有时可以通过推测之后需要被执行的工作，提前执行它们来提高性能。[LINQPad**]就使用了这个技术来加速新查询的创建。另一种方式就是可以多线程并行运行解决相同问题的不同算法，因为预先不知道哪个算法更好，这样做就可以尽早获得结果。 允许同时处理请求 在服务端，客户端请求可能同时到达，因此需要并行处理（如果你使用 ASP.NET、WCF、Web Services 或者 Remoting，.NET Framework 会自动创建线程）。这在客户端同样有用，例如处理 P2P 网络连接，或是处理来自用户的多个请求。 如果使用了 ASP.NET 和 WCF 之类的技术，可能[不会注意到多线程被使用]，除非是访问共享数据时（比如通过静态字段共享数据）。如果没有正确的[加锁]，就[可能产生线程安全问题]。 多线程同样也会带来缺点，最大的问题是它提高了程序的复杂度。使用多个线程本身并不复杂，复杂的是线程间的交互（一般是通过共享数据）。无论线程间的交互是否有意为之，都会带来较长的开发周期，以及带来间歇的、难以重现的 bug。因此，最好保证线程间的交互尽量少，并坚持简单和已被证明的多线程交互设计。这篇文章主要就是关于如何处理这种复杂的问题，如果能够移除线程间交互，那会轻松许多。 一个好的策略是把多线程逻辑使用可重用的类封装，以便于独立的检验和测试。.NET Framework 提供了许多高层的线程构造，之后会讲到。 当频繁地调度和切换线程时（并且如果活动线程数量大于 CPU 核心数），多线程会增加资源和 CPU 的开销，线程的创建和销毁也会增加开销。多线程并不总是能提升程序的运行速度，如果使用不当，反而可能降低速度。 例如，当需要进行大量的磁盘 I/O 时，几个工作线程顺序执行可能会比 10 个线程同时执行要快。（在[使用 Wait 和 Pulse 进行同步]中，将会描述如何实现 [生产者 / 消费者队列]，它提供了上述功能。） 2创建和启动线程像我们在简介中看到的那样，使用Thread类的构造方法来创建线程，通过传递ThreadStart委托来指明线程从哪里开始运行，下面是ThreadStart委托的定义： 1public delegate void ThreadStart(); 调用Start方法后，线程开始执行，直到它所执行的方法返回后，线程终止。下面这个例子使用完整的 C# 语法创建TheadStart委托： 1234567891011121314class ThreadTest&#123; static void Main() &#123; Thread t = new Thread (new ThreadStart (Go)); t.Start(); // 在新线程运行 GO() Go(); // 同时在主线程运行 GO() &#125; static void Go() &#123; Console.WriteLine (\"hello!\"); &#125;&#125; 在这个例子中，线程t执行Go()方法，几乎同时主线程也执行Go()方法，结果将打印两个 hello。 线程也可以使用更简洁的语法创建，使用方法组（method group），让 C# 编译器推断ThreadStart委托类型： 1Thread t = new Thread (Go); // 无需显式使用 ThreadStart 另一个快捷的方式是使用 lambda 表达式或者匿名方法： 12345static void Main()&#123; Thread t = new Thread ( () =&gt; Console.WriteLine (\"Hello!\") ); t.Start();&#125; 2.1向线程传递数据向一个线程的目标方法传递参数最简单的方式是使用 lambda 表达式调用目标方法，在表达式内指定参数: 12345678910static void Main()&#123; Thread t = new Thread ( () =&gt; Print (\"Hello from t!\") ); t.Start();&#125;static void Print (string message)&#123; Console.WriteLine (message);&#125; 使用这种方式，可以向方法传递任意数量的参数。甚至可以将整个实现封装为一个多语句的 lambda 表达式： 12345new Thread (() =&gt;&#123; Console.WriteLine (\"I'm running on another thread!\"); Console.WriteLine (\"This is so easy!\");&#125;).Start(); 在 C# 2.0 中，也可以很容易的使用匿名方法来进行相同的操作： 1234new Thread (delegate()&#123; ...&#125;).Start(); 另一个方法是向Thread的Start方法传递参数： 1234567891011static void Main()&#123; Thread t = new Thread (Print); t.Start (\"Hello from t!\");&#125;static void Print (object messageObj)&#123; string message = (string) messageObj; // 需要强制类型转换 Console.WriteLine (message);&#125; 可以这样是因为Thread的构造方法通过重载来接受两个委托中的任意一个： 12public delegate void ThreadStart();public delegate void ParameterizedThreadStart (object obj); ParameterizedThreadStart的限制是它只接受一个参数。并且由于它是object类型，通常需要类型转换。 Lambda 表达式与被捕获变量如我们所见，lambda 表达式是向线程传递数据的最强大的方法。然而必须小心，不要在启动线程之后误修改被捕获变量（captured variables）。例如，考虑下面的例子： 12for (int i = 0; i &lt; 10; i++) new Thread (() =&gt; Console.Write (i)).Start(); 输出结果是不确定的！可能是这样0223557799。 问题在于变量i在整个循环中指向相同的内存地址。所以，每一个线程在调用Console.Write时，都在使用这个值在运行时会被改变的变量！ 类似的问题在[C# 4.0 in a Nutshell**]的第 8 章的 “Captured Variables” 有描述。这个问题与多线程没什么关系，而是和 C# 的捕获变量的规则有关（在for和foreach的场景下有时不是很理想）。 解决方法就是使用临时变量，如下所示： 12345for (int i = 0; i &lt; 10; i++)&#123; int temp = i; new Thread (() =&gt; Console.Write (temp)).Start();&#125; 变量temp对于每一个循环迭代是局部的。所以，每一个线程会捕获一个不同的内存地址，从而不会产生问题。我们可以使用更为简单的代码来演示前面的问题： 12345678string text = \"t1\";Thread t1 = new Thread ( () =&gt; Console.WriteLine (text) );text = \"t2\";Thread t2 = new Thread ( () =&gt; Console.WriteLine (text) );t1.Start();t2.Start(); 因为两个lambda表达式捕获了相同的text变量，t2会被打印两次： 12t2t2 2.2线程命名每一个线程都有一个 Name 属性，我们可以设置它以便于调试。这在 Visual Studio 中非常有用，因为线程的名字会显示在线程窗口（Threads Window）与调试位置（Debug Location）工具栏上。线程的名字只能设置一次，以后尝试修改会抛出异常。 静态的Thread.CurrentThread属性会返回当前执行的线程。在下面的例子中，我们设置主线程的名字： 12345678910111213141516class ThreadNaming&#123; static void Main() &#123; Thread.CurrentThread.Name = \"main\"; Thread worker = new Thread (Go); worker.Name = \"worker\"; worker.Start(); Go(); &#125; static void Go() &#123; Console.WriteLine (\"Hello from \" + Thread.CurrentThread.Name); &#125;&#125; 2.3前台与后台线程默认情况下，显式创建的线程都是前台线程（foreground threads）。只要有一个前台线程在运行，程序就可以保持存活，而后台线程（background threads）并不能保持程序存活。当一个程序中所有前台线程停止运行时，仍在运行的所有后台线程会被强制终止。 线程的前台/后台状态与它的优先级和执行时间的分配无关。 可以通过线程的IsBackground属性来查询或修改线程的前后台状态。如下面的例子： 123456789class PriorityTest&#123; static void Main (string[] args) &#123; Thread worker = new Thread ( () =&gt; Console.ReadLine() ); if (args.Length &gt; 0) worker.IsBackground = true; worker.Start(); &#125;&#125; 如果这个程序以无参数的形式运行，工作线程会默认为前台，并在ReadLine时等待用户输入回车。此时主线程退出，但是程序仍然在运行，因为有一个前台线程依然存活。 相反，如果给Main()传递了参数，工作线程设置为后台状态，当主线程结束时，程序几乎立即退出（终止ReadLine需要一咪咪时间）。 当进程以这种方式结束时，后台线程执行栈中所有finally块就会被避开。如果程序依赖finally（或是using）块来执行清理工作，例如释放资源或是删除临时文件，就可能会产生问题。为了避免这种问题，在退出程序时可以显式的等待这些后台线程结束。有两种方法可以实现： 如果是自己创建的线程，在线程上调用[Join](方法。 如果是使用[线程池线程]，使用[事件等待句柄]。 在任一种情况下，都应指定一个超时时间，从而可以放弃由于某种原因而无法正常结束的线程。这是后备的退出策略：我们希望程序最后可以关闭，而不是让用户去开任务管理器(╯-_-)╯╧══╧ 如果用户使用任务管理器强行终止了 .NET 进程，所有线程都会被当作后台线程一般丢弃。这是通过观察得出的结论，并不是通过文档，而且可能会因为 CLR 和操作系统的版本不同而有不同的行为。 前台线程不需要这种处理，但是必须小心避免会使线程无法结束的 bug。程序无法正常退出的一个很有可能的原因就是仍有前台线程存在。 2.4线程优先级线程的Priority属性决定了相对于操作系统中的其它活动线程，它可以获得多少执行时间。线程优先级的取值如下： 1enum ThreadPriority &#123; Lowest, BelowNormal, Normal, AboveNormal, Highest &#125; 只有当多个线程同时活动时，线程优先级才有意义。 在提升线程优先级前请三思，这可能会导致其它线程的资源饥饿（resource starvation，译者注：指没有分配到足够的CPU时间来运行）等问题。 提升线程的优先级是无法使其能够处理实时任务的，因为它还受到程序进程优先级的影响。要进行实时任务，必须同时使用System.Diagnostics中的Process类来提升进程的优先级（记得这不是我告诉你的）： 12using (Process p = Process.GetCurrentProcess()) p.PriorityClass = ProcessPriorityClass.High; ProcessPriorityClass.High实际上就是一个略低于最高优先级Realtime的级别。将一个进程的优先级设置为Realtime是通知操作系统，我们绝不希望该进程将 CPU 时间出让给其它进程。如果你的程序误入一个无限循环，会发现甚至是操作系统也被锁住了，就只好去按电源按钮了o(&gt;_&lt;)o 正是由于这一原因，High 通常是实时程序的最好选择。 如果实时程序拥有用户界面，提升进程的优先级会导致大量的 CPU 时间被用于屏幕更新，这会降低整台机器的速度（特别是当 UI 很复杂时）。降低主线程的优先级，并提升进程的优先级可以保证需要进行实时任务的工作线程不会被屏幕重绘所抢占。但是这依然没有解决其它程序的CPU时间饥饿的问题，因为操作系统依然为这个进程分配了大量 CPU 资源。 理想的解决方案是分离 UI 线程和实时工作线程，使用两个进程分别运行。这样就可以分别设置各自的进程优先级，彼此之间通过 Remoting 或是内存映射文件进行通信。内存映射文件十分适用于这一任务，在C# 4.0 in a Nutshell**的第 14 和 25 章会讲到。 即使是提升了进程优先级，托管环境在处理强实时需求时仍然有限制。除了自动垃圾回收带来的延迟，操作系统也不能够完全满足实时任务的需要，即便是非托管的程序也是如此。最好的解决办法还是使用独立的硬件或者专门的实时平台。 2.5异常处理当线程开始运行后，其创建代码所在的try / catch / finally块与该线程不再有任何关系。考虑下面的程序： 1234567891011121314public static void Main()&#123; try &#123; new Thread (Go).Start(); &#125; catch (Exception ex) &#123; // 永远执行不到这里 Console.WriteLine (\"Exception!\"); &#125;&#125;static void Go() &#123; throw null; &#125; // 产生 NullReferenceException 异常 这个例子中的try / catch语句是无效的，而新创建的线程将会遇到一个未处理的NullReferenceException。因为主线程直接跳过catch。 修改方法是将异常处理移到Go方法中： 12345678910111213141516171819public static void Main()&#123; new Thread (Go).Start();&#125;static void Go()&#123; try &#123; // ... throw null; // 异常会在下面被捕获 // ... &#125; catch (Exception ex) &#123; // 一般会记录异常， 和/或通知其它线程我们遇到问题了 // ... &#125;&#125; 在生产环境的程序中，所有线程的入口方法处都应该有一个异常处理器，就如同在主线程所做的那样（一般可能是在执行栈上靠近入口的地方）。未处理的异常会使得整个程序停止运行，弹出一个难看的对话框。 在写异常处理块的时候，最好不要忽略错误。一般应该记录异常详细信息，然后可以弹出一个对话框让用户可以选择是否自动把这些信息提交到你的服务器。最后应该关闭程序，因为很可能错误已经破坏的程序的状态。然而这么做会导致用户丢失当前的工作，比如打开的文档。 WPF 和 Windows Forms 应用中的“全局”异常处理事件（Application.DispatcherUnhandledException和Application.ThreadException）只会在主UI线程有未处理的异常时触发。对于工作线程上的异常仍然需要手动处理。 AppDomain.CurrentDomain.UnhandledException会对所有未处理的异常触发，但是它不提供阻止程序退出的办法。 然而在某些情况下，可以不必处理工作线程上的异常，因为 .NET Framework 会为你处理。这些会在接下来的内容中讲到： [异步委托] [BackgroundWorker] [任务并行库（TPL）] 3线程池 当启动一个线程时，会有几百毫秒的时间花费在准备一些额外的资源上，例如一个新的私有局部变量栈这样的事情。每个线程会占用（默认情况下）1MB 内存。线程池（thread pool）可以通过共享与回收线程来减轻这些开销，允许多线程应用在很小的粒度上而没有性能损失。在多核心处理器以分治（divide-and-conquer）的风格执行计算密集代码时将会十分有用。 线程池会限制其同时运行的工作线程总数。太多的活动线程会加重操作系统的管理负担，也会降低 CPU 缓存的效果。一旦达到数量限制，任务就会进行排队，等待一个任务完成后才会启动另一个。这使得程序任意并发成为可能，例如 web 服务器。（异步方法模式（asynchronous method pattern）是进一步高效利用线程池的高级技术，我们在C# 4.0 in a Nutshell**的 23 章来讲）。 有多种方法可以使用线程池： 通过[任务并行库（TPL）]（Framework 4.0 中加入） 调用[ThreadPool.QueueUserWorkItem] 通过[异步委托] 通过[BackgroundWorker] 以下构造会间接使用线程池： WCF、Remoting、ASP.NET 和 ASMX 网络服务应用 [System.Timers.Timer]和 [System.Threading.Timer] .NET Framework 中名字以 Async 结尾的方法，例如WebClient上的方法（使用[基于事件的异步模式，EAP]），和大部分BeginXXX方法（异步编程模型模式，APM） PLINQ 任务并行库（Task Parallel Library，TPL）与 PLINQ 足够强大并面向高层，即使使用线程池并不重要，也应该使用它们来辅助多线程。我们会在[第 5 部分]中进行更详细的讨论。现在，简单看一下如何使用[Task]类作为在线程池线程上运行委托的简单方法。 在使用线程池线程时有几点需要小心： 无法设置线程池线程的Name属性，这会令调试更为困难（当然，调试时也可以在 Visual Studio 的线程窗口中给线程附加备注）。 线程池线程永远是[后台线程]（一般不是问题）。 [阻塞]线程池线程可能会在程序早期带来额外的延迟，除非调用了ThreadPool.SetMinThreads（见[优化线程池]）。 可以改变线程池线程的[优先级]，当它用完后返回线程池时会被恢复到默认状态。 可以通过Thread.CurrentThread.IsThreadPoolThread属性来查询当前是否运行在线程池线程上。 3.1通过 TPL 使用线程池可以很容易的使用任务并行库（Task Parallel Library，TPL）中的[Task]类来使用线程池。 Task类在 Framework 4.0 时被加入：如果你熟悉旧式的构造，可以将非泛型的Task类看作[ThreadPool.QueueUserWorkItem]的替代，而泛型的Task&lt;TResult&gt;看作[异步委托]的替代。比起旧式的构造，新式的构造会更快速，更方便，并且更灵活。 要使用非泛型的Task类，调用Task.Factory.StartNew，并传递目标方法的委托： 123456789static void Main() // Task 类在 System.Threading.Tasks 命名空间中&#123; Task.Factory.StartNew (Go);&#125;static void Go()&#123; Console.WriteLine (\"Hello from the thread pool!\");&#125; Task.Factory.StartNew返回一个Task对象，可以用来监视任务，例如通过调用Wait)方法来等待其结束。 当调用Task的[Wait方法]时，所有未处理的异常会在宿主线程被重新抛出。（如果不调用Wait而是丢弃不管，未处理的异常会[像普通的线程那样]结束程序。（译者注：在 .NET 4.5 中，为了支持基于async / await的异步模式，Task中这种“未观察”的异常默认会被忽略，而不会导致程序结束。 泛型的Task&lt;TResult&gt;类是非泛型Task的子类。它可以使你在其完成执行后得到一个返回值。在下面的例子中，我们使用Task&lt;TResult&gt;来下载一个网页： 12345678910111213141516171819static void Main()&#123; // 启动 task： Task&lt;string&gt; task = Task.Factory.StartNew&lt;string&gt; ( () =&gt; DownloadString (\"http://www.gkarch.com\") ); // 执行其它工作，它会和 task 并行执行： RunSomeOtherMethod(); // 通过 Result 属性获取返回值： // 如果仍在执行中, 当前进程会阻塞等待直到 task 结束： string result = task.Result;&#125;static string DownloadString (string uri)&#123; using (var wc = new System.Net.WebClient()) return wc.DownloadString (uri);&#125; （这里的&lt;string&gt; 类型参数是为了示例的清晰，它可以被省略，让编译器推断。） 查询task的Result属性时，未处理的异常会被封装在[AggregateException]中自动重新抛出。然而，如果没有查询Result属性（并且也没有调用Wait），未处理的异常会令程序结束。 TPL 具有更多的特性，非常适合于利用多核处理器。关于 TPL 的讨论我们在[第 5 部分]中继续。 3.2不通过 TPL 使用线程池如果是使用 .NET Framework 4.0 以前的版本，则不能使用任务并行库。你必须通过一种旧的构造使用线程池：ThreadPool.QueueUserWorkItem与异步委托。这两者之间的不同在于异步委托可以让你从线程中返回数据，同时异步委托还可以将异常封送回调用方。 QueueUserWorkItem要使用QueueUserWorkItem，仅需要使用希望在线程池线程上运行的委托来调用该方法： 1234567891011static void Main()&#123; ThreadPool.QueueUserWorkItem (Go); ThreadPool.QueueUserWorkItem (Go, 123); Console.ReadLine();&#125;static void Go (object data) // 第一次调用时 data 为 null&#123; Console.WriteLine (\"Hello from the thread pool! \" + data);&#125; 输出结果： 12Hello from the thread pool!Hello from the thread pool! 123 目标方法Go，必须接受单一一个object参数（来满足WaitCallback委托）。这提供了一种向方法传递数据的便捷方式，就像ParameterizedThreadStart一样。与Task不同，QueueUserWorkItem并不会返回一个对象来帮助我们在后续管理其执行。并且，你必须在目标代码中显式处理异常，未处理的异常会[令程序结束] 异步委托ThreadPool.QueueUserWorkItem并没有提供在线程执行结束之后从线程中返回值的简单机制。异步委托调用（asynchronous delegate invocations ）解决了这一问题，可以允许双向传递任意数量的参数。而且，异步委托上的未处理异常可以方便的原线程上重新抛出（更确切的说，在调用EndInvoke的线程上），所以它们不需要显式处理。 不要混淆异步委托和异步方法（asynchronous methods ，以 Begin 或 End 开始的方法，比如File.BeginRead/File.EndRead）。异步方法表面上看使用了相似的方式，但是其实是为了解决更困难的问题。我们在C# 4.0 in a Nutshell**的第 23 章中描述。 下面是如何通过异步委托启动一个工作线程： 创建目标方法的委托（通常是一个Func类型的委托）。 在该委托上调用BeginInvoke，保存其IAsyncResult类型的返回值。 BeginInvokde会立即返回。当线程池线程正在工作时，你可以执行其它的动作。 当需要结果时，在委托上调用EndInvoke，传递所保存的IAsyncResult对象。 接下来的例子中，我们使用异步委托调用来和主线程中并行运行一个返回字行串长度的简单方法： 123456789101112static void Main()&#123; Func&lt;string, int&gt; method = Work; IAsyncResult cookie = method.BeginInvoke (\"test\", null, null); // // 这里可以并行执行其它任务 // int result = method.EndInvoke (cookie); Console.WriteLine (\"String length is: \" + result);&#125;static int Work (string s) &#123; return s.Length; &#125; EndInvoke会做三件事： 如果异步委托还没有结束，它会等待异步委托完成执行。 它会接收返回值（也包括ref和out方式的参数）。 它会向调用线程抛出未处理的异常。 如果使用异步委托调用的方法没有返回值，技术上你仍然需要调用EndInvoke。在实践中，这里存在争论，因为不调用EndInvoke也不会有什么损失。然而如果你选择不调用它，就需要考虑目标方法中的异常处理来避免错误无法察觉。 （译者注：MSDN文档**中明确写了 “无论您使用何种方法，都要调用 EndInvoke 来完成异步调用。”，所以最好不要偷懒。） 当调用BeginInvoke时也可以指定一个回调委托。这是一个在完成时会被自动调用的、接受IAsyncResult对象的方法。这样可以在后面的代码中“忘记”异步委托，但是需要在回调方法里做点其它工作： 12345678910111213141516static void Main()&#123; Func&lt;string, int&gt; method = Work; method.BeginInvoke (\"test\", Done, method); // ... //&#125;static int Work (string s) &#123; return s.Length; &#125;static void Done (IAsyncResult cookie)&#123; var target = (Func&lt;string, int&gt;) cookie.AsyncState; int result = target.EndInvoke (cookie); Console.WriteLine (\"String length is: \" + result);&#125; BeginInvoke的最后一个参数是一个用户状态对象，用于设置IAsyncResult的AsyncState属性。它可以是需要的任何东西，在这个例子中，我们用它向回调方法传递method委托，这样才能够在它上面调用EndInvoke。 3.3优化线程池线程池初始时其池内只有一个线程。随着任务的分配，线程池管理器就会向池内“注入”新线程来满足工作负荷的需要，直到最大数量的限制。在足够的非活动时间之后，线程池管理器在认为“回收”一些线程能够带来更好的吞吐量时进行线程回收。 可以通过调用ThreadPool.SetMaxThreads方法来设置线程池可以创建的线程上限；默认如下： Framework 4.0，32位环境下：1023 Framework 4.0，64位环境下：32768 Framework 3.5：每个核心 250 Framework 2.0：每个核心 25 （这些数字可能根据硬件和操作系统不同而有差异。）数量这么多是因为要确定[阻塞]（等待一些条件，比如远程计算机的相应）的线程的条件是否被满足。 也可以通过ThreadPool.SetMinThreads设置线程数量下限。下限的作用比较奇妙：它是一种高级的优化技术，用来指示线程池管理器在达到下限之前不要延迟线程的分配。当存在[阻塞]线程时，提高下限可以改善程序并发性。 默认下限数量是 CPU 核心数，也就是能充分利用 CPU 的最小数值。在服务器环境下（比如 IIS 中的 ASP.NET），下限数量一般要高的多，差不多 50 或者更高。 最小线程数量是如何起作用的？ 将线程池的最小线程数设置为 x 并不是立即创建至少 x 个线程，而是线程会根据需要来创建。这个数值是指示线程池管理器当需要的时候，立即 创建 x 个线程。那么问题是为什么线程池在其它情况下会延迟创建线程？ 答案是为了防止短生命周期的任务导致线程数量短暂高峰，使程序的内存足迹（memory footprint）快速膨胀。为了描述这个问题，考虑在一个 4 核的计算机上运行一个客户端程序，它一次发起了 40 个任务请求。如果每个任务都是一个 10ms 的计算，假设它们平均分配在 4 个核心上，总共的开销就是 100ms 多。理想情况下，我们希望这 40 个任务运行在 4 个线程上： 如果线程数量更少，就无法充分利用 4 个核心。 如果线程数量更多，会浪费内存和 CPU 时间去创建不必要的线程。 线程池就是以这种方式工作的。让线程数量和 CPU 核心数量匹配，就能够既保持小的内存足迹，又不损失性能。当然这也需要线程都能被充分使用（在这个例子中满足该条件）。 但是，现在来假设任务不是进行 10ms 的计算，而是请求互联网，使用半秒钟等待响应，此时本地 CPU 是空闲状态。线程池管理器的线程经济策略（译者注：指上面说的线程数量匹配核心数）这时就不灵了，应该创建更多的线程，让所有的请求同时进行。 幸运的是，线程池管理器还有一个后备方案。如果在半秒内没有能够响应请求队列，就会再创建一个新的线程，以此类推，直到线程数量上限。 半秒的等待时间是一把双刃剑。一方面它意味着一次性的短暂任务不会使程序快速消耗不必要的40MB（或者更多）的内存。另一方面，在线程池线程被阻塞时，比如在请求数据库或者调用WebClient.DownloadFile，就进行不必要的等待。因为这种原因，你可以通过调用SetMinThreads来让线程池管理器在分配最初的 x 个线程时不要等待，例如： 1ThreadPool.SetMinThreads (50, 50); （第二个参数是表示多少个线程分配给 I/O 完成端口（I/O completion ports，IOCP），来被APM使用，这会在C# 4.0 in a Nutshell** 的第 23 章描述。） 最小线程数量的默认值是 CPU 核心数。 总结：面对长时间等待的线程，因为这些线程只占时间，并不需要cpu计算，所以线程池管理器之前的平分策略就出现了问题，由此引入半秒等待机制，一旦此线程运行时间超过半秒就直接开启新的线程给新任务。但半秒等待机制还是存在利弊，利是防止很多线程的同时开启一下子占用大量内存，弊是必须等待半秒线程管理器才会开启新线程导致时间浪费，此时设置最小线程数量显得尤为重要，可以有效的防止等待，也不会占用很多内存（根据你自己的设置）","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://luox78.github.io/tags/thread/"}]},{"title":"初识JavaScript01","slug":"JavaScript01","date":"2017-12-27T12:55:09.751Z","updated":"2018-01-01T11:38:56.825Z","comments":true,"path":"2017/12/27/JavaScript01/","link":"","permalink":"https://luox78.github.io/2017/12/27/JavaScript01/","excerpt":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt;","text":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt; 默认如果直接在script标签中定义变量，则属于“全局作用域范围”(全局执行环境)，即属于window对象。1 . 全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源2 . 一个页面中的多个script标签中的变量可以互相访问。3 . JS有垃圾回收机制，会定时对可释放资源的变量回收。将变量设置为null则表示可以被回收了。 123456789&lt;script&gt; function name(parameters) &#123; var i = 0; i++; alert(i); &#125; //方法无返回值，会返回undefined alert(name());&lt;/script&gt; 1234567&lt;script&gt; var i = 1;&lt;/script&gt;&lt;script&gt; //全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源 alert(i);//1&lt;/script&gt; 方法内部不使用var定义的变量相当于全局变量1234567891011&lt;script&gt; function f1(parameters) &#123; i = 100; //var i = 100; &#125;&lt;/script&gt;&lt;script&gt; f1(); alert(i);//100 //alert(i);使用未定义&lt;/script&gt; switchjs中switch中的判断是严格判断就是全等于（===）123456789101112&lt;script&gt; var i = 90; switch (i) &#123; case 90: alert(\"number\"); break; case \"90\": alert(\"string\"); break; default: &#125;&lt;/script&gt; js类型转换注意点： 1 Number（）将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN 2 String（）转换不成功返回undefined， toString（）报错 3 Boolean（）转换当为0或为空（值为空或者null）时返回false，其余返回true1234567891011121314151617181920&lt;script&gt; alert(parseInt(\"90\")); //90 alert(parseInt(\"90aaaaaaaaaa\")); //90 alert(parseInt(\"aaaaaa\")); //NaN alert(parseInt(111, 2)); //代表给定一个二进制的数111输出十进制 alert(parseFloat(10.111)); //10.111 alert(Number(\"40addd\")); //将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN //alert(isNaN(\"aaa\")); //true var str; alert(String(str)); //undefined alert(str.toString()); //报错 //boolean var b1 = Boolean(\"\"); //false - 空字符串 var b2 = Boolean(\"hello\"); //true - 非空字符串 var b1 = Boolean(50); //true - 非零数字 var b1 = Boolean(null); //false – null var b1 = Boolean(0); //false - 零 var b1 = Boolean(new object()); //true - 对象 &lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"LINQ","slug":"Ten_LINQ_Myth","date":"2017-12-26T14:34:53.555Z","updated":"2018-01-01T11:38:28.505Z","comments":true,"path":"2017/12/26/Ten_LINQ_Myth/","link":"","permalink":"https://luox78.github.io/2017/12/26/Ten_LINQ_Myth/","excerpt":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3);","text":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3); 2 All LINQ queries must use query syntax. lambda syntax query syntax 12345678//Here's an example of lambda syntax:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); Here's the same thing expressed in query syntax://string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = from p in people where p.Length &gt; 3 select p; 3 To retrieve all customers from the customer table, you must perform a query similar to the following:12345678910111213141516171819The expression:from c in db.Customers select c is a frivolous query! You can simply go:db.CustomersSimilarly, the following LINQ to XML query:var xe = from e in myXDocument.Descendants (\"phone\") select e;can be simplified to:var xe = myXDocument.Descendants (\"phone\");And this:Customer customer = (from c in db.Customers where c.ID == 123 select c) .Single();can be simplified to:Customer customer = db.Customers.Single (c =&gt; c.ID == 123); 4 A LINQ to SQL or EF query will be executed in one round-trip only if the query was built in a single step.LINQ follows a lazy evaluation model, which means queries execute not when constructed, but when enumerated. This means you can build up a query in as many steps as you like, and it won’t actually hit the server until you eventually start consuming the results. For instance, the following query retrieves the names of all customers whose name starts with the letter ‘A’, and who have made at least two purchases. We build this query in three steps:123456var query = db.Customers.Where (c =&gt; c.Name.StartsWith (\"A\"));query = query.Where (c =&gt; c.Purchases.Count() &gt;= 2);var result = query.Select (c =&gt; c.Name);foreach (string name in result) // Only now is the query executed! Console.WriteLine (name); 5 Because SQL emits flat result sets, LINQ queries must be structured to emit flat result sets, too.For example, if you want to retrieve the names of customers in the state of WA along with all their purchases, you can simply do the following:1234567from c in db.Customerswhere c.State == \"WA\"select new&#123; c.Name, c.Purchases // An EntitySet (collection)&#125; The hierarchical result from this query is much easier to work with than a flat result set! We can achieve the same result without association properties as follows:1234567from c in db.Customerswhere c.State == \"WA\"select new&#123; c.Name, Purchases = db.Purchases.Where (p =&gt; p.CustomerID == c.ID)&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"LINQ","slug":"LINQ","permalink":"https://luox78.github.io/tags/LINQ/"}]},{"title":"C#6 特性","slug":"CS6","date":"2017-12-26T12:27:56.003Z","updated":"2018-01-01T11:37:40.958Z","comments":true,"path":"2017/12/26/CS6/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS6/","excerpt":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符","text":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符 空操作符 ( ?. )123456if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0) &#123; Console.WriteLine(user.Project.Tasks.First().Name); &#125; //现在Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 注意： 上面的代码虽然可以让我们少些很多代码，而且也减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常，那么使用这个特性反而隐藏了Bug NameOf利用nameof减少手写带来的错误 12345Person p;if(p == null)&#123; throw new Exception(\"nameof(Person)\"); &#125; 表达式方法体1private static string SayHello() =&gt; \"Hello World\"; 自动属性初始化器1234567891011121314151617181920//以前public class Person &#123; public int Age &#123; get; set; &#125; public Person() &#123; Age = 100; &#125; &#125; //现在public class Person &#123; public int Age &#123; get; private set; &#125; &#125; //同时增加了只读属性初始化public class Person &#123; public int Age &#123; get; &#125; = 100; &#125; Index 初始化器1234567var names = new Dictionary&lt;int, string&gt; &#123; [1] = \"Jack\", [2] = \"Alex\", [3] = \"Eric\", [4] = \"Jo\" &#125;; using 静态类的方法可以使用 static using123456789101112using System; using static System.Math; namespace CSharp6NewFeatures &#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(Log10(5)+PI); &#125; &#125; &#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"C#7 特性","slug":"CS7","date":"2017-12-25T16:01:58.230Z","updated":"2018-01-11T12:38:20.180Z","comments":true,"path":"2017/12/26/CS7/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS7/","excerpt":"作者：Mads Torgersen译者：Vicey Wang 这是一篇描述上周四作为 Visual Studio 2017 的一部分所发行的 C# 7.0 中的新语言特性的文章。","text":"作者：Mads Torgersen译者：Vicey Wang 这是一篇描述上周四作为 Visual Studio 2017 的一部分所发行的 C# 7.0 中的新语言特性的文章。 C# 7.0 新增了许多新功能并引入了对数据消费、代码简化和性能的关注。也许最重要的新特性是使返回多个结果更加方便的元组（tuples），和可以用来简化由数据形状而决定的代码的模式匹配（pattern matching）。但是还有许多大大小小的新功能。我们希望它们能够组合起来以使你的代码更加有效率和干净，并使你更开心，富有生产力。 如果你对这些特性的设计流程感兴趣的话，你可以在 C# 语言设计 Github 站点 找到设计笔记、建议和大量的讨论。 如果感觉这篇文章似曾相识，那可能是由于去年八月发行的一个预备版本而造成的。在 C# 7.0 的最终版本中，少部分细节被修改了，其中一些是为了响应帖子中精彩的反馈而修改的。 好好享受 C# 7.0，好好享受 hacking 吧！ Mads Torgersen, C# 语言团队 PM Out 变量（Out variables)在之前的 C# 版本中，使用 out 参数并不像我们期盼的那样流畅。在你能够使用 out 参数来调用一个函数之前，你首先需要声明待传入的变量。同时由于你一般不会初始化这些变量（它们毕竟会被这些方法覆写），你也无法使用 var 来声明它们，而是需要指定完整的类型： 123456public void PrintCoordinates(Point p)&#123; int x, y; // 需要“预声明” p.GetCoordinates(out x, out y); WriteLine($\"(&#123;x&#125;, &#123;y&#125;)\");&#125; 在 C# 7.0 中我们添加了 out 变量；使你能够在传入一个 out 参数的地方声明一个变量： 12345public void PrintCoordinates(Point p)&#123; p.GetCoordinates(out int x, out int y); WriteLine($\"(&#123;x&#125;, &#123;y&#125;)\");&#125; 请注意，这些变量位于包含它们的代码块的作用域，因此之后的代码可以使用它们。许多种类的语句不会建立它们自己的代码块，因此在这些语句中声明的 out 变量通常被引入到（这个）封闭作用域中。 由于 out 变量直接以 out 参数的形式声明，编译器通常可以分辨它们的类型应该是什么（除非有冲突的重载），所以完全可以用 var 替代类型来声明它们： 1p.GetCoordinates(out var x, out var y); Out 参数的一个常见使用场景是会返回一个指示是否成功的 Try… 模式，然后 out 参数来携带获得的结果： 12345public void PrintStars(string s)&#123; if (int.TryParse(s, out var i)) &#123; WriteLine(new string('*', i)); &#125; else &#123; WriteLine(\"Cloudy - no stars tonight!\"); &#125;&#125; 我们也允许以 _（下划线）形式“舍弃” out 参数，来使你忽略你不关心的参数： 1p.GetCoordinates(out var x, out _); // 我只关心 x 模式匹配（Pattern matching）C# 7.0 引入了模式匹配的概念，一种从抽象的角度来说，指可以测试一个值是否有某种特定的“形状”、并在满足这一条件的时候从值中提取信息的句法元素。 C# 7.0 中的模式的例子有： c（c 为 C# 中的一个常量表达式）形式的常量模式（Constant pattern），来测试输入是否等于 c T x（T 为一个类型，x 为一个标识符）形式的类型模式（Type pattern），来测试输入是否有类型 T，并在满足条件的时候将值提取成全新的 T 类型的变量 x var x（x 为一个标识符）形式的变量匹配（Var patterns），这种匹配总是能够成功，并会将输入的值简单的放入一个全新的与输入类型相同的变量 x 中。 这只是个开始——模式现在是 C# 中的一种新的语言元素了，我们也希望在未来能向 C# 中加入更多的模式。 在 C# 7.0 中我们用模式改进了两个已有的语言结构： is 表达式的右边现在可以是表达式，而不仅仅是类型了 switch 语句中的 case 子句现在可以匹配模式，而不仅仅是常量了 在未来的 C# 版本中我们会添加更多可以使用模式的地方。 具有模式的 Is 表达式这里有一个用常量模式和类型模式来使用 is 表达式的例子： 123456public void PrintStars(object o)&#123; if (o is null)return; // 常量模式 “null” if (!(o is int i)) return; // 类型模式 “int i” WriteLine(new string('*', i));&#125; 如你所见，模式变量（**pattern variables）——通过模式引入的变量——和之前描述过的 out 变量很像，都可以在表达式中声明，也可以在最近的作用域中使用。和 out 变量一样，模式变量也是可以修改的。我们经常以“表达式变量”来统称 out 变量和模式变量。 模式和 Try 模式通常可以被很好地组合使用： 1if (o is int i || (o is string s &amp;&amp; int.TryParse(s, out i)) &#123; /* 使用 i */ &#125; 具有模式的 Switch 语句我们正在使 switch 语句一般化，因此： 你可以筛选任意类型（不仅仅是原生类型） 模式可以被用在 case 子句中 Case 子句可以有额外的限制条件 这是个简单的例子： 1234567891011121314151617switch(shape)&#123; case Circle c: WriteLine($\"circle with radius &#123;c.Radius&#125;\"); break; case Rectangle s when (s.Length == s.Height): WriteLine($\"&#123;s.Length&#125; x &#123;s.Height&#125; square\"); break; case Rectangle r: WriteLine($\"&#123;r.Length&#125; x &#123;r.Height&#125; rectangle\"); break; default: WriteLine(\"&lt;unknown shape&gt;\"); break; case null: throw new ArgumentNullException(nameof(shape));&#125; 关于这个新扩展的 switch 语句有一些需要注意的事项： 现在 case 子句的顺序变得重要了：就如 catch 子句一样，case 子句不再一定不相交，第一个匹配的项将被选择。因此将正方形的情况（见上图例）放在矩形之前很重要。同样，编译器会帮你标出永远无法到达的分支。在此之前你无法指定计算顺序，因此这不会造成（旧代码）行为的大变化。 default 子句将总是在最后被计算： 即使 null 的情况被放在最后，它仍会在 default 子句被选中之前被检查。这是为了与现存的语义兼容。然而，良好的习惯通常会将 default 子句放在最后。 在最后的 null 子句不会无法到达： 这是因为类型模式（的行为）以目前的 is 表达式为例子，且不会与 null 匹配。这保证了 null 值不会意外地被类型模式抢先匹配；你需要更加明确如何处理它们（或是将它们留给 default 子句）。 由 case …: 标签引入的模式变量只在当前的 switch 节有效。 元组（Tuples）我们经常希望能从一个方法中返回一个以上的结果。旧版本的 C# 中的选项远远达不到令人满意的程度： Out 参数： 使用起来很笨拙（哪怕你使用了上面所述的改进），并且无法在 async 方法中使用。 System.Tuple&lt;…&gt; 返回类型： 用起来很啰嗦，并且需要分配一个元组对象。 自定义每个方法的传输类型： 需要用一大堆代码来实现一个类，而目的仅仅是临时打包几个变量。 通过动态类型返回匿名类： 性能有瓶颈，且没有静态类型检查。 为了在这方面做得更好，C# 7.0 加入了元组类型（tuple types）和元组字面量（tuple literals）： 12345(string, string, string) LookupName(long id) // 元组返回类型&#123; ... // 从数据储存中取出第一个、中间和最后一个数据 return (first, middle, last); // 元组字面量&#125; 这种方法现在会很有效率地返回三个字符串，包装成一个元组值中的元素。 方法的调用者将会收到一个元组，并可以分别访问各个元素： 12var names = LookupName(id);WriteLine($\"found &#123;names.Item1&#125; &#123;names.Item3&#125;.\"); Item1 等是元组元素的默认名称，并且总是可用的。但是这样描述性不是非常好，因此你可以选择性地使用另一种更好的方法： 1(string first, string middle, string last) LookupName(long id) // 元组元素拥有了名称 现在元组的接收者可以使用更具描述性的名字了： 12var names = LookupName(id);WriteLine($\"found &#123;names.first&#125; &#123;names.last&#125;.\"); 你也可以直接在元组字面量中指定元素名称： 1return (first: first, middle: middle, last: last); // 在字面量中命名元组元素 通常来说你可以无视名字而将元组类型互相转换：只要每个元素之间是可转换的（assignable），元组类型即可自由地互相转换。 元组是值类型，它们的元素是简单的公共、可修改的字段。它们具有值相等性，意味着如果两个元组间每个元素两两相等（且拥有相同的哈希值）则两个元组相等（且拥有相同的哈希值）。 这使得元组在多返回值之外的许多场景也很有用。例如，如果你需要一个拥有多个键的字典，使用一个元组作为你的键，一切都会正常运行。如果你需要一个每个位置有多个值的列表，使用元组吧，诸如搜索列表这样的功能将会正确的工作。 元组依赖于一族被称为 ValueTuple&lt;…&gt; 的底层泛型结构类型。如果你指向了一个还未包含这些类型的框架，你可以从 Nuget 中获得它们： 在解决方案管理器中右击项目并选中“管理 NuGet 程序包” 选择“浏览”标签并将“nuget.org”选为“程序包源” 搜索“System.ValueTuple”并安装它。 解构（Deconstruction）另一个使用元组的方法是去解构它们。一个解构声明（deconstructing declaration**）是一种用来将一个元组（或其他值类型)分成许多部分并将这些部分分别转换为全新的变量的语法： 12(string first, string middle, string last) = LookupName(id1); // 解构声明WriteLine($\"found &#123;first&#125; &#123;last&#125;.\"); 在一个解构声明中，你可以为独立的变量声明使用 var： 1(var first, var middle, var last) = LookupName(id1); // 在内部使用 var 甚至把一个单独的 var 放在括号外作为缩写： 1var (first, middle, last) = LookupName(id1); // 在外部使用 var 你也可以通过 解构分配（deconstructing assignment）将其解构到已存在的变量上： 1(first, middle, last) = LookupName(id2); // 解构分配 解构不仅仅适用于元组。任何类型都可以被解构，只要它拥有一个如下形式的（实例或扩展）解构方法（deconstructor method）： 1public void Deconstruct(out T1 x1, ..., out Tn xn) &#123; ... &#125; Out 参数构成解构的结果。 （为什么它使用 out 参数而不是返回一个元组？那是因为这样一来你可以对不同的值的数量拥有不同的重载了）。 1234567891011class Point&#123; public int X &#123; get; &#125; public int Y &#123; get; &#125; public Point(int x, int y) &#123; X = x; Y = y; &#125; public void Deconstruct(out int x, out int y) &#123; x = X; y = Y; &#125;&#125;(var myX, var myY) = GetPoint(); // 调用 Deconstruct(out myX, out myY); 它将成为一种常见的模式，通过以这种方式“对称地”拥有构造器和解构器。 如同 out 变量，我们允许在解构中“舍弃”你不关心的部分： 1(var myX, _) = GetPoint(); // 我只关心 myX 本地方法（Local functions）有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 本地函数（local function）： 123456789101112public int Fibonacci(int x)&#123; if (x &lt; 0) throw new ArgumentException(\"Less negativity please!\", nameof(x)); return Fib(x).current; (int current, int previous) Fib(int i) &#123; if (i == 0) return (1, 0); var (p, pp) = Fib(i - 1); return (p + pp, p); &#125;&#125; 作用域内的参数和本地变量都在本地方法中可用，就如同在 lambda 表达式中一样。 例如，被实现为迭代器的方法通常需要一个非迭代的包装函数以在调用时检查参数。（迭代器本身在 MoveNext 被调用之前不会开始）。本地方法完美的适用于这种场景： 123456789101112131415public IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; filter)&#123; if (source == null) throw new ArgumentNullException(nameof(source)); if (filter == null) throw new ArgumentNullException(nameof(filter)); return Iterator(); IEnumerable&lt;T&gt; Iterator() &#123; foreach (var element in source) &#123; if (filter(element)) &#123; yield return element; &#125; &#125; &#125;&#125; 如果 Iterator 是 Filter 旁的私有函数，它可能会被其他成员意外地直接使用（而没有参数检查）。同时，它还需要接收与 Filter 相同的参数，而不是直接在作用域中使用它们。 字面量改进C# 7.0 允许 _（下划线）在数字字面量中作为数字分隔符 （digit separator）： 12var d = 123_456;var x = 0xAB_CD_EF; 你可以将它们放置在任意位置来增强可读性。它们不会影响值。 同时，C# 7.0 引入了二进制字面量（binary literals），这样你可以直接指定位模板而不用将十六进制记号牢记于心。 1var b = 0b1010_1011_1100_1101_1110_1111; 引用返回和引用本地变量（Ref returns and locals）就像你可以在 C# 中以引用方式传值（使用 ref 修饰符）一样，你现在可以以引用方式返回值，并将它们以引用的方式存在本地变量中。 12345678910111213141516public ref int Find(int number, int[] numbers)&#123; for (int i = 0; i &lt; numbers.Length; i++) &#123; if (numbers[i] == number) &#123; return ref numbers[i]; // 返回储存的位置，而不是值 &#125; &#125; throw new IndexOutOfRangeException($\"&#123;nameof(number)&#125; not found\");&#125;int[] array = &#123; 1, 15, -39, 0, 7, 14, -12 &#125;;ref int place = ref Find(7, array); // 为 7 在数列中的位置起个别名place = 9; // 在数列中以 9 替换 7WriteLine(array[4]); // 输出 9 这对向很大的数据结构中传递占位符来说非常有用。例如，一个游戏可能将它的数据存在一个庞大的预先分配好的结构体数组（以避免垃圾回收的停顿）中。现在方法可以返回直接指向这种解构的引用，调用者可以借此来读或者修改数据。 为了确保这样做是安全的，有一些限制： 你只能返回“可以安全返回”的引用：一种是传给你的，另一种是指向对象中的字段的。 引用本地变量被初始化到一个确定的储存位置，且不可被修改为指向另一个（引用变量）。 更加一般化的 Async 返回类型在此之前，C# 中的 async 方法只能返回 void，Task 或是 Task 中的一个。C# 7.0 允许用这样的方式定义其他的类型以使它们可以从被 async 方法所返回。 例如，我们现在有一个 ValueTask 结构类型。它被用来防止 async 操作的结果在仍在 await 的时候就可用的情况下的 Task 对象的创建。对大多数 async 场景，例如使用到缓存，这可以大幅减少内存分配并可以获得巨大的性能提升。 你可以想象得到，有许多种能使这种“类 Task”类型非常有用的方法。正确的创建它们可能不是那么直观，因此我们并不期待大多数人来造自己的轮子，但是它们将会出现在框架和 API 中，然后调用者们就可以像今天使用 Task 一样地返回并 await 它们了。 更多的表达式体成员（Expression bodied members）表达式体方法，属性等是 C# 6.0 中的一大亮点，但我们并未所有成员上启用它。C# 7.0 在可以拥有表达式体的列表中添加了访问器、构造器和析构器： 12345678910111213class Person&#123; private static ConcurrentDictionary&lt;int, string&gt; names = new ConcurrentDictionary&lt;int, string&gt;(); private int id = GetId(); public Person(string name) =&gt; names.TryAdd(id, name); // 构造器 ~Person() =&gt; names.TryRemove(id, out *); // 析构器 public string Name &#123; get =&gt; names[id]; // get 访问器 set =&gt; names[id] = value; // set 访问器 &#125;&#125; 这是由社区贡献的特性的一个例子，而不是微软 C# 编译器团队（贡献的）。对，开源！ 抛出表达式（Throw expressions）在表达式中抛出异常非常简单：只要调用一个为你做这件事的方法！但是在 C# 7.0 中我们直接允许将 throw 在特定位置作为一个表达式： 1234567891011class Person&#123; public string Name &#123; get; &#125; public Person(string name) =&gt; Name = name ?? throw new ArgumentNullException(nameof(name)); public string GetFirstName() &#123; var parts = Name.Split(\" \"); return (parts.Length &gt; 0) ? parts[0] : throw new InvalidOperationException(\"No name!\"); &#125; public string GetLastName() =&gt; throw new NotImplementedException();&#125; （全文完）","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-25T13:51:57.623Z","updated":"2017-12-27T15:14:33.446Z","comments":true,"path":"2017/12/25/hello-world/","link":"","permalink":"https://luox78.github.io/2017/12/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}