{"meta":{"title":"luox78","subtitle":"Daily Learning","description":"Blog for luox78","author":"luox78","url":"https://luox78.github.io"},"pages":[],"posts":[{"title":"Entity Framework02-code first修改模型，迁移数据库","slug":"Entity Framework Code First to a Update model and migrate","date":"2018-01-18T14:24:01.824Z","updated":"2018-01-19T15:39:15.091Z","comments":true,"path":"2018/01/18/Entity Framework Code First to a Update model and migrate/","link":"","permalink":"https://luox78.github.io/2018/01/18/Entity Framework Code First to a Update model and migrate/","excerpt":"本文以asp.net mvc自己提供的身份验证为例 添加属性在Models\\IdentityModels.cs 里 ApplicationUser类下添加你想添加的属性，比如生日 1public DateTime BirthDate &#123; get; set; &#125;","text":"本文以asp.net mvc自己提供的身份验证为例 添加属性在Models\\IdentityModels.cs 里 ApplicationUser类下添加你想添加的属性，比如生日 1public DateTime BirthDate &#123; get; set; &#125; 使用Migrations修改数据库 由于已经改变了model的属性所以应该修改之前的数据库 前往工具/NUGET/程序包管理器控制台 输入Enable-Migrations初始化迁移 Add-Migration &quot;Birthdate&quot; 添加名为Birthdate的迁移文件进你的工程 Update-Database执行你的迁移文件更新数据库 修改你的view对应的model在 Models\\AccountViewModels.cs中找到RegisterViewModel类添加属性，当然也可以添加你想要的特性 1public DateTime BirthDate &#123; get; set; &#125; 修改对应的view展示12345&lt;div class=\"input-field col s12 m3 l3\"&gt; &lt;i class=\"material-icons prefix\"&gt;date_range&lt;/i&gt; @Html.LabelFor(m =&gt; m.BirthDate) @Html.TextBoxFor(m =&gt; m.BirthDate, new &#123; @class = \"datepicker\" &#125;)&lt;/div&gt; 运行就能看到修改后的结果了 如何展示新的信息 得到 UserId, 可以通过 ASP.NET Identity system 1var currentUserId = User.Identity.GetUserId(); 实例化UserManager在ASP.Identity system命名空间下 1var manager = new UserManager&lt;MyUser&gt;(new UserStore&lt;MyUser&gt;(new MyDbContext())); 得到当前用户实例 1var currentUser = manager.FindById(User.Identity.GetUserId()); 通过实例展现修改的信息 1var birthdate = currentUser.BirthDate 自己创建新的model，展示想显示的信息123456789101112131415161718public class MyUser : IdentityUser &#123; public virtual MyUserInfo MyUserInfo &#123; get; set; &#125; &#125; public class MyUserInfo&#123; public int Id &#123; get; set; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; &#125; public class MyDbContext : IdentityDbContext&lt;MyUser&gt; &#123; public MyDbContext() : base(\"DefaultConnection\") &#123; &#125; public System.Data.Entity.DbSet&lt;MyUserInfo&gt; MyUserInfo &#123; get; set; &#125; &#125; Getting Profile information When the User Logs in, you can display the profile information by doing the following Get the current logged in UserId, so you can look the user up in ASP.NET Identity system var currentUserId = User.Identity.GetUserId(); Instantiate the UserManager in ASP.Identity system so you can look up the user in the system var manager = new UserManager(new UserStore(new MyDbContext())); Get the User object var currentUser = manager.FindById(User.Identity.GetUserId()); Get the profile information about the user currentUser.MyUserInfo.FirstName","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://luox78.github.io/tags/Entity-Framework/"}]},{"title":"初始JQuery03","slug":"JQuery03","date":"2018-01-17T11:49:11.642Z","updated":"2018-01-17T16:30:46.518Z","comments":true,"path":"2018/01/17/JQuery03/","link":"","permalink":"https://luox78.github.io/2018/01/17/JQuery03/","excerpt":"","text":"RadioButton|checkbox123&lt;input id=\"Radio2\" checked=\"checked\" name=\"gender\" type=\"radio\" value=\"男\" /&gt;男&lt;input id=\"Radio1\" checked=\"checked\" name=\"gender\" type=\"radio\" value=\"女\" /&gt;女&lt;input id=\"Radio3\"checked=\"checked\" name=\"gender\" type=\"radio\" value=\"未知\" /&gt;未知 如何取选中的值 1$(\"input[name=gender]:checked\").val() 设置RadioButton的选中值 1.attr(‘checked’,true); $(&quot;input[name=gender]&quot;).val([&quot;女&quot;]);也可以直接设置，注意val中参数的[]不能省略,val()的参数必须是一个数组。 RadioButton的选择技巧对于CheckBox和Select列表框也适用 12$(‘#selOne’).val([‘1’,’2’,’3’]);//同时设置多个下拉菜单选中$(\"#btn1\").attr(\"checked\",true) 实现全选部不选 123456$(\"#btn1\").click(function () &#123; $(\"input:checkbox\").prop(\"checked\",true); &#125;); $(\"#btn2\").click(function () &#123; $(\"input:checkbox\").prop(&#123; checked: false &#125;); &#125;);","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://luox78.github.io/categories/JQuery/"}],"tags":[{"name":"jQueryfoundation","slug":"jQueryfoundation","permalink":"https://luox78.github.io/tags/jQueryfoundation/"},{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"Entity Framework01-code first建立一个新数据库","slug":"Entity Framework Code First to a New Database","date":"2018-01-16T12:24:50.695Z","updated":"2018-01-16T12:42:21.729Z","comments":true,"path":"2018/01/16/Entity Framework Code First to a New Database/","link":"","permalink":"https://luox78.github.io/2018/01/16/Entity Framework Code First to a New Database/","excerpt":"建立model编写.net class建立model","text":"建立model编写.net class建立model 1234567891011121314151617public class Blog &#123; public int BlogId &#123; get; set; &#125; public string Name &#123; get; set; &#125; public virtual List&lt;Post&gt; Posts &#123; get; set; &#125; &#125; public class Post &#123; public int PostId &#123; get; set; &#125; public string Title &#123; get; set; &#125; public string Content &#123; get; set; &#125; public int BlogId &#123; get; set; &#125; public virtual Blog Blog &#123; get; set; &#125; &#125; 类中带id的会自动标志成主键 两个导航属性 (Blog.Posts and Post.Blog) virtual，这是entity framework懒加载（ Lazy Loading ）的特征，懒加载值得是这些属性内容会自动从数据库中加载出来 建立上下文（Context）添加引用 1using System.Data.Entity; 建立数据库上下文，继承自DbContext 12345public class BloggingContext : DbContext&#123; public DbSet&lt;Blog&gt; Blogs &#123; get; set; &#125; public DbSet&lt;Post&gt; Posts &#123; get; set; &#125;&#125; DbSet代表数据库中的表，上下文中存储就是关系表 读取 存入数据存入 1234var tmpBlog = new Blog() &#123; Name = \"luox78's blog\" &#125;;var db = new BloggingContext();db.Blogs.Add(tmpBlog);db.SaveChanges(); 读取 123456var obj = db.Blogs.Where(blog =&gt; blog.BlogId == 1);foreach (var blog in obj)&#123; Console.WriteLine(blog.Name);&#125;//luox78's blog 数据在哪儿？ Visual Studio 2010数据库一般建在 local SQL Express Visual Studio 2012以上一般在 LocalDb.aspx) 数据库命名是项目名加上建立的上下文名字 执行完写入之后数据已经进入数据库 接下来我会分别介绍各个部分 原文：Entity Framework Code First to a New Database.aspx) 翻译：luox78","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://luox78.github.io/tags/Entity-Framework/"}]},{"title":"初始JQuery02","slug":"JQuery02","date":"2018-01-15T11:48:34.839Z","updated":"2018-01-15T15:20:34.568Z","comments":true,"path":"2018/01/15/JQuery02/","link":"","permalink":"https://luox78.github.io/2018/01/15/JQuery02/","excerpt":"selector相对定位不仅可以使用选择器进行进行绝对定位，还可以进行相对定位，只要在$()指定第二个参数，第二个参数为相对的元素. 1234//$(this) 代表tr，在tr下面找td$(\"tr\").click(function() &#123; $(\"td:even\", $(this)).css(\"backgroundColor\", \"red\"); &#125;);","text":"selector相对定位不仅可以使用选择器进行进行绝对定位，还可以进行相对定位，只要在$()指定第二个参数，第二个参数为相对的元素. 1234//$(this) 代表tr，在tr下面找td$(\"tr\").click(function() &#123; $(\"td:even\", $(this)).css(\"backgroundColor\", \"red\"); &#125;); 属性过滤选择器 $(&quot;div[id]&quot;)选取有id属性的&lt;div&gt; $(&quot;div[title=test]&quot;)选取title属性为“test”的&lt;div&gt;，jQuery中没有对getElementsByName进行封装，用$(&quot;input[name=abc]&quot;) $(&quot;div[title!=test]&quot;)选取title属性不为“test”的&lt;div&gt; 还可以选择开头[name^=值]、结束[] name$=值]、包含[ name*=值]等，条件还可以复合。【[属性1=a][属性2=b]…】 表单对象属性选择器（过滤器） $(&quot;#form1:enabled&quot;)选取id为form1的表单内所有启用的元素 $(&quot;#form1:disabled&quot;)选取id为form1的表单内所有禁用的元素 $(“input:checked”)选取所有选中的元素（Radio、CheckBox）,这个中间不能加空格. $(&quot;select:selected&quot;)选取所有选中的选项元素（下拉列表） 注意：$(&#39;&#39;:input&quot;)选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;和&lt;button&gt;元素。和$(&quot;input&quot;)不一样， $(&quot;input&quot;)只获得&lt;input&gt; $(&quot;:text&quot;)选取所有单行文本框，等价于$(&quot;input[type=text]&quot;),$(‘input[type=text]’),$(‘:text’); 同理还有:radio、:checkbox、:submit、:image、:reset、:button、:file、:hidden。 jQuery的Dom操作 使用html()方法读取或者设置元素的innerHTML 使用text()方法读取或者设置元素的innerText： 使用attr()方法读取或者设置元素的属性，对于jQuery没有封装的属性（所有浏览器没有差异的属性）用attr进行操作。 1234//获取alert($(\"a:first\").attr(\"href\"));//设置$(\"a:first\").attr(\"href\", \"http://www.luox78.com\"); 使用removeAttr删除属性。删除的属性在源代码中看不到，这是和清空属性的区别。attr(‘name’,’’) 动态创建Dom节点先创建jquery dom对象var obj=$(&quot;&lt;div style=&quot;background-color:blue;&quot; /&gt;&quot;); 再动态添加$(&quot;body&quot;).append(obj);或者obj.appendTo($(&quot;body&quot;)) append方法用来在元素的末尾追加元素（最后一个子节点）。增加元素末尾(儿子) prepend，在元素的开始添加元素（第一个子节点）。增加元素开始(儿子) after，在元素之后添加元素（添加兄弟）增加元素后面(兄弟) before：在元素之前添加元素（添加兄弟）增加元素前面(兄弟) 子元素.appendTo(父元素);//主动巴结!到最后一个 子元素.prependTo(父元素);//主动巴结到第一个。 (*)A.insertBefore(B);将A加到到B的前面，等同于B.before(A); (*)X.insertAfter(Y);将X加到到Y的后面，等同于Y.after(X); 删除节点empty();清空某元素下的所有子节点 remove(selector)删除当前元素，返回值为被删除的元素。还可以继续使用被删除的节点。比如重新添加到其他节点下： 12var lis = $(\"#ulSite li\").remove();$(\"#ulSite2\").append(lis); clone()克隆节点，只复制节点，没事件 节点操作 替换节点： $(&quot;br&quot;).replaceWith(&quot;&lt;hr/&gt;&quot;);用&lt;hr/&gt;替换br$(‘&lt;br/’).replaceAll(‘hr’); //调用者也得是选择器选择到 的元素。用&lt;br/&gt;元素替换所有的hr 包裹节点 wrap()方法用来将所有元素逐个用指定标签包裹：[wrapAll()]$(“b”).wrap(“&lt;font color=‘red’&gt;&lt;/font&gt;”)将所粗体字红色显示结果：&lt;font color=‘red’&gt;&lt;b&gt;&lt;/b&gt;&lt;/font&gt;wrapInner()//在内部围绕","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://luox78.github.io/categories/JQuery/"}],"tags":[{"name":"jQueryfoundation","slug":"jQueryfoundation","permalink":"https://luox78.github.io/tags/jQueryfoundation/"},{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"GET，POST，PUT，DELETE的区别","slug":"get_post","date":"2018-01-15T11:46:57.475Z","updated":"2018-01-15T11:52:23.430Z","comments":true,"path":"2018/01/15/get_post/","link":"","permalink":"https://luox78.github.io/2018/01/15/get_post/","excerpt":"Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。","text":"Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。到这里，大家应该有个大概的了解了，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 (1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 注意：这里安全的含义仅仅是指是非修改信息。 (2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念： 幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。 幂等有一下几种定义： 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a) = abs(abs(a))。 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。 看完上述解释后，应该可以理解GET幂等的含义了。 但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。 2.根据HTTP规范，POST表示可能修改变服务器上的资源的请求。继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。 上面大概说了一下HTTP规范中GET和POST的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说： 1.很多人贪方便，更新资源时用了GET，因为用POST必须要到FORM（表单），这样会麻烦一点。 2.对资源的增，删，改，查操作，其实都可以通过GET/POST完成，不需要用到PUT和DELETE。 3.另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的Web MVC框架基本上都只支持GET和POST两种HTTP方法，而不支持PUT和DELETE方法。 简单解释一下MVC：MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。 以上3点典型地描述了老一套的风格（没有严格遵守HTTP规范），随着架构的发展，现在出现REST(Representational State Transfer)，一套支持HTTP规范的新风格，这里不多说了，可以参考《RESTful Web Services》。 说完原理性的问题，我们再从表面现像上面看看GET和POST的区别： 1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST把提交的数据则放置在是HTTP包的包体中。 2.”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！ 以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的： (1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5] (2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。 对于ASP程序，Request对象处理每个表单域时存在100K的数据长度限制。但如果使用Request.BinaryRead则没有这个限制。 由这个延伸出去，对于IIS 6.0，微软出于安全考虑，加大了限制。我们还需要注意： 1).IIS 6.0默认ASP POST数据量最大为200KB，每个表单域限制是100KB。 2).IIS 6.0默认上传文件的最大大小是4MB。 3).IIS 6.0默认最大请求头是16KB。 IIS 6.0之前没有这些限制。[见参考资料5] 所以上面的80K，100K可能只是默认值而已(注：关于IIS4和IIS5的参数，我还没有确认)，但肯定是可以自己设置的。由于每个版本的IIS对这些参数的默认值都不一样，具体请参考相关的IIS配置文档。 3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\\”XXXX\\”)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&amp;password=hyddd，用request.getQueryString()得到的是：name=hyddd&amp;password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。 4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。 总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！ 纯属hyddd个人总结，如有错漏请指出。:&gt; 参考资料： [1].http://hi.baidu.com/liuzd003/blog/item/7bfecbfa6ea94ed8b58f318c.html [2].http://www.blogjava.net/onlykeke/archive/2006/08/23/65285.aspx [3].http://baike.baidu.com/view/2067025.htm [4].http://www.chxwei.com/article.asp?id=373 [5].http://blog.csdn.net/somat/archive/2004/10/29/158707.aspx 转载请说明出处，谢谢[hyddd(http://www.cnblogs.com/hyddd/)]","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"request","slug":"request","permalink":"https://luox78.github.io/tags/request/"}]},{"title":"Swagger - 前后端分离后的契约","slug":"swagger","date":"2018-01-15T11:39:51.811Z","updated":"2018-01-15T11:52:05.404Z","comments":true,"path":"2018/01/15/swagger/","link":"","permalink":"https://luox78.github.io/2018/01/15/swagger/","excerpt":"前后端分离按照现在的趋势，前后端分离几乎已经是业界对开发和部署方式所达成的一种共识。所谓的前后端分离，并不是传统行业中的按部门划分，一部分人只做前端（HTML/CSS/JavaScript等等），另一部分人只做后端（或者叫服务端），因为这种方式是不工作的：比如很多团队采取了后端的模板技术（JSP, FreeMarker, ERB等等），前端的开发和调试需要一个后台Web容器的支持，从而无法将前后端开发和部署做到真正的分离。","text":"前后端分离按照现在的趋势，前后端分离几乎已经是业界对开发和部署方式所达成的一种共识。所谓的前后端分离，并不是传统行业中的按部门划分，一部分人只做前端（HTML/CSS/JavaScript等等），另一部分人只做后端（或者叫服务端），因为这种方式是不工作的：比如很多团队采取了后端的模板技术（JSP, FreeMarker, ERB等等），前端的开发和调试需要一个后台Web容器的支持，从而无法将前后端开发和部署做到真正的分离。 通常，前后端分别有着自己的开发流程，构建工具，测试等。做前端的谁也不会想要用Maven或者Gradle作为构建工具，同样的道理，做后端的谁也不会想要用Grunt或者Gulp作为构建工具。前后端仅仅通过接口来协作，这个接口可能是JSON格式的RESTFul的接口，也可能是XML的，重点是后台只负责数据的提供和计算，而完全不处理展现。而前端则负责拿到数据，组织数据并展现的工作。这样结构清晰，关注点分离，前后端会变得相对独立并松耦合。但是这种想法依然还是很理想化，前后端集成往往还是一个很头痛的问题。比如在最后需要集成的时候，我们才发现最开始商量好的数据结构发生了变化，而且这种变化往往是在所难免的，这样就会增加大量的集成时间。 归根结底，还是前端或者后端感知到变化的时间周期太长，不能“及时协商，尽早解决”，最终导致集中爆发。怎么解决这个问题呢？我们需要提前协商好一些契约，并将这些契约作为可以被测试的中间产品，然后前后端都通过自动化测试来检验这些契约，一旦契约发生变化，测试就会失败。这样，每个失败的测试都会驱动双方再次协商，有效的缩短了反馈周期，并且降低集成风险。具体的实践方式，请参加我同事的一篇博文，“前后端分离了，然后呢？”http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/。 不过，仅仅靠纪律是不够的，还需要通过工具的辅助来提高效率。下面，我们就来看一下，一个API设计工具——Swagger，将如何帮助我们更好的实现“前后端分离”。 SwaggerSwagger包括库、编辑器、代码生成器等很多部分，这里我们主要讲一下Swagger Editor。这是一个完全开源的项目，并且它也是一个基于Angular的成功案例，我们可以下载源码并自己部署它，也可以修改它或集成到我们自己的软件中。 在Swagger Editor中，我们可以基于YAML语法定义我们的RESTful API，然后它会自动生成一篇排版优美的API文档，并且提供实时预览。相信大多数朋友都遇到过这样一个场景：明明调用的是之前约定好的API，拿到的结果却不是想要的。可能因为是有人修改了API的接口，却忘了更新文档；或者是文档更新的不及时；又或者是文档写的有歧义，大家的理解各不相同。总之，让API文档总是与API定义同步更新，是一件非常有价值的事。下面我们通过一个例子来感受一下Swagger给我们带来的好处。 首先我们需要安装一个Swagger Editor，或者也可以直接使用在线版本http://editor.swagger.io/。如果需要在本地启动编辑器，执行以下三行命令即可（前提是已经安装好了Node.js）： 123git clone https://github.com/swagger-api/swagger-editor.gitcd swagger-editornpm start 当我们修改了API的定义之后，在编辑器右侧就可以看到相应的API文档了，而且永远是最新的。 不仅如此，它还能够自动生成Mock server所需要的代码，这样一来前端开发就再也不用等着后端API 的实现了。除此之外，它还有一个更强大的功能，甚至能够帮助我们自动生成不同语言的客户端的代码。Swagger是基于插件来实现各种不同的语言的，所以，如果已经提供的语言中没有你正在用的，你也可以自己实现相应的插件，甚至是从源代码级别进行定制化。 契约测试谈到了前后端分离，那么在所难免，会遇到一些集成的问题：一拨人在全心全意的进行前端开发，另一拨人在心无旁骛的做后端开发，那么谁应该为集成买单呢？在现在这个持续集成、持续交付的年代里，我们应该如何去保证双方不会分道扬镳、越走越远呢？ 所以，在一开始就定一个契约就成了迫在眉睫的事情，双方就API相关的内容，包括路径、参数、类型等达成一致，当然，这份契约并不是一旦创建就不能修改的，而且，如果一开始没有设计好，很有可能会频繁的修改。这个时候，要让双方都能够实时的跟踪最新的API就成了一个难题。还好，在总结了前人的经验和教训之后，我们早已有了应对之策，那就是契约测试。 老马（Martin Fowler）早在2011年的时候就发表了一篇博客http://martinfowler.com/bliki/IntegrationContractTest.html，专门讨论了如何做契约测试。 首先，我们先假设我们已经有了一份契约，可能是基于JSON格式的，有可能是基于XML格式的，这都不重要。然后，前端会根据这份契约建立一个Mock server，所有的测试都发往这个Mock server。有两方面的原因：一是这个时候可能后台的API还没有开发完成；二是有可能因为网络等其他方面的原因导致直接调用真实的后台API会很不稳定或者很耗时。到这里，可能有人就要说了，如果后台的API实现和之前约定的并不一样，怎么能保证到了集成的时候双方还能很顺利的集成呢？其实这个问题并不难，只需要让前端的测试定期连接真实的API执行一遍就能尽早的发现差异性。比方说，在我们平常的build pipeline上添加一个job，让这些测试每天在午夜里连着真实的API执行。如果，第二天发现这些测试有的失败了，那么就需要和开发后台API的人员进行一次沟通了，很有可能由于真实的业务逻辑发生了变化，API在实现的时候，已经和之前的契约不一致了，如果是这样，那么相应的测试和契约定义就需要更新以满足最新的业务需求。 总之，进行契约测试的目的就是尽早的发现差异性，并作出调整，将最后集成的风险降到最低。 原文 http://www.cnblogs.com/whitewolf/","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"https://luox78.github.io/tags/swagger/"}]},{"title":"初始JQuery01","slug":"JQuery01","date":"2018-01-14T07:30:29.287Z","updated":"2018-01-14T14:00:04.329Z","comments":true,"path":"2018/01/14/JQuery01/","link":"","permalink":"https://luox78.github.io/2018/01/14/JQuery01/","excerpt":"常见的JavaScript框架库为什么使用JavaScript框架库？ 普通JavaScript的缺点：每种控件的操作方式不统一，不同浏览器下有区别，要编写跨浏览器的程序非常麻烦。因此出现了很多对JavaScript的封装库","text":"常见的JavaScript框架库为什么使用JavaScript框架库？ 普通JavaScript的缺点：每种控件的操作方式不统一，不同浏览器下有区别，要编写跨浏览器的程序非常麻烦。因此出现了很多对JavaScript的封装库 jQuery: jQuery就是JavaScript语法写的一些函数类，内部仍然是调用JavaScript实现的，所以并不是代替JavaScript的。使用jQuery的代码、编写jQuery的扩展插件等仍然需要JavaScript的技术，jQuery本身就是一堆JavaScript函数。 jQuery是最火的JavaScript库，已经被集成到VS2010了，得到了MS的支持，MS的Ajax toolkit和jQuery结合也是最方便，jQuery的扩展插件也是非常多 jQuery简介什么是jQuery？ jQuery就是一个JavaScript函数库 jQuery能做什么？jQuery是做什么的？ jQuery本身就是一堆JavaScript函数，JavaScript是做什么的，jQuery也一样。毕竟jQuery只是用JavaScript编写的函数库而已，有些功能jQuery没有封装，则还需要通过自己写JavaScript来实现。 jQuery中的顶级对象$$jQuery中最常用的对象即对象，要想使用jQuery的方法必须通过对象。只有将普通的Dom对象封装成jQuery对象，然后才能调用jQuery中的各种方法。 $是jQuery简写，在代码中可以使用jQuery代替，但一般为了方便大家都直接使用。 jquery里面的几个函数 $.map(array,callback(element,index));element 为元素 ，index 为遍历的索引 一个数组中的元素转换到另一个数组中。 作为参数的转换函数会为每个数组元素调用，而且会给这个转换函数传递一个表示被转换的元素作为参数。转换函数可以返回转换后的值、null（删除数组中的项目）或一个包含值的数组，并扩展至原始数组中。 1234567891011 var arr = [1, 2, 3, 4, 5, 6]; $.map(arr, function() &#123; console.log(arguments[0] * 2); &#125;); var data = &#123; \"luox78\": \"shuai\", \"age\": 18 &#125;; $.map(data, function () &#123; console.log(arguments[0]); &#125;); return false 演示 1234567$.map(arr, function() &#123; if (arguments[1] &gt; 3) return false; console.log(arguments[0]); &#125;); //1, 2, 3, 4 each(callback) 以每一个匹配的元素作为上下文来执行一个函数。 意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。返回 ‘false’ 将停止循环 (就像在普通的循环中使用 ‘break’)。返回 ‘true’ 跳至下一个循环(就像在普通的循环中使用’continue’)。 HTML 代码: 1&lt;img/&gt;&lt;img/&gt; jQuery 代码: 123$(\"img\").each(function(i)&#123; this.src = \"test\" + i + \".jpg\"; &#125;); jQuery.each(object, [callback]) 123$.each( [0,1,2], function(i, n)&#123; alert( \"Item #\" + i + \": \" + n );&#125;); jQuery.trim(str) 去掉字符串起始和结尾的空格。 jQuery 代码: 1$.trim(\" hello, how are you? \"); 结果: 1\"hello, how are you?\" JQuery选择器js dom 转换成JQuery对象 12var div = document.getElementById(\"div\");$(div).css(\"backgroundColor\", \"black\"); JQuery转换成dom对象 1$(div).get[0];//$(div)[0]; 问题 Array（数组）对象有没有对应的jQuery对象？ 数组本身就不是Dom对象。不存在与jQuery对象之间的转换。使用jQuery语句可以直接使用数组，就像jquery.each()或jquery.map() 链式编程什么是 链式编程 1$(\"#btn\").click(function()).css(XXX).text(); 说明 Jquery对象中的方法，一般带参数的返回jquery对象本身，不带参数的返回要的值，使用带参数的方法就实现了所谓的 链式编程，注意：返回的jquery对象有可能是一个集合 selector常见的 12345$('#id')、Id选择器$('span')、标签选择器$('.cls')，类选择器$('*[name=gender]')或$('[name=gender]')，属性过滤选择器：$('div.cls') 标签类选择器 多条件选择器 1$(“p,div,span.menuitem”)，同时选择p标签、div标签和拥有menuitem样式的span标签元素 层次选择器 后代，$(“div li”)获取div下的所有li元素（后代，子、子的子……） 子元素，$(“div &gt; li”)获取div下的直接li子元素 【必须是直接子元素】 相邻元素1：jquery(“.menuitem + div”)获取样式名为menuitem之后的相邻的（紧接着的）第一个div元素（不常用）等同于jquery(‘.menuitem’).next(‘div’);如果相邻的那个元素不是div,则不会继续向后找。 相邻元素2：jquery(“.menuitem ~ div”)获取样式名为menuitem之后所有的兄弟div元素，等同于jquery(‘. menuitem ’).nextAll(‘div’)。【nextAll(‘*’)或nextAll()表示后面的所有元素。】 获得兄弟元素的几个方法 next();//当前元素之后的紧邻着的第一个兄弟元素（下一个） nextAll();//当前元素之后的所有兄弟元素 prev();//当前元素之前的紧邻着的兄弟元素（上一个） prevAll();//当前元素之前的所有兄弟元素 siblings();//当前元素的所有兄弟元素 html 1234&lt;div&gt; &lt;input type=\"button\" value=\"使第一个层变色\" id=\"btn1\" /&gt; &lt;input type=\"button\" value=\"使第三个层变色\" id=\"btn2\" /&gt; &lt;/div&gt; js 123$(\"#btn1\").click(function() &#123; $(\"#div\").prev().css('backgroundColor', \"red\"); &#125;); 注意方法括号中可以加筛选的表达式，限制查找的元素 12345678910HTML 代码:&lt;div&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt;&lt;p class=\"selected\"&gt;Hello Again&lt;/p&gt;&lt;p&gt;And Again&lt;/p&gt;jQuery 代码:$(\"p\").prev(\".selected\")结果:[ &lt;p class=\"selected\"&gt;Hello Again&lt;/p&gt; ] 基本过滤选择器:first选取第一个元素。$(“div:first”)选取第一个&lt;div&gt; :last选取最后一个元素。$(“div:last”)选取最后一个&lt;div&gt; :not(选择器) 选取不满足“选择器”条件的元素，$(“input:not(.myClass)”)选取样式名不是myClass的&lt;input&gt; :even、:odd，选取索引是偶数、奇数的元素：$(“input:even”)选取索引是奇数的&lt;input&gt; :eq(索引序号)、gt(索引序号)、:lt(索引序号) 选取索引等于、大于、小于索引序号的元素，比如$(“input:lt(5)”)选取索引小于5的&lt;input&gt; $(“:header”)选取所有的h1……h6元素（*） $(“div:animated”)选取正在执行动画的&lt;div&gt;元素。 （*） 12//大于索引2的又小于后面索引2的,每次筛选都是上次筛选,即每次筛选后索引都清零$('div:gt(2):lt(2)').css('backgroundColor', 'yellow'); 一些问题如何判断对象是否存在 jQuery选择器返回的是一个对象数组，调用text()、html()、click()之类方法的时候其实是对数组中每个元素迭代调用每个方法，因此即使通过id选择的元素不存在也不会报错，如果需要判断指定的id是否存在，应该写 123if ($(\"#btn1\").length &lt;= 0) &#123; alert(\"id为btn1的元素不存在！\"); &#125; 样式操作addClass(class|fn) 概述 为每个匹配的元素添加指定的类名。 参数 class StringV1.0 一个或多个要添加到元素中的CSS类名，请用空格分开 function(index, class) FunctionV1.4 此函数必须返回一个或多个空格分隔的class名。接受两个参数，index参数为对象在这个集合中的索引值，class参数为这个对象原先的class属性值。 示例 参数class 描述: 为匹配的元素加上 ‘selected’ 类 jQuery 代码: 12$(\"p\").addClass(\"selected\");$(\"p\").addClass(\"selected1 selected2\"); removeClass([class|fn]) 概述 从所有匹配的元素中删除全部或者指定的类。 参数 classStringV1.0 一个或多个要删除的CSS类名，请用空格分开 function(index, class)FunctionV1.4 此函数必须返回一个或多个空格分隔的class名。接受两个参数，index参数为对象在这个集合中的索引值，class参数为这个对象原先的class属性值。 示例 参数class 描述: 从匹配的元素中删除 ‘selected’ 类 jQuery 代码: 1$(\"p\").removeClass(\"selected\"); 参数class 描述: 删除匹配元素的所有类 jQuery 代码: 1$(\"p\").removeClass(); 回调函数描述: 删除最后一个元素上与前面重复的class jQuery 代码: 123$('li:last').removeClass(function() &#123; return $(this).prev().attr('class');&#125;); toggleClass (class|fn[,sw]) 概述 如果存在（不存在）就删除（添加）一个类。 参数 classStringV1.0 CSS类名 class,switchString,BooleanV1.3 1:要切换的CSS类名. 2:用于决定元素是否包含class的布尔值。 switchBooleanV1.4 用于决定元素是否包含class的布尔值。 function(index, class,switch)[, switch]Function,BooleanV1.4 1:用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数。 2: 一个用来判断样式类添加还是移除的 boolean 值。 示例 参数class 描述: 为匹配的元素切换 ‘selected’ 类 jQuery 代码: 1$(\"p\").toggleClass(\"selected\"); 参数class,switch 描述: 每点击三下加上一次 ‘highlight’ 类 HTML 代码: 1&lt;strong&gt;jQuery 代码:&lt;/strong&gt; jQuery 代码: 1234var count = 0;$(\"p\").click(function()&#123; $(this).toggleClass(\"highlight\", count++ % 3 == 0);&#125;); 回调函数 描述: 根据父元素来设置class属性 jQuery 代码: 1234567$('div.foo').toggleClass(function() &#123; if ($(this).parent().is('.bar') &#123; return 'happy'; &#125; else &#123; return 'sad'; &#125;&#125;); hasClass(class) 概述 检查当前的元素是否含有某个特定的类，如果有，则返回true。 这其实就是 is(“.” + class)。 参数 classStringV1.2 用于匹配的类名","categories":[{"name":"JQuery","slug":"JQuery","permalink":"https://luox78.github.io/categories/JQuery/"}],"tags":[{"name":"jQueryfoundation","slug":"jQueryfoundation","permalink":"https://luox78.github.io/tags/jQueryfoundation/"},{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"初识JavaScript06","slug":"JavaScript06","date":"2018-01-13T11:39:26.030Z","updated":"2018-01-13T14:09:01.936Z","comments":true,"path":"2018/01/13/JavaScript06/","link":"","permalink":"https://luox78.github.io/2018/01/13/JavaScript06/","excerpt":"一些问题 window.event.keyCode实现对键盘的获取 回车的keyCode为13，Tab的keyCode为9,只有少数的键才能被替换，大部分是不行的，有权限问题 checkbox &lt;input type=&quot;checkbox&quot; id=&quot;check&quot;/&gt;&lt;label for=&quot;check&quot;&gt;11111&lt;/label&gt;让标签指向checkbox，","text":"一些问题 window.event.keyCode实现对键盘的获取 回车的keyCode为13，Tab的keyCode为9,只有少数的键才能被替换，大部分是不行的，有权限问题 checkbox &lt;input type=&quot;checkbox&quot; id=&quot;check&quot;/&gt;&lt;label for=&quot;check&quot;&gt;11111&lt;/label&gt;让标签指向checkbox， checkbox属性checked=“checked”|true为选中，=false为未选中,=false只在js中使用 JS中操作select 清空options 12while (document.getElementById(\"shi\").firstChild) &#123; document.getElementById(\"shi\").removeChild(document.getElementById(\"shi\").firstChild); &#125; 根据数据添加 12345for (var key in datas) &#123; var opt = document.createElement(\"option\"); opt.innerText = key; document.getElementById(\"shen\").appendChild(opt); &#125; 如何获取选择项 1var shis = datas[this[this.selectedIndex].text];//this指select对象 ​","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"Newtonsoft.Json介绍","slug":"Newtonsoft_Json","date":"2018-01-12T15:43:30.908Z","updated":"2018-01-12T16:31:33.467Z","comments":true,"path":"2018/01/12/Newtonsoft_Json/","link":"","permalink":"https://luox78.github.io/2018/01/12/Newtonsoft_Json/","excerpt":"在做开发的时候，很多数据交换都是以json格式传输的。而使用Json的时候，我们很多时候会涉及到几个序列化对象的使用：DataContractJsonSerializer,JavaScriptSerializer","text":"在做开发的时候，很多数据交换都是以json格式传输的。而使用Json的时候，我们很多时候会涉及到几个序列化对象的使用：DataContractJsonSerializer,JavaScriptSerializer 和 Json.NET即Newtonsoft.Json。大多数人都会选择性能以及通用性较好Json.NET，这个不是微软的类库，但是一个开源的世界级的Json操作类库，从下面的性能对比就可以看到它的其中之一的性能优点。 齐全的API介绍，使用方式简单 常见用法JsonConvert Json.Net是支持序列化和反序列化DataTable,DataSet,Entity Framework和Entity的。下面分别举例说明序列化和反序列化。 DataTable： 12345678910111213141516//序列化DataTableDataTable dt = new DataTable();dt.Columns.Add(\"Age\", Type.GetType(\"System.Int32\"));dt.Columns.Add(\"Name\", Type.GetType(\"System.String\"));dt.Columns.Add(\"Sex\", Type.GetType(\"System.String\"));dt.Columns.Add(\"IsMarry\", Type.GetType(\"System.Boolean\"));for (int i = 0; i &lt; 4; i++)&#123; DataRow dr = dt.NewRow(); dr[\"Age\"] = i + 1; dr[\"Name\"] = \"Name\" + i; dr[\"Sex\"] = i % 2 == 0 ? \"男\" : \"女\"; dr[\"IsMarry\"] = i % 2 &gt; 0 ? true : false; dt.Rows.Add(dr);&#125;Console.WriteLine(JsonConvert.SerializeObject(dt)); 利用上面字符串进行反序列化 123456string json = JsonConvert.SerializeObject(dt);dt=JsonConvert.DeserializeObject&lt;DataTable&gt;(json);foreach (DataRow dr in dt.Rows)&#123; Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\\t&#123;3&#125;\\t\", dr[0], dr[1], dr[2], dr[3]);&#125; Entity序列化和DataTable一样，就不过多介绍了。 JsonSerializer12345678910111213Product product = new Product();product.ExpiryDate = new DateTime(2008, 12, 28);JsonSerializer serializer = new JsonSerializer();serializer.Converters.Add(new JavaScriptDateTimeConverter());serializer.NullValueHandling = NullValueHandling.Ignore;using (StreamWriter sw = new StreamWriter(@\"c:\\json.txt\"))using (JsonWriter writer = new JsonTextWriter(sw))&#123; serializer.Serialize(writer, product); // &#123;\"ExpiryDate\":new Date(1230375600000),\"Price\":0&#125;&#125; LINQ to JSON1234567891011121314151617JObject o = JObject.Parse(@\"&#123; 'CPU': 'Intel', 'Drives': [ 'DVD read/writer', '500 gigabyte hard drive' ]&#125;\");string cpu = (string)o[\"CPU\"];// Intelstring firstDrive = (string)o[\"Drives\"][0];// DVD read/writerIList&lt;string&gt; allDrives = o[\"Drives\"].Select(t =&gt; (string)t).ToList();// DVD read/writer// 500 gigabyte hard drive Parsing JSON textParsing a JSON Object from text 123456789string json = @\"&#123; CPU: 'Intel', Drives: [ 'DVD read/writer', '500 gigabyte hard drive' ]&#125;\";JObject o = JObject.Parse(json); Parsing a JSON Array from text 1234567string json = @\"[ 'Small', 'Medium', 'Large']\";JArray a = JArray.Parse(json); Loading JSON from a fileReading JSON from a file 12345using (StreamReader reader = File.OpenText(@\"c:\\person.json\"))&#123; JObject o = (JObject)JToken.ReadFrom(new JsonTextReader(reader)); // do stuff&#125; Querying JSON with LINQ123456789101112131415161718192021222324252627282930313233343536373839404142string json = @\"&#123; 'channel': &#123; 'title': 'James Newton-King', 'link': 'http://james.newtonking.com', 'description': 'James Newton-King\\'s blog.', 'item': [ &#123; 'title': 'Json.NET 1.3 + New license + Now on CodePlex', 'description': 'Annoucing the release of Json.NET 1.3, the MIT license and the source on CodePlex', 'link': 'http://james.newtonking.com/projects/json-net.aspx', 'categories': [ 'Json.NET', 'CodePlex' ] &#125;, &#123; 'title': 'LINQ to JSON beta', 'description': 'Annoucing LINQ to JSON', 'link': 'http://james.newtonking.com/projects/json-net.aspx', 'categories': [ 'Json.NET', 'LINQ' ] &#125; ] &#125; &#125;\"; JObject rss = JObject.Parse(json); string rssTitle = (string)rss[\"channel\"][\"title\"]; // James Newton-King string itemTitle = (string)rss[\"channel\"][\"item\"][0][\"title\"]; // Json.NET 1.3 + New license + Now on CodePlex JArray categories = (JArray)rss[\"channel\"][\"item\"][0][\"categories\"]; // [\"Json.NET\", \"CodePlex\"] IList&lt;string&gt; categoriesText = categories.Select(c =&gt; (string)c).ToList(); // Json.NET // CodePlex Convert JSON to XML1XNode node = JsonConvert.DeserializeXNode(json, \"Root\"); Convert XML to JSON1234567891011121314151617181920212223242526272829303132333435363738 1string xml = @\"&lt;?xml version='1.0' standalone='no'?&gt; 2&lt;root&gt; 3 &lt;person id='1'&gt; 4 &lt;name&gt;Alan&lt;/name&gt; 5 &lt;url&gt;http://www.google.com&lt;/url&gt; 6 &lt;/person&gt; 7 &lt;person id='2'&gt; 8 &lt;name&gt;Louis&lt;/name&gt; 9 &lt;url&gt;http://www.yahoo.com&lt;/url&gt;10 &lt;/person&gt;11&lt;/root&gt;\";1213XmlDocument doc = new XmlDocument();14doc.LoadXml(xml);1516string json = JsonConvert.SerializeXmlNode(doc);1718Console.WriteLine(json);19// &#123;20// \"?xml\": &#123;21// \"@version\": \"1.0\",22// \"@standalone\": \"no\"23// &#125;,24// \"root\": &#123;25// \"person\": [26// &#123;27// \"@id\": \"1\",28// \"name\": \"Alan\",29// \"url\": \"http://www.google.com\"30// &#125;,31// &#123;32// \"@id\": \"2\",33// \"name\": \"Louis\",34// \"url\": \"http://www.yahoo.com\"35// &#125;36// ]37// &#125;38// &#125; Convert XML to JSON and force array12345678910111213141516171819202122232425262728293031323334353637383940414243 1string xml = @\"&lt;person id='1'&gt; 2 &lt;name&gt;Alan&lt;/name&gt; 3 &lt;url&gt;http://www.google.com&lt;/url&gt; 4 &lt;role&gt;Admin1&lt;/role&gt; 5&lt;/person&gt;\"; 6 7XmlDocument doc = new XmlDocument(); 8doc.LoadXml(xml); 910string json = JsonConvert.SerializeXmlNode(doc);1112Console.WriteLine(json);13// &#123;14// \"person\": &#123;15// \"@id\": \"1\",16// \"name\": \"Alan\",17// \"url\": \"http://www.google.com\",18// \"role\": \"Admin1\"19// &#125;20// &#125;2122xml = @\"&lt;person xmlns:json='http://james.newtonking.com/projects/json' id='1'&gt;23 &lt;name&gt;Alan&lt;/name&gt;24 &lt;url&gt;http://www.google.com&lt;/url&gt;25 &lt;role json:Array='true'&gt;Admin&lt;/role&gt;26&lt;/person&gt;\";2728doc = new XmlDocument();29doc.LoadXml(xml);3031json = JsonConvert.SerializeXmlNode(doc);3233Console.WriteLine(json);34// &#123;35// \"person\": &#123;36// \"@id\": \"1\",37// \"name\": \"Alan\",38// \"url\": \"http://www.google.com\",39// \"role\": [40// \"Admin\"41// ]42// &#125;43// &#125; 类转换用法​ 1.忽略某些属性 ​ 2.默认值的处理 ​ 3.空值的处理 ​ 4.支持非公共成员 ​ 5.日期处理 ​ 6.自定义序列化的字段名称 7.动态决定属性是否序列化 ​ 8.枚举值的自定义格式化问题 9.自定义类型转换 10.全局序列化设置 一.忽略某些属性 类似本问开头介绍的接口优化，实体中有些属性不需要序列化返回，可以使用该特性。首先介绍Json.Net序列化的模式:OptOut 和 OptIn options 说明 OptIn 默认情况下,所有的成员不会被序列化,类中的成员只有标有特性JsonProperty的才会被序列化,当类的成员很多,但客户端仅仅需要一部分数据时,很有用 OptOut 默认值,类中所有公有成员会被序列化,如果不想被序列化,可以用特性JsonIgnore 仅需要姓名属性 1234567891011121314[JsonObject(MemberSerialization.OptIn)]public class Person&#123; public int Age &#123; get; set; &#125; [JsonProperty] public string Name &#123; get; set; &#125; public string Sex &#123; get; set; &#125; public bool IsMarry &#123; get; set; &#125; public DateTime Birthday &#123; get; set; &#125;&#125; 不需要是否结婚属性 1234567891011121314[JsonObject(MemberSerialization.OptOut)]public class Person&#123; public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Sex &#123; get; set; &#125; [JsonIgnore] public bool IsMarry &#123; get; set; &#125; public DateTime Birthday &#123; get; set; &#125;&#125; 通过上面的例子可以看到，要实现不返回某些属性的需求很简单。1.在实体类上加上[JsonObject(MemberSerialization.OptOut)] 2.在不需要返回的属性上加上 [JsonIgnore]说明。 二.默认值处理​ 序列化时想忽略默认值属性可以通过JsonSerializerSettings.DefaultValueHandling来确定，该值为枚举值 DefaultValueHandling.Ignore 序列化和反序列化时,忽略默认值 DefaultValueHandling.Include 序列化和反序列化时,包含默认值 12[DefaultValue(10)]public int Age &#123; get; set; &#125; 1234Person p = new Person &#123; Age = 10, Name = \"张三丰\", Sex = \"男\", IsMarry = false, Birthday = new DateTime(1991, 1, 2) &#125;;JsonSerializerSettings jsetting=new JsonSerializerSettings();jsetting.DefaultValueHandling=DefaultValueHandling.Ignore;Console.WriteLine(JsonConvert.SerializeObject(p, Formatting.Indented, jsetting)); 最终结果如下： 三.空值的处理序列化时需要忽略值为NULL的属性，可以通过JsonSerializerSettings.NullValueHandling来确定，另外通过JsonSerializerSettings设置属性是对序列化过程中所有属性生效的，想单独对某一个属性生效可以使用JsonProperty，下面将分别展示两个方式 1.JsonSerializerSettings 1234Person p = new Person &#123; room=null,Age = 10, Name = \"张三丰\", Sex = \"男\", IsMarry = false, Birthday = new DateTime(1991, 1, 2) &#125;;JsonSerializerSettings jsetting=new JsonSerializerSettings();jsetting.NullValueHandling = NullValueHandling.Ignore;Console.WriteLine(JsonConvert.SerializeObject(p, Formatting.Indented, jsetting)); 2.JsonProperty 通过JsonProperty属性设置的方法，可以实现某一属性特别处理的需求，如默认值处理，空值处理，自定义属性名处理，格式化处理。上面空值处理实现 12[JsonProperty(NullValueHandling=NullValueHandling.Ignore)]public Room room &#123; get; set; &#125; 四.支持非公共成员 序列化时默认都是处理公共成员，如果需要处理非公共成员，就要在该成员上加特性”JsonProperty” 12[JsonProperty]private int Height &#123; get; set; &#125; 五.日期处理 对于Dateime类型日期的格式化就比较麻烦了，系统自带的会格式化成iso日期标准，但是实际使用过程中大多数使用的可能是yyyy-MM-dd 或者yyyy-MM-dd HH:mm:ss两种格式的日期，解决办法是可以将DateTime类型改成string类型自己格式化好，然后在序列化。如果不想修改代码，可以采用下面方案实现。 ​ Json.Net提供了IsoDateTimeConverter日期转换这个类，可以通过JsnConverter实现相应的日期转换 12[JsonConverter(typeof(IsoDateTimeConverter))]public DateTime Birthday &#123; get; set; &#125; 但是IsoDateTimeConverter日期格式不是我们想要的，我们可以继承该类实现自己的日期 1234567891011121314public class ChinaDateTimeConverter : DateTimeConverterBase&#123; private static IsoDateTimeConverter dtConverter = new IsoDateTimeConverter &#123; DateTimeFormat = \"yyyy-MM-dd\" &#125;; public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) &#123; return dtConverter.ReadJson(reader, objectType, existingValue, serializer); &#125; public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) &#123; dtConverter.WriteJson(writer, value, serializer); &#125;&#125; ​ 自己实现了一个yyyy-MM-dd格式化转换类，可以看到只是初始化IsoDateTimeConverter时给的日期格式为yyyy-MM-dd即可，下面看下效果 12[JsonConverter(typeof(ChinaDateTimeConverter))]public DateTime Birthday &#123; get; set; &#125; 可以根据自己需求实现不同的转换类 六.自定义序列化的字段名称 实体中定义的属性名可能不是自己想要的名称，但是又不能更改实体定义，这个时候可以自定义序列化字段名称。 12[JsonProperty(PropertyName = \"CName\")]public string Name &#123; get; set; &#125; 七.动态决定属性是否序列化 这个是为了实现@米粒儿提的需求特别增加的，根据某些场景，可能A场景输出A，B，C三个属性，B场景输出E，F属性。虽然实际中不一定存在这种需求，但是json.net依然可以支持该特性。 继承默认的DefaultContractResolver类，传入需要输出的属性 ​ 重写修改了一下，大多数情况下应该是要排除的字段少于要保留的字段, 为了方便书写这里修改了构造函数加入retain表示props是需要保留的字段还是要排除的字段 12345678910111213141516171819202122232425262728293031323334353637public class LimitPropsContractResolver : DefaultContractResolver &#123; string[] props = null; bool retain; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=\"props\"&gt;传入的属性数组&lt;/param&gt; /// &lt;param name=\"retain\"&gt;true:表示props是需要保留的字段 false：表示props是要排除的字段&lt;/param&gt; public LimitPropsContractResolver(string[] props, bool retain=true) &#123; //指定要序列化属性的清单 this.props = props; this.retain = retain; &#125; protected override IList&lt;JsonProperty&gt; CreateProperties(Type type, MemberSerialization memberSerialization) &#123; IList&lt;JsonProperty&gt; list = base.CreateProperties(type, memberSerialization); //只保留清单有列出的属性 return list.Where(p =&gt; &#123; if (retain) &#123; return props.Contains(p.PropertyName); &#125; else &#123; return !props.Contains(p.PropertyName); &#125; &#125;).ToList(); &#125; 123456public int Age &#123; get; set; &#125;[JsonIgnore]public bool IsMarry &#123; get; set; &#125;public string Sex &#123; get; set; &#125; 123JsonSerializerSettings jsetting=new JsonSerializerSettings();jsetting.ContractResolver = new LimitPropsContractResolver(new string[] &#123; \"Age\", \"IsMarry\" &#125;);Console.WriteLine(JsonConvert.SerializeObject(p, Formatting.Indented, jsetting)); 使用自定义的解析类，只输出”Age”, “IsMarry”两个属性，看下最终结果.只输出了Age属性，为什么IsMarry属性没有输出呢，因为标注了JsonIgnore 看到上面的结果想要实现pc端序列化一部分，手机端序列化另一部分就很简单了吧，我们改下代码实现一下 1234567891011string[] propNames = null;if (p.Age &gt; 10)&#123; propNames = new string[] &#123; \"Age\", \"IsMarry\" &#125;;&#125;else&#123; propNames = new string[] &#123; \"Age\", \"Sex\" &#125;;&#125;jsetting.ContractResolver = new LimitPropsContractResolver(propNames);Console.WriteLine(JsonConvert.SerializeObject(p, Formatting.Indented, jsetting)); 八.枚举值的自定义格式化问题 默认情况下对于实体里面的枚举类型系统是格式化成改枚举对应的整型数值,那如果需要格式化成枚举对应的字符怎么处理呢？Newtonsoft.Json也帮我们想到了这点，下面看实例 123456789101112131415161718192021public enum NotifyType&#123; /// &lt;summary&gt; /// Emil发送 /// &lt;/summary&gt; Mail=0, /// &lt;summary&gt; /// 短信发送 /// &lt;/summary&gt; SMS=1&#125;public class TestEnmu&#123; /// &lt;summary&gt; /// 消息发送类型 /// &lt;/summary&gt; public NotifyType Type &#123; get; set; &#125;&#125;JsonConvert.SerializeObject(new TestEnmu()); 输出结果： 现在改造一下，输出”Type”:”Mail” 12345678public class TestEnmu&#123; /// &lt;summary&gt; /// 消息发送类型 /// &lt;/summary&gt; [JsonConverter(typeof(StringEnumConverter))] public NotifyType Type &#123; get; set; &#125;&#125; 其它的都不变，在Type属性上加上了JsonConverter(typeof(StringEnumConverter))表示将枚举值转换成对应的字符串,而StringEnumConverter是Newtonsoft.Json内置的转换类型,最终输出结果 九.自定义类型转换默认情况下对于实体里面的Boolean系统是格式化成true或者false,对于true转成”是” false转成”否”这种需求改怎么实现了？我们可以自定义类型转换实现该需求，下面看实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class BoolConvert : JsonConverter &#123; private string[] arrBString &#123; get; set; &#125; public BoolConvert() &#123; arrBString = \"是,否\".Split(','); &#125; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; /// &lt;param name=\"BooleanString\"&gt;将bool值转换成的字符串值&lt;/param&gt; public BoolConvert(string BooleanString) &#123; if (string.IsNullOrEmpty(BooleanString)) &#123; throw new ArgumentNullException(); &#125; arrBString = BooleanString.Split(','); if (arrBString.Length != 2) &#123; throw new ArgumentException(\"BooleanString格式不符合规定\"); &#125; &#125; public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) &#123; bool isNullable = IsNullableType(objectType); Type t = isNullable ? Nullable.GetUnderlyingType(objectType) : objectType; if (reader.TokenType == JsonToken.Null) &#123; if (!IsNullableType(objectType)) &#123; throw new Exception(string.Format(\"不能转换null value to &#123;0&#125;.\", objectType)); &#125; return null; &#125; try &#123; if (reader.TokenType == JsonToken.String) &#123; string boolText = reader.Value.ToString(); if (boolText.Equals(arrBString[0], StringComparison.OrdinalIgnoreCase)) &#123; return true; &#125; else if (boolText.Equals(arrBString[1], StringComparison.OrdinalIgnoreCase)) &#123; return false; &#125; &#125; if (reader.TokenType == JsonToken.Integer) &#123; //数值 return Convert.ToInt32(reader.Value) == 1; &#125; &#125; catch (Exception ex) &#123; throw new Exception(string.Format(\"Error converting value &#123;0&#125; to type '&#123;1&#125;'\", reader.Value, objectType)); &#125; throw new Exception(string.Format(\"Unexpected token &#123;0&#125; when parsing enum\", reader.TokenType)); &#125; /// &lt;summary&gt; /// 判断是否为Bool类型 /// &lt;/summary&gt; /// &lt;param name=\"objectType\"&gt;类型&lt;/param&gt; /// &lt;returns&gt;为bool类型则可以进行转换&lt;/returns&gt; public override bool CanConvert(Type objectType) &#123; return true; &#125; public bool IsNullableType(Type t) &#123; if (t == null) &#123; throw new ArgumentNullException(\"t\"); &#125; return (t.BaseType.FullName==\"System.ValueType\" &amp;&amp; t.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;)); &#125; public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) &#123; if (value == null) &#123; writer.WriteNull(); return; &#125; bool bValue = (bool)value; if (bValue) &#123; writer.WriteValue(arrBString[0]); &#125; else &#123; writer.WriteValue(arrBString[1]); &#125; &#125; &#125; 自定义了BoolConvert类型，继承自JsonConverter。构造函数参数BooleanString可以让我们自定义将true false转换成相应字符串。下面看实体里面怎么使用这个自定义转换类型 12345public class Person&#123; [JsonConverter(typeof(BoolConvert))] public bool IsMarry &#123; get; set; &#125;&#125; ‘ 相应的有什么个性化的转换需求，都可以使用自定义转换类型的方式实现。 十.全局序列化设置文章开头提出了Null值字段怎么不返回的问题，相应的在高级用法也给出了相应的解决方案使用jsetting.NullValueHandling = NullValueHandling.Ignore; 来设置不返回空值。这样有个麻烦的地方，每个不想返回空值的序列化都需设置一下。可以对序列化设置一些默认值方式么？下面将解答 123456789101112131415 Newtonsoft.Json.JsonSerializerSettings setting = new Newtonsoft.Json.JsonSerializerSettings();JsonConvert.DefaultSettings = new Func&lt;JsonSerializerSettings&gt;(() =&gt;&#123; //日期类型默认格式化处理 setting.DateFormatHandling = Newtonsoft.Json.DateFormatHandling.MicrosoftDateFormat; setting.DateFormatString = \"yyyy-MM-dd HH:mm:ss\"; //空值处理 setting.NullValueHandling = NullValueHandling.Ignore; //高级用法九中的Bool类型转换 设置 setting.Converters.Add(new BoolConvert(\"是,否\")); return setting;&#125;); 这样设置以后，以后使用序列化的地方就不需要单独设置了，个人最喜欢设置的是空值处理这一块。 本文来源https://www.cnblogs.com/yanweidie/p/4605212.html https://www.newtonsoft.com/json/help/html/Introduction.htm","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://luox78.github.io/tags/Json/"}]},{"title":"C#路径","slug":"CS_path","date":"2018-01-11T14:11:08.831Z","updated":"2018-01-11T15:04:34.328Z","comments":true,"path":"2018/01/11/CS_path/","link":"","permalink":"https://luox78.github.io/2018/01/11/CS_path/","excerpt":"获取当前文件的路径string str1=Process.GetCurrentProcess().MainModule.FileName;//可获得当前执行的exe的文件名。string str2=Environment.CurrentDirectory;//获取和设置当前目录（即该进程从中启动的目录）的完全限定路径。","text":"获取当前文件的路径string str1=Process.GetCurrentProcess().MainModule.FileName;//可获得当前执行的exe的文件名。string str2=Environment.CurrentDirectory;//获取和设置当前目录（即该进程从中启动的目录）的完全限定路径。(备注:按照定义，如果该进程在本地或网络驱动器的根目录中启动，则此属性的值为驱动器名称后跟一个尾部反斜杠（如“C:\\”）。如果该进程在子目录中启动，则此属性的值为不带尾部反斜杠的驱动器和子目录路径[如“C:\\mySubDirectory”])。string str3=Directory.GetCurrentDirectory(); //获取应用程序的当前工作目录。string str4=AppDomain.CurrentDomain.BaseDirectory;//获取基目录，它由程序集冲突解决程序用来探测程序集。string str5=Application.StartupPath;//获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。string str6=Application.ExecutablePath;//获取启动了应用程序的可执行文件的路径，包括可执行文件的名称。string str7=AppDomain.CurrentDomain.SetupInformation.ApplicationBase;//获取或设置包含该应用程序的目录的名称。 System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName获取模块的完整路径。 System.Environment.CurrentDirectory获取和设置当前目录(该进程从中启动的目录)的完全限定目录。 System.IO.Directory.GetCurrentDirectory()获取应用程序的当前工作目录。这个不一定是程序从中启动的目录啊，有可能程序放在C:\\www里,这个函数有可能返回C:\\Documents and Settings\\ZYB\\,或者C:\\Program Files\\Adobe\\,有时不一定返回什么东东，这是任何应用程序最后一次操作过的目录，比如你用Word打开了E:\\doc\\my.doc这个文件，此时执行这个方法就返回了E:\\doc了。 System.AppDomain.CurrentDomain.BaseDirectory获取程序的基目录。 System.Windows.Forms.Application.StartupPath获取启动了应用程序的可执行文件的路径。效果和2、5一样。只是5返回的字符串后面多了一个&quot;\\&quot;而已。 System.Windows.Forms.Application.ExecutablePath获取启动了应用程序的可执行文件的路径及文件名，效果和1一样。 System.AppDomain.CurrentDomain.SetupInformation.ApplicationBase获取和设置包括该应用程序的目录的名称。 操作环境变量 利用System.Environment.GetEnvironmentVariable()方法可以很方便地取得系统环境变量，如： System.Environment.GetEnvironmentVariable(&quot;windir&quot;)就可以取得windows系统目录的路径。以下是一些常用的环境变量取值： System.Environment.GetEnvironmentVariable(“windir”); System.Environment.GetEnvironmentVariable(“INCLUDE”); System.Environment.GetEnvironmentVariable(“TMP”); System.Environment.GetEnvironmentVariable(“TEMP”); System.Environment.GetEnvironmentVariable(“Path”); 获取上级目录本文实例讲述了C#的path.GetFullPath 获取上级目录实现方法，分享给大家供大家参考。具体实现方法如下： string path = new directoryinfo(&quot;../&quot;).fullname;//当前应用程序路径的上级目录 获取当前目录可以使用 appdomain.currentdomain.basedirectory 获取当前目录的上级目录 path.getfullpath(&quot;..&quot;) asp就比.net简单了，直接../就行了 如果是asp.net直接用server.mappath(&quot;~/bg/&quot;)就可以了。","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"path","slug":"path","permalink":"https://luox78.github.io/tags/path/"}]},{"title":"位操作","slug":"Bitwise_operations","date":"2018-01-09T14:30:38.481Z","updated":"2018-01-12T16:30:46.083Z","comments":true,"path":"2018/01/09/Bitwise_operations/","link":"","permalink":"https://luox78.github.io/2018/01/09/Bitwise_operations/","excerpt":"位操作 符号 名称 演示 &amp; 与 1 &amp; 1 = 11 &amp; 0 = 00 &amp; 0 = 0 ｜ 或 1｜1 = 11｜0 = 10｜0 = 0 ^ 异或 1 ^ 1 = 01 ^ 0 = 10 ^ 0 = 0 ~ 非 ~1 = 0~0 = 1 &lt;&lt; 左移 10101 &lt;&lt; 2 =10100(相当于乘2) &gt;&gt; 右移 10101 &gt;&gt; 2 =00101(相当于除2)","text":"位操作 符号 名称 演示 &amp; 与 1 &amp; 1 = 11 &amp; 0 = 00 &amp; 0 = 0 ｜ 或 1｜1 = 11｜0 = 10｜0 = 0 ^ 异或 1 ^ 1 = 01 ^ 0 = 10 ^ 0 = 0 ~ 非 ~1 = 0~0 = 1 &lt;&lt; 左移 10101 &lt;&lt; 2 =10100(相当于乘2) &gt;&gt; 右移 10101 &gt;&gt; 2 =00101(相当于除2) 常见函数set_bit12345// 给position位设置为1static int set_bit(int i,int position)&#123; return i | 1 &lt;&lt; position;&#125; clear_bit12345//给position位设置为0static int clear_bit(int i,int position)&#123; return i &amp; ~(1 &lt;&lt; position);&#125; flip_bit12345 //翻转position位的值static int flip_bit(int i,int position)&#123; return i ^ (1 &lt;&lt; position);&#125; is_bit_set12345//判断position位是否为bit（1）static int is_bit_set(int i,int position)&#123; return i &gt;&gt; position &amp; 1;&#125; modify_bit(见补码)12345//state 为 1 是set_bit ；state 为 0 时clear_bit static int modify_bit(int i,int position,int state)&#123; return (i &amp; ~(1 &lt;&lt; position)) | (-state &amp; 1 &lt;&lt; position);&#125; 补码（二补数） 补码用来表示负数的 https://zh.wikipedia.org/wiki/二補數 表示 补码使用有符号第一位表示正负，1为负 0为正，所以8有符号位数范围+-127，无符号位数255-0，无符号位数在C#中UInt32代表无符号32位 十进制值 二进制（二进制补码表示） 二补（2 - n）2 0 0000 0000 0000 0000 1 0000 0001 1111 1111 2 0000 0010 1111 1110 126 0111 1110 1000 0010 127 0111 1111 1000 0001 -128 1000 0000 1000 0000 -127 1000 0001 0111 1111 -126 1000 0010 0111 1110 -2 1111 1110 0000 0010 -1 1111 1111 0000 0001 为什么使用补码 二补数系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的二补数来表示，因此只要有加法电路及二补数电路即可完成各种有号数加法及减法，在电路设计上相当方便。 如何进行表示 ​ -1 原码：0000 0001 反码：1111 1110 补码=反码+1：1111 1111 一种简易的方式，可以找出二进位数字的二补数 先由最低位元开始找。 若该位元为0，将二补数对应位元填0，继续找下一位元（较高的位元）。 若找到第一个为1的位元，将二补数对应位元填1。 将其馀未转换的位元进行位元反相，将结果填入对应的二补数。 以0011 1100为例（图中的^表示目前转换的数字，-表示还不确定的位数）： 原数字 补码 0011 1100 —- —0（此位元为0） ​ ^ 0011 1100 —- –00（此位元为0） ​ ^ 0011 1100 —- -100（找到第1个为1的位元） ​ ^ 0011 1100 1100 0100（其馀位元直接反相） ^ 因此其结果为1100 0100 一些位操作一些提示 C#中不能直接将一串二进制数赋值给int32，可以用一下转换 Convert.ToInt32(&quot;1111&quot;,2)1111的二进制，即15 int32类型 Convert.ToString(15,2)15的二进制字符串，”1111“ 是否为偶数1234static bool is_even(int i)&#123; return (i &amp; 1) == 0;&#125; 返回有多少位不同1234static int diff_bit(int a,int b)&#123; return Convert.ToString(a ^ b, 2).Where(m =&gt; m == '1').Count();&#125; 四舍五入2的幂数123456789101112static int roundUpToNextPowerOfTwo(int x)&#123; x--; x |= x &gt;&gt; 1; // handle 2 bit x |= x &gt;&gt; 2; // handle 4 bit numbers x |= x &gt;&gt; 4; // handle 8 bit numbers x |= x &gt;&gt; 8; // handle 16 bit numbers x |= x &gt;&gt; 16; // handle 32 bit numbers x++; return x;&#125; 交换两个数,效率比附tmp值低123456static void swapXor(ref int a,ref int b)&#123; a ^= b; b ^= a; a ^= b;&#125; 取绝对值12345static int myabs(int a)&#123; int bit31 = a &gt;&gt; 31; return (a ^ bit31) - bit31;&#125;","categories":[{"name":"DailyLearning","slug":"DailyLearning","permalink":"https://luox78.github.io/categories/DailyLearning/"}],"tags":[{"name":"bitwiseOperations","slug":"bitwiseOperations","permalink":"https://luox78.github.io/tags/bitwiseOperations/"}]},{"title":"初识JavaScript05","slug":"JavaScript05","date":"2018-01-06T15:22:04.269Z","updated":"2018-01-09T15:47:31.898Z","comments":true,"path":"2018/01/06/JavaScript05/","link":"","permalink":"https://luox78.github.io/2018/01/06/JavaScript05/","excerpt":"练习通过document.getElementById(&quot;XXX&quot;).style.display隐藏的是真正的使层消失 通过document.getElementById(&quot;div1&quot;).style.visibility实现的隐藏位置仍然占着，不过没有显示 以下演示了这一过程","text":"练习通过document.getElementById(&quot;XXX&quot;).style.display隐藏的是真正的使层消失 通过document.getElementById(&quot;div1&quot;).style.visibility实现的隐藏位置仍然占着，不过没有显示 以下演示了这一过程1234567891011121314151617181920212223&lt;body&gt; &lt;input id=\"btn1\" type=\"button\" value=\"hide div via display\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"hide div via visibility\" /&gt; &lt;div id=\"div1\" style=\"background-color: black;height: 200px\"&gt;&lt;/div&gt; &lt;input type=\"text\" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById(\"btn1\").onclick = function () &#123; if (document.getElementById(\"div1\").style.display !== \"none\") &#123; document.getElementById(\"div1\").style.display = \"none\"; &#125; else &#123; document.getElementById(\"div1\").style.display = \"block\"; &#125; &#125; document.getElementById(\"btn2\").onclick = function () &#123; if (document.getElementById(\"div1\").style.visibility !== \"hidden\") &#123; document.getElementById(\"div1\").style.visibility = \"hidden\"; &#125; else &#123; document.getElementById(\"div1\").style.visibility = \"visible\"; &#125; &#125;&lt;/script&gt; 动态添加层 1234567891011121314&lt;a id=\"a1\" href=\"javascript:void(0)\"&gt;luox78&lt;/a&gt; document.getElementById(\"a1\").onmouseover= function() &#123; var divObj = document.createElement(\"div\"); divObj.style.height = \"200px\"; divObj.style.backgroundColor = \"blue\"; divObj.style.positon = \"absolute\"; divObj.style.left = this.offsetLeft + 'px'; document.body.appendChild(divObj); //删除才创建的层 document.getElementById(\"a1\").onmouseleave = function() &#123; document.body.removeChild(divObj); &#125; &#125; 动态隐藏层 123456789101112131415161718192021222324252627&lt;div id=\"div1\" style=\"height: 1000px; border: black 3px solid\"&gt;？？？？？？？？？？？？、、、、、、、、、、、、、&lt;/div&gt; &lt;script&gt; var height = document.getElementById(\"div1\").style.height;//记录一开始的高度 document.getElementById(\"btn1\").onclick = function () &#123; var div = document.getElementById(\"div1\"); div.style.overflow = \"hidden\"; //点击时先判断是否隐藏 if (div.style.display === \"none\") &#123; div.style.display = \"block\"; div.style.height = height; return; &#125; var setId = window.setInterval(function () &#123; if (parseInt(div.style.height) &lt; 100) &#123; window.clearInterval(setId); //document.body.removeChild(div); div.style.display = \"none\";//隐藏 console.log(\"div has been removed\"); &#125; div.style.height = (div.offsetHeight - 100) + \"px\";//高度减100px &#125;, 100); &#125;&lt;/script&gt; 案例：图片跟着鼠标移动 12345678&lt;img id=\"img\" src=\"TIM截图20180108210345.png\"/&gt;document.onmousemove= function() &#123; var img = document.getElementById(\"img\"); img.style.position = \"absolute\"; img.style.left = window.event.clientX - img.width/2 + \"px\"; img.style.top = window.event.clientY - img.height/2 + \"px\"; &#125; 问题给标签设置属性值 label.setAttribute(&quot;属性名&quot;,&quot;属性值&quot;);设置属性值 this.getAttribute(&quot;属性名&quot;)获取属性值 123456789101112131415161718192021222324&lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt; var tds = document.getElementsByTagName(\"td\"); for (var i = 0; i &lt; tds.length; i++) &#123; tds[i].setAttribute(\"innerText\", tds[i].innerText); tds[i].onclick = function () &#123; alert(this.getAttribute(\"innerText\")); &#125; &#125;&lt;/script&gt; 显示浏览器型号 1alert(window.navigator.userAgent);//检测浏览器 文本显示 word-break: break-all;实现自动换行 overflow: hidden;超出边框隐藏 123&lt;div style=\"height: 100px; width: 100px; border: black 2px solid; word-break: break-all;overflow: hidden\"&gt;luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78luox78&lt;/div&gt; JS中的正则表达式 var reg = new RegExp(/Pattern/);先创建正则对象 reg.test(&quot;string&quot;)判断string是否满足pattern 123var reg = new RegExp(/^[0-9]&#123;3&#125;$/);console.log(reg.test(\"122\"));//trueconsole.log(reg.test(\"1221\"));//false var reg=/pattern/(/pattern/g)全局模式 var result=reg.exec(&quot;string&quot;) 12345var msg=\"cmcc 10086;union 10010\";var pattern=/\\d+/;while(var res=pattern.exec(msg))&#123; alert(res);//10086 10010&#125; match(regexp)，非全局模式下相当于调用exec(),全局模式下相当于调用c#的matches()，返回数组中是所有的匹配结果（不包含提取组的信息） 1234var s = \"aaa@163.com\";var regex = /(.+)@(.+)/;var match = s.match(regex);alert(RegExp.$1 + “，服务器：” + RegExp.$2);（$1…$9） 字符串.replace(/pattern/g,”要替换的字符串$1”); 模拟Trim()方法 12345var str = ' aaaaaaaaaaa ';alert('---' + exTrim(str) + '-----');function exTrim(s) &#123; return s.replace(/(^\\s+)|(\\s+$)/g, '');&#125; 密码强度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;body&gt; &lt;input type=\"text\" name=\"name\" value=\"\" id=\"txt\" /&gt; &lt;table border=\"1\" id=\"tb\"&gt; &lt;tr&gt; &lt;td&gt; 弱 &lt;/td&gt; &lt;td&gt; 中 &lt;/td&gt; &lt;td&gt; 强 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; document.getElementById('txt').onkeyup = function () &#123; //获取td var tds = document.getElementById('tb').getElementsByTagName('td'); for (var i = 0; i &lt; tds.length; i++) &#123; tds[i].style.backgroundColor = '#E6E6E6'; &#125; //获取密码 var pwd = this.value; if (pwd.length &gt; 0) &#123; //根据密码验证强度 var result = getPassWord(pwd); //强度设置颜色 if (result &lt;= 1) &#123; //弱 tds[0].style.backgroundColor = 'red'; &#125; else if (result == 2) &#123; //中 tds[0].style.backgroundColor = 'orange'; tds[1].style.backgroundColor = 'orange'; &#125; else if (result == 3) &#123; //强 tds[0].style.backgroundColor = 'green'; tds[1].style.backgroundColor = 'green'; tds[2].style.backgroundColor = 'green'; &#125; &#125; &#125;; &#125;; function getPassWord(pwdMsg) &#123; var lvl = 0; //密码中有数字lvl+1 if (pwdMsg.match(/\\d/)) &#123; lvl++; //这么写简单 &#125; //密码中有字母lvl+1 if (pwdMsg.match(/[a-zA-Z]/)) &#123; lvl++; &#125; //密码中有其他符号lvl+1 if (pwdMsg.match(/[^0-9a-zA-Z]/)) &#123; lvl++; &#125; //密码小于6位lvl-1 if (pwdMsg.length &lt;= 6) &#123; lvl--; &#125; return lvl; &#125;&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"05JavaScript深入之作用域链","slug":"JavaScript深入之作用域链","date":"2018-01-04T12:12:50.527Z","updated":"2018-01-04T12:47:19.899Z","comments":true,"path":"2018/01/04/JavaScript深入之作用域链/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之作用域链/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第五篇，讲述作用链的创建过程，最后结合着变量对象，执行上下文栈，让我们一起捋一捋函数创建和执行的过程中到底发生了什么？ 前言 在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲作用域链。 作用域链在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建在《JavaScript深入之词法作用域和动态作用域》中讲到，函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 举个例子： 123456 function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为： 123456789foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 12Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 捋一捋以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = \"global scope\";function checkscope()&#123; var scope2 = 'local scope'; return scope2;&#125;checkscope(); 执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = &#123; Scope: checkscope.[[scope]],&#125; 4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 12345678checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;&#125; 5.第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: [AO, [[Scope]]]&#125; 6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: 'local scope' &#125;, Scope: [AO, [[Scope]]]&#125; 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 下一篇文章《JavaScript深入之从ECMAScript规范解读this》 本文相关链接《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"03JavaScript深入之执行上下文栈","slug":"JavaScript深入之执行上下文栈","date":"2018-01-04T12:12:50.525Z","updated":"2018-01-04T12:47:14.515Z","comments":true,"path":"2018/01/04/JavaScript深入之执行上下文栈/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之执行上下文栈/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第三篇，讲解执行上下文栈的是如何执行的，也回答了第二篇中的略难的思考题。 顺序执行？","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第三篇，讲解执行上下文栈的是如何执行的，也回答了第二篇中的略难的思考题。 顺序执行？ 如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟： 123456789101112131415var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 然而去看这段代码： 12345678910111213141516function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 打印的结果却是两个 foo2。 刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 执行上下文栈接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 1ECStack = []; 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext： 123ECStack = [ globalContext]; 现在 JavaScript 遇到下面的这段代码了： 12345678910111213function fun3() &#123; console.log('fun3')&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码： 123456789101112131415161718192021// 伪代码// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中竟然调用了fun2，还要创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// 擦，fun2还调用了fun3！ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 解答思考题好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript深入之词法作用域和动态作用域》最后的问题： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 让我们模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 让我们模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。 下一篇文章《JavaScript深入之变量对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"07JavaScript深入之执行上下文","slug":"JavaScript深入之执行上下文","date":"2018-01-04T12:12:50.523Z","updated":"2018-01-04T12:47:09.114Z","comments":true,"path":"2018/01/04/JavaScript深入之执行上下文/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之执行上下文/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第七篇，结合之前所讲的四篇文章，以权威指南的demo为例，具体讲解当函数执行的时候，执行上下文栈、变量对象、作用域链是如何变化的。 前言 在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析我们分析第一段代码： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 123ECStack = [ globalContext]; 2.全局上下文初始化 12345globalContext = &#123; VO: [global, scope, checkscope], Scope: [globalContext.VO], this: globalContext.VO&#125; 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1234ECStack = [ checkscopeContext, globalContext]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 12345ECStack = [ fContext, checkscopeContext, globalContext]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1234ECStack = [ checkscopeContext, globalContext]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 123ECStack = [ globalContext]; 第二段代码就留给大家去尝试模拟它的执行过程。 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。 下一篇文章《JavaScript深入之闭包》 相关链接《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 《JavaScript深入之作用域链》 《JavaScript深入之从ECMAScript规范解读this》 重要参考《一道js面试题引发的思考》 本文写的太好，给了我很多启发。感激不尽！ 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"04JavaScript深入之变量对象","slug":"JavaScript深入之变量对象","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:23.366Z","comments":true,"path":"2018/01/04/JavaScript深入之变量对象/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之变量对象/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第四篇，具体讲解执行上下文中的变量对象与活动对象。全局上下文下的变量对象是什么？函数上下文下的活动对象是如何分析和执行的？还有两个思考题帮你加深印象，快来看看吧！ 前言","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第四篇，具体讲解执行上下文中的变量对象与活动对象。全局上下文下的变量对象是什么？函数上下文下的活动对象是如何分析和执行的？还有两个思考题帮你加深印象，快来看看吧！ 前言 在上篇《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。 全局上下文我们先了解一个概念，叫全局对象。在 W3School 中也有介绍： 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 如果看的不是很懂的话，容我再来介绍下全局对象: 1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。 1console.log(this); 2.全局对象是由 Object 构造函数实例化的一个对象。 1console.log(this instanceof Object); 3.预定义了一堆，嗯，一大堆函数和属性。 123// 都能生效console.log(Math.random());console.log(this.Math.random()); 4.作为全局变量的宿主。 12var a = 1;console.log(this.a); 5.客户端 JavaScript 中，全局对象有 window 属性指向自身。 12345var a = 1;console.log(window.a);this.window.b = 2;console.log(this.b); 花了一个大篇幅介绍全局对象，其实就想说： 全局上下文中的变量对象就是全局对象呐！ 函数上下文在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码， 变量对象会包括： 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 举个例子： 12345678910function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 在进入执行上下文后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c()&#123;&#125;, d: undefined&#125; 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 还是上面的例子，当代码执行完后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression \"d\"&#125; 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 思考题最后让我们看几个例子： 1.第一题 123456789101112function foo() &#123; console.log(a); a = 1;&#125;foo(); // ???function bar() &#123; a = 1; console.log(a);&#125;bar(); // ??? 第一段会报错：Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的 “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是： 12345AO = &#123; arguments: &#123; length: 0 &#125;&#125; 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。 2.第二题 1234567console.log(foo);function foo()&#123; console.log(\"foo\");&#125;var foo = 1; 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 下一篇文章《JavaScript深入之作用域链》 本文相关链接《JavaScript深入之执行上下文栈》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"01JavaScript深入之从原型到原型链","slug":"JavaScript深入之从原型到原型链","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:53.275Z","comments":true,"path":"2018/01/04/JavaScript深入之从原型到原型链/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之从原型到原型链/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第一篇，从原型与原型链开始讲起，如果你想知道构造函数的实例的原型，原型的原型，原型的原型的原型是什么，就来看看这篇文章吧。 构造函数创建对象 我们先使用构造函数创建一个对象： 123456function Person() &#123;&#125;var person = new Person();person.name = 'Kevin';console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = 'Kevin';var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor ，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： 1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： 12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 12345678910111213function Person() &#123;&#125;Person.prototype.name = 'Kevin';var person = new Person();person.name = 'Daisy';console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： 123var obj = new Object();obj.name = 'Kevin'console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？ null，我们可以打印： 1console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子： 12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： 1person.constructor === Person.prototype.constructor __proto__其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 下一篇文章JavaScript深入之词法作用域和动态作用域 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"08JavaScript深入之闭包","slug":"JavaScript深入之闭包","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:16.025Z","comments":true,"path":"2018/01/04/JavaScript深入之闭包/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之闭包/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第八篇，介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第八篇，介绍理论上的闭包和实践上的闭包，以及从作用域链的角度解析经典的闭包题。 定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： 1234567var a = 1;function foo() &#123; console.log(a);&#125;foo(); foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript权威指南》中就讲到：从技术的角度讲，所有的JavaScript函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动： 1234567891011var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的PHP同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125; 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function()&#123; console.log(i); &#125; &#125;)(i);&#125;data[0]();data[1]();data[2](); 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 下一篇文章JavaScript深入之参数按值传递 相关链接如果想了解执行上下文的具体变化，不妨循序渐进，阅读这六篇： 《JavaScript深入之词法作用域和动态作用域》 《JavaScript深入之执行上下文栈》 《JavaScript深入之变量对象》 《JavaScript深入之作用域链》 《JavaScript深入之从ECMAScript规范解读this》 《JavaScript深入之执行上下文》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"12JavaScript深入之new的模拟实现","slug":"JavaScript深入之new的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-08T07:04:32.670Z","comments":true,"path":"2018/01/04/JavaScript深入之new的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之new的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十二篇，通过new的模拟实现，带大家揭开使用new获得构造函数实例的真相 new","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十二篇，通过new的模拟实现，带大家揭开使用new获得构造函数实例的真相 new 一句话介绍 new: new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一 也许有点难懂，我们在模拟 new 之前，先看看 new 实现了哪些功能。 举个例子： 12345678910111213141516171819202122// Otaku 御宅族，简称宅function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;// 因为缺乏锻炼的缘故，身体强度让人担忧Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin 从这个例子中，我们可以看到，实例 person 可以： 访问到 Otaku 构造函数里的属性 访问到 Otaku.prototype 中的属性 接下来，我们可以尝试着模拟一下了。 因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的： 12345678function Otaku () &#123; ……&#125;// 使用 newvar person = new Otaku(……);// 使用 objectFactoryvar person = objectFactory(Otaku, ……) 初步实现分析： 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。 在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。 现在，我们可以尝试着写第一版了： 1234567891011121314// 第一版代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;; 在这一版中，我们： 用new Object() 的方式新建了一个对象 obj 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 返回 obj 更多关于： 原型与原型链，可以看《JavaScript深入之从原型到原型链》 apply，可以看《JavaScript深入之call和apply的模拟实现》 经典继承，可以看《JavaScript深入之继承》 复制以下的代码，到浏览器中，我们可以做一下测试： 12345678910111213141516171819202122232425262728function Otaku (name, age) &#123; this.name = name; this.age = age; this.habit = 'Games';&#125;Otaku.prototype.strength = 60;Otaku.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; Constructor.apply(obj, arguments); return obj;&#125;;var person = objectFactory(Otaku, 'Kevin', '18')console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // 60person.sayYourName(); // I am Kevin []~(￣▽￣)~** 返回值效果实现接下来我们再来看一种情况，假如构造函数有返回值，举个例子： 12345678910111213141516function Otaku (name, age) &#123; this.strength = 60; this.age = age; return &#123; name: name, habit: 'Games' &#125;&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined 在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。 而且还要注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？ 再举个例子： 12345678910111213function Otaku (name, age) &#123; this.strength = 60; this.age = age; return 'handsome boy';&#125;var person = new Otaku('Kevin', '18');console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18 结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。 所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。 再来看第二版的代码，也是最后一版的代码： 1234567891011121314// 第二版的代码function objectFactory() &#123; var obj = new Object(), Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === 'object' ? ret : obj;&#125;; 下一篇文章JavaScript深入之类数组对象与arguments 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之继承》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"14JavaScript深入之创建对象的多种方式以及优缺点","slug":"JavaScript深入之创建对象的多种方式以及优缺点","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:36.114Z","comments":true,"path":"2018/01/04/JavaScript深入之创建对象的多种方式以及优缺点/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之创建对象的多种方式以及优缺点/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面这篇文章讲解创建对象的各种方式，以及优缺点。","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十四篇，讲解创建对象的各种方式，以及优缺点。 写在前面这篇文章讲解创建对象的各种方式，以及优缺点。但是注意： 这篇文章更像是笔记，因为《JavaScript高级程序设计》写得真是太好了！ 1. 工厂模式1234567891011function createPerson(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson('kevin'); 缺点：对象无法识别，因为所有的实例都指向一个原型 2. 构造函数模式12345678function Person(name) &#123; this.name = name; this.getName = function () &#123; console.log(this.name); &#125;;&#125;var person1 = new Person('kevin'); 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次 2.1 构造函数模式优化12345678910function Person(name) &#123; this.name = name; this.getName = getName;&#125;function getName() &#123; console.log(this.name);&#125;var person1 = new Person('kevin'); 优点：解决了每个方法都要被重新创建的问题 缺点：这叫啥封装…… 3. 原型模式12345678910function Person(name) &#123;&#125;Person.prototype.name = 'keivn';Person.prototype.getName = function () &#123; console.log(this.name);&#125;;var person1 = new Person(); 优点：方法不会重新创建 缺点：1. 所有的属性和方法都共享 2. 不能初始化参数 3.1 原型模式优化123456789101112function Person(name) &#123;&#125;Person.prototype = &#123; name: 'kevin', getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：封装性好了一点 缺点：重写了原型，丢失了constructor属性 3.2 原型模式优化12345678910111213function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'kevin', getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：实例可以通过constructor属性找到所属构造函数 缺点：原型模式该有的缺点还是有 4. 组合模式构造函数模式与原型模式双剑合璧。 123456789101112function Person(name) &#123; this.name = name;&#125;Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：该共享的共享，该私有的私有，使用最广泛的方式 缺点：有的人就是希望全部都写在一起，即更好的封装性 4.1 动态原型模式12345678910function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype.getName = function () &#123; console.log(this.name); &#125; &#125;&#125;var person1 = new Person(); 注意：使用动态原型模式时，不能用对象字面量重写原型 解释下为什么： 1234567891011121314151617181920function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125; &#125; &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');// 报错 并没有该方法person1.getName();// 注释掉上面的代码，这句是可以执行的。person2.getName(); 为了解释这个问题，假设开始执行var person1 = new Person(&#39;kevin&#39;)。 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。 我们回顾下 new 的实现步骤： 首先新建一个对象 然后将对象的原型指向 Person.prototype 然后 Person.apply(obj) 返回这个对象 注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！ 如果你就是想用字面量方式写代码，可以尝试下这种： 12345678910111213141516171819function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function () &#123; console.log(this.name); &#125; &#125; return new Person(name); &#125;&#125;var person1 = new Person('kevin');var person2 = new Person('daisy');person1.getName(); // kevinperson2.getName(); // daisy 5.1 寄生构造函数模式123456789101112131415function Person(name) &#123; var o = new Object(); o.name = name; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var person1 = new Person('kevin');console.log(person1 instanceof Person) // falseconsole.log(person1 instanceof Object) // true 寄生构造函数模式，我个人认为应该这样读： 寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。 也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！ 这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数，我们可以这样写： 12345678910111213141516171819202122function SpecialArray() &#123; var values = new Array(); for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]); &#125; values.toPipedString = function () &#123; return this.join(\"|\"); &#125;; return values;&#125;var colors = new SpecialArray('red', 'blue', 'green');var colors2 = SpecialArray('red2', 'blue2', 'green2');console.log(colors);console.log(colors.toPipedString()); // red|blue|greenconsole.log(colors2);console.log(colors2.toPipedString()); // red2|blue2|green2 你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new，实际上两者的结果是一样的。 但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。 在可以使用其他模式的情况下，不要使用这种模式。 但是值得一提的是，上面例子中的循环： 123for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]);&#125; 可以替换成： 1values.push.apply(values, arguments); 5.2 稳妥构造函数模式1234567891011121314151617function person(name)&#123; var o = new Object(); o.sayName = function()&#123; console.log(name); &#125;; return o;&#125;var person1 = person('kevin');person1.sayName(); // kevinperson1.name = \"daisy\";person1.sayName(); // kevinconsole.log(person1.name); // daisy 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 与寄生构造函数模式有两点不同： 新创建的实例方法不引用 this 不使用 new 操作符调用构造函数 稳妥对象最适合在一些安全的环境中。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。 下一篇文章JavaScript深入之继承的多种方式和优缺点 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之new的模拟实现》 《JavaScript深入之call和apply的模拟实现》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"11JavaScript深入之bind的模拟实现","slug":"JavaScript深入之bind的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:45:47.438Z","comments":true,"path":"2018/01/04/JavaScript深入之bind的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之bind的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十一篇，通过bind函数的模拟实现，带大家真正了解bind的特性 bind一句话介绍 bind:","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十一篇，通过bind函数的模拟实现，带大家真正了解bind的特性 bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 返回函数的模拟实现从第一个特点开始，我们举个例子： 123456789101112var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;// 返回了一个函数var bindFoo = bar.bind(foo); bindFoo(); // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看《JavaScript深入之call和apply的模拟实现》。我们来写第一版的代码： 12345678// 第一版Function.prototype.bind2 = function (context) &#123; var self = this; return function () &#123; return self.apply(context); &#125;&#125; 此外，之所以 return self.apply(context)，是考虑到绑定函数可能是有返回值的，依然是这个例子： 1234567891011var foo = &#123; value: 1&#125;;function bar() &#123; return this.value;&#125;var bindFoo = bar.bind(foo);console.log(bindFoo()); // 1 传参的模拟实现接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： 12345678910111213141516var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(this.value); console.log(name); console.log(age);&#125;var bindFoo = bar.bind(foo, 'daisy');bindFoo('18');// 1// daisy// 18 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 这可咋办？不急，我们用 arguments 进行处理： 1234567891011121314// 第二版Function.prototype.bind2 = function (context) &#123; var self = this; // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1); return function () &#123; // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); &#125;&#125; 构造函数效果的模拟实现完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： 12345678910111213141516171819202122232425var value = 2;var foo = &#123; value: 1&#125;;function bar(name, age) &#123; this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age);&#125;bar.prototype.friend = 'kevin';var bindFoo = bar.bind(foo, 'daisy');var obj = new bindFoo('18');// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 (哈哈，我这是为我的下一篇文章《JavaScript深入系列之new的模拟实现》打广告)。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： 12345678910111213141516// 第三版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); &#125; // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound;&#125; 如果对原型链稍有困惑，可以查看《JavaScript深入之从原型到原型链》。 构造函数效果的优化实现但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： 1234567891011121314151617// 第四版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ 三个小问题接下来处理些小问题: 1.apply 这段代码跟 MDN 上的稍有不同 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是： 12self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于 context 是否存在的判断，然而这个是错误的！ 举个例子： 1234567891011var value = 2;var foo = &#123; value: 1, bar: bar.bind(null)&#125;;function bar() &#123; console.log(this.value);&#125;foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ 2.调用 bind 的不是函数咋办？ 不行，我们要报错！ 123if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");&#125; 3.我要在线上用 那别忘了做个兼容： 123Function.prototype.bind = Function.prototype.bind || function () &#123; ……&#125;; 当然最好是用 es5-shim 啦。 最终代码所以最最后的代码就是： 1234567891011121314151617181920Function.prototype.bind2 = function (context) &#123; if (typeof this !== \"function\") &#123; throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 下一篇文章《JavaScript深入系列之new的模拟实现》 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入系列之new的模拟实现》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"10JavaScript深入之call和apply的模拟实现","slug":"JavaScript深入之call和apply的模拟实现","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:45:55.246Z","comments":true,"path":"2018/01/04/JavaScript深入之call和apply的模拟实现/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之call和apply的模拟实现/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十篇，通过call和apply的模拟实现，带你揭开call和apply改变this的真相 call一句话介绍 call：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十篇，通过call和apply的模拟实现，带你揭开call和apply改变this的真相 call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： 123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： 12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： 123456// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： 123456789101112131415161718// 第一版Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call2(foo); // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： 1234567891011121314var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call(foo, 'kevin', 18);// kevin// 18// 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： 1234567891011121314// 以上个例子为例，此时的arguments为：// arguments = &#123;// 0: foo,// 1: 'kevin',// 2: 18,// length: 3// &#125;// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']');&#125;// 执行后 args为 [\"arguments[1]\", \"arguments[2]\", \"arguments[3]\"] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 1234// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(','))// (O_o)??// 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： 1eval('context.fn(' + args +')') 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： 1234567891011121314151617181920212223242526// 第二版Function.prototype.call2 = function(context) &#123; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; eval('context.fn(' + args +')'); delete context.fn;&#125;// 测试一下var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call2(foo, 'kevin', 18); // kevin// 18// 1 (๑•̀ㅂ•́)و✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： 1.this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： 12345678var value = 1;function bar() &#123; console.log(this.value);&#125;bar.call(null); // 1 虽然这个例子本身不使用 call，结果依然一样。 2.函数是可以有返回值的！ 举个例子： 12345678910111213141516171819var obj = &#123; value: 1&#125;function bar(name, age) &#123; return &#123; value: this.value, name: name, age: age &#125;&#125;console.log(bar.call(obj, 'kevin', 18));// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 不过都很好解决，让我们直接看第三版也就是最后一版的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 第三版Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ apply的模拟实现apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现： 12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; 下一篇文章JavaScript深入之bind的模拟实现 重要参考知乎问题 不能使用call、apply、bind，如何用 js 实现 call 或者 apply 的功能？ 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"15JavaScript深入之继承的多种方式和优缺点","slug":"JavaScript深入之继承的多种方式和优缺点","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:58.484Z","comments":true,"path":"2018/01/04/JavaScript深入之继承的多种方式和优缺点/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之继承的多种方式和优缺点/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十五篇，讲解JavaScript各种继承方式和优缺点。 写在前面","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十五篇，讲解JavaScript各种继承方式和优缺点。 写在前面 本文讲解JavaScript各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript高级程序设计》写得真是太好了！ 1.原型链继承1234567891011121314151617function Parent () &#123; this.name = 'kevin';&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 12345678910111213141516171819function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\", \"yayu\"] 2.在创建 Child 的实例时，不能向Parent传参 2.借用构造函数(经典继承)1234567891011121314151617function Parent () &#123; this.names = ['kevin', 'daisy'];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push('yayu');console.log(child1.names); // [\"kevin\", \"daisy\", \"yayu\"]var child2 = new Child();console.log(child2.names); // [\"kevin\", \"daisy\"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child('kevin');console.log(child1.name); // kevinvar child2 = new Child('daisy');console.log(child2.name); // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 3.组合继承原型链继承和经典继承双剑合璧。 1234567891011121314151617181920212223242526272829303132function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"black\"]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [\"red\", \"blue\", \"green\"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 4.原型式继承12345function createObj(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // [\"daisy\", \"kelly\", \"taylor\"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 5. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj (o) &#123; var clone = object.create(o); clone.sayName = function () &#123; console.log('hi'); &#125; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6. 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('kevin', '18');console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent(); 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18'); 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name); 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 12345678910111213141516171819202122232425function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin', '18');console.log(child1); 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候：prototype(Child, Parent); 引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 相关链接《JavaScript深入之从原型到原型链》 《JavaScript深入之call和apply的模拟实现》 《JavaScript深入之new的模拟实现》 《JavaScript深入之创建对象》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"06JavaScript深入之从ECMAScript规范解读this","slug":"JavaScript深入之从ECMAScript规范解读this","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:47.643Z","comments":true,"path":"2018/01/04/JavaScript深入之从ECMAScript规范解读this/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之从ECMAScript规范解读this/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第六篇，本篇我们追根溯源，从ECMAScript5规范解读this在函数调用时到底是如何确定的。 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第六篇，本篇我们追根溯源，从ECMAScript5规范解读this在函数调用时到底是如何确定的。 前言在《JavaScript深入之执行上下文栈》中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲 this，然而不好讲。 …… 因为我们要从 ECMASciript5 规范开始讲起。 先奉上 ECMAScript 5.1 规范地址： 英文版：http://es5.github.io/#x15.1 中文版：http://yanhaijing.com/es5/#115 让我们开始了解规范吧！ Types首先是第 8 章 Types： Types are further subclassified into ECMAScript language types and specification types. An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object. A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. 我们简单的翻译一下： ECMAScript 的类型分为语言类型和规范类型。 ECMAScript 语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。 而规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。 没懂？没关系，我们只要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。 今天我们要讲的重点是便是其中的 Reference 类型。它与 this 的指向有着密切的关联。 Reference那什么又是 Reference ？ 让我们看 8.7 章 The Reference Specification Type： The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators. 所以 Reference 类型就是用来解释诸如 delete、typeof 以及赋值等操作行为的。 抄袭尤雨溪大大的话，就是： 这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。 再看接下来的这段具体介绍 Reference 的内容： A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String. 这段讲述了 Reference 的构成，由三个组成部分，分别是： base value referenced name strict reference 可是这些到底是什么呢？ 我们简单的理解的话： base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。 referenced name 就是属性的名称。 举个例子： 12345678var foo = 1;// 对应的Reference是：var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 再举个例子： 1234567891011121314var foo = &#123; bar: function () &#123; return this; &#125;&#125;; foo.bar(); // foo// bar对应的Reference是：var BarReference = &#123; base: foo, propertyName: 'bar', strict: false&#125;; 而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。 这两个方法很简单，简单看一看： 1.GetBase GetBase(V). Returns the base value component of the reference V. 返回 reference 的 base value。 2.IsPropertyReference IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false. 简单的理解：如果 base value 是一个对象，就返回true。 GetValue除此之外，紧接着在 8.7.1 章规范中就讲了一个用于从 Reference 类型获取对应值的方法： GetValue。 简单模拟 GetValue 的使用： 123456789var foo = 1;var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;;GetValue(fooReference) // 1; GetValue 返回对象属性真正的值，但是要注意： 调用 GetValue，返回的将是具体的值，而不再是一个 Reference 这个很重要，这个很重要，这个很重要。 如何确定this的值关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段： 看规范 11.2.3 Function Calls： 这里讲了当函数调用的时候，如何确定 this 的取值。 只看第一步、第六步、第七步： 1.Let ref be the result of evaluating MemberExpression. 6.If Type(ref) is Reference, then a.If IsPropertyReference(ref) is true, then i.Let thisValue be GetBase(ref). b.Else, the base of ref is an Environment Record i.Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). 7.Else, Type(ref) is not Reference. a. Let thisValue be undefined. 让我们描述一下： 1.计算 MemberExpression 的结果赋值给 ref 2.判断 ref 是不是一个 Reference 类型 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) 2.3 如果 ref 不是 Reference，那么 this 的值为 undefined 具体分析让我们一步一步看： 计算 MemberExpression 的结果赋值给 ref 什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions： MemberExpression : PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》 FunctionExpression // 函数定义表达式 MemberExpression [ Expression ] // 属性访问表达式 MemberExpression . IdentifierName // 属性访问表达式 new MemberExpression Arguments // 对象创建表达式 举个例子： 123456789101112131415161718192021function foo() &#123; console.log(this)&#125;foo(); // MemberExpression 是 foofunction foo() &#123; return function() &#123; console.log(this) &#125;&#125;foo()(); // MemberExpression 是 foo()var foo = &#123; bar: function () &#123; return this; &#125;&#125;foo.bar(); // MemberExpression 是 foo.bar 所以简单理解 MemberExpression 其实就是()左边的部分。 2.判断 ref 是不是一个 Reference 类型。 关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个Reference类型。 举最后一个例子： 12345678910111213141516171819var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar());//示例2console.log((foo.bar)());//示例3console.log((foo.bar = foo.bar)());//示例4console.log((false || foo.bar)());//示例5console.log((foo.bar, foo.bar)()); foo.bar()在示例 1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？ 查看规范 11.2.1 Property Accessors，这里展示了一个计算的过程，什么都不管了，就看最后一步： Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 我们得知该表达式返回了一个 Reference 类型！ 根据之前的内容，我们知道该值为： 12345var Reference = &#123; base: foo, name: 'bar', strict: false&#125;; 接下来按照 2.1 的判断流程走： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？ 前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。 base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。 这个时候我们就可以确定 this 的值了： 1this = GetBase(ref)， GetBase 也已经铺垫了，获得 base value 值，这个例子中就是foo，所以 this 的值就是 foo ，示例1的结果就是 2！ 唉呀妈呀，为了证明 this 指向foo，真是累死我了！但是知道了原理，剩下的就更快了。 (foo.bar)()看示例2： 1console.log((foo.bar)()); foo.bar 被 () 包住，查看规范 11.1.6 The Grouping Operator 直接看结果部分： Return the result of evaluating Expression. This may be of type Reference. NOTE This algorithm does not apply GetValue to the result of evaluating Expression. 实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。 (foo.bar = foo.bar)()看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = ): 计算的第三步： 3.Let rval be GetValue(rref). 因为使用了 GetValue，所以返回的值不是 Reference 类型， 按照之前讲的判断逻辑： 2.3 如果 ref 不是Reference，那么 this 的值为 undefined this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象。 (false || foo.bar)()看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators： 计算第二步： 2.Let lval be GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined (foo.bar, foo.bar)()看示例5，逗号操作符，查看规范11.14 Comma Operator ( , ) 计算第二步： 2.Call GetValue(lref). 因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined 揭晓结果所以最后一个例子的结果是： 1234567891011121314151617181920var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;//示例1console.log(foo.bar()); // 2//示例2console.log((foo.bar)()); // 2//示例3console.log((foo.bar = foo.bar)()); // 1//示例4console.log((false || foo.bar)()); // 1//示例5console.log((foo.bar, foo.bar)()); // 1 注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。 补充最最后，忘记了一个最最普通的情况： 12345function foo() &#123; console.log(this)&#125;foo(); MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值： 12345var fooReference = &#123; base: EnvironmentRecord, name: 'foo', strict: false&#125;; 接下来进行判断： 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref) 因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number, 和 an environment record 中的一种。 IsPropertyReference(ref) 的结果为 false，进入下个判断： 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么this的值为 ImplicitThisValue(ref) base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref) 查看规范 10.2.1.1.6，ImplicitThisValue 方法的介绍：该函数始终返回 undefined。 所以最后 this 的值就是 undefined。 多说一句尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？ 123456789var value = 1;var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125;console.log((false || foo.bar)()); // 1 此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。 此篇讲解执行上下文的 this，即便不是很理解此篇的内容，依然不影响大家了解执行上下文这个主题下其他的内容。所以，依然可以安心的看下一篇文章。 下一篇文章《JavaScript深入之执行上下文》 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"09JavaScript深入之参数按值传递","slug":"JavaScript深入之参数按值传递","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:30.018Z","comments":true,"path":"2018/01/04/JavaScript深入之参数按值传递/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之参数按值传递/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数：","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第九篇，除了按值传递、引用传递，还有第三种传递方式 —— 按共享传递 定义在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数： ECMAScript中所有函数的参数都是按值传递的。 什么是按值传递呢？ 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 按值传递举个简单的例子： 1234567var value = 1;function foo(v) &#123; v = 2; console.log(v); //2&#125;foo(value);console.log(value) // 1 很好理解，当传递 value 到函数 foo 中，相当于拷贝了一份 value，假设拷贝的这份叫 _value，函数中修改的都是 _value 的值，而不会影响原来的 value 值。 引用传递拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题。 所以还有另一种传递方式叫做按引用传递。 所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响该对象的值，因为两者引用的是同一个对象。 举个例子： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o.value = 2; console.log(o.value); //2&#125;foo(obj);console.log(obj.value) // 2 哎，不对啊，连我们的红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按引用传递成功呢？ 而这究竟是不是引用传递呢？ 第三种传递方式不急，让我们再看个例子： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o = 2; console.log(o); //2&#125;foo(obj);console.log(obj.value) // 1 如果 JavaScript 采用的是引用传递，外层的值也会被修改呐，这怎么又没被改呢？所以真的不是引用传递吗？ 这就要讲到其实还有第三种传递方式，叫按共享传递。 而共享传递是指，在传递对象的时候，传递对象的引用的副本。 注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！ 所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。 最后，你可以这样理解： 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。 所以，高程，谁叫你是红宝书嘞！ 下一篇文章JavaScript深入之call和apply的模拟实现 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"13JavaScript深入之类数组对象与arguments","slug":"JavaScript深入之类数组对象与arguments","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:47:03.392Z","comments":true,"path":"2018/01/04/JavaScript深入之类数组对象与arguments/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之类数组对象与arguments/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十三篇，讲解类数组对象与对象的相似与差异以及arguments的注意要点 类数组对象","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列第十三篇，讲解类数组对象与对象的相似与差异以及arguments的注意要点 类数组对象 所谓的类数组对象: 拥有一个 length 属性和若干索引属性的对象 举个例子： 12345678var array = ['name', 'age', 'sex'];var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125; 即便如此，为什么叫做类数组对象呢？ 那让我们从读写、获取长度、遍历三个方面看看这两个对象。 读写12345console.log(array[0]); // nameconsole.log(arrayLike[0]); // namearray[0] = 'new name';arrayLike[0] = 'new name'; 长度12console.log(array.length); // 3console.log(arrayLike.length); // 3 遍历123456for(var i = 0, len = array.length; i &lt; len; i++) &#123; ……&#125;for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123; ……&#125; 是不是很像？ 那类数组对象可以使用数组的方法吗？比如： 1arrayLike.push('4'); 然而上述代码会报错: arrayLike.push is not a function 所以终归还是类数组呐…… 调用数组方法如果类数组就是任性的想用数组的方法怎么办呢？ 既然无法直接调用，我们可以用 Function.call 间接调用： 1234567891011var arrayLike = &#123;0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;Array.prototype.join.call(arrayLike, '&amp;'); // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item)&#123; return item.toUpperCase();&#125;); // [\"NAME\", \"AGE\", \"SEX\"] 类数组转对象在上面的例子中已经提到了一种类数组转数组的方法，再补充三个： 123456789var arrayLike = &#123;0: 'name', 1: 'age', 2: 'sex', length: 3 &#125;// 1. sliceArray.prototype.slice.call(arrayLike); // [\"name\", \"age\", \"sex\"] // 2. spliceArray.prototype.splice.call(arrayLike, 0); // [\"name\", \"age\", \"sex\"] // 3. ES6 Array.fromArray.from(arrayLike); // [\"name\", \"age\", \"sex\"] // 4. applyArray.prototype.concat.apply([], arrayLike) 那么为什么会讲到类数组对象呢？以及类数组有什么应用吗？ 要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。 Arguments对象接下来重点讲讲 Arguments 对象。 Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。 举个例子： 12345function foo(name, age, sex) &#123; console.log(arguments);&#125;foo('name', 'age', 'sex') 打印结果如下： 我们可以看到除了类数组的索引属性和length属性之外，还有一个callee属性，接下来我们一个一个介绍。 length属性Arguments对象的length属性，表示实参的长度，举个例子： 12345678910function foo(b, c, d)&#123; console.log(\"实参的长度为：\" + arguments.length)&#125;console.log(\"形参的长度为：\" + foo.length)foo(1)// 形参的长度为：3// 实参的长度为：1 callee属性Arguments 对象的 callee 属性，通过它可以调用函数自身。 讲个闭包经典面试题使用 callee 的解决方法： 123456789101112131415var data = [];for (var i = 0; i &lt; 3; i++) &#123; (data[i] = function () &#123; console.log(arguments.callee.i) &#125;).i = i;&#125;data[0]();data[1]();data[2]();// 0// 1// 2 接下来讲讲 arguments 对象的几个注意要点： arguments 和对应参数的绑定12345678910111213141516171819202122232425262728function foo(name, age, sex, hobbit) &#123; console.log(name, arguments[0]); // name name // 改变形参 name = 'new name'; console.log(name, arguments[0]); // new name new name // 改变arguments arguments[1] = 'new age'; console.log(age, arguments[1]); // new age new age // 测试未传入的是否会绑定 console.log(sex); // undefined sex = 'new sex'; console.log(sex, arguments[2]); // new sex undefined arguments[3] = 'new hobbit'; console.log(hobbit, arguments[3]); // undefined new hobbit&#125;foo('name', 'age') 传入的参数，实参和 arguments 的值会共享，当没有传入时，实参与 arguments 值不会共享 除此之外，以上是在非严格模式下，如果是在严格模式下，实参和 arguments 是不会共享的。 传递参数将参数从一个函数传递到另一个函数 123456789// 使用 apply 将 foo 的参数传递给 barfunction foo() &#123; bar.apply(this, arguments);&#125;function bar(a, b, c) &#123; console.log(a, b, c);&#125;foo(1, 2, 3) 强大的ES6使用ES6的 … 运算符，我们可以轻松转成数组。 12345function func(...arguments) &#123; console.log(arguments); // [1, 2, 3]&#125;func(1, 2, 3); 应用arguments的应用其实很多，在下个系列，也就是 JavaScript 专题系列中，我们会在 jQuery 的 extend 实现、函数柯里化、递归等场景看见 arguments 的身影。这篇文章就不具体展开了。 如果要总结这些场景的话，暂时能想到的包括： 参数不定长 函数柯里化 递归调用 函数重载… 欢迎留言回复。 下一篇文章JavaScript深入之创建对象的多种方式以及优缺点 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"02JavaScript深入之词法作用域和动态作用域","slug":"JavaScript深入之词法作用域和动态作用域","date":"2018-01-04T12:12:50.507Z","updated":"2018-01-04T12:46:41.534Z","comments":true,"path":"2018/01/04/JavaScript深入之词法作用域和动态作用域/","link":"","permalink":"https://luox78.github.io/2018/01/04/JavaScript深入之词法作用域和动态作用域/","excerpt":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第二篇，JavaScript采用词法作用域，什么语言采用了动态作用域？两者的区别又是什么？还有一个略难的思考题，快来看看吧。 作用域","text":"本文来自https://github.com/mqyqingfeng/Blog JavaScript深入系列的第二篇，JavaScript采用词法作用域，什么语言采用了动态作用域？两者的区别又是什么？还有一个略难的思考题，快来看看吧。 作用域 作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设JavaScript采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 动态作用域也许你会好奇什么语言是动态作用域？ bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。 123456789value=1function foo () &#123; echo $value;&#125;function bar () &#123; local value=2; foo;&#125;bar 这个文件也可以在github博客仓库中找到。 思考题最后，让我们看一个《JavaScript权威指南》中的例子： 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 但是在这里真正想让大家思考的是： 虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下一篇文章————《JavaScript深入之执行上下文栈》。 下一篇文章JavaScript深入之执行上下文栈 深入系列JavaScript深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript深入系列预计写十五篇左右，旨在帮大家捋顺JavaScript底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎star，对作者也是一种鼓励。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"深入理解JS","slug":"深入理解JS","permalink":"https://luox78.github.io/tags/深入理解JS/"}]},{"title":"初识JavaScript04","slug":"JavaScript04","date":"2018-01-03T13:46:51.448Z","updated":"2018-01-06T14:51:14.361Z","comments":true,"path":"2018/01/03/JavaScript04/","link":"","permalink":"https://luox78.github.io/2018/01/03/JavaScript04/","excerpt":"window对象的属性 document.write()会覆盖原有的全部内容","text":"window对象的属性 document.write()会覆盖原有的全部内容 123456789&lt;body&gt; 你是谁&lt;input type=\"button\" id=\"btn\" value=\"click\" /&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById(\"btn\").onclick = function () &#123; document.write('&lt;font size=\"7\"&gt;luox78&lt;/font&gt;'); &#125;&lt;/script&gt; document.getElementById(),getElementsByName(),`getElementsByTagName, 1234567891011&lt;body&gt; &lt;input type=\"text\" name=\"txt\" /&gt; &lt;input type=\"text\" name=\"txt\" /&gt; &lt;input type=\"text\" name=\"txt\"/&gt;&lt;/body&gt;&lt;script&gt; var inputs = document.getElementsByName(\"txt\"); for (var i = 0; i &lt; inputs.length; i++) &#123; inputs[i].value = \"luox78\"; &#125;&lt;/script&gt; 注意循环中使用this,javascript执行上下文 12345678910111213141516171819202122232425&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;input type=\"button\" name=\"btn\" value=\"???????????\" /&gt;&gt; &lt;script&gt;&gt; //点击一个按钮，被点击的按钮显示“呜呜”，其他按钮显示“哈哈”&gt; var inputs = document.getElementsByName('btn');&gt; for (var i = 0; i &lt; inputs.length; i++) &#123;&gt; if (inputs[i].type == 'button') &#123;&gt; inputs[i].onclick = function() &#123;&gt; for (var j = 0; j &lt; inputs.length; j++) &#123;&gt; if (inputs[j].type == 'button') &#123;&gt; inputs[j].value = \"哈哈\";&gt; &#125;&gt; &#125;&gt; this.value = \"呜呜\";&gt; //inputs[i].value = \"呜呜\"; 这样写不能达到预期的效果&gt; &#125;;&gt; &#125;&gt; &#125;&gt; &lt;/script&gt;&gt; 事件冒泡演示 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=\"div1\" style=\"height: 200px; background-color: aquamarine\"&gt; &lt;div id=\"div2\" style=\"background-color: black; width: 600px;height: 200px;\"&gt; &lt;div id=\"div3\" style=\"background-color: blue; height: 200px;width: 300px\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById(\"div1\").onclick= function() &#123; console.log(this.id); &#125; document.getElementById(\"div2\").onclick = function () &#123; console.log(this.id); &#125; document.getElementById(\"div3\").onclick = function () &#123; console.log(this.id); &#125;&lt;/script&gt;结果（分别点击div1，div2，div3）： div1 div2 div1 div3 div2 div1 将div3中console.log(this.id)改成console.log(window.event.srcElement.id)，效果一致，但window.event.srcElement.id为事件源 如何取消事件冒泡呢？使用window.event.cancelBubble=true，在div3 onclick中加入window.event.cancelBubble=true，console中只输出了div3 动态添加元素演示点击按钮添加td 123456789101112131415161718192021222324&lt;body&gt; &lt;input id=\"txt\" type=\"text\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"add remark\" /&gt; &lt;br /&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;评论&lt;/th&gt; &lt;/thead&gt; &lt;tbody id=\"tbody\"&gt;&lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(\"btn2\").onclick = function () &#123; var txt = document.getElementById(\"txt\").value; var tbody = document.getElementById(\"tbody\"); if (txt != null &amp;&amp; txt.length != 0) &#123; var tr = document.createElement(\"tr\"); var td = document.createElement(\"td\"); tr.appendChild(td); td.textContent = txt; tbody.appendChild(tr); &#125; &#125;&lt;/script&gt; document.XXX方法： createElement(&#39;element&#39;);创建一个节点 appendChild(node); 追加一个节点 removeChild(node);移除一个节点 replaceChild(new,old);替换一个节点 insertBefore(new,参照);把节点加到前面（插到某个节点前面） 属性： firstChild lastChild 动态设置styledocument.getElementById(&quot;XXX&quot;).style或document.getElementById(&quot;XXX&quot;)下","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"同步基础","slug":"CS_Thread02","date":"2018-01-02T13:19:59.458Z","updated":"2018-01-03T11:46:34.983Z","comments":true,"path":"2018/01/02/CS_Thread02/","link":"","permalink":"https://luox78.github.io/2018/01/02/CS_Thread02/","excerpt":"1同步概要在第 1 部分：基础知识中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。 下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。","text":"1同步概要在第 1 部分：基础知识中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。 下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。 同步构造可以分为以下四类： 简单的阻塞方法 这些方法会使当前线程等待另一个线程结束或是自己等待一段时间。Sleep、Join与Task.Wait都是简单的阻塞方法。 锁构造 锁构造能够限制每次可以执行某些动作或是执行某段代码的线程数量。排它锁构造是最常见的，它每次只允许一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。标准的排它锁构造是lock（Monitor.Enter/Monitor.Exit）、Mutex与 SpinLock。非排它锁构造是Semaphore、SemaphoreSlim以及读写锁。 信号构造 信号构造可以使一个线程暂停，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：事件等待句柄（event wait handle ）和Monitor类的Wait / Pluse方法。Framework 4.0 加入了CountdownEvent与Barrier类。 非阻塞同步构造 非阻塞同步构造通过调用处理器指令来保护对公共字段的访问。CLR 与 C# 提供了下列非阻塞构造：Thread.MemoryBarrier 、Thread.VolatileRead、Thread.VolatileWrite、volatile关键字以及Interlocked类。 阻塞这个概念对于前三类来说都非常重要，接下来我们简要的剖析下它。 1.1阻塞当线程的执行由于某些原因被暂停，比如调用Sleep等待一段时间，或者通过Join或EndInvoke方法等待其它线程结束时，则认为此线程被阻塞（blocked）。被阻塞的线程会立即出让（yields）其处理器时间片，之后不再消耗处理器时间，直到阻塞条件被满足。可以通过线程的ThreadState属性来检查一个线程是否被阻塞： 1bool blocked = (someThread.ThreadState &amp; ThreadState.WaitSleepJoin) != 0; （上面例子中线程状态可能在进行状态判断和依据状态进行操作之间发生改变，因此这段代码仅可用于调试诊断的场景。） 当一个线程被阻塞或是解除阻塞时，操作系统会进行上下文切换（context switch），这会带来几微秒的额外时间开销。 阻塞会在以下 4 种情况下解除（电源按钮可不能算╮(╯▽╰)╭）： 阻塞条件被满足 操作超时（如果指定了超时时间） 通过Thread.Interrupt中断 通过Thread.Abort中止 通过Suspend方法（已过时，不应该再使用）暂停线程的执行不被认为是阻塞。 1.2阻塞 vs 自旋有时线程必须暂停，直到特定条件被满足。信号构造和锁构造可以通过在条件被满足前阻塞线程来实现。但是还有一种更为简单的方法：线程可以通过自旋（spinning）来等待条件被满足。例如： 123while (!proceed);// 或者：while (DateTime.Now &lt; nextStartTime); 一般来说，这会非常浪费处理器时间：因为对 CLR 和操作系统来说，这个线程正在执行重要的计算，就给它分配了相应的资源。 有时会组合使用阻塞与自旋： 1while (!proceed) Thread.Sleep (10); 尽管并不优雅，但是这比仅使用自旋更高效（一般来说）。然而这样也可能会出现问题，这是由proceed标识上的并发问题引起的。正确的使用和锁构造和信号构造可以避免这个问题。 自旋在等待的条件很快（大致几微秒）就能被满足的情况下更高效，因为它避免了上下文切换带来的额外开销。.NET Framework 提供了专门的方法和类型来辅助实现自旋，在第 5 部分会讲到。 1.3线程状态可以通过线程的ThreadState属性来查询线程状态，它会返回一个ThreadState类型的按位方式组合的枚举值，其中包含了三“层”信息。然而大多数值都是冗余的、无用的或者过时不建议使用的。下图是其中一“层”信息： 下面的代码可以提取线程状态中最有用的 4 个值: Unstarted、Running、WaitSleepJoin和Stopped： 123456public static ThreadState SimpleThreadState (ThreadState ts)&#123; return ts &amp; (ThreadState.Unstarted | ThreadState.WaitSleepJoin | ThreadState.Stopped);&#125; ThreadState属性在进行调试诊断时有用，但不适合用来进行同步，因为线程状态可能在判断状态和依据状态进行操作之间发生改变。 2锁排它锁用于确保同一时间只允许一个线程执行指定的代码段。主要的两个排它锁构造是lock和Mutex（互斥体）。其中lock更快，使用也更方便。而Mutex的优势是它可以跨进程的使用。 在这一节里，我们从介绍lock构造开始，然后介绍Mutex和信号量（semaphore）（用于非排它场景）。稍后在第 4 部分会介绍读写锁（reader / writer lock）。 Framework 4.0 加入了SpinLock结构体，可以用于高并发场景。 让我们从下边这个类开始： 12345678910class ThreadUnsafe&#123; static int _val1 = 1, _val2 = 1; static void Go() &#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0; &#125;&#125; 这个类不是线程安全的：如果Go方法同时被两个线程调用，可能会产生除数为零错误，因为可能在一个线程刚好执行完if的判断语句但还没执行Console.WriteLine语句时，_val2就被另一个线程设置为零。 下边使用lock解决这个问题： 1234567891011121314class ThreadSafe&#123; static readonly object _locker = new object(); static int _val1, _val2; static void Go() &#123; lock (_locker) &#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0; &#125; &#125;&#125; 同一时间只有一个线程可以锁定同步对象（这里指_locker），并且其它竞争锁的线程会被阻塞，直到锁被释放。如果有多个线程在竞争锁，它们会在一个“就绪队列（ready queue）”中排队，并且遵循先到先得的规则（需要说明的是，Windows 系统和 CLR 的差别可能导致这个队列在有时会不遵循这个规则）。因为一个线程的访问不能与另一个线程相重叠，排它锁有时也被这样描述：它强制对锁保护的内容进行顺序（serialized）访问。在这个例子中，我们保护的是Go方法的内部逻辑，还有_val1与_val2字段。 在竞争锁时被阻塞的线程，它的线程状态是WaitSleepJoin。在中断与中止中，我们会描述如何通过其它线程强制释放被阻塞的线程，这是一种可以用于结束线程的重型技术（译者注：这里指它们应该被作为在没有其它更为优雅的办法时的最后手段）。 锁构造比较 构造 用途 跨进程 开销* lock（Monitor.Enter/Monitor.Exit） 确保同一时间只有一个线程可以访问资源或代码 - 20ns Mutex yes 1000ns SemaphoreSlim（Framework 4.0 中加入） 确保只有不超过指定数量的线程可以并发访问资源或代码 - 200ns Semaphore yes 1000ns ReaderWriterLockSlim（Framework 3.5 中加入） 允许多个读线程和一个写线程共存 - 40ns ReaderWriterLock（已过时） - 100ns * 时间代表在同一线程上一次进行加锁和释放锁（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。 2.1Monitor.Enter 与 Monitor.ExitC# 的lock语句是一个语法糖，它其实就是使用了try / finally来调用Monitor.Enter与Monitor.Exit方法。下面是在之前示例中的Go方法内部所发生的事情（简化的版本）： 1234567Monitor.Enter (_locker);try&#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0;&#125;finally &#123; Monitor.Exit (_locker); &#125; 如果在同一个对象上没有先调用Monitor.Enter就调用Monitor.Exit会抛出一个异常。 lockTaken 重载刚刚所描述的就是 C# 1.0、2.0 和 3.0 的编译器翻译lock语句产生的代码。 然而它有一个潜在的缺陷。考虑这样的情况：在Monitor.Enter的实现内部或者在Monitor.Enter与try中间有异常被抛出（可能是因为在线程上调用了Abort，或者有OutOfMemoryException异常被抛出），这时不一定能够获得锁。如果获得了锁，那么该锁就不会被释放，因为不可能执行到try / finally内，这会导致锁泄漏。 为了避免这种危险，CLR 4.0 的设计者为Monitor.Enter添加了下面的重载： 1public static void Enter (object obj, ref bool lockTaken); 当（且仅当）Enter方法抛出异常，锁没有能够获得时，lockTaken为false。 下边是正确的使用方式（这就是 C# 4.0 对于lock语句的翻译）： 1234567bool lockTaken = false;try&#123; Monitor.Enter (_locker, ref lockTaken); // 你的代码...&#125;finally &#123; if (lockTaken) Monitor.Exit (_locker); &#125; TryEnterMonitor还提供了一个TryEnter方法，允许以毫秒或是TimeSpan方式指定超时时间。如果获得了锁，该方法会返回true，而如果由于超时没有获得锁，则会返回false。TryEnter也可以以无参数的形式进行调用，这是对锁进行“测试”，如果不能立即获得锁就会立即返回false。 类似于Enter方法，该方法在 CLR 4.0 中也被重载来接受lockTaken参数。 2.2选择同步对象对所有参与同步的线程可见的任何对象都可以被当作同步对象使用，但有一个硬性规定：同步对象必须为引用类型。同步对象一般是私有的（因为这有助于封装锁逻辑），并且一般是一个实例或静态字段。同步对象也可以就是其要保护的对象，如下面例子中的_list字段： 12345678910class ThreadSafe&#123; List &lt;string&gt; _list = new List &lt;string&gt;(); void Test() &#123; lock (_list) &#123; _list.Add (\"Item 1\"); // ... 一个只被用来加锁的字段（例如前面例子中的_locker）可以精确控制锁的作用域与粒度。对象自己（this），甚至是其类型都可以被当作同步对象来使用： 123lock (this) &#123; ... &#125;// 或者：lock (typeof (Widget)) &#123; ... &#125; // 保护对静态资源的访问 这种方式的缺点在于并没有对锁逻辑进行封装，从而很难避免死锁与过多的阻塞。同时类型上的锁也可能会跨越应用程序域（application domain）边界（在同一进程内）。 你也可以在被 lambda 表达式或匿名方法所捕获的局部变量上加锁。 锁在任何情况下都不会限制对同步对象本身的访问。换句话说，x.ToString()不会因为其它线程调用lock(x)而阻塞，两个线程都要调用lock(x)才能使阻塞发生。 2.3何时加锁简单的原则是，需要在访问任意可写的共享字段（any writable shared field）时加锁。即使是最简单的操作，例如对一个字段的赋值操作，都必须考虑同步。在下面的类中，Increment与Assign方法都不是线程安全的： 123456class ThreadUnsafe&#123; static int _x; static void Increment() &#123; _x++; &#125; static void Assign() &#123; _x = 123; &#125;&#125; 以下是线程安全的版本： 12345678class ThreadSafe&#123; static readonly object _locker = new object(); static int _x; static void Increment() &#123; lock (_locker) _x++; &#125; static void Assign() &#123; lock (_locker) _x = 123; &#125;&#125; 在非阻塞同步（nonblocking synchronization）中，我们会解释这种需求是如何产生的，以及在这些场景下内存屏障（memory barrier，内存栅栏，内存栅障）和Interlocked类如何提供替代方法进行锁定。 2.4锁与原子性如果一组变量总是在相同的锁内进行读写，就可以称为原子的（atomically）读写。假定字段x与y总是在对locker对象的lock内进行读取与赋值： 1lock (locker) &#123; if (x != 0) y /= x; &#125; 可以说x和y是被原子的访问的，因为上面的代码块无法被其它的线程分割或抢占。如果被其它线程分割或抢占，x和y就可能被别的线程修改导致计算结果无效。而现在 x和y总是在相同的排它锁中进行访问，因此不会出现除数为零的错误。 在lock锁内抛出异常将打破锁的原子性，考虑如下代码： 12345678910decimal _savingsBalance, _checkBalance;void Transfer (decimal amount)&#123; lock (_locker) &#123; _savingsBalance += amount; _checkBalance -= amount + GetBankFee(); &#125;&#125; 如果GetBankFee()方法内抛出异常，银行可能就要损失钱财了。在这个例子中，我们可以通过更早的调用GetBankFee()来避免这个问题。对于更复杂情况，解决方案是在catch或finally中实现“回滚（rollback）”逻辑。 指令原子性是一个相似但不同的概念： 如果一条指令可以在 CPU 上不可分割地执行，那么它就是原子的。（见非阻塞同步） 2.5嵌套锁线程可以用嵌套（重入）的方式重对相同的对象进行加锁： 123456lock (locker) lock (locker) lock (locker) &#123; // ... &#125; 或者： 123Monitor.Enter (locker); Monitor.Enter (locker); Monitor.Enter (locker);// ...Monitor.Exit (locker); Monitor.Exit (locker); Monitor.Exit (locker); 在这样的场景中，只有当最外层的lock语句退出或是执行了匹配数目的Monitor.Exit语句时，对象才会被解锁。 嵌套锁可以用于在锁中调用另一个方法（也使用了同一对象来锁定）： 123456789101112131415static readonly object _locker = new object();static void Main()&#123; lock (_locker) &#123; AnotherMethod(); // 这里依然拥有锁，因为锁是可重入的 &#125;&#125;static void AnotherMethod()&#123; lock (_locker) &#123; Console.WriteLine (\"Another method\"); &#125;&#125; 线程只会在第一个（最外层）lock处阻塞。 2.6死锁当两个线程等待的资源都被对方占用时，它们都无法执行，这就产生了死锁。演示死锁最简单的方法就是使用两个锁： 123456789101112131415object locker1 = new object();object locker2 = new object();new Thread (() =&gt; &#123; lock (locker1) &#123; Thread.Sleep (1000); lock (locker2); // 死锁 &#125; &#125;).Start();lock (locker2)&#123; Thread.Sleep (1000); lock (locker1); // 死锁&#125; 更复杂的死锁链可能由三个或更多的线程创建。 在标准环境下，CLR 不会像SQL Server一样自动检测和解决死锁。除非你指定了锁定的超时时间，否则死锁会造成参与的线程无限阻塞。（在SQL CLR 集成宿主环境中，死锁能够被自动检测，并在其中一个线程上抛出可捕获的异常。） 死锁是多线程中最难解决的问题之一，尤其是在有很多关联对象的时候。这个困难在根本上在于无法确定调用方（caller）已经拥有了哪些锁。 你可能会锁定类x中的私有字段a，而并不知道调用方（或者调用方的调用方）已经锁住了类y中的字段b。同时，另一个线程正在执行顺序相反的操作，这样就创建了死锁。讽刺的是，这个问题会由于（良好的）面向对象的设计模式而加剧，因为这类模式建立的调用链直到运行时才能确定。 流行的建议：“以一致的顺序对对象加锁以避免死锁”，尽管它对于我们最初的例子有帮助，但是很难应用到刚才所描述的场景。更好的策略是：如果发现在锁区域中的对其它类的方法调用最终会引用回当前对象，就应该小心，同时考虑是否真的需要对其它类的方法调用加锁（往往是需要的，但是有时也会有其它选择）。更多的依靠声明方式（declarative）与数据并行（data parallelism）、不可变类型（immutable types）与非阻塞同步构造（ nonblocking synchronization constructs），可以减少对锁的需要。 有另一种思路来帮助理解这个问题：当你在拥有锁的情况下访问其它类的代码，对于锁的封装就存在潜在的泄露。这不是 CLR 或 .NET Framework 的问题，而是因为锁本身的局限性。锁的问题在许多研究项目中被分析，包括软件事务内存（Software Transactional Memory）。 另一个死锁的场景是：如果已拥有一个锁，在调用Dispatcher.Invoke（在 WPF 程序中）或是Control.Invoke（在 Windows Forms 程序中）时，如果 UI 恰好要运行等待同一个锁的另一个方法，就会在这里发生死锁。这通常可以通过调用BeginInvoke而不是Invoke来简单的修复。或者，可以在调用Invoke之前释放锁，但是如果是调用方获得的锁，那么这种方法可能并不会起作用。我们在富客户端应用与线程亲和中来解释Invoke和BeginInvoke。 2.7性能锁是非常快的，在一个 2010 时代的计算机上，没有竞争的情况下获取并释放锁一般只需 20 纳秒。如果存在竞争，产生的上下文切换会把开销增加到微秒的级别，并且线程被重新调度前可能还会等待更久的时间。如果需要锁定的时间很短，那么可以使用自旋锁（SpinLock）来避免上下文切换的开销。 如果获取锁后保持的时间太长而不释放，就会降低并发度，同时也会加大死锁的风险。 2.8互斥体（Mutex）互斥体类似于 C# 的lock，不同在于它是可以跨越多个进程工作。换句话说，Mutex可以是机器范围（computer-wide）的，也可以是程序范围（application-wide）的。 没有竞争的情况下，获取并释放Mutex需要几微秒的时间，大约比lock慢 50 倍。 使用Mutex类时，可以调用WaitOne方法来加锁，调用ReleaseMutex方法来解锁。关闭或销毁Mutex会自动释放锁。与lock语句一样，Mutex只能被获得该锁的线程释放。 跨进程Mutex的一种常见的应用就是确保只运行一个程序实例。下面演示了这是如何实现的： 12345678910111213141516171819202122232425class OneAtATimePlease&#123; static void Main() &#123; // 命名的 Mutex 是机器范围的，它的名称需要是唯一的 // 比如使用公司名+程序名，或者也可以用 URL using (var mutex = new Mutex (false, \"oreilly.com OneAtATimeDemo\")) &#123; // 可能其它程序实例正在关闭，所以可以等待几秒来让其它实例完成关闭 if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false)) &#123; Console.WriteLine (\"Another app instance is running. Bye!\"); return; &#125; RunProgram(); &#125; &#125; static void RunProgram() &#123; Console.WriteLine (\"Running. Press Enter to exit\"); Console.ReadLine(); &#125;&#125; 如果在终端服务（Terminal Services）下运行，机器范围的Mutex默认仅对于运行在相同终端服务器会话的应用程序可见。要使其对所有终端服务器会话可见，需要在其名字前加上Global\\。 2.9信号量（Semaphore）信号量类似于一个夜总会：它具有一定的容量，并且有保安把守。一旦满员，就不允许其他人进入，这些人将在外面排队。当有一个人离开时，排在最前头的人便可以进入。这种构造最少需要两个参数：夜总会中当前的空位数以及夜总会的总容量。 容量为 1 的信号量与Mutex和lock类似，所不同的是信号量没有“所有者”，它是线程无关（thread-agnostic）的。任何线程都可以在调用Semaphore上的Release方法，而对于Mutex和lock，只有获得锁的线程才可以释放。 SemaphoreSlim是 Framework 4.0 加入的轻量级的信号量，功能与Semaphore相似，不同之处是它对于并行编程的低延迟需求做了优化。在传统的多线程方式中也有用，因为它支持在等待时指定取消标记 （cancellation token）。但它不能跨进程使用。 在Semaphore上调用WaitOne或Release会产生大概 1 微秒的开销，而SemaphoreSlim产生的开销约是其四分之一。 信号量在有限并发的需求中有用，它可以阻止过多的线程同时执行特定的代码段。在下面的例子中，五个线程尝试进入一个只允许三个线程进入的夜总会： 12345678910111213141516171819class TheClub&#123; static SemaphoreSlim _sem = new SemaphoreSlim (3); // 容量为 3 static void Main() &#123; for (int i = 1; i &lt;= 5; i++) new Thread (Enter).Start (i); &#125; static void Enter (object id) &#123; Console.WriteLine (id + \" wants to enter\"); _sem.Wait(); Console.WriteLine (id + \" is in!\"); // 同时只能有 Thread.Sleep (1000 * (int) id); // 3个线程 Console.WriteLine (id + \" is leaving\"); // 执行这里 _sem.Release(); &#125;&#125; 输出结果： 1234567891011121 wants to enter1 is in!2 wants to enter2 is in!3 wants to enter3 is in!4 wants to enter5 wants to enter1 is leaving4 is in!2 is leaving5 is in! 如果Sleep语句被替换为密集的磁盘 I/O 操作，由于Semaphore限制了过多的并发硬盘活动，就可能改善整体性能。 类似于Mutex，命名的Semaphore也可以跨进程使用。 3线程安全说一个程序或方法是线程安全（ thread-safe）的，是指它在任意的多线程场景中都不存在不确定性。线程安全主要是通过锁以及减少线程交互来实现。 一般的类型很少有完全线程安全的，原因如下： 完全线程安全的开发负担很重，特别是如果一个类型有很多字段的情况（在任意多线程并发的情况下每个字段都有交互的潜在可能）。 线程安全可能会损失性能（某种程度上，无论类型是否实际被用于多线程都会增加损耗）。 线程安全的类型并不能确保使用该类型的程序也是线程安全的，为了实现程序线程安全所涉及的工作经常会使得类型线程安全成为多余。 因此线程安全通常只会在需要时再实现，只为了处理特定的多线程场景。 然而，有些方法可以用来“作弊” ，使庞大和复杂的类在多线程环境中安全运行。一种方法是牺牲粒度，将大段代码甚至是访问的整个对象封装在一个排它锁内，从而保证在高层上能进行顺序访问。事实上，如果我们希望在多线程环境中使用线程不安全的第三方代码（或大多数 Framework 的类型）时，这种策略是十分有用的。它仅仅是简单的使用了相同的排它锁，来保护对非线程安全对象上所有属性、方法和字段的访问。这种解决方案适用于对象的方法都能够快速执行的场景（否则会导致大量的阻塞）。 除基本类型外，很少有 .NET Framework 的类型能在比并发读取更高的需求下保证其实例成员是线程安全的。实现线程安全的责任就落在了开发人员身上，一般就是使用排它锁。（命名空间System.Collections.Concurrent中的类型是个例外，它们是线程安全的数据结构。） 另一种“作弊”的方法是通过最小化共享数据来减少线程交互。这是一种优秀的方法，隐式的用于“ 无状态（stateless）”的中间层程序和网页服务器中。由于多个客户端请求可以同时到达，服务端方法就必须是线程安全的。无状态设计（因可伸缩性（scalability）好而流行）在本质上限制了交互的可能性，因为类并不需要持久化请求之间的数据。线程交互仅限于静态字段，比如在内存中缓存通用数据，或者提供认证和审计这样的基础服务时需要考虑。 实现线程安全的最后一种方式是使用自动锁机制（automatic locking regime）。如果继承 ContextBoundObject 类并使用 Synchronization 特性，.NET Framework 就可以实现这种机制。当该对象上的方法或属性被调用时，一个对象范围（object-wide）的锁就会自动作用于整个方法或属性的调用。尽管这样降低了实现线程安全的负担，但是也有它的问题：它很可能造成死锁、降低并发度并引起并非有意的重入。正是由于这些原因，手动加锁通常是更好的选择（直到有更好用的自动锁机制出现）。 3.1线程安全与 .NET Framework 类型锁可以用来将线程不安全的代码转换为线程安全的代码。.NET Framework 就是一个好例子：几乎所有的非基本类型的实例成员都不是线程安全的（对于比只读访问更高的需求），然而如果对指定对象的所有访问都通过锁进行保护，它们就可以被用于多线程代码中。例如，两个线程同时向同一个List中添加对象，然后枚举它： 12345678910111213141516171819class ThreadSafe&#123; static List &lt;string&gt; _list = new List &lt;string&gt;(); static void Main() &#123; new Thread (AddItem).Start(); new Thread (AddItem).Start(); &#125; static void AddItem() &#123; lock (_list) _list.Add (\"Item \" + _list.Count); string[] items; lock (_list) items = _list.ToArray(); foreach (string s in items) Console.WriteLine (s); &#125;&#125; 在这个例子中，我们使用_list对象本身来加锁。如果有两个关联的List，就需要选择一个公共对象来加锁（可以使用其中一个List对象，然而更好的方式是使用一个独立的字段）。 枚举 .NET 的集合也不是线程安全的，因为如果在枚举的过程中集合被修改则会抛出异常。在这个例子中，我们并没有将整个枚举过程加锁，而是首先将其中的对象复制到一个数组中。如果我们要进行的枚举可能很耗时，那么可以通过上述方式避免过长时间锁定。（另一种解决方案是使用读写锁（reader / writer lock）） 对线程安全的对象加锁有时也需要对线程安全的对象加锁，为了举例说明，假设 Framework 的List类是线程安全的，我们要给它添加一个条目： 1if (!_list.Contains (newItem)) _list.Add (newItem); 无论List本身是否线程安全，上面的语句都不是线程安全的！为了防止if条件判断执行后，在实际添加条目之前，被其它线程抢占修改了_list，整个if所包含的代码都需要封装在一个锁中。并且在所有要修改_list的地方都要使用这个锁。例如，下面的语句也需要封装在相同的锁中： 1_list.Clear(); 这也是为了确保了它不会在前面语句的执行过程中抢先执行。换句话说，我们不得不像对于非线程安全的集合一样锁定线程安全的集合（这使得对于List类是线程安全的假设变得多余）。 在高并发的环境下，对集合的访问加锁可能会产生大量阻塞，为此 Framework 4.0 提供了线程安全的队列、栈和字典。 静态成员将对对象的访问封装在一个自定义锁中的方式，只有当所有参与并发的线程都知道并使用这个锁时才能起作用。然而如果需要加锁的逻辑有更大范围那就不是这么简单了。最糟糕的情况就是public类型中的静态成员。比如，我们假设DateTime结构体上的静态属性DateTime.Now不是线程安全的，即两个并发线程调用会导致错误的输出或是异常。使用外部加锁进行修正的唯一方法就是在调用DateTime.Now之前对类型本身加锁：lock(typeof(DateTime))。这仅适用于所有的程序员都接受这样做（这不太可能）。此外，对类型加锁也有其自身的问题。 因此，DateTime结构体的静态成员都经过细致的处理，来保证它是线程安全的。这在 .NET Framework 中是一个通用模式：静态成员是线程安全的，而实例成员则不是。编写类型让别人使用时，遵守这种模式就不会令别人感到困惑和遇到难以解决的线程安全问题。换句话说，保证静态成员的线程安全，就不会妨碍你的类型的使用者实现线程安全。 静态方法的线程安全是必须由明确的编码实现的，不是说把方法写成静态的就能自动实现线程安全！ 只读线程安全使类型对于并发只读访问是线程安全的会很有益，这意味着使用者可以避免使用排它锁。许多 .NET Framework 类型都遵循这一原则：例如集合对于并发读是线程安全的。 自己遵循这一愿则也很简单：如果我们希望一个类型对于并发只读访问是线程安全的，那么不要在使用者期望是只读的方法内修改字段（也不要加锁后修改）。例如，在集合的ToArray()方法的实现中，也许会从压紧（compacting）集合的内部结构开始。然而，这会导致使用者认为是只读的操作并非线程安全。 只读线程安全也是枚举器与可枚举类型分离的原因之一：两个线程可以在一个集合上同时进行枚举，因为它们会分别获得单独的枚举器。 如果缺乏文档，在认为一个方法是只读前一定要谨慎。一个很好的例子是Random类：当调用Random.Next()时，它会更新私有的种子（seed）值。因此，或者对Random类的使用加锁，或者每个线程使用单独的实例。 3.2应用服务器中的线程安全应用服务器需要使用多线程来处理多个客户端的同时请求。WCF、ASP.NET 以及 Web Services 应用都是隐式多线程的。使用 TCP 或 HTTP 之类网络通道的远程（Remoting）服务应用程序也是如此。这意味着服务端编程必须考虑线程安全，考虑在处理客户端请求的线程间是否存在交互的可能。幸运的是，这种交互的可能性不大，一般服务端类要不然是无状态的（无字段），要不然就有为每个客户端或每个请求创建单独对象实例的激活模型。交互通常仅在静态字段上出现，有时是用于在内存中缓存数据库数据来提高性能。 例如，有一个查询数据库的RetrieveUser方法： 12// User 是一个自定义类型，包含用户数据的字段internal User RetrieveUser (int id) &#123; ... &#125; 如果对这个方法的调用很频繁，可以通过在一个静态Dictionary中缓存查询结果来提高性能。下边是一个考虑了线程安全的方案： 1234567891011121314151617static class UserCache&#123; static Dictionary &lt;int, User&gt; _users = new Dictionary &lt;int, User&gt;(); internal static User GetUser (int id) &#123; User u = null; lock (_users) if (_users.TryGetValue (id, out u)) return u; u = RetrieveUser (id); // 从数据库获取数据 lock (_users) _users [id] = u; return u; &#125;&#125; 至少必须要在读取和更新字典时加锁来保证线程安全。在这个例子中，在加锁的便捷和性能之间进行了平衡。我们的设计略有一些效率问题：如果两个线程同时使用未缓存过数据的id调用这个方法，RetrieveUser就可能被调用两次，并且其中一次对字典的更新是不必要的。对整个方法加锁可以避免这一问题，但会导致更糟的效率：整个缓存在调用RetrieveUser的期间都会被加锁，在这段时间内，其它需要这样获取用户信息的线程都会被阻塞。 3.3富客户端应用与线程亲和（译者注：这里的 thread affinity 译为线程亲和，是指 UI 控件与线程的一种“绑定”关系，而不是通常理解中的线程与 CPU 核心的绑定关系。） WPF 与 Windows Forms 库都遵循基于线程亲和的模型。尽管它们有各自的实现，但是原理非常相似。 富客户端的构成主要基于DependencyObject（WPF 中）或是Control（Windows Forms 中）。这些对象具有线程亲和性（thread affinity），意思是只有创建它们的线程才能访问其成员。违反这一原则会引起不可预料的行为，或是抛出异常。 这样的好处是访问 UI 对象时并不需要加锁。而坏处是，如果希望调用在另一线程 Y 上创建的对象 X 的成员，就必须将请求封送（marshal）到线程 Y 。通过下列方法显式实现： WPF 中：在其Dispatcher对象上调用Invoke或BeginInvoke。 Windows Forms 中：调用Control对象上的Invoke或BeginInvoke。 Invoke和BeginInvoke都接受一个委托，代表我们希望在目标控件上运行的的方法。Invoke是同步工作的：调用方在封送的委托执行完成前会被阻塞；BeginInvoke是异步工作的：调用方立即返回，封送请求被加入队列（使用与处理键盘、鼠标、定时器事件相同的消息队列）。 假定窗体包含一个名为txtMessage的文本框，我们希望使用一个工作线程更新其内容，下面是 WPF 的示例： 1234567891011121314151617181920public partial class MyWindow : Window&#123; public MyWindow() &#123; InitializeComponent(); new Thread (Work).Start(); &#125; void Work() &#123; Thread.Sleep (5000); // 模拟耗时任务 UpdateMessage (\"The answer\"); &#125; void UpdateMessage (string message) &#123; Action action = () =&gt; txtMessage.Text = message; Dispatcher.Invoke (action); &#125;&#125; Windows Forms 的代码类似，所不同的是我们调用Form的Invoke方法： 12345void UpdateMessage (string message)&#123; Action action = () =&gt; txtMessage.Text = message; this.Invoke (action);&#125; Framework 提供了两个构造来简化这个过程： BackgroundWorker 任务延续（Task continuations） 工作线程 vs UI 线程我们可以认为富客户端应用程序中有两种不同的线程类别：UI 线程和工作线程。UI 线程创建（并“占有”） UI 元素，工作线程则不会；工作线程通常执行长时间任务，例如获取数据。 大多数的富客户端应用只有一个 UI 线程（它也是应用程序的主线程），它再去根据需要创建工作线程，可以直接创建或者使用BackgroundWorker。这些工作线程可以将代码封送回主 UI 线程来更新控件或报告工作进度。 那么，应用程序何时会需要多个 UI 线程呢？主要的应用场景是：如果应用具有多个顶级窗口，每个顶级窗口都是被称为单文档界面（Single Document Interface，SDI）的程序，例如 Microsoft Word。每个 SDI 窗口通常会在任务栏上显示为独立的应用程序，并且与其它的 SDI 窗口在功能上基本隔离。通过为每一个这样的窗口设置独立的 UI 线程，可以使应用程序有更好的响应。 3.4不可变对象不可变对象的状态不能被修改，无论通过外部还是内部。不可变对象的字段通常被声明为只读的，并且在构造过程中就会被初始化好。 不变性（immutability ）是函数式编程的一个标志：不是修改对象，而是使用不同的属性创建一个新的对象。LINQ 就遵循这种模式。不变性在多线程中也很有价值，它可以通过消除（或是最小化）写入的可能来避免共享可写状态的问题。 使用不可变对象的一个模式是：封装一组相关的字段来最小化锁定的时长。下面的例子中，假设有两个字段： 12int _percentComplete;string _statusMessage; 我们希望对其进行原子的读 / 写操作。除了加锁之外，也可以定义如下的不可变类： 12345678910111213class ProgressStatus // 代表某活动进度&#123; public readonly int PercentComplete; public readonly string StatusMessage; // 这个类可能还有其它很多字段... public ProgressStatus (int percentComplete, string statusMessage) &#123; PercentComplete = percentComplete; StatusMessage = statusMessage; &#125;&#125; 然后，我们可以定义一个该类型的字段，以及一个用于加锁的对象： 12readonly object _statusLocker = new object();ProgressStatus _status; 现在，我们就可以读 / 写该类型的值，而仅需要为一次赋值加锁： 1234var status = new ProgressStatus (50, \"Working on it\");// 想象一下我们曾经在这要处理多少个字段 ...// ...lock (_statusLocker) _status = status; // 非常短暂的锁 要读取该对象，首先获取该对象的一个副本（在锁内），然后就可以读取其值而不需要继续占有锁： 12345ProgressStatus statusCopy;lock (_locker ProgressStatus) statusCopy = _status; // 也是一个短暂的锁int pc = statusCopy.PercentComplete;string msg = statusCopy.StatusMessage;// ... （译者注：上面代码有误，lock中应该是_statusLocker。这里的statusCopy也不是真正的副本，而仅仅相当于_status的别名，这么做是为了通过刷新处理器缓存，获取_status当前的一致状态。） 技术上讲，最后两行代码的线程安全，是因为之前的lock进行了隐式的内存屏障（memory barrier）。 需要注意的是，这种无锁（译者注：这里不是说完全没有用到锁，而是指锁非常短暂）的方法可以避免一组相关字段出现不一致的情况。但它无法阻止后续的操作修改数据，因此，通常需要使用锁。在第 5 部分中，将会看到使用不变性来简化多线程的更多示例，包括PLINQ。 可以根据先前的值安全的创建一个新的ProgressStatus对象（例如：在其上可以“增加”PercentComplete的值），而仅需锁定一行代码。实际上不使用锁都可以，我们可以显式使用内存屏障、Interlocked.CompareExchange还有自旋等待。这种高级技术将在稍后的并行编程中讲解。 4使用事件等待句柄进行信号同步（译者注：signal / signalling 直译是信号 / 发信号，一般在通讯领域用于控制的信号称为信令，但是计算机领域一般还是称之为信号。这里的 signaling 指使用信号进行线程同步，翻译成信号或者信号同步。） 事件等待句柄（event wait handle）用于信号同步。信号同步就是一个线程进行等待，直到它收到其它线程的通知的过程。事件等待句柄是最简单的信号构造，与 C# 的事件（译者注：指基于event关键字的事件模式）无关。它们有三个成员：AutoResetEvent、ManualResetEvent以及CountdownEvent( Framework 4.0 中加入)。前两个的功能基本都是在它们的基类EventWaitHandle上实现的。 信号构造比较 构造 用途 跨进程 开销* AutoResetEvent 使线程在收到其它线程信号时解除阻塞一次 yes 1000ns ManualResetEvent 使线程在收到其它线程信号时解除阻塞，并且不继续阻塞直到被复位 yes 1000ns ManualResetEventSlim（Framework 4.0 中加入） - 40ns CountdownEvent（Framework 4.0 中加入） 使线程在收到预定数量的信号时解除阻塞 - 40ns Barrier（Framework 4.0 中加入） 实现线程执行屏障 - 80ns Wait 和 Pulse 使线程阻塞，直到自定义条件被满足 - 120ns每个Pulse * 时间代表在同一线程上进行发信号并等待（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。 4.1AutoResetEventAutoResetEvent就像验票闸机：插入一张票，就只允许一个人通过。类名字里的 “ auto “ 是指打开的闸门可以自动关闭，或着说在有人通过后 “reset （复位）”。在闸机处调用WaitOne方法（等待这 “one（一个）” 闸机打开），线程就会进入等待或者说阻塞。票的插入则通过调用Set方法。如果有多个线程调用WaitOne，便会在闸机前排队（与锁同样，由于操作系统的差异，这个等待队列的先入先出顺序有时可能被破坏）。票可以来自任意线程，换句话说，任何能够访问这个AutoResetEvent对象的（非阻塞）线程都可以调用Set方法来放行一个被阻塞的线程。 有两种方式可以创建AutoResetEvent对象，第一种是通过构造方法： 1var auto = new AutoResetEvent (false); （如果传递ture给构造方法则相当于在创建后立即调用Set方法。） 第二种方式是像下边的代码这样创建AutoResetEvent： 1var auto = new EventWaitHandle (false, EventResetMode.AutoReset); 在接下来的例子中，一个线程开始等待直到收到另一个线程的信号。 1234567891011121314151617class BasicWaitHandle&#123; static EventWaitHandle _waitHandle = new AutoResetEvent (false); static void Main() &#123; new Thread (Waiter).Start(); Thread.Sleep (1000); // 暂停 1 秒 _waitHandle.Set(); // 唤醒 Waiter &#125; static void Waiter() &#123; Console.WriteLine (\"Waiting...\"); _waitHandle.WaitOne(); // 等待通知 Console.WriteLine (\"Notified\"); &#125; 输出结果： 1Waiting... (pause) Notified. 如果在没有线程等待的时候调用Set，该事件等待句柄会保持“打开”状态直到有线程调用WaitOne。这个行为可以帮助避免一个前往闸机的线程和一个正在插入票的线程之间的配合问题（“糟糕，票早插入了 1 微秒，真不幸，你要永远等下去了！”）。然而，在一个没有任何线程在等待的闸机上反复调用Set并不会允许一堆线程通过：仅仅允许下一个通过，多出来的票被“浪费”了。 在AutoResetEvent上调用Reset可以关闭闸机（应该是开启状态的），这个调用不会等待或阻塞。 WaitOne接受一个可选的timeout参数，如果等待不是由于收到了信号，而是超时结束则返回false。 调用WaitOne并给定一个为 0 的超时时间，可以用来测试等待句柄是否是“打开”的，并且不会阻塞调用方。但是要记住，如果AutoResetEvent是打开的则会复位（关闭）它。 销毁等待句柄（译者注：这里把 dispose 翻译为销毁。） 一旦等待句柄使用完成，可以调用它的Close方法来释放操作系统资源。或者，也可以简单地丢弃所有对等待句柄的引用，让垃圾回收器在稍后处理它（等待句柄实现了销毁模式，会在析构方法中调用Close）。这是少数几个能被接受的（有争论）依赖这种备用机制的场景之一，因为等待句柄对操作系统而言是轻量级资源（异步委托（asynchronous delegates）就是这样来释放其IAsyncResult的等待句柄的 ）。 等待句柄在应用程序域被卸载时会自动地释放。 双向信号我们设定一种场景：主线程需要连续向工作线程发 3 次信号。如果主线程只是在等待句柄上快速的多次调用Set，第 2 个和第 3 个信号可能会丢失，这是由于工作线程可能要花时间去处理每个信号。 解决方案是：主线程需要在发信号前等待工作线程就绪。这可以再用一个AutoResetEvent做到，例如： 12345678910111213141516171819202122232425262728293031323334353637class TwoWaySignaling&#123; static EventWaitHandle _ready = new AutoResetEvent (false); static EventWaitHandle _go = new AutoResetEvent (false); static readonly object _locker = new object(); static string _message; static void Main() &#123; new Thread (Work).Start(); _ready.WaitOne(); // 首先等待工作线程就绪 lock (_locker) _message = \"ooo\"; _go.Set(); // 通知工作线程执行 _ready.WaitOne(); lock (_locker) _message = \"ahhh\"; // 给工作线程其它信息 _go.Set(); _ready.WaitOne(); lock (_locker) _message = null; // 发信号通知工作线程退出 _go.Set(); &#125; static void Work() &#123; while (true) &#123; _ready.Set(); // 表示我们准备好了 _go.WaitOne(); // 等待开始 lock (_locker) &#123; if (_message == null) return; // 优雅地退出 Console.WriteLine (_message); &#125; &#125; &#125;&#125; 输出结果： 12oooahhh 这里我们使用了一个为null的消息来指示工作线程结束。对于无限运行（译者注：指类似这里的while (true)方式无限循环）的线程，退出机制是非常重要的！ 生产者 / 消费者队列生产者 / 消费者队列是一个在多线程中常见的需求，它是这样工作的： 建立一个队列，用于描述需要执行的工作项，或需要处理的数据。 当有任务需要执行时，把它加入队列中，这样调用方就可以继续处理其它事情。 一个或多个工作线程在后台工作，它们从队列中取出工作项并执行。 这种模型的好处是，可以精确控制工作线程的数量，使你能够限制 CPU 和其它资源的消耗。比如，如果任务执行密集的磁盘 I/O 操作，可以仅使用一个工作线程来执行工作，这样能够避免操作系统和其它应用出现饥饿。其它类型的应用也许就可以使用 20 个工作线程。也可以在队列生命周期内动态添加和移除工作线程。CLR 的线程池本身就是一种生产者 / 消费者队列。 生产者 / 消费者队列一般只是存放需要任务处理的数据项，例如数据项可能是文件名，而任务是加密这些文件。 下边的例子，使用一个AutoResetEvent发信号给工作线程，工作线程在所有任务都已完成时（或者说队列为空时）会处于等待状态。通过加入null任务来通知工作线程结束： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Threading;using System.Collections.Generic;class ProducerConsumerQueue : IDisposable&#123; EventWaitHandle _wh = new AutoResetEvent (false); Thread _worker; readonly object _locker = new object(); Queue&lt;string&gt; _tasks = new Queue&lt;string&gt;(); public ProducerConsumerQueue() &#123; _worker = new Thread (Work); _worker.Start(); &#125; public void EnqueueTask (string task) &#123; lock (_locker) _tasks.Enqueue (task); _wh.Set(); &#125; public void Dispose() &#123; EnqueueTask (null); // 通知消费者退出 _worker.Join(); // 等待消费者线程完成执行 _wh.Close(); // 释放所有系统资源 &#125; void Work() &#123; while (true) &#123; string task = null; lock (_locker) if (_tasks.Count &gt; 0) &#123; task = _tasks.Dequeue(); if (task == null) return; &#125; if (task != null) &#123; Console.WriteLine (\"Performing task: \" + task); Thread.Sleep (1000); // 模拟执行工作... &#125; else _wh.WaitOne(); // 没有任务了，等待信号 &#125; &#125;&#125; 为保证线程安全，我们使用了一个锁来保护对Queue&lt;string&gt;的访问。在Dispose方法中，我们也显式关闭了等待句柄，因为在程序生命周期中，有可能会创建和销毁许多这个类的实例。 下边是测试这个队列的主方法： 123456789101112static void Main()&#123; using (ProducerConsumerQueue q = new ProducerConsumerQueue()) &#123; q.EnqueueTask (\"Hello\"); for (int i = 0; i &lt; 10; i++) q.EnqueueTask (\"Say \" + i); q.EnqueueTask (\"Goodbye!\"); &#125; // 使用 using 语句结束时会调用 q 的 Dispose 方法 // 该方法向队列中插入一个 null 的任务，并等待消费者完成退出。&#125; 输出结果： 12345678Performing task: HelloPerforming task: Say 1Performing task: Say 2Performing task: Say 3......Performing task: Say 9Goodbye! Framework 4.0 提供了一个新的类型BlockingCollection，它实现了生产者 / 消费者队列的功能。 前面我们自己写的生产者 / 消费者队列还是有价值的，它不仅仅为了举例说明AutoResetEvent和线程安全，也是更多其它复杂构造的基础。例如，如果想要实现有界阻塞队列（bounded blocking queue）（可以限制队列中任务的个数），并且希望支持取消（和移除）队列中工作项，我们的代码就是一个很好的起点。之后在讨论Wait 和 Pulse时会让这个的生产者 / 消费者队列的例子更进一步。 4.2ManualResetEventManualResetEvent就像一个普通的门。调用Set方法打开门，允许任意数量的线程调用WaitOne方法来通过。调用Reset方法关闭门。如果线程在一个关闭的门上调用WaitOne方法将会被阻塞，当门下次打开时，会被立即放行。除这些不同以外，ManualResetEvent就和AutoResetEvent差不多了。 与AutoResetEvent类似，可以使用两种方式构造ManualResetEvent: 12var manual1 = new ManualResetEvent (false);var manual2 = new EventWaitHandle (false, EventResetMode.ManualReset); 从 Framework 4.0 开始，提供了另一个版本的ManualResetEvent，名为ManualResetEventSlim。后者为短等待时间做了优化，它提供了进行一定次数迭代自旋的能力，也实现了一种更有效的管理机制，允许通过CancellationToken取消Wait等待。但它不能用于跨进程的信号同步。ManualResetEventSlim不是WaitHandle的子类，但它提供一个WaitHandle的属性，会返回一个基于WaitHandle的对象（使用它的性能和一般的等待句柄相同）。 信号构造与性能对于AutoResetEvent和ManualResetEvent，使用它们等待或者发信号需要大概 1 微秒时间（假设没有阻塞）。 ManualResetEventSlim和CountdownEvent在等待时间很短的情况下可以比上面两个快 50 倍。这是因为它们不依赖操作系统，并能择机使用自旋构造。 然而大多数情况下，信号构造自身的开销并不会造成瓶颈，所以很少需要去考虑。高度并发的场景是个例外，我们将在第 5 部分进行讨论。 ManualResetEvent在需要让一个线程解除其它多个线程的阻塞时有用。如果是相反的需求，可以使用CountdownEvent。 4.3CountdownEventCountdownEvent 可以让你等待 1 个以上的线程。这个类型是 Framework 4.0 加入的，并且是一个高效的纯托管实现。 如果在使用较早版本的 .NET Framework，也不是没有办法。稍后我们会介绍如何使用Wait 和 Pulse来实现CountdownEvent。 使用CountdownEvent时，需要指定一个计数器数值，也就是你希望等待的线程数量： 1var countdown = new CountdownEvent (3); // 初始计数为 3 调用Signal方法会将计数减 1，调用Wait会阻塞直到计数为 0。例如： 123456789101112131415161718static CountdownEvent _countdown = new CountdownEvent (3);static void Main()&#123; new Thread (SaySomething).Start (\"I am thread 1\"); new Thread (SaySomething).Start (\"I am thread 2\"); new Thread (SaySomething).Start (\"I am thread 3\"); _countdown.Wait(); // 阻塞直到收到 3 次信号 Console.WriteLine (\"All threads have finished speaking!\");&#125;static void SaySomething (object thing)&#123; Thread.Sleep (1000); Console.WriteLine (thing); _countdown.Signal();&#125; 有时通过使用结构化并行（structured parallelism）构造会比CountdownEvent更容易解决问题。我们将在第 5 部分来说明（PLINQ 和 Parallel类）。 调用AddCount，可以增加CountdownEvent的计数。然而，如果计数已经为 0，就会抛出一个异常：是无法通过调用AddCount来复位（unsignal）的。为避免异常，可以用TryAddCount替代，它在当前计数为 0 时会返回false。 想要复位，可以调用Reset：把构造复位到初始状态，计数恢复原值。 像ManualResetEventSlim一样，CountdownEvent也提供WaitHandle属性，可以在其它类或方法希望得到一个基于WaitHandle的对象时使用。 4.4创建跨进程的 EventWaitHandleEventWaitHandle的构造方法允许以命名的方式进行创建，这样它就可以跨进程使用。名称就是一个字符串，可以随意起名，但是注意不要和别人的命名冲突！如果名字在计算机上已存在，你就会获取一个它对应的EventWaitHandle的引用，否则操作系统会创建一个新的。例如： 12EventWaitHandle wh = new EventWaitHandle (false, EventResetMode.AutoReset, \"MyCompany.MyApp.SomeName\"); 如果两个应用程序分别执行这个代码，它们就可以进行信号同步：这个等待句柄可以在跨这两个进程内的所有线程中使用。 4.5等待句柄和线程池如果你的应用有很多线程，这些线程大部分时间都在阻塞，那么可以通过调用ThreadPool.RegisterWaitForSingleObject来减少资源消耗。这个方法接受一个委托，它会在向等待句柄发信号时执行。当处于等待状态时，它不会浪费线程资源： 123456789101112131415161718static ManualResetEvent _starter = new ManualResetEvent (false);public static void Main()&#123; RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject (_starter, Go, \"Some Data\", -1, true); Thread.Sleep (5000); Console.WriteLine (\"Signaling worker...\"); _starter.Set(); Console.ReadLine(); reg.Unregister (_starter); // 完成后的清理&#125;public static void Go (object data, bool timedOut)&#123; Console.WriteLine (\"Started - \" + data); // 执行任务 ....&#125; 输出结果： 123(5 second delay)Signaling worker...Started - Some Data 当向等待句柄发信号时（或者已超时），委托会在一个线程池线程运行。 除等待句柄和委托外，RegisterWaitForSingleObject还接受一个“黑盒”对象，它会被传递给委托的目标方法（像ParameterizedThreadStart一样）；还有一个以毫秒为单位的超时时间（-1 代表没有超时时间）；和一个布尔值用来设置请求是一次性的还是可重复的。 RegisterWaitForSingleObject在需要处理很多并发请求的应用服务器中非常有用。假如你需要在ManualResetEvent上阻塞，调用WaitOne就可以了： 12345void AppServerMethod()&#123; _wh.WaitOne(); // ... 继续执行&#125; 如果 100 个客户端调用这个方法，就会有 100 个服务端线程被浪费在阻塞上。把_wh.WaitOne换成RegisterWaitForSingleObject可以让方法立即返回，就不会浪费线程资源： 1234567891011void AppServerMethod&#123; RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject (_wh, Resume, null, -1, true); // ...&#125;static void Resume (object data, bool timedOut)&#123; // ... 继续执行&#125; 传递给Resume的data对象可以用来传递和暂存一些瞬态数据。 4.6WaitAny、WaitAll 和 SignalAndWait除了Set、WaitOne和Reset方法外，在WaitHandle类上还有一些静态方法用来解决更复杂的同步问题。 WaitAny、WaitAll和SignalAndWait方法可以向多个等待句柄发信号和进行等待操作。等待句柄可以是不同的类型（包括Mutex和Semaphore，因为它们都派生自抽象类WaitHandle）。对于ManualResetEventSlim和CountdownEvent，也可以通过它们的WaitHandle属性来让这些方法使用。 WaitAll和SignalAndWait与旧有的 COM 架构有古怪的联系：这些方法要求调用方必须在多线程套间（multithreaded apartment）中，这个模式最不适合交互操作。比如 WPF 或 Windows 应用程序的主线程就不能在这种模式下操作剪贴板。我们稍后会讨论到它们的替代方案。 WaitHandle.WaitAny等待一组等待句柄中任意一个，WaitHandle.WaitAll等待给定的所有等待句柄。这个等待是原子的，就是说如果在等待两个AutoResetEvent： WaitAny当任意一个事件处于“打开”状态时就能结束等待。 WaitAll当两个事件同时处于“打开”状态时才能结束等待。 （译者注：见前文，AutoResetEvent在被Set时，如果没有线程在等待，会保持“打开”状态，直到有线程等待它，会放行一个线程，并“关闭”或者说“复位”。这里用WaitAny等待两个AutoResetEvent，那么它只会触发其中一个的复位，另一个如果也被Set，会继续保持“打开”；而如果是WaitAll，则必须两个都处于“打开”状态才能结束等待，同时触发两个事件的复位。） SignalAndWait会调用一个WaitHandle的Set方法，然后调用另一个WaitHandle的WaitOne方法。在向第一个句柄发信号后，会（让当前线程）跳到第二个句柄的等待队列的最前位置。你可以把它看作是“交换”两个信号，在一对EventWaitHandle上调用这个方法来设定两个线程的会合点（rendezvous），或者说是让它们在某一个时间点“相遇”。不管是AutoResetEvent还是ManualResetEvent都可以用来实现这个技巧。第一个线程执行： 1WaitHandle.SignalAndWait (wh1, wh2); 而第二个线程相反： 1WaitHandle.SignalAndWait (wh2, wh1); WaitAll 和 SignalAndWait 的替代方案WaitAll和SignalAndWait不能运行在单线程套间（single-threaded apartment）中。幸运的是，还有替代方案。对于SignalAndWait，其实很少需要它的插队机制：例如在上边的会合例子中，如果等待句柄完全只是为了会合使用，那么就可以在第一个句柄上调用Set，然后在第二个句柄上调用WaitOne。在Barrier类中，我们将探索实现线程会合的另外一个方法。 对于WaitAll，有时可以使用Parallel 类的 Invoke 方法来替代，这个我们将在第 5 部分讨论。（我们也会讨论Task和任务延续（continuations），以及如何使用TaskFactory的ContinueWhenAny作为WaitAny的替代。） 对于其它情况，答案是使用底层的方法来解决所有信号同步问题：见Wait 和 Pulse。 5同步上下文（译者注：这里的同步上下文（synchronization context）并不是指System.Threading.SynchronizationContext类。而是指 CLR 的自动锁机制中的同步域或者说加锁的范围。） 对于手动锁定，另一种实现方案是使用声明方式（declaratively）来锁定。通过从ContextBoundObject类派生并添加Synchronization特性，可以指示 CLR 自动加锁。例如： 12345678910111213141516171819202122232425using System;using System.Threading;using System.Runtime.Remoting.Contexts;[Synchronization]public class AutoLock : ContextBoundObject&#123; public void Demo() &#123; Console.Write (\"Start...\"); Thread.Sleep (1000); // 这里我们无法抢占 Console.WriteLine (\"end\"); // 感谢自动锁 &#125;&#125;public class Test&#123; public static void Main() &#123; AutoLock safeInstance = new AutoLock(); new Thread (safeInstance.Demo).Start(); new Thread (safeInstance.Demo).Start(); safeInstance.Demo(); //并发调用 Demo 3 次 &#125;&#125; 输出结果： 123Start... endStart... endStart... end CLR 确保了同一时刻只有一个线程可以执行 safeInstance中的代码。它通过创建了一个同步对象，并在每次调用safeInstance的方法和属性时进行锁定来实现。锁的作用范围，在这里是指safeInstance对象，被称为同步上下文（synchronization context）。 那么，它是如何工作的呢？一个线索是Synchronization特性的命名空间：System.Runtime.Remoting.Contexts。ContextBoundObject可以被认为是一个“远程（remote）”对象，这意味着所有方法的调用都是会被拦截。为了实现这种拦截，当我们实例化AutoLock时，CLR 自动返回了一个具有相同方法和属性的AutoLock的代理对象，它扮演着中间人角色。自动锁定就是在中间人上进行的。总的来说，这种拦截会在每次方法调用时增加大概 1 微秒的开销。 自动同步不能用于保护静态成员，也不能用于非派生自 ContextBoundObject的类。（例如：Windows Forms 窗体） 锁在内部以相同的方式运作，可以期待下面的例子与之前的有一样的结果： 1234567891011121314151617181920212223[Synchronization]public class AutoLock : ContextBoundObject&#123; public void Demo() &#123; Console.Write (\"Start...\"); Thread.Sleep (1000); Console.WriteLine (\"end\"); &#125; public void Test() &#123; new Thread (Demo).Start(); new Thread (Demo).Start(); new Thread (Demo).Start(); Console.ReadLine(); &#125; public static void Main() &#123; new AutoLock().Test(); &#125;&#125; （注意我们偷偷加了Console.ReadLine语句。）因为这个类的对象在同一时间只有一个线程可以执行代码，三个新线程将阻塞在Demo方法处，直到Test 方法完成，也就是要等待ReadLine完成。因此只有在按了回车键之后，才会得到和之前一样的结果。这种线程安全的重型武器足以阻碍所有类内部的多线程！ 此外，我们仍未解决之前描述的一个问题：如果AutoLock是一个集合类，如果在其它类中执行下面的代码，那么仍然需要加锁： 1if (safeInstance.Count &gt; 0) safeInstance.RemoveAt (0); 除非执行这段代码的类本身也是一个同步的ContextBoundObject！ 同步上下文的作用域可以扩展到超过单一对象的范围。默认情况下，如果一个同步对象在另一个类中被实例化，它们会共享同一个同步上下文（换言之，就是一个巨大的锁！）。这个行为可以通过在Synchronization特性构造方法中使用一个整型标识来改变，可以使用下列SynchronizationAttribute类中定义的常量之一： 常量 作用 NOT_SUPPORTED 相当于不使用Synchronized特性 SUPPORTED 如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则保持非同步状态 REQUIRED（默认值） 如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则创建新的同步上下文 REQUIRES_NEW 始终创建新的同步上下文 所以如果SynchronizedA在SynchronizedB中被实例化，而SynchronizedB使用下面这种声明的话，它们就有各自的同步上下文： 12[Synchronization (SynchronizationAttribute.REQUIRES_NEW)]public class SynchronizedB : ContextBoundObject &#123; // ... 越大的同步上下文越容易管理，但是并发的可能性就越低。另一方面，分离的同步上下文则容易造成死锁，例如： 1234567891011121314151617181920[Synchronization]public class Deadlock : ContextBoundObject&#123; public Deadlock Other; public void Demo() &#123; Thread.Sleep (1000); Other.Hello(); &#125; void Hello() &#123; Console.WriteLine (\"hello\"); &#125;&#125;public class Test&#123; static void Main() &#123; Deadlock dead1 = new Deadlock(); Deadlock dead2 = new Deadlock(); dead1.Other = dead2; dead2.Other = dead1; new Thread (dead1.Demo).Start(); dead2.Demo(); &#125;&#125; 因为两个Deadlock的实例都是在Test中创建的，而Test是非同步类，所以这两个实例会拥有它自己的同步上下文，因此有它自己的锁。当它们互相调用的时候，用不了多久就会死锁（确切的说是一秒！）。如果Deadlock和 Test是由不同的开发团队写的，这个问题会藏的很深。别指望负责Test的团队能意识到他们犯了什么错，更别指望能知道如何解决了。而对于显式的加锁，死锁的原因通常更容易被发现。 5.1重入（译者注：在单线程场景下，方法没有退出前自身再被调用也是重入，比如显式的递归调用，或者隐式的通过消息队列机制等等，这种重入和作者讨论的多线程场景下的重入并不是完全相同的概念。） 线程安全方法有时也被称为可重入的（reentrant），因为它可能在执行中途被抢占，然后在另外的线程再被调用也不会有问题。在一般意义上，线程安全和可重入是同义词或者是密切相关的。 然而，在自动锁机制下，重入有另一个更危险的潜在问题。如果Synchronization特性的reentrant参数为true： 1[Synchronization(true)] 那么在执行离开上下文时，同步上下文的锁会被临时释放。在之前的例子中，这可以防止死锁的发生，当然是符合我们期望的。但是，一个副作用是，在过渡期间，任何线程都可以自由的调用原对象上的任何方法（重新进入（re-entering）同步上下文），这会导致多线程编程异常复杂，应该极力避免它。这就是可重入的问题。 因为[Synchronization(true)]作用于类上，就导致了类中所有会离开同步上下文的方法调用都会带来可重入的副作用问题。 虽然可重入可能是危险的，但有些时候几乎没有其它选择。例如，在一个同步类内部实现了多线程，方法是通过委托把逻辑交给运行在其它同步上下文中的工作线程。如果没有重入，那么工作线程就可能会导致彼此之间或是原线程的阻塞。 这凸显了自动同步的一个基本缺点：范围过大的锁定作用域将制造出巨大的麻烦：死锁、可重入以及降低并发度。这使得手动锁定在任何场景都显得更为合适，而并不仅仅只在简单的场景下。 原文：http://www.albahari.com/threading/part2.aspx翻译：https://blog.gkarch.com/threading/part2.html","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://luox78.github.io/tags/thread/"}]},{"title":"初识JavaScript03","slug":"JavaScript03","date":"2017-12-31T11:50:33.903Z","updated":"2018-01-04T13:54:33.153Z","comments":true,"path":"2017/12/31/JavaScript03/","link":"","permalink":"https://luox78.github.io/2017/12/31/JavaScript03/","excerpt":"Array对象 js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组 赋值","text":"Array对象 js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组 赋值 123456789101112131415//1var arr = new Array(3); arr[0] = 0; arr[1] = 1; arr[2] = 2; alert(arr);//0,1,2 arr[3] = 3;//0,1,2,3 alert(arr); //2 for(var i=0;i&lt;5;i++)&#123; arr[i]=i; &#125; //3 var arr=[1,2,3,\"string\"]; var arr=new Array(1,2,3,\"string\"); Json(键值对)12345var arr=&#123;\"gender\":\"male\",\"name\":\"luox78\",\"age\":18&#125;;for(var key in arr)&#123; alert(key+arr[key]); //取值的另一种方式 arr.key&#125; 原型 相当于C#拓展方法 注意：不能跨script标签使用 123456//简易的邮箱判断String.prototype.checkEmail=function()&#123; return this.indexOf(\"@\")&gt;0?true:false;&#125;;var str=\"111@163.com\";alert(str.checkEmail());//true; DOM DOM document object model 为什么要有dom为了更方便的操作html。DOM就是把Html页面模拟成一个对象，就像XDocument一样，把Xml模拟成了一个对象，提供了操作各个节点的方法，直接调用就可以了。 window，document对象 window代表浏览器整个窗口，alert等操作只能用window操作(window可以省略) document代表整个页面，只能操作页面元素 ，及内置方法 1234window.alert(\"hello\");var n=90;window.alert(window.n);//90document.getElementById('btn').id; 但通过window获取元素时会碰到一个问题，就是元素嵌套必须一层一层访问，如访问form中的buttonwindow.form1.btn.id，此时应该使用document对象简化操作,document.getElementById(&#39;btn&#39;).id document演示1234567//当click时先弹出body area 然后才是html body 涉及事件冒泡document.body.onmousedown=function()&#123; alert(\"body area\");&#125;document.onmousedown=function()&#123; alert(\"html area\");&#125; window常见方法 window.alert(&#39;大家好!&#39;);//弹出警告对话框 window.confirm(&#39;确定要删除吗？&#39;);//确定、取消对话框，返回true或false; 123456789101112&lt;body&gt; &lt;input type=\"button\" id=\"btn3\"/&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(\"btn3\").onclick= function() &#123; if (window.confirm(\"Are you sure to delete?\")) &#123; alert(\"delete success\"); &#125; else &#123; alert(\"delete failed\"); &#125; &#125;&lt;/script&gt; window.navigate(url);//将网页重新导航到url,只支持IE、Opera11.6,建议使用window.location.href=&#39;url&#39;;//支持大多数浏览器 123456window.onload = function() &#123; window.navigate(\"https://luox78.github.io\"); &#125;//基本上都不行window.onload = function () &#123; window.location.href = \"https://luox78.github.io\"; &#125;//推荐使用 window.setInterval(function,delay)每个delay ms执行一次 setTimeout(function,delay)只会执行一次，clearTimeout(setId)是为了清理占用的内存 1234567891011//botton value自增例子&lt;script&gt; var num = parseInt(document.getElementById(\"btn\").value); var setId = setInterval(function () &#123; document.getElementById(\"btn\").value = num++; &#125;, 1); document.getElementById(\"btn\").onclick= function() &#123; clearInterval(setId);//计时器一旦被销毁不能再创建 &#125;&lt;/script&gt; 事件 跟C#中事件，委托差不多 注意点： 事件=函数名，等于给事件赋值不会调用 事件=函数名（），会执行一次函数，这种赋值其实并不正确，事件应该不能等于函数返回值 &lt;body&gt;中 123456&lt;body&gt; &lt;input type=\"button\" id=\"btn\"/&gt; &lt;input type=\"button\" onclick=\"f1();\" /&gt; &lt;input type=\"button\" onclick=f1 /&gt; &lt;input type=\"button\" id=\"btn2\" value=\"change method\"/&gt;&lt;/body&gt; onclick=f1;的意思就是说onclick触发的方法就是f1. onclick=“f1();”的意思就是说onclick直接调用window.f1(); &lt;script&gt;中 12345678910111213&lt;script&gt; function f1() &#123; alert(\"f1\"); &#125; function f3() &#123; alert(\"f3\"); &#125; document.getElementById(\"btn\").onclick = f1; document.getElementById(\"btn2\").onclick = function() &#123; document.getElementById(\"btn\").onclick = f3; alert(\"change completed\"); &#125;&lt;/script&gt; body、document对象的事件 window.onload 网页加载完毕时触发，浏览器是一边下载文档、一边解析执行，可能会出现JavaScript执行时需要操作某个元素，这个元素还没有加载，如果这样就要把操作的代码放到body的onload事件中，或者可以把JavaScript放到元素之后。元素的onload事件是元素自己加载完毕时触发，body onload才是全部加载完成 window.控件Id（不建议使用),document.getElementById(“控件Id”);(推荐) onunload（页面卸载后触发） 网页关闭（或者离开）后触发。//刷新页面的时候、关闭选项卡的时候（多个选项卡） onbeforeunload（页面卸载前触发） 在网页准备关闭（或者离开）前触发。//注意浏览器缓存 &lt;bodyonbeforeunload=“return ‘真的要放弃发帖退出吗?’; ”&gt;。显示的文字随浏览器版本而有差异。// =“window.event.returnValue=‘’只兼容IE 除了属性之外，当然还有通用的HTML元素的事件：onclick（单击）、ondblclick（双击）、onkeydown（按键按下）、onkeypress（点击按键）、onkeyup（按键释放）、onmousedown（鼠标按下）、onmousemove（鼠标移动）、onmouseout（鼠标离开元素范围）、onmouseover（鼠标移动到元素范围）、onmouseup（鼠标按键释放）、oncontextmenu（在浏览器中单击鼠标右键显示”右键菜单”时触发）等。 window对象事件,属性 window.location window.location.href=‘’;//重新导航到新页面,可以取值，也可以赋值。 window.location.reload();//刷新当前页 window.event 123456789&lt;script&gt; document.getElementById(\"dv\").onmousedown= function() &#123; if (window.event.shiftKey) &#123; alert(\"you have pressed the shift\"); &#125; else &#123; alert(\"only mouse click\"); &#125; &#125;&lt;/script&gt; window.event.shiftKey .ctrlKey .altKey etc 获取是否按下某键 clientX、clientY发生事件时鼠标在客户区域的坐标(指显示html区域)； screenX、screenY发生事件时鼠标在屏幕上的坐标； offsetX、offsetY发生事件时鼠标相对于事件源（比如点击按钮时触发onclick）的坐标。当页面中有&lt;!DOCTYPE（文档定义）时，对offsetX和offsetY单击时的解析不同(使用onmousedown的时候与onclick测试结果不同)（单击按钮中文字的时候。） (window.event.returnValue)returnValue属性，如果将returnValue设置为false，就会取消默认事件的处理。在超链接的onclick里面禁止访问href的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。(onsubmit=&quot;window.event.returnValue=false;&quot;) •window.event.returnValue不兼容火狐浏览器 •FireFox:e. preventDefault();取消事件的默认动作。 •直接写return false;IE、FF、Chrome都可以。 window.event.button，发生事件时鼠标按键，IE:1为左键，2为右键，4中滑轮,3左右键同时按下//要测试event.button的值的时候，请在onmousedown事件中测试 ​ window.screen对象，获取屏幕的信息 1234window.onload= function() &#123; alert(screen.width); alert(screen.height); &#125; clipboardData 对象，对粘贴板的操作 onpaste,oncopy事件 12345678910&lt;script&gt; document.body.oncopy = function () &#123; alert(\"forbid copy\"); return false; &#125; document.body.onpaste= function() &#123; alert(\"forbid paste\"); return false; &#125;&lt;/script&gt; window.clipboardData.getData``window.clipboardData.setData已弃用，新的粘贴复制方法下面介绍 ​ js实现各种复制到剪贴板的方法一、实现点击按钮，复制文本框中的的内容 12345678&lt;script type=\"text/javascript\"&gt; function copyUrl2() &#123; var Url2 = document.getElementById(\"biao1\"); Url2.select(); // 选择对象 document.execCommand(\"Copy\"); // 执行浏览器复制命令 alert(\"已复制好，可贴粘。\"); &#125;&lt;/script&gt; 二、点击文本框时，复制文本框里面的内容 123456789&lt;input onclick=\"oCopy(this)\" value=\"你好.要copy的内容!\"&gt;&lt;script language=\"javascript\"&gt; function oCopy(obj) &#123; obj.select(); js = obj.createTextRange(); js.execCommand(\"Copy\") alert(\"复制成功!\"); &#125;&lt;/script&gt; 三、复制文本框或者隐藏域中的内容 12345678910111213141516&lt;script language=\"javascript\"&gt; function CopyUrl(target) &#123; target.value = myimg.value; target.select(); js = myimg.createTextRange(); js.execCommand(\"Copy\"); alert(\"复制成功!\"); &#125; function AddImg(target) &#123; target.value = \"[IMG]\" + myimg.value + \"[/ img]\"; target.select(); js = target.createTextRange(); js.execCommand(\"Copy\"); alert(\"复制成功!\"); &#125;&lt;/script&gt; 四、复制 span 标记中的内容 123456789101112&lt;script type=\"text/javascript\"&gt; function copyText(obj) &#123; var rng = document.body.createTextRange(); rng.moveToElementText(obj); rng.scrollIntoView(); rng.select(); rng.execCommand(\"Copy\"); rng.collapse(false); alert(\"复制成功!\"); &#125;&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"初识JavaScript02","slug":"JavaScript02","date":"2017-12-28T13:39:52.479Z","updated":"2017-12-31T14:26:24.140Z","comments":true,"path":"2017/12/28/JavaScript02/","link":"","permalink":"https://luox78.github.io/2017/12/28/JavaScript02/","excerpt":"js中的事件1 通过调用方法名或在“”内部写2 通过id，使用document.getElementById实现事件","text":"js中的事件1 通过调用方法名或在“”内部写2 通过id，使用document.getElementById实现事件 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;input id=\"btn\" type=\"button\" value=\"show time\" onclick=\"alert(new Date().toLocaleString());\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"show time\" onclick=\"f1();\" /&gt; &lt;input id=\"btn3\" type=\"button\" value=\"show time\" /&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"#\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"javascript:void(0);\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"javascript:alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //alert(new Date().toLocaleString()); function f1() &#123; alert(new Date().toLocaleDateString()); &#125; document.getElementById('btn3').onclick = function f2() &#123; alert(new Date().toLocaleDateString()); &#125; //script 写在上面要加一个窗体以加载事件以防止报错 window.onload = function () &#123; document.getElementById('btn3').onclick = function f2() &#123; alert(new Date().toLocaleDateString()); &#125; &#125;&lt;/script&gt; js调试1 直接在vs中点调试，下断点2 直接在浏览器中调试，按f12-调试 js中的函数1 JavaScript中声明函数的方式：（无需声明返回值类型） 1234567function add(i1, i2) &#123; return i1 + i2; //如果不写return返回的是undefined &#125;int add(int i1,int i2)//C#写法 2 不需要声明返回值类型、参数类型。函数定义以function开头。 1234567var r = add(1, 2);alert(r);r = add(\"你好\", \"tom\");alert(r); 3 JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。 4 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectAll、focus等函数名不要用。//不要与系统函数重名。(在单击事件中调用自己定义的focus方法，有问题。与系统的focus()方法重名了) 注意点1 js方法小写开头 2 js中定义名字的方法没有返回值接受到的是undefined 3 js不支持方法重载，只认最后一个 12345678function add(n1,n2) &#123; return n1 + n2; &#125; function add(n1, n2, n3) &#123; return n1 + n2 + n3; &#125; alert(add(1, 2));//NaN,此时调用的三个参数的add，n3位undefined，导致最后结果为NaN 12345678function add(n1, n2, n3) &#123; return n1 + n2 + n3; &#125; function add(n1, n2) &#123; return n1 + n2; &#125; alert(add(1, 2, 3));//3 通过arguments实现传入多个值123456789function add() &#123; var sum = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum; &#125; alert(add(10, 20, 30));//60 4 return写成return {Name:’yzk’,Age:18};而不要写成： 12345return&#123; Name:’yzk’, Age:18&#125; 原因是js会在语句末尾自动增加”分号”，如果将大括号另起一行，则return语句后自动增加“分号”后，返回值就变成了undefined了。 5 12345var x = 10;function add(n) &#123; n = n + 1; return n &#125;alert(add(x));//4 js搜索的是整个页面的方法，当出现重名的方法，js会使用最后一个（一般是同一个script标签中，涉及加载问题）function add(n) &#123; n = n + 3; return n; &#125;alert(add(x));//4 匿名函数 为了解决方法名冲突（主要是导入文件） 1 写法一 123456//js为动态类型，只有运行时才知道方法有没有返回值，所以f此时代表的是方法 var f = function (n) &#123; return n + 1; &#125; var n = f(10); alert(n);//11 2 写法二 1234//跟第一种一个意思，没有接受方法而已(function(n) &#123; return n + 1; &#125;)(10); 3 写法三 创建一个方法对象，参数传入：方法的参数和方法体，浏览器解析成正常方法所以效率低，不推荐 12var m = new Function(\"m\", \"n\", \"return m+n\");alert(m(10, 20)); js的闭包 定义：在一定函数里面再定义一个函数，•内部函数函数能访问外部函数作用域范围内的变量，这时这个内部函数就叫做闭包。 无论这个内部函数在哪里被调用都能访问的到外部函数作用域中的那些变量。12345678910function f1() &#123; var n = 100; function f2() &#123; alert(n); &#125; return f2(); &#125; var res = f1(); res(); 闭包的目的： ​ * 通过闭包实现访问闭包外方法的局部变量（解决在匿名函数中调用局部变量相关的问题） ​ * 这样使得局部变量一直保存在内存中，模拟面向对象 闭包如何实现的： ​ * 通过作用域链（使用变量先搜索自己作用域里面的数，没有再往上搜索）​ 闭包模拟面向对象 闭包获取数据会长时间占用内存，尽量减少使用js中利用函数可以模拟面向对象123456789101112131415&lt;script&gt; //类名首字母大写以示区分 function Person()&#123; &#125; var per=new Person(); per.name=\"luox78\"; per.age=18; per.say=function ()&#123; alert(\"hello\"); &#125; alert(per.name); per.say();&lt;/script&gt; 123456789&lt;script&gt; function Person(name)&#123; this.name=name; &#125; var per=new Person(\"luo78\"); //访问里面变量的两种方法 alert(per.name); alert(per[\"name\"]);&lt;/script&gt; js里面string的常用方法length 返回字符串长度charAt(index) 返回index位置的字符split(&quot;分隔符&quot;,limit) 多个分隔符使用正则表达式，limit代表返回个数js中数组可以直接显示，中间是逗号隔开1234var str = \"1|2|3|4#6\";alert(str.split(\"|\"));//1,2,3,4//js中split使用正则，且使用直接//转义特殊字符alert(str.split(\\☆|#\\)); substr(startindex,len) 返回截取start位置后len长度的字符串123var str=\"luox78\";alert(str.substr(2));//ox78alert(str.substr(2,2));//ox substring(startindex,stopindex) 返回截取start位置到stop位置的字符串1alert(str.substring(0,3));//luo toUpperCase() toLowerCase() 返回大写，小写match() replace() search() 后面dom部分涉及indexOf(&quot;str&quot;,position) 返回str的索引位置， str指想找的字符串，position指想找的第几个","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"C#中的多线程 - 01基础知识","slug":"CS_Thread01","date":"2017-12-28T12:50:03.698Z","updated":"2017-12-31T12:44:41.774Z","comments":true,"path":"2017/12/28/CS_Thread01/","link":"","permalink":"https://luox78.github.io/2017/12/28/CS_Thread01/","excerpt":"1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：","text":"1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子： 所有示例都假定已经引用了以下命名空间： 12using System;using System.Threading; 12345678910111213141516class ThreadTest&#123; static void Main() &#123; Thread t = new Thread (WriteY); // 创建新线程 t.Start(); // 启动新线程，执行WriteY() // 同时，在主线程做其它事情 for (int i = 0; i &lt; 1000; i++) Console.Write (\"x\"); &#125; static void WriteY() &#123; for (int i = 0; i &lt; 1000; i++) Console.Write (\"y\"); &#125;&#125; 输出结果： 1234xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx... 主线程创建了一个新线程t来不断打印字母 “ y “，与此同时，主线程在不停打印字母 “ x “。 线程一旦启动，线程的IsAlive属性值就会为true，直到线程结束。当传递给Thread的构造方法的委托执行完成时，线程就会结束。一旦结束，该线程不能再重新启动。 CLR 为每个线程分配各自独立的栈空间，因此局部变量是独立的。在下面的例子中，我们定义一个拥有局部变量的方法，然后在主线程和新创建的线程中同时执行该方法。 1234567891011static void Main()&#123; new Thread (Go).Start(); // 在新线程执行Go() Go(); // 在主线程执行Go()&#125;static void Go()&#123; // 定义和使用局部变量 - 'cycles' for (int cycles = 0; cycles &lt; 5; cycles++) Console.Write ('?');&#125; 输出结果：?????????? 变量cycles的副本是分别在各自的栈中创建的，因此才会输出 10 个问号。 线程可以通过对同一对象的引用来共享数据。例如： 1234567891011121314151617class ThreadTest&#123; bool done; static void Main() &#123; ThreadTest tt = new ThreadTest(); // 创建一个公共的实例 new Thread (tt.Go).Start(); tt.Go(); &#125; // 注意： Go现在是一个实例方法 void Go() &#123; if (!done) &#123; done = true; Console.WriteLine (\"Done\"); &#125; &#125;&#125; 由于两个线程是调用了同一个的ThreadTest实例上的Go()，它们共享了done字段，因此输出结果是一次 “ Done “，而不是两次。 输出结果：Done 静态字段提供了另一种在线程间共享数据的方式，以下是一个静态的done字段的例子： 123456789101112131415class ThreadTest&#123; static bool done; // 静态字段在所有线程中共享 static void Main() &#123; new Thread (Go).Start(); Go(); &#125; static void Go() &#123; if (!done) &#123; done = true; Console.WriteLine (\"Done\"); &#125; &#125;&#125; 以上两个例子引出了一个关键概念[线程安全（thread safety）]。上述两个例子的输出实际上是不确定的：” Done “ 有可能会被打印两次。如果在Go方法里调换指令的顺序，” Done “ 被打印两次的几率会大幅提高： 1234static void Go()&#123; if (!done) &#123; Console.WriteLine (\"Done\"); done = true; &#125;&#125; 输出结果： 12DoneDone (很可能!) 这个问题是因为一个线程对if中的语句估值的时候，另一个线程正在执行WriteLine语句，这时done还没有被设置为true。 修复这个问题需要在读写公共字段时，获得一个[排它锁（互斥锁，exclusive lock ）]。C# 提供了[lock]来达到这个目的： 12345678910111213141516171819class ThreadSafe&#123; static bool done; static readonly object locker = new object(); static void Main() &#123; new Thread (Go).Start(); Go(); &#125; static void Go() &#123; lock (locker) &#123; if (!done) &#123; Console.WriteLine (\"Done\"); done = true; &#125; &#125; &#125;&#125; 当两个线程同时争夺一个锁的时候（例子中的locker），一个线程等待，或者说[阻塞]，直到锁变为可用。这样就确保了在同一时刻只有一个线程能进入临界区（critical section，不允许并发执行的代码），所以 “ Done “ 只被打印了一次。像这种用来避免在多线程下的不确定性的方式被称为[线程安全（thread-safe）]。 在线程间共享数据是造成多线程复杂、难以定位的错误的主要原因。尽管这通常是必须的，但应该尽可能保持简单。 一个线程被阻塞时，不会消耗 CPU 资源。 1.1Join 和 Sleep可以通过调用Join方法来等待另一个线程结束，例如： 123456789101112static void Main()&#123; Thread t = new Thread (Go); t.Start(); t.Join(); Console.WriteLine (\"Thread t has ended!\");&#125;static void Go()&#123; for (int i = 0; i &lt; 1000; i++) Console.Write (\"y\");&#125; 输出 “ y “ 1,000 次之后，紧接着会输出 “ Thread t has ended! “。当调用Join时可以使用一个超时参数，以毫秒或是TimeSpan形式。如果线程正常结束则返回true，如果超时则返回false。 Thread.Sleep会将当前的线程阻塞一段时间： 12Thread.Sleep (TimeSpan.FromHours (1)); // 阻塞 1小时Thread.Sleep (500); // 阻塞 500 毫秒 当使用Sleep或Join等待时，线程是[阻塞（blocked）]状态，因此不会消耗 CPU 资源。 Thread.Sleep(0)会立即释放当前的时间片，将 CPU 资源出让给其它线程。Framework 4.0 新的Thread.Yield()方法与其相同，除了它只会出让给运行在相同处理器核心上的其它线程。 Sleep(0)和Yield在调整代码性能时偶尔有用，它也是一个很好的诊断工具，可以用于找出[线程安全（thread safety）]的问题。如果在你代码的任意位置插入Thread.Yield()会影响到程序，基本可以确定存在 bug。 1.2线程是如何工作的线程在内部由一个线程调度器（thread scheduler）管理，一般 CLR 会把这个任务交给操作系统完成。线程调度器确保所有活动的线程能够分配到适当的执行时间，并且保证那些处于等待或阻塞状态（例如，等待排它锁或者用户输入）的线程不消耗CPU时间。 在单核计算机上，线程调度器会进行时间切片（time-slicing），快速的在活动线程中切换执行。在 Windows 操作系统上，一个时间片通常在十几毫秒（译者注：默认 15.625ms），远大于 CPU 在线程间进行上下文切换的开销（通常在几微秒区间）。 在多核计算机上，多线程的实现是混合了时间切片和真实的并发，不同的线程同时运行在不同的 CPU 核心上。几乎可以肯定仍然会使用到时间切片，因为操作系统除了要调度其它的应用，还需要调度自身的线程。 线程的执行由于外部因素（比如时间切片）被中断称为被抢占（preempted）。在大多数情况下，线程无法控制其在何时及在什么代码处被抢占。 1.3线程 vs 进程好比多个进程并行在计算机上执行，多个线程是在一个进程中并行执行。进程是完全隔离的，而线程是在一定程度上隔离。一般的，线程与运行在相同程序中的其它线程共享堆内存。这就是线程为何有用的部分原因，一个线程可以在后台获取数据，而另一个线程可以同时显示已获取到的数据。 1.4线程的使用与误用多线程有许多用处，下面是通常的应用场景： 维持用户界面的响应 使用工作线程并行运行时间消耗大的任务，这样主UI线程就仍然可以响应键盘、鼠标的事件。 有效利用 CPU 多线程在一个线程等待其它计算机或硬件设备响应时非常有用。当一个线程在执行任务时被阻塞，其它线程就可以利用这个空闲出来的CPU核心。 并行计算 在多核心或多处理器的计算机上，计算密集型的代码如果通过分治策略（divide-and-conquer，见[第 5 部分]）将工作量分摊到多个线程，就可以提高计算速度。 推测执行（speculative execution） 在多核心的计算机上，有时可以通过推测之后需要被执行的工作，提前执行它们来提高性能。[LINQPad**]就使用了这个技术来加速新查询的创建。另一种方式就是可以多线程并行运行解决相同问题的不同算法，因为预先不知道哪个算法更好，这样做就可以尽早获得结果。 允许同时处理请求 在服务端，客户端请求可能同时到达，因此需要并行处理（如果你使用 ASP.NET、WCF、Web Services 或者 Remoting，.NET Framework 会自动创建线程）。这在客户端同样有用，例如处理 P2P 网络连接，或是处理来自用户的多个请求。 如果使用了 ASP.NET 和 WCF 之类的技术，可能[不会注意到多线程被使用]，除非是访问共享数据时（比如通过静态字段共享数据）。如果没有正确的[加锁]，就[可能产生线程安全问题]。 多线程同样也会带来缺点，最大的问题是它提高了程序的复杂度。使用多个线程本身并不复杂，复杂的是线程间的交互（一般是通过共享数据）。无论线程间的交互是否有意为之，都会带来较长的开发周期，以及带来间歇的、难以重现的 bug。因此，最好保证线程间的交互尽量少，并坚持简单和已被证明的多线程交互设计。这篇文章主要就是关于如何处理这种复杂的问题，如果能够移除线程间交互，那会轻松许多。 一个好的策略是把多线程逻辑使用可重用的类封装，以便于独立的检验和测试。.NET Framework 提供了许多高层的线程构造，之后会讲到。 当频繁地调度和切换线程时（并且如果活动线程数量大于 CPU 核心数），多线程会增加资源和 CPU 的开销，线程的创建和销毁也会增加开销。多线程并不总是能提升程序的运行速度，如果使用不当，反而可能降低速度。 例如，当需要进行大量的磁盘 I/O 时，几个工作线程顺序执行可能会比 10 个线程同时执行要快。（在[使用 Wait 和 Pulse 进行同步]中，将会描述如何实现 [生产者 / 消费者队列]，它提供了上述功能。） 2创建和启动线程像我们在简介中看到的那样，使用Thread类的构造方法来创建线程，通过传递ThreadStart委托来指明线程从哪里开始运行，下面是ThreadStart委托的定义： 1public delegate void ThreadStart(); 调用Start方法后，线程开始执行，直到它所执行的方法返回后，线程终止。下面这个例子使用完整的 C# 语法创建TheadStart委托： 1234567891011121314class ThreadTest&#123; static void Main() &#123; Thread t = new Thread (new ThreadStart (Go)); t.Start(); // 在新线程运行 GO() Go(); // 同时在主线程运行 GO() &#125; static void Go() &#123; Console.WriteLine (\"hello!\"); &#125;&#125; 在这个例子中，线程t执行Go()方法，几乎同时主线程也执行Go()方法，结果将打印两个 hello。 线程也可以使用更简洁的语法创建，使用方法组（method group），让 C# 编译器推断ThreadStart委托类型： 1Thread t = new Thread (Go); // 无需显式使用 ThreadStart 另一个快捷的方式是使用 lambda 表达式或者匿名方法： 12345static void Main()&#123; Thread t = new Thread ( () =&gt; Console.WriteLine (\"Hello!\") ); t.Start();&#125; 2.1向线程传递数据向一个线程的目标方法传递参数最简单的方式是使用 lambda 表达式调用目标方法，在表达式内指定参数: 12345678910static void Main()&#123; Thread t = new Thread ( () =&gt; Print (\"Hello from t!\") ); t.Start();&#125;static void Print (string message)&#123; Console.WriteLine (message);&#125; 使用这种方式，可以向方法传递任意数量的参数。甚至可以将整个实现封装为一个多语句的 lambda 表达式： 12345new Thread (() =&gt;&#123; Console.WriteLine (\"I'm running on another thread!\"); Console.WriteLine (\"This is so easy!\");&#125;).Start(); 在 C# 2.0 中，也可以很容易的使用匿名方法来进行相同的操作： 1234new Thread (delegate()&#123; ...&#125;).Start(); 另一个方法是向Thread的Start方法传递参数： 1234567891011static void Main()&#123; Thread t = new Thread (Print); t.Start (\"Hello from t!\");&#125;static void Print (object messageObj)&#123; string message = (string) messageObj; // 需要强制类型转换 Console.WriteLine (message);&#125; 可以这样是因为Thread的构造方法通过重载来接受两个委托中的任意一个： 12public delegate void ThreadStart();public delegate void ParameterizedThreadStart (object obj); ParameterizedThreadStart的限制是它只接受一个参数。并且由于它是object类型，通常需要类型转换。 Lambda 表达式与被捕获变量如我们所见，lambda 表达式是向线程传递数据的最强大的方法。然而必须小心，不要在启动线程之后误修改被捕获变量（captured variables）。例如，考虑下面的例子： 12for (int i = 0; i &lt; 10; i++) new Thread (() =&gt; Console.Write (i)).Start(); 输出结果是不确定的！可能是这样0223557799。 问题在于变量i在整个循环中指向相同的内存地址。所以，每一个线程在调用Console.Write时，都在使用这个值在运行时会被改变的变量！ 类似的问题在[C# 4.0 in a Nutshell**]的第 8 章的 “Captured Variables” 有描述。这个问题与多线程没什么关系，而是和 C# 的捕获变量的规则有关（在for和foreach的场景下有时不是很理想）。 解决方法就是使用临时变量，如下所示： 12345for (int i = 0; i &lt; 10; i++)&#123; int temp = i; new Thread (() =&gt; Console.Write (temp)).Start();&#125; 变量temp对于每一个循环迭代是局部的。所以，每一个线程会捕获一个不同的内存地址，从而不会产生问题。我们可以使用更为简单的代码来演示前面的问题： 12345678string text = \"t1\";Thread t1 = new Thread ( () =&gt; Console.WriteLine (text) );text = \"t2\";Thread t2 = new Thread ( () =&gt; Console.WriteLine (text) );t1.Start();t2.Start(); 因为两个lambda表达式捕获了相同的text变量，t2会被打印两次： 12t2t2 2.2线程命名每一个线程都有一个 Name 属性，我们可以设置它以便于调试。这在 Visual Studio 中非常有用，因为线程的名字会显示在线程窗口（Threads Window）与调试位置（Debug Location）工具栏上。线程的名字只能设置一次，以后尝试修改会抛出异常。 静态的Thread.CurrentThread属性会返回当前执行的线程。在下面的例子中，我们设置主线程的名字： 12345678910111213141516class ThreadNaming&#123; static void Main() &#123; Thread.CurrentThread.Name = \"main\"; Thread worker = new Thread (Go); worker.Name = \"worker\"; worker.Start(); Go(); &#125; static void Go() &#123; Console.WriteLine (\"Hello from \" + Thread.CurrentThread.Name); &#125;&#125; 2.3前台与后台线程默认情况下，显式创建的线程都是前台线程（foreground threads）。只要有一个前台线程在运行，程序就可以保持存活，而后台线程（background threads）并不能保持程序存活。当一个程序中所有前台线程停止运行时，仍在运行的所有后台线程会被强制终止。 线程的前台/后台状态与它的优先级和执行时间的分配无关。 可以通过线程的IsBackground属性来查询或修改线程的前后台状态。如下面的例子： 123456789class PriorityTest&#123; static void Main (string[] args) &#123; Thread worker = new Thread ( () =&gt; Console.ReadLine() ); if (args.Length &gt; 0) worker.IsBackground = true; worker.Start(); &#125;&#125; 如果这个程序以无参数的形式运行，工作线程会默认为前台，并在ReadLine时等待用户输入回车。此时主线程退出，但是程序仍然在运行，因为有一个前台线程依然存活。 相反，如果给Main()传递了参数，工作线程设置为后台状态，当主线程结束时，程序几乎立即退出（终止ReadLine需要一咪咪时间）。 当进程以这种方式结束时，后台线程执行栈中所有finally块就会被避开。如果程序依赖finally（或是using）块来执行清理工作，例如释放资源或是删除临时文件，就可能会产生问题。为了避免这种问题，在退出程序时可以显式的等待这些后台线程结束。有两种方法可以实现： 如果是自己创建的线程，在线程上调用[Join](方法。 如果是使用[线程池线程]，使用[事件等待句柄]。 在任一种情况下，都应指定一个超时时间，从而可以放弃由于某种原因而无法正常结束的线程。这是后备的退出策略：我们希望程序最后可以关闭，而不是让用户去开任务管理器(╯-_-)╯╧══╧ 如果用户使用任务管理器强行终止了 .NET 进程，所有线程都会被当作后台线程一般丢弃。这是通过观察得出的结论，并不是通过文档，而且可能会因为 CLR 和操作系统的版本不同而有不同的行为。 前台线程不需要这种处理，但是必须小心避免会使线程无法结束的 bug。程序无法正常退出的一个很有可能的原因就是仍有前台线程存在。 2.4线程优先级线程的Priority属性决定了相对于操作系统中的其它活动线程，它可以获得多少执行时间。线程优先级的取值如下： 1enum ThreadPriority &#123; Lowest, BelowNormal, Normal, AboveNormal, Highest &#125; 只有当多个线程同时活动时，线程优先级才有意义。 在提升线程优先级前请三思，这可能会导致其它线程的资源饥饿（resource starvation，译者注：指没有分配到足够的CPU时间来运行）等问题。 提升线程的优先级是无法使其能够处理实时任务的，因为它还受到程序进程优先级的影响。要进行实时任务，必须同时使用System.Diagnostics中的Process类来提升进程的优先级（记得这不是我告诉你的）： 12using (Process p = Process.GetCurrentProcess()) p.PriorityClass = ProcessPriorityClass.High; ProcessPriorityClass.High实际上就是一个略低于最高优先级Realtime的级别。将一个进程的优先级设置为Realtime是通知操作系统，我们绝不希望该进程将 CPU 时间出让给其它进程。如果你的程序误入一个无限循环，会发现甚至是操作系统也被锁住了，就只好去按电源按钮了o(&gt;_&lt;)o 正是由于这一原因，High 通常是实时程序的最好选择。 如果实时程序拥有用户界面，提升进程的优先级会导致大量的 CPU 时间被用于屏幕更新，这会降低整台机器的速度（特别是当 UI 很复杂时）。降低主线程的优先级，并提升进程的优先级可以保证需要进行实时任务的工作线程不会被屏幕重绘所抢占。但是这依然没有解决其它程序的CPU时间饥饿的问题，因为操作系统依然为这个进程分配了大量 CPU 资源。 理想的解决方案是分离 UI 线程和实时工作线程，使用两个进程分别运行。这样就可以分别设置各自的进程优先级，彼此之间通过 Remoting 或是内存映射文件进行通信。内存映射文件十分适用于这一任务，在C# 4.0 in a Nutshell**的第 14 和 25 章会讲到。 即使是提升了进程优先级，托管环境在处理强实时需求时仍然有限制。除了自动垃圾回收带来的延迟，操作系统也不能够完全满足实时任务的需要，即便是非托管的程序也是如此。最好的解决办法还是使用独立的硬件或者专门的实时平台。 2.5异常处理当线程开始运行后，其创建代码所在的try / catch / finally块与该线程不再有任何关系。考虑下面的程序： 1234567891011121314public static void Main()&#123; try &#123; new Thread (Go).Start(); &#125; catch (Exception ex) &#123; // 永远执行不到这里 Console.WriteLine (\"Exception!\"); &#125;&#125;static void Go() &#123; throw null; &#125; // 产生 NullReferenceException 异常 这个例子中的try / catch语句是无效的，而新创建的线程将会遇到一个未处理的NullReferenceException。因为主线程直接跳过catch。 修改方法是将异常处理移到Go方法中： 12345678910111213141516171819public static void Main()&#123; new Thread (Go).Start();&#125;static void Go()&#123; try &#123; // ... throw null; // 异常会在下面被捕获 // ... &#125; catch (Exception ex) &#123; // 一般会记录异常， 和/或通知其它线程我们遇到问题了 // ... &#125;&#125; 在生产环境的程序中，所有线程的入口方法处都应该有一个异常处理器，就如同在主线程所做的那样（一般可能是在执行栈上靠近入口的地方）。未处理的异常会使得整个程序停止运行，弹出一个难看的对话框。 在写异常处理块的时候，最好不要忽略错误。一般应该记录异常详细信息，然后可以弹出一个对话框让用户可以选择是否自动把这些信息提交到你的服务器。最后应该关闭程序，因为很可能错误已经破坏的程序的状态。然而这么做会导致用户丢失当前的工作，比如打开的文档。 WPF 和 Windows Forms 应用中的“全局”异常处理事件（Application.DispatcherUnhandledException和Application.ThreadException）只会在主UI线程有未处理的异常时触发。对于工作线程上的异常仍然需要手动处理。 AppDomain.CurrentDomain.UnhandledException会对所有未处理的异常触发，但是它不提供阻止程序退出的办法。 然而在某些情况下，可以不必处理工作线程上的异常，因为 .NET Framework 会为你处理。这些会在接下来的内容中讲到： [异步委托] [BackgroundWorker] [任务并行库（TPL）] 3线程池 当启动一个线程时，会有几百毫秒的时间花费在准备一些额外的资源上，例如一个新的私有局部变量栈这样的事情。每个线程会占用（默认情况下）1MB 内存。线程池（thread pool）可以通过共享与回收线程来减轻这些开销，允许多线程应用在很小的粒度上而没有性能损失。在多核心处理器以分治（divide-and-conquer）的风格执行计算密集代码时将会十分有用。 线程池会限制其同时运行的工作线程总数。太多的活动线程会加重操作系统的管理负担，也会降低 CPU 缓存的效果。一旦达到数量限制，任务就会进行排队，等待一个任务完成后才会启动另一个。这使得程序任意并发成为可能，例如 web 服务器。（异步方法模式（asynchronous method pattern）是进一步高效利用线程池的高级技术，我们在C# 4.0 in a Nutshell**的 23 章来讲）。 有多种方法可以使用线程池： 通过[任务并行库（TPL）]（Framework 4.0 中加入） 调用[ThreadPool.QueueUserWorkItem] 通过[异步委托] 通过[BackgroundWorker] 以下构造会间接使用线程池： WCF、Remoting、ASP.NET 和 ASMX 网络服务应用 [System.Timers.Timer]和 [System.Threading.Timer] .NET Framework 中名字以 Async 结尾的方法，例如WebClient上的方法（使用[基于事件的异步模式，EAP]），和大部分BeginXXX方法（异步编程模型模式，APM） PLINQ 任务并行库（Task Parallel Library，TPL）与 PLINQ 足够强大并面向高层，即使使用线程池并不重要，也应该使用它们来辅助多线程。我们会在[第 5 部分]中进行更详细的讨论。现在，简单看一下如何使用[Task]类作为在线程池线程上运行委托的简单方法。 在使用线程池线程时有几点需要小心： 无法设置线程池线程的Name属性，这会令调试更为困难（当然，调试时也可以在 Visual Studio 的线程窗口中给线程附加备注）。 线程池线程永远是[后台线程]（一般不是问题）。 [阻塞]线程池线程可能会在程序早期带来额外的延迟，除非调用了ThreadPool.SetMinThreads（见[优化线程池]）。 可以改变线程池线程的[优先级]，当它用完后返回线程池时会被恢复到默认状态。 可以通过Thread.CurrentThread.IsThreadPoolThread属性来查询当前是否运行在线程池线程上。 3.1通过 TPL 使用线程池可以很容易的使用任务并行库（Task Parallel Library，TPL）中的[Task]类来使用线程池。 Task类在 Framework 4.0 时被加入：如果你熟悉旧式的构造，可以将非泛型的Task类看作[ThreadPool.QueueUserWorkItem]的替代，而泛型的Task&lt;TResult&gt;看作[异步委托]的替代。比起旧式的构造，新式的构造会更快速，更方便，并且更灵活。 要使用非泛型的Task类，调用Task.Factory.StartNew，并传递目标方法的委托： 123456789static void Main() // Task 类在 System.Threading.Tasks 命名空间中&#123; Task.Factory.StartNew (Go);&#125;static void Go()&#123; Console.WriteLine (\"Hello from the thread pool!\");&#125; Task.Factory.StartNew返回一个Task对象，可以用来监视任务，例如通过调用Wait)方法来等待其结束。 当调用Task的[Wait方法]时，所有未处理的异常会在宿主线程被重新抛出。（如果不调用Wait而是丢弃不管，未处理的异常会[像普通的线程那样]结束程序。（译者注：在 .NET 4.5 中，为了支持基于async / await的异步模式，Task中这种“未观察”的异常默认会被忽略，而不会导致程序结束。 泛型的Task&lt;TResult&gt;类是非泛型Task的子类。它可以使你在其完成执行后得到一个返回值。在下面的例子中，我们使用Task&lt;TResult&gt;来下载一个网页： 12345678910111213141516171819static void Main()&#123; // 启动 task： Task&lt;string&gt; task = Task.Factory.StartNew&lt;string&gt; ( () =&gt; DownloadString (\"http://www.gkarch.com\") ); // 执行其它工作，它会和 task 并行执行： RunSomeOtherMethod(); // 通过 Result 属性获取返回值： // 如果仍在执行中, 当前进程会阻塞等待直到 task 结束： string result = task.Result;&#125;static string DownloadString (string uri)&#123; using (var wc = new System.Net.WebClient()) return wc.DownloadString (uri);&#125; （这里的&lt;string&gt; 类型参数是为了示例的清晰，它可以被省略，让编译器推断。） 查询task的Result属性时，未处理的异常会被封装在[AggregateException]中自动重新抛出。然而，如果没有查询Result属性（并且也没有调用Wait），未处理的异常会令程序结束。 TPL 具有更多的特性，非常适合于利用多核处理器。关于 TPL 的讨论我们在[第 5 部分]中继续。 3.2不通过 TPL 使用线程池如果是使用 .NET Framework 4.0 以前的版本，则不能使用任务并行库。你必须通过一种旧的构造使用线程池：ThreadPool.QueueUserWorkItem与异步委托。这两者之间的不同在于异步委托可以让你从线程中返回数据，同时异步委托还可以将异常封送回调用方。 QueueUserWorkItem要使用QueueUserWorkItem，仅需要使用希望在线程池线程上运行的委托来调用该方法： 1234567891011static void Main()&#123; ThreadPool.QueueUserWorkItem (Go); ThreadPool.QueueUserWorkItem (Go, 123); Console.ReadLine();&#125;static void Go (object data) // 第一次调用时 data 为 null&#123; Console.WriteLine (\"Hello from the thread pool! \" + data);&#125; 输出结果： 12Hello from the thread pool!Hello from the thread pool! 123 目标方法Go，必须接受单一一个object参数（来满足WaitCallback委托）。这提供了一种向方法传递数据的便捷方式，就像ParameterizedThreadStart一样。与Task不同，QueueUserWorkItem并不会返回一个对象来帮助我们在后续管理其执行。并且，你必须在目标代码中显式处理异常，未处理的异常会[令程序结束] 异步委托ThreadPool.QueueUserWorkItem并没有提供在线程执行结束之后从线程中返回值的简单机制。异步委托调用（asynchronous delegate invocations ）解决了这一问题，可以允许双向传递任意数量的参数。而且，异步委托上的未处理异常可以方便的原线程上重新抛出（更确切的说，在调用EndInvoke的线程上），所以它们不需要显式处理。 不要混淆异步委托和异步方法（asynchronous methods ，以 Begin 或 End 开始的方法，比如File.BeginRead/File.EndRead）。异步方法表面上看使用了相似的方式，但是其实是为了解决更困难的问题。我们在C# 4.0 in a Nutshell**的第 23 章中描述。 下面是如何通过异步委托启动一个工作线程： 创建目标方法的委托（通常是一个Func类型的委托）。 在该委托上调用BeginInvoke，保存其IAsyncResult类型的返回值。 BeginInvokde会立即返回。当线程池线程正在工作时，你可以执行其它的动作。 当需要结果时，在委托上调用EndInvoke，传递所保存的IAsyncResult对象。 接下来的例子中，我们使用异步委托调用来和主线程中并行运行一个返回字行串长度的简单方法： 123456789101112static void Main()&#123; Func&lt;string, int&gt; method = Work; IAsyncResult cookie = method.BeginInvoke (\"test\", null, null); // // 这里可以并行执行其它任务 // int result = method.EndInvoke (cookie); Console.WriteLine (\"String length is: \" + result);&#125;static int Work (string s) &#123; return s.Length; &#125; EndInvoke会做三件事： 如果异步委托还没有结束，它会等待异步委托完成执行。 它会接收返回值（也包括ref和out方式的参数）。 它会向调用线程抛出未处理的异常。 如果使用异步委托调用的方法没有返回值，技术上你仍然需要调用EndInvoke。在实践中，这里存在争论，因为不调用EndInvoke也不会有什么损失。然而如果你选择不调用它，就需要考虑目标方法中的异常处理来避免错误无法察觉。 （译者注：MSDN文档**中明确写了 “无论您使用何种方法，都要调用 EndInvoke 来完成异步调用。”，所以最好不要偷懒。） 当调用BeginInvoke时也可以指定一个回调委托。这是一个在完成时会被自动调用的、接受IAsyncResult对象的方法。这样可以在后面的代码中“忘记”异步委托，但是需要在回调方法里做点其它工作： 12345678910111213141516static void Main()&#123; Func&lt;string, int&gt; method = Work; method.BeginInvoke (\"test\", Done, method); // ... //&#125;static int Work (string s) &#123; return s.Length; &#125;static void Done (IAsyncResult cookie)&#123; var target = (Func&lt;string, int&gt;) cookie.AsyncState; int result = target.EndInvoke (cookie); Console.WriteLine (\"String length is: \" + result);&#125; BeginInvoke的最后一个参数是一个用户状态对象，用于设置IAsyncResult的AsyncState属性。它可以是需要的任何东西，在这个例子中，我们用它向回调方法传递method委托，这样才能够在它上面调用EndInvoke。 3.3优化线程池线程池初始时其池内只有一个线程。随着任务的分配，线程池管理器就会向池内“注入”新线程来满足工作负荷的需要，直到最大数量的限制。在足够的非活动时间之后，线程池管理器在认为“回收”一些线程能够带来更好的吞吐量时进行线程回收。 可以通过调用ThreadPool.SetMaxThreads方法来设置线程池可以创建的线程上限；默认如下： Framework 4.0，32位环境下：1023 Framework 4.0，64位环境下：32768 Framework 3.5：每个核心 250 Framework 2.0：每个核心 25 （这些数字可能根据硬件和操作系统不同而有差异。）数量这么多是因为要确定[阻塞]（等待一些条件，比如远程计算机的相应）的线程的条件是否被满足。 也可以通过ThreadPool.SetMinThreads设置线程数量下限。下限的作用比较奇妙：它是一种高级的优化技术，用来指示线程池管理器在达到下限之前不要延迟线程的分配。当存在[阻塞]线程时，提高下限可以改善程序并发性。 默认下限数量是 CPU 核心数，也就是能充分利用 CPU 的最小数值。在服务器环境下（比如 IIS 中的 ASP.NET），下限数量一般要高的多，差不多 50 或者更高。 最小线程数量是如何起作用的？ 将线程池的最小线程数设置为 x 并不是立即创建至少 x 个线程，而是线程会根据需要来创建。这个数值是指示线程池管理器当需要的时候，立即 创建 x 个线程。那么问题是为什么线程池在其它情况下会延迟创建线程？ 答案是为了防止短生命周期的任务导致线程数量短暂高峰，使程序的内存足迹（memory footprint）快速膨胀。为了描述这个问题，考虑在一个 4 核的计算机上运行一个客户端程序，它一次发起了 40 个任务请求。如果每个任务都是一个 10ms 的计算，假设它们平均分配在 4 个核心上，总共的开销就是 100ms 多。理想情况下，我们希望这 40 个任务运行在 4 个线程上： 如果线程数量更少，就无法充分利用 4 个核心。 如果线程数量更多，会浪费内存和 CPU 时间去创建不必要的线程。 线程池就是以这种方式工作的。让线程数量和 CPU 核心数量匹配，就能够既保持小的内存足迹，又不损失性能。当然这也需要线程都能被充分使用（在这个例子中满足该条件）。 但是，现在来假设任务不是进行 10ms 的计算，而是请求互联网，使用半秒钟等待响应，此时本地 CPU 是空闲状态。线程池管理器的线程经济策略（译者注：指上面说的线程数量匹配核心数）这时就不灵了，应该创建更多的线程，让所有的请求同时进行。 幸运的是，线程池管理器还有一个后备方案。如果在半秒内没有能够响应请求队列，就会再创建一个新的线程，以此类推，直到线程数量上限。 半秒的等待时间是一把双刃剑。一方面它意味着一次性的短暂任务不会使程序快速消耗不必要的40MB（或者更多）的内存。另一方面，在线程池线程被阻塞时，比如在请求数据库或者调用WebClient.DownloadFile，就进行不必要的等待。因为这种原因，你可以通过调用SetMinThreads来让线程池管理器在分配最初的 x 个线程时不要等待，例如： 1ThreadPool.SetMinThreads (50, 50); （第二个参数是表示多少个线程分配给 I/O 完成端口（I/O completion ports，IOCP），来被APM使用，这会在C# 4.0 in a Nutshell** 的第 23 章描述。） 最小线程数量的默认值是 CPU 核心数。 总结：面对长时间等待的线程，因为这些线程只占时间，并不需要cpu计算，所以线程池管理器之前的平分策略就出现了问题，由此引入半秒等待机制，一旦此线程运行时间超过半秒就直接开启新的线程给新任务。但半秒等待机制还是存在利弊，利是防止很多线程的同时开启一下子占用大量内存，弊是必须等待半秒线程管理器才会开启新线程导致时间浪费，此时设置最小线程数量显得尤为重要，可以有效的防止等待，也不会占用很多内存（根据你自己的设置）","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://luox78.github.io/tags/thread/"}]},{"title":"初识JavaScript01","slug":"JavaScript01","date":"2017-12-27T12:55:09.751Z","updated":"2018-01-01T11:38:56.825Z","comments":true,"path":"2017/12/27/JavaScript01/","link":"","permalink":"https://luox78.github.io/2017/12/27/JavaScript01/","excerpt":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt;","text":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt; 默认如果直接在script标签中定义变量，则属于“全局作用域范围”(全局执行环境)，即属于window对象。1 . 全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源2 . 一个页面中的多个script标签中的变量可以互相访问。3 . JS有垃圾回收机制，会定时对可释放资源的变量回收。将变量设置为null则表示可以被回收了。 123456789&lt;script&gt; function name(parameters) &#123; var i = 0; i++; alert(i); &#125; //方法无返回值，会返回undefined alert(name());&lt;/script&gt; 1234567&lt;script&gt; var i = 1;&lt;/script&gt;&lt;script&gt; //全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源 alert(i);//1&lt;/script&gt; 方法内部不使用var定义的变量相当于全局变量1234567891011&lt;script&gt; function f1(parameters) &#123; i = 100; //var i = 100; &#125;&lt;/script&gt;&lt;script&gt; f1(); alert(i);//100 //alert(i);使用未定义&lt;/script&gt; switchjs中switch中的判断是严格判断就是全等于（===）123456789101112&lt;script&gt; var i = 90; switch (i) &#123; case 90: alert(\"number\"); break; case \"90\": alert(\"string\"); break; default: &#125;&lt;/script&gt; js类型转换注意点： 1 Number（）将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN 2 String（）转换不成功返回undefined， toString（）报错 3 Boolean（）转换当为0或为空（值为空或者null）时返回false，其余返回true1234567891011121314151617181920&lt;script&gt; alert(parseInt(\"90\")); //90 alert(parseInt(\"90aaaaaaaaaa\")); //90 alert(parseInt(\"aaaaaa\")); //NaN alert(parseInt(111, 2)); //代表给定一个二进制的数111输出十进制 alert(parseFloat(10.111)); //10.111 alert(Number(\"40addd\")); //将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN //alert(isNaN(\"aaa\")); //true var str; alert(String(str)); //undefined alert(str.toString()); //报错 //boolean var b1 = Boolean(\"\"); //false - 空字符串 var b2 = Boolean(\"hello\"); //true - 非空字符串 var b1 = Boolean(50); //true - 非零数字 var b1 = Boolean(null); //false – null var b1 = Boolean(0); //false - 零 var b1 = Boolean(new object()); //true - 对象 &lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"LINQ","slug":"Ten_LINQ_Myth","date":"2017-12-26T14:34:53.555Z","updated":"2018-01-01T11:38:28.505Z","comments":true,"path":"2017/12/26/Ten_LINQ_Myth/","link":"","permalink":"https://luox78.github.io/2017/12/26/Ten_LINQ_Myth/","excerpt":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3);","text":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3); 2 All LINQ queries must use query syntax. lambda syntax query syntax 12345678//Here's an example of lambda syntax:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); Here's the same thing expressed in query syntax://string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = from p in people where p.Length &gt; 3 select p; 3 To retrieve all customers from the customer table, you must perform a query similar to the following:12345678910111213141516171819The expression:from c in db.Customers select c is a frivolous query! You can simply go:db.CustomersSimilarly, the following LINQ to XML query:var xe = from e in myXDocument.Descendants (\"phone\") select e;can be simplified to:var xe = myXDocument.Descendants (\"phone\");And this:Customer customer = (from c in db.Customers where c.ID == 123 select c) .Single();can be simplified to:Customer customer = db.Customers.Single (c =&gt; c.ID == 123); 4 A LINQ to SQL or EF query will be executed in one round-trip only if the query was built in a single step.LINQ follows a lazy evaluation model, which means queries execute not when constructed, but when enumerated. This means you can build up a query in as many steps as you like, and it won’t actually hit the server until you eventually start consuming the results. For instance, the following query retrieves the names of all customers whose name starts with the letter ‘A’, and who have made at least two purchases. We build this query in three steps:123456var query = db.Customers.Where (c =&gt; c.Name.StartsWith (\"A\"));query = query.Where (c =&gt; c.Purchases.Count() &gt;= 2);var result = query.Select (c =&gt; c.Name);foreach (string name in result) // Only now is the query executed! Console.WriteLine (name); 5 Because SQL emits flat result sets, LINQ queries must be structured to emit flat result sets, too.For example, if you want to retrieve the names of customers in the state of WA along with all their purchases, you can simply do the following:1234567from c in db.Customerswhere c.State == \"WA\"select new&#123; c.Name, c.Purchases // An EntitySet (collection)&#125; The hierarchical result from this query is much easier to work with than a flat result set! We can achieve the same result without association properties as follows:1234567from c in db.Customerswhere c.State == \"WA\"select new&#123; c.Name, Purchases = db.Purchases.Where (p =&gt; p.CustomerID == c.ID)&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"LINQ","slug":"LINQ","permalink":"https://luox78.github.io/tags/LINQ/"}]},{"title":"C#6 特性","slug":"CS6","date":"2017-12-26T12:27:56.003Z","updated":"2018-01-01T11:37:40.958Z","comments":true,"path":"2017/12/26/CS6/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS6/","excerpt":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符","text":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符 空操作符 ( ?. )123456if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0) &#123; Console.WriteLine(user.Project.Tasks.First().Name); &#125; //现在Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 注意： 上面的代码虽然可以让我们少些很多代码，而且也减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常，那么使用这个特性反而隐藏了Bug NameOf利用nameof减少手写带来的错误 12345Person p;if(p == null)&#123; throw new Exception(\"nameof(Person)\"); &#125; 表达式方法体1private static string SayHello() =&gt; \"Hello World\"; 自动属性初始化器1234567891011121314151617181920//以前public class Person &#123; public int Age &#123; get; set; &#125; public Person() &#123; Age = 100; &#125; &#125; //现在public class Person &#123; public int Age &#123; get; private set; &#125; &#125; //同时增加了只读属性初始化public class Person &#123; public int Age &#123; get; &#125; = 100; &#125; Index 初始化器1234567var names = new Dictionary&lt;int, string&gt; &#123; [1] = \"Jack\", [2] = \"Alex\", [3] = \"Eric\", [4] = \"Jo\" &#125;; using 静态类的方法可以使用 static using123456789101112using System; using static System.Math; namespace CSharp6NewFeatures &#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(Log10(5)+PI); &#125; &#125; &#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"C#7 特性","slug":"CS7","date":"2017-12-25T16:01:58.230Z","updated":"2018-01-11T12:38:20.180Z","comments":true,"path":"2017/12/26/CS7/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS7/","excerpt":"作者：Mads Torgersen译者：Vicey Wang 这是一篇描述上周四作为 Visual Studio 2017 的一部分所发行的 C# 7.0 中的新语言特性的文章。","text":"作者：Mads Torgersen译者：Vicey Wang 这是一篇描述上周四作为 Visual Studio 2017 的一部分所发行的 C# 7.0 中的新语言特性的文章。 C# 7.0 新增了许多新功能并引入了对数据消费、代码简化和性能的关注。也许最重要的新特性是使返回多个结果更加方便的元组（tuples），和可以用来简化由数据形状而决定的代码的模式匹配（pattern matching）。但是还有许多大大小小的新功能。我们希望它们能够组合起来以使你的代码更加有效率和干净，并使你更开心，富有生产力。 如果你对这些特性的设计流程感兴趣的话，你可以在 C# 语言设计 Github 站点 找到设计笔记、建议和大量的讨论。 如果感觉这篇文章似曾相识，那可能是由于去年八月发行的一个预备版本而造成的。在 C# 7.0 的最终版本中，少部分细节被修改了，其中一些是为了响应帖子中精彩的反馈而修改的。 好好享受 C# 7.0，好好享受 hacking 吧！ Mads Torgersen, C# 语言团队 PM Out 变量（Out variables)在之前的 C# 版本中，使用 out 参数并不像我们期盼的那样流畅。在你能够使用 out 参数来调用一个函数之前，你首先需要声明待传入的变量。同时由于你一般不会初始化这些变量（它们毕竟会被这些方法覆写），你也无法使用 var 来声明它们，而是需要指定完整的类型： 123456public void PrintCoordinates(Point p)&#123; int x, y; // 需要“预声明” p.GetCoordinates(out x, out y); WriteLine($\"(&#123;x&#125;, &#123;y&#125;)\");&#125; 在 C# 7.0 中我们添加了 out 变量；使你能够在传入一个 out 参数的地方声明一个变量： 12345public void PrintCoordinates(Point p)&#123; p.GetCoordinates(out int x, out int y); WriteLine($\"(&#123;x&#125;, &#123;y&#125;)\");&#125; 请注意，这些变量位于包含它们的代码块的作用域，因此之后的代码可以使用它们。许多种类的语句不会建立它们自己的代码块，因此在这些语句中声明的 out 变量通常被引入到（这个）封闭作用域中。 由于 out 变量直接以 out 参数的形式声明，编译器通常可以分辨它们的类型应该是什么（除非有冲突的重载），所以完全可以用 var 替代类型来声明它们： 1p.GetCoordinates(out var x, out var y); Out 参数的一个常见使用场景是会返回一个指示是否成功的 Try… 模式，然后 out 参数来携带获得的结果： 12345public void PrintStars(string s)&#123; if (int.TryParse(s, out var i)) &#123; WriteLine(new string('*', i)); &#125; else &#123; WriteLine(\"Cloudy - no stars tonight!\"); &#125;&#125; 我们也允许以 _（下划线）形式“舍弃” out 参数，来使你忽略你不关心的参数： 1p.GetCoordinates(out var x, out _); // 我只关心 x 模式匹配（Pattern matching）C# 7.0 引入了模式匹配的概念，一种从抽象的角度来说，指可以测试一个值是否有某种特定的“形状”、并在满足这一条件的时候从值中提取信息的句法元素。 C# 7.0 中的模式的例子有： c（c 为 C# 中的一个常量表达式）形式的常量模式（Constant pattern），来测试输入是否等于 c T x（T 为一个类型，x 为一个标识符）形式的类型模式（Type pattern），来测试输入是否有类型 T，并在满足条件的时候将值提取成全新的 T 类型的变量 x var x（x 为一个标识符）形式的变量匹配（Var patterns），这种匹配总是能够成功，并会将输入的值简单的放入一个全新的与输入类型相同的变量 x 中。 这只是个开始——模式现在是 C# 中的一种新的语言元素了，我们也希望在未来能向 C# 中加入更多的模式。 在 C# 7.0 中我们用模式改进了两个已有的语言结构： is 表达式的右边现在可以是表达式，而不仅仅是类型了 switch 语句中的 case 子句现在可以匹配模式，而不仅仅是常量了 在未来的 C# 版本中我们会添加更多可以使用模式的地方。 具有模式的 Is 表达式这里有一个用常量模式和类型模式来使用 is 表达式的例子： 123456public void PrintStars(object o)&#123; if (o is null)return; // 常量模式 “null” if (!(o is int i)) return; // 类型模式 “int i” WriteLine(new string('*', i));&#125; 如你所见，模式变量（**pattern variables）——通过模式引入的变量——和之前描述过的 out 变量很像，都可以在表达式中声明，也可以在最近的作用域中使用。和 out 变量一样，模式变量也是可以修改的。我们经常以“表达式变量”来统称 out 变量和模式变量。 模式和 Try 模式通常可以被很好地组合使用： 1if (o is int i || (o is string s &amp;&amp; int.TryParse(s, out i)) &#123; /* 使用 i */ &#125; 具有模式的 Switch 语句我们正在使 switch 语句一般化，因此： 你可以筛选任意类型（不仅仅是原生类型） 模式可以被用在 case 子句中 Case 子句可以有额外的限制条件 这是个简单的例子： 1234567891011121314151617switch(shape)&#123; case Circle c: WriteLine($\"circle with radius &#123;c.Radius&#125;\"); break; case Rectangle s when (s.Length == s.Height): WriteLine($\"&#123;s.Length&#125; x &#123;s.Height&#125; square\"); break; case Rectangle r: WriteLine($\"&#123;r.Length&#125; x &#123;r.Height&#125; rectangle\"); break; default: WriteLine(\"&lt;unknown shape&gt;\"); break; case null: throw new ArgumentNullException(nameof(shape));&#125; 关于这个新扩展的 switch 语句有一些需要注意的事项： 现在 case 子句的顺序变得重要了：就如 catch 子句一样，case 子句不再一定不相交，第一个匹配的项将被选择。因此将正方形的情况（见上图例）放在矩形之前很重要。同样，编译器会帮你标出永远无法到达的分支。在此之前你无法指定计算顺序，因此这不会造成（旧代码）行为的大变化。 default 子句将总是在最后被计算： 即使 null 的情况被放在最后，它仍会在 default 子句被选中之前被检查。这是为了与现存的语义兼容。然而，良好的习惯通常会将 default 子句放在最后。 在最后的 null 子句不会无法到达： 这是因为类型模式（的行为）以目前的 is 表达式为例子，且不会与 null 匹配。这保证了 null 值不会意外地被类型模式抢先匹配；你需要更加明确如何处理它们（或是将它们留给 default 子句）。 由 case …: 标签引入的模式变量只在当前的 switch 节有效。 元组（Tuples）我们经常希望能从一个方法中返回一个以上的结果。旧版本的 C# 中的选项远远达不到令人满意的程度： Out 参数： 使用起来很笨拙（哪怕你使用了上面所述的改进），并且无法在 async 方法中使用。 System.Tuple&lt;…&gt; 返回类型： 用起来很啰嗦，并且需要分配一个元组对象。 自定义每个方法的传输类型： 需要用一大堆代码来实现一个类，而目的仅仅是临时打包几个变量。 通过动态类型返回匿名类： 性能有瓶颈，且没有静态类型检查。 为了在这方面做得更好，C# 7.0 加入了元组类型（tuple types）和元组字面量（tuple literals）： 12345(string, string, string) LookupName(long id) // 元组返回类型&#123; ... // 从数据储存中取出第一个、中间和最后一个数据 return (first, middle, last); // 元组字面量&#125; 这种方法现在会很有效率地返回三个字符串，包装成一个元组值中的元素。 方法的调用者将会收到一个元组，并可以分别访问各个元素： 12var names = LookupName(id);WriteLine($\"found &#123;names.Item1&#125; &#123;names.Item3&#125;.\"); Item1 等是元组元素的默认名称，并且总是可用的。但是这样描述性不是非常好，因此你可以选择性地使用另一种更好的方法： 1(string first, string middle, string last) LookupName(long id) // 元组元素拥有了名称 现在元组的接收者可以使用更具描述性的名字了： 12var names = LookupName(id);WriteLine($\"found &#123;names.first&#125; &#123;names.last&#125;.\"); 你也可以直接在元组字面量中指定元素名称： 1return (first: first, middle: middle, last: last); // 在字面量中命名元组元素 通常来说你可以无视名字而将元组类型互相转换：只要每个元素之间是可转换的（assignable），元组类型即可自由地互相转换。 元组是值类型，它们的元素是简单的公共、可修改的字段。它们具有值相等性，意味着如果两个元组间每个元素两两相等（且拥有相同的哈希值）则两个元组相等（且拥有相同的哈希值）。 这使得元组在多返回值之外的许多场景也很有用。例如，如果你需要一个拥有多个键的字典，使用一个元组作为你的键，一切都会正常运行。如果你需要一个每个位置有多个值的列表，使用元组吧，诸如搜索列表这样的功能将会正确的工作。 元组依赖于一族被称为 ValueTuple&lt;…&gt; 的底层泛型结构类型。如果你指向了一个还未包含这些类型的框架，你可以从 Nuget 中获得它们： 在解决方案管理器中右击项目并选中“管理 NuGet 程序包” 选择“浏览”标签并将“nuget.org”选为“程序包源” 搜索“System.ValueTuple”并安装它。 解构（Deconstruction）另一个使用元组的方法是去解构它们。一个解构声明（deconstructing declaration**）是一种用来将一个元组（或其他值类型)分成许多部分并将这些部分分别转换为全新的变量的语法： 12(string first, string middle, string last) = LookupName(id1); // 解构声明WriteLine($\"found &#123;first&#125; &#123;last&#125;.\"); 在一个解构声明中，你可以为独立的变量声明使用 var： 1(var first, var middle, var last) = LookupName(id1); // 在内部使用 var 甚至把一个单独的 var 放在括号外作为缩写： 1var (first, middle, last) = LookupName(id1); // 在外部使用 var 你也可以通过 解构分配（deconstructing assignment）将其解构到已存在的变量上： 1(first, middle, last) = LookupName(id2); // 解构分配 解构不仅仅适用于元组。任何类型都可以被解构，只要它拥有一个如下形式的（实例或扩展）解构方法（deconstructor method）： 1public void Deconstruct(out T1 x1, ..., out Tn xn) &#123; ... &#125; Out 参数构成解构的结果。 （为什么它使用 out 参数而不是返回一个元组？那是因为这样一来你可以对不同的值的数量拥有不同的重载了）。 1234567891011class Point&#123; public int X &#123; get; &#125; public int Y &#123; get; &#125; public Point(int x, int y) &#123; X = x; Y = y; &#125; public void Deconstruct(out int x, out int y) &#123; x = X; y = Y; &#125;&#125;(var myX, var myY) = GetPoint(); // 调用 Deconstruct(out myX, out myY); 它将成为一种常见的模式，通过以这种方式“对称地”拥有构造器和解构器。 如同 out 变量，我们允许在解构中“舍弃”你不关心的部分： 1(var myX, _) = GetPoint(); // 我只关心 myX 本地方法（Local functions）有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 本地函数（local function）： 123456789101112public int Fibonacci(int x)&#123; if (x &lt; 0) throw new ArgumentException(\"Less negativity please!\", nameof(x)); return Fib(x).current; (int current, int previous) Fib(int i) &#123; if (i == 0) return (1, 0); var (p, pp) = Fib(i - 1); return (p + pp, p); &#125;&#125; 作用域内的参数和本地变量都在本地方法中可用，就如同在 lambda 表达式中一样。 例如，被实现为迭代器的方法通常需要一个非迭代的包装函数以在调用时检查参数。（迭代器本身在 MoveNext 被调用之前不会开始）。本地方法完美的适用于这种场景： 123456789101112131415public IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; filter)&#123; if (source == null) throw new ArgumentNullException(nameof(source)); if (filter == null) throw new ArgumentNullException(nameof(filter)); return Iterator(); IEnumerable&lt;T&gt; Iterator() &#123; foreach (var element in source) &#123; if (filter(element)) &#123; yield return element; &#125; &#125; &#125;&#125; 如果 Iterator 是 Filter 旁的私有函数，它可能会被其他成员意外地直接使用（而没有参数检查）。同时，它还需要接收与 Filter 相同的参数，而不是直接在作用域中使用它们。 字面量改进C# 7.0 允许 _（下划线）在数字字面量中作为数字分隔符 （digit separator）： 12var d = 123_456;var x = 0xAB_CD_EF; 你可以将它们放置在任意位置来增强可读性。它们不会影响值。 同时，C# 7.0 引入了二进制字面量（binary literals），这样你可以直接指定位模板而不用将十六进制记号牢记于心。 1var b = 0b1010_1011_1100_1101_1110_1111; 引用返回和引用本地变量（Ref returns and locals）就像你可以在 C# 中以引用方式传值（使用 ref 修饰符）一样，你现在可以以引用方式返回值，并将它们以引用的方式存在本地变量中。 12345678910111213141516public ref int Find(int number, int[] numbers)&#123; for (int i = 0; i &lt; numbers.Length; i++) &#123; if (numbers[i] == number) &#123; return ref numbers[i]; // 返回储存的位置，而不是值 &#125; &#125; throw new IndexOutOfRangeException($\"&#123;nameof(number)&#125; not found\");&#125;int[] array = &#123; 1, 15, -39, 0, 7, 14, -12 &#125;;ref int place = ref Find(7, array); // 为 7 在数列中的位置起个别名place = 9; // 在数列中以 9 替换 7WriteLine(array[4]); // 输出 9 这对向很大的数据结构中传递占位符来说非常有用。例如，一个游戏可能将它的数据存在一个庞大的预先分配好的结构体数组（以避免垃圾回收的停顿）中。现在方法可以返回直接指向这种解构的引用，调用者可以借此来读或者修改数据。 为了确保这样做是安全的，有一些限制： 你只能返回“可以安全返回”的引用：一种是传给你的，另一种是指向对象中的字段的。 引用本地变量被初始化到一个确定的储存位置，且不可被修改为指向另一个（引用变量）。 更加一般化的 Async 返回类型在此之前，C# 中的 async 方法只能返回 void，Task 或是 Task 中的一个。C# 7.0 允许用这样的方式定义其他的类型以使它们可以从被 async 方法所返回。 例如，我们现在有一个 ValueTask 结构类型。它被用来防止 async 操作的结果在仍在 await 的时候就可用的情况下的 Task 对象的创建。对大多数 async 场景，例如使用到缓存，这可以大幅减少内存分配并可以获得巨大的性能提升。 你可以想象得到，有许多种能使这种“类 Task”类型非常有用的方法。正确的创建它们可能不是那么直观，因此我们并不期待大多数人来造自己的轮子，但是它们将会出现在框架和 API 中，然后调用者们就可以像今天使用 Task 一样地返回并 await 它们了。 更多的表达式体成员（Expression bodied members）表达式体方法，属性等是 C# 6.0 中的一大亮点，但我们并未所有成员上启用它。C# 7.0 在可以拥有表达式体的列表中添加了访问器、构造器和析构器： 12345678910111213class Person&#123; private static ConcurrentDictionary&lt;int, string&gt; names = new ConcurrentDictionary&lt;int, string&gt;(); private int id = GetId(); public Person(string name) =&gt; names.TryAdd(id, name); // 构造器 ~Person() =&gt; names.TryRemove(id, out *); // 析构器 public string Name &#123; get =&gt; names[id]; // get 访问器 set =&gt; names[id] = value; // set 访问器 &#125;&#125; 这是由社区贡献的特性的一个例子，而不是微软 C# 编译器团队（贡献的）。对，开源！ 抛出表达式（Throw expressions）在表达式中抛出异常非常简单：只要调用一个为你做这件事的方法！但是在 C# 7.0 中我们直接允许将 throw 在特定位置作为一个表达式： 1234567891011class Person&#123; public string Name &#123; get; &#125; public Person(string name) =&gt; Name = name ?? throw new ArgumentNullException(nameof(name)); public string GetFirstName() &#123; var parts = Name.Split(\" \"); return (parts.Length &gt; 0) ? parts[0] : throw new InvalidOperationException(\"No name!\"); &#125; public string GetLastName() =&gt; throw new NotImplementedException();&#125; （全文完）","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-25T13:51:57.623Z","updated":"2017-12-27T15:14:33.446Z","comments":true,"path":"2017/12/25/hello-world/","link":"","permalink":"https://luox78.github.io/2017/12/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}