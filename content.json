{"meta":{"title":"luox78","subtitle":"Daily Learning","description":"Blog for luox78","author":"luox78","url":"https://luox78.github.io"},"pages":[],"posts":[{"title":"同步基础","slug":"CS_Thread02","date":"2018-01-02T13:19:59.458Z","updated":"2018-01-02T13:32:29.110Z","comments":true,"path":"2018/01/02/CS_Thread02/","link":"","permalink":"https://luox78.github.io/2018/01/02/CS_Thread02/","excerpt":"1同步概要在第 1 部分：基础知识中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。 下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。","text":"1同步概要在第 1 部分：基础知识中，我们描述了如何在线程上启动任务、配置线程以及双向传递数据。同时也说明了局部变量对于线程来说是私有的，以及引用是如何在线程之间共享，允许其通过公共字段进行通信。 下一步是同步（synchronization）：为期望的结果协调线程的行为。当多个线程访问同一个数据时，同步尤其重要，但是这是一件非常容易搞砸的事情。 同步构造可以分为以下四类： 简单的阻塞方法 这些方法会使当前线程等待另一个线程结束或是自己等待一段时间。Sleep、Join与Task.Wait都是简单的阻塞方法。 锁构造 锁构造能够限制每次可以执行某些动作或是执行某段代码的线程数量。排它锁构造是最常见的，它每次只允许一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。标准的排它锁构造是lock（Monitor.Enter/Monitor.Exit）、Mutex与 SpinLock。非排它锁构造是Semaphore、SemaphoreSlim以及读写锁。 信号构造 信号构造可以使一个线程暂停，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：事件等待句柄（event wait handle ）和Monitor类的Wait / Pluse方法。Framework 4.0 加入了CountdownEvent与Barrier类。 非阻塞同步构造 非阻塞同步构造通过调用处理器指令来保护对公共字段的访问。CLR 与 C# 提供了下列非阻塞构造：Thread.MemoryBarrier 、Thread.VolatileRead、Thread.VolatileWrite、volatile关键字以及Interlocked类。 阻塞这个概念对于前三类来说都非常重要，接下来我们简要的剖析下它。 1.1阻塞当线程的执行由于某些原因被暂停，比如调用Sleep等待一段时间，或者通过Join或EndInvoke方法等待其它线程结束时，则认为此线程被阻塞（blocked）。被阻塞的线程会立即出让（yields）其处理器时间片，之后不再消耗处理器时间，直到阻塞条件被满足。可以通过线程的ThreadState属性来检查一个线程是否被阻塞： 1bool blocked = (someThread.ThreadState &amp; ThreadState.WaitSleepJoin) != 0; （上面例子中线程状态可能在进行状态判断和依据状态进行操作之间发生改变，因此这段代码仅可用于调试诊断的场景。） 当一个线程被阻塞或是解除阻塞时，操作系统会进行上下文切换（context switch），这会带来几微秒的额外时间开销。 阻塞会在以下 4 种情况下解除（电源按钮可不能算╮(╯▽╰)╭）： 阻塞条件被满足 操作超时（如果指定了超时时间） 通过Thread.Interrupt中断 通过Thread.Abort中止 通过Suspend方法（已过时，不应该再使用）暂停线程的执行不被认为是阻塞。 1.2阻塞 vs 自旋有时线程必须暂停，直到特定条件被满足。信号构造和锁构造可以通过在条件被满足前阻塞线程来实现。但是还有一种更为简单的方法：线程可以通过自旋（spinning）来等待条件被满足。例如： 123while (!proceed);// 或者：while (DateTime.Now &lt; nextStartTime); 一般来说，这会非常浪费处理器时间：因为对 CLR 和操作系统来说，这个线程正在执行重要的计算，就给它分配了相应的资源。 有时会组合使用阻塞与自旋： 1while (!proceed) Thread.Sleep (10); 尽管并不优雅，但是这比仅使用自旋更高效（一般来说）。然而这样也可能会出现问题，这是由proceed标识上的并发问题引起的。正确的使用和锁构造和信号构造可以避免这个问题。 自旋在等待的条件很快（大致几微秒）就能被满足的情况下更高效，因为它避免了上下文切换带来的额外开销。.NET Framework 提供了专门的方法和类型来辅助实现自旋，在第 5 部分会讲到。 1.3线程状态可以通过线程的ThreadState属性来查询线程状态，它会返回一个ThreadState类型的按位方式组合的枚举值，其中包含了三“层”信息。然而大多数值都是冗余的、无用的或者过时不建议使用的。下图是其中一“层”信息： 下面的代码可以提取线程状态中最有用的 4 个值: Unstarted、Running、WaitSleepJoin和Stopped： 123456public static ThreadState SimpleThreadState (ThreadState ts)&#123; return ts &amp; (ThreadState.Unstarted | ThreadState.WaitSleepJoin | ThreadState.Stopped);&#125; ThreadState属性在进行调试诊断时有用，但不适合用来进行同步，因为线程状态可能在判断状态和依据状态进行操作之间发生改变。 2锁排它锁用于确保同一时间只允许一个线程执行指定的代码段。主要的两个排它锁构造是lock和Mutex（互斥体）。其中lock更快，使用也更方便。而Mutex的优势是它可以跨进程的使用。 在这一节里，我们从介绍lock构造开始，然后介绍Mutex和信号量（semaphore）（用于非排它场景）。稍后在第 4 部分会介绍读写锁（reader / writer lock）。 Framework 4.0 加入了SpinLock结构体，可以用于高并发场景。 让我们从下边这个类开始： 12345678910class ThreadUnsafe&#123; static int _val1 = 1, _val2 = 1; static void Go() &#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0; &#125;&#125; 这个类不是线程安全的：如果Go方法同时被两个线程调用，可能会产生除数为零错误，因为可能在一个线程刚好执行完if的判断语句但还没执行Console.WriteLine语句时，_val2就被另一个线程设置为零。 下边使用lock解决这个问题： 1234567891011121314class ThreadSafe&#123; static readonly object _locker = new object(); static int _val1, _val2; static void Go() &#123; lock (_locker) &#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0; &#125; &#125;&#125; 同一时间只有一个线程可以锁定同步对象（这里指_locker），并且其它竞争锁的线程会被阻塞，直到锁被释放。如果有多个线程在竞争锁，它们会在一个“就绪队列（ready queue）”中排队，并且遵循先到先得的规则（需要说明的是，Windows 系统和 CLR 的差别可能导致这个队列在有时会不遵循这个规则）。因为一个线程的访问不能与另一个线程相重叠，排它锁有时也被这样描述：它强制对锁保护的内容进行顺序（serialized）访问。在这个例子中，我们保护的是Go方法的内部逻辑，还有_val1与_val2字段。 在竞争锁时被阻塞的线程，它的线程状态是WaitSleepJoin。在中断与中止中，我们会描述如何通过其它线程强制释放被阻塞的线程，这是一种可以用于结束线程的重型技术（译者注：这里指它们应该被作为在没有其它更为优雅的办法时的最后手段）。 锁构造比较 构造 用途 跨进程 开销* lock（Monitor.Enter/Monitor.Exit） 确保同一时间只有一个线程可以访问资源或代码 - 20ns Mutex ** 1000ns SemaphoreSlim（Framework 4.0 中加入） 确保只有不超过指定数量的线程可以并发访问资源或代码 - 200ns Semaphore ** 1000ns ReaderWriterLockSlim（Framework 3.5 中加入） 允许多个读线程和一个写线程共存 - 40ns ReaderWriterLock（已过时） - 100ns * 时间代表在同一线程上一次进行加锁和释放锁（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。 2.1Monitor.Enter 与 Monitor.ExitC# 的lock语句是一个语法糖，它其实就是使用了try / finally来调用Monitor.Enter与Monitor.Exit方法。下面是在之前示例中的Go方法内部所发生的事情（简化的版本）： 1234567Monitor.Enter (_locker);try&#123; if (_val2 != 0) Console.WriteLine (_val1 / _val2); _val2 = 0;&#125;finally &#123; Monitor.Exit (_locker); &#125; 如果在同一个对象上没有先调用Monitor.Enter就调用Monitor.Exit会抛出一个异常。 lockTaken 重载刚刚所描述的就是 C# 1.0、2.0 和 3.0 的编译器翻译lock语句产生的代码。 然而它有一个潜在的缺陷。考虑这样的情况：在Monitor.Enter的实现内部或者在Monitor.Enter与try中间有异常被抛出（可能是因为在线程上调用了Abort，或者有OutOfMemoryException异常被抛出），这时不一定能够获得锁。如果获得了锁，那么该锁就不会被释放，因为不可能执行到try / finally内，这会导致锁泄漏。 为了避免这种危险，CLR 4.0 的设计者为Monitor.Enter添加了下面的重载： 1public static void Enter (object obj, ref bool lockTaken); 当（且仅当）Enter方法抛出异常，锁没有能够获得时，lockTaken为false。 下边是正确的使用方式（这就是 C# 4.0 对于lock语句的翻译）： 1234567bool lockTaken = false;try&#123; Monitor.Enter (_locker, ref lockTaken); // 你的代码...&#125;finally &#123; if (lockTaken) Monitor.Exit (_locker); &#125; TryEnterMonitor还提供了一个TryEnter方法，允许以毫秒或是TimeSpan方式指定超时时间。如果获得了锁，该方法会返回true，而如果由于超时没有获得锁，则会返回false。TryEnter也可以以无参数的形式进行调用，这是对锁进行“测试”，如果不能立即获得锁就会立即返回false。 类似于Enter方法，该方法在 CLR 4.0 中也被重载来接受lockTaken参数。 2.2选择同步对象对所有参与同步的线程可见的任何对象都可以被当作同步对象使用，但有一个硬性规定：同步对象必须为引用类型。同步对象一般是私有的（因为这有助于封装锁逻辑），并且一般是一个实例或静态字段。同步对象也可以就是其要保护的对象，如下面例子中的_list字段： 12345678910class ThreadSafe&#123; List &lt;string&gt; _list = new List &lt;string&gt;(); void Test() &#123; lock (_list) &#123; _list.Add (\"Item 1\"); // ... 一个只被用来加锁的字段（例如前面例子中的_locker）可以精确控制锁的作用域与粒度。对象自己（this），甚至是其类型都可以被当作同步对象来使用： 123lock (this) &#123; ... &#125;// 或者：lock (typeof (Widget)) &#123; ... &#125; // 保护对静态资源的访问 这种方式的缺点在于并没有对锁逻辑进行封装，从而很难避免死锁与过多的阻塞。同时类型上的锁也可能会跨越应用程序域（application domain）边界（在同一进程内）。 你也可以在被 lambda 表达式或匿名方法所捕获的局部变量上加锁。 锁在任何情况下都不会限制对同步对象本身的访问。换句话说，x.ToString()不会因为其它线程调用lock(x)而阻塞，两个线程都要调用lock(x)才能使阻塞发生。 2.3何时加锁简单的原则是，需要在访问任意可写的共享字段（any writable shared field）时加锁。即使是最简单的操作，例如对一个字段的赋值操作，都必须考虑同步。在下面的类中，Increment与Assign方法都不是线程安全的： 123456class ThreadUnsafe&#123; static int _x; static void Increment() &#123; _x++; &#125; static void Assign() &#123; _x = 123; &#125;&#125; 以下是线程安全的版本： 12345678class ThreadSafe&#123; static readonly object _locker = new object(); static int _x; static void Increment() &#123; lock (_locker) _x++; &#125; static void Assign() &#123; lock (_locker) _x = 123; &#125;&#125; 在非阻塞同步（nonblocking synchronization）中，我们会解释这种需求是如何产生的，以及在这些场景下内存屏障（memory barrier，内存栅栏，内存栅障）和Interlocked类如何提供替代方法进行锁定。 2.4锁与原子性如果一组变量总是在相同的锁内进行读写，就可以称为原子的（atomically）读写。假定字段x与y总是在对locker对象的lock内进行读取与赋值： 1lock (locker) &#123; if (x != 0) y /= x; &#125; 可以说x和y是被原子的访问的，因为上面的代码块无法被其它的线程分割或抢占。如果被其它线程分割或抢占，x和y就可能被别的线程修改导致计算结果无效。而现在 x和y总是在相同的排它锁中进行访问，因此不会出现除数为零的错误。 在lock锁内抛出异常将打破锁的原子性，考虑如下代码： 12345678910decimal _savingsBalance, _checkBalance;void Transfer (decimal amount)&#123; lock (_locker) &#123; _savingsBalance += amount; _checkBalance -= amount + GetBankFee(); &#125;&#125; 如果GetBankFee()方法内抛出异常，银行可能就要损失钱财了。在这个例子中，我们可以通过更早的调用GetBankFee()来避免这个问题。对于更复杂情况，解决方案是在catch或finally中实现“回滚（rollback）”逻辑。 指令原子性是一个相似但不同的概念： 如果一条指令可以在 CPU 上不可分割地执行，那么它就是原子的。（见非阻塞同步） 2.5嵌套锁线程可以用嵌套（重入）的方式重对相同的对象进行加锁： 123456lock (locker) lock (locker) lock (locker) &#123; // ... &#125; 或者： 123Monitor.Enter (locker); Monitor.Enter (locker); Monitor.Enter (locker);// ...Monitor.Exit (locker); Monitor.Exit (locker); Monitor.Exit (locker); 在这样的场景中，只有当最外层的lock语句退出或是执行了匹配数目的Monitor.Exit语句时，对象才会被解锁。 嵌套锁可以用于在锁中调用另一个方法（也使用了同一对象来锁定）： 123456789101112131415static readonly object _locker = new object();static void Main()&#123; lock (_locker) &#123; AnotherMethod(); // 这里依然拥有锁，因为锁是可重入的 &#125;&#125;static void AnotherMethod()&#123; lock (_locker) &#123; Console.WriteLine (\"Another method\"); &#125;&#125; 线程只会在第一个（最外层）lock处阻塞。 2.6死锁当两个线程等待的资源都被对方占用时，它们都无法执行，这就产生了死锁。演示死锁最简单的方法就是使用两个锁： 123456789101112131415object locker1 = new object();object locker2 = new object();new Thread (() =&gt; &#123; lock (locker1) &#123; Thread.Sleep (1000); lock (locker2); // 死锁 &#125; &#125;).Start();lock (locker2)&#123; Thread.Sleep (1000); lock (locker1); // 死锁&#125; 更复杂的死锁链可能由三个或更多的线程创建。 在标准环境下，CLR 不会像SQL Server一样自动检测和解决死锁。除非你指定了锁定的超时时间，否则死锁会造成参与的线程无限阻塞。（在SQL CLR 集成宿主环境中，死锁能够被自动检测，并在其中一个线程上抛出可捕获的异常。） 死锁是多线程中最难解决的问题之一，尤其是在有很多关联对象的时候。这个困难在根本上在于无法确定调用方（caller）已经拥有了哪些锁。 你可能会锁定类x中的私有字段a，而并不知道调用方（或者调用方的调用方）已经锁住了类y中的字段b。同时，另一个线程正在执行顺序相反的操作，这样就创建了死锁。讽刺的是，这个问题会由于（良好的）面向对象的设计模式而加剧，因为这类模式建立的调用链直到运行时才能确定。 流行的建议：“以一致的顺序对对象加锁以避免死锁”，尽管它对于我们最初的例子有帮助，但是很难应用到刚才所描述的场景。更好的策略是：如果发现在锁区域中的对其它类的方法调用最终会引用回当前对象，就应该小心，同时考虑是否真的需要对其它类的方法调用加锁（往往是需要的，但是有时也会有其它选择）。更多的依靠声明方式（declarative）与数据并行（data parallelism）、不可变类型（immutable types）与非阻塞同步构造（ nonblocking synchronization constructs），可以减少对锁的需要。 有另一种思路来帮助理解这个问题：当你在拥有锁的情况下访问其它类的代码，对于锁的封装就存在潜在的泄露。这不是 CLR 或 .NET Framework 的问题，而是因为锁本身的局限性。锁的问题在许多研究项目中被分析，包括软件事务内存（Software Transactional Memory）。 另一个死锁的场景是：如果已拥有一个锁，在调用Dispatcher.Invoke（在 WPF 程序中）或是Control.Invoke（在 Windows Forms 程序中）时，如果 UI 恰好要运行等待同一个锁的另一个方法，就会在这里发生死锁。这通常可以通过调用BeginInvoke而不是Invoke来简单的修复。或者，可以在调用Invoke之前释放锁，但是如果是调用方获得的锁，那么这种方法可能并不会起作用。我们在富客户端应用与线程亲和中来解释Invoke和BeginInvoke。 2.7性能锁是非常快的，在一个 2010 时代的计算机上，没有竞争的情况下获取并释放锁一般只需 20 纳秒。如果存在竞争，产生的上下文切换会把开销增加到微秒的级别，并且线程被重新调度前可能还会等待更久的时间。如果需要锁定的时间很短，那么可以使用自旋锁（SpinLock）来避免上下文切换的开销。 如果获取锁后保持的时间太长而不释放，就会降低并发度，同时也会加大死锁的风险。 2.8互斥体（Mutex）互斥体类似于 C# 的lock，不同在于它是可以跨越多个进程工作。换句话说，Mutex可以是机器范围（computer-wide）的，也可以是程序范围（application-wide）的。 没有竞争的情况下，获取并释放Mutex需要几微秒的时间，大约比lock慢 50 倍。 使用Mutex类时，可以调用WaitOne方法来加锁，调用ReleaseMutex方法来解锁。关闭或销毁Mutex会自动释放锁。与lock语句一样，Mutex只能被获得该锁的线程释放。 跨进程Mutex的一种常见的应用就是确保只运行一个程序实例。下面演示了这是如何实现的： 12345678910111213141516171819202122232425class OneAtATimePlease&#123; static void Main() &#123; // 命名的 Mutex 是机器范围的，它的名称需要是唯一的 // 比如使用公司名+程序名，或者也可以用 URL using (var mutex = new Mutex (false, \"oreilly.com OneAtATimeDemo\")) &#123; // 可能其它程序实例正在关闭，所以可以等待几秒来让其它实例完成关闭 if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false)) &#123; Console.WriteLine (\"Another app instance is running. Bye!\"); return; &#125; RunProgram(); &#125; &#125; static void RunProgram() &#123; Console.WriteLine (\"Running. Press Enter to exit\"); Console.ReadLine(); &#125;&#125; 如果在终端服务（Terminal Services）下运行，机器范围的Mutex默认仅对于运行在相同终端服务器会话的应用程序可见。要使其对所有终端服务器会话可见，需要在其名字前加上Global\\。 2.9信号量（Semaphore）信号量类似于一个夜总会：它具有一定的容量，并且有保安把守。一旦满员，就不允许其他人进入，这些人将在外面排队。当有一个人离开时，排在最前头的人便可以进入。这种构造最少需要两个参数：夜总会中当前的空位数以及夜总会的总容量。 容量为 1 的信号量与Mutex和lock类似，所不同的是信号量没有“所有者”，它是线程无关（thread-agnostic）的。任何线程都可以在调用Semaphore上的Release方法，而对于Mutex和lock，只有获得锁的线程才可以释放。 SemaphoreSlim是 Framework 4.0 加入的轻量级的信号量，功能与Semaphore相似，不同之处是它对于并行编程的低延迟需求做了优化。在传统的多线程方式中也有用，因为它支持在等待时指定取消标记 （cancellation token）。但它不能跨进程使用。 在Semaphore上调用WaitOne或Release会产生大概 1 微秒的开销，而SemaphoreSlim产生的开销约是其四分之一。 信号量在有限并发的需求中有用，它可以阻止过多的线程同时执行特定的代码段。在下面的例子中，五个线程尝试进入一个只允许三个线程进入的夜总会： 12345678910111213141516171819class TheClub&#123; static SemaphoreSlim _sem = new SemaphoreSlim (3); // 容量为 3 static void Main() &#123; for (int i = 1; i &lt;= 5; i++) new Thread (Enter).Start (i); &#125; static void Enter (object id) &#123; Console.WriteLine (id + \" wants to enter\"); _sem.Wait(); Console.WriteLine (id + \" is in!\"); // 同时只能有 Thread.Sleep (1000 * (int) id); // 3个线程 Console.WriteLine (id + \" is leaving\"); // 执行这里 _sem.Release(); &#125;&#125; 输出结果： 1234567891011121 wants to enter1 is in!2 wants to enter2 is in!3 wants to enter3 is in!4 wants to enter5 wants to enter1 is leaving4 is in!2 is leaving5 is in! 如果Sleep语句被替换为密集的磁盘 I/O 操作，由于Semaphore限制了过多的并发硬盘活动，就可能改善整体性能。 类似于Mutex，命名的Semaphore也可以跨进程使用。 3线程安全说一个程序或方法是线程安全（ thread-safe）的，是指它在任意的多线程场景中都不存在不确定性。线程安全主要是通过锁以及减少线程交互来实现。 一般的类型很少有完全线程安全的，原因如下： 完全线程安全的开发负担很重，特别是如果一个类型有很多字段的情况（在任意多线程并发的情况下每个字段都有交互的潜在可能）。 线程安全可能会损失性能（某种程度上，无论类型是否实际被用于多线程都会增加损耗）。 线程安全的类型并不能确保使用该类型的程序也是线程安全的，为了实现程序线程安全所涉及的工作经常会使得类型线程安全成为多余。 因此线程安全通常只会在需要时再实现，只为了处理特定的多线程场景。 然而，有些方法可以用来“作弊” ，使庞大和复杂的类在多线程环境中安全运行。一种方法是牺牲粒度，将大段代码甚至是访问的整个对象封装在一个排它锁内，从而保证在高层上能进行顺序访问。事实上，如果我们希望在多线程环境中使用线程不安全的第三方代码（或大多数 Framework 的类型）时，这种策略是十分有用的。它仅仅是简单的使用了相同的排它锁，来保护对非线程安全对象上所有属性、方法和字段的访问。这种解决方案适用于对象的方法都能够快速执行的场景（否则会导致大量的阻塞）。 除基本类型外，很少有 .NET Framework 的类型能在比并发读取更高的需求下保证其实例成员是线程安全的。实现线程安全的责任就落在了开发人员身上，一般就是使用排它锁。（命名空间System.Collections.Concurrent中的类型是个例外，它们是线程安全的数据结构。） 另一种“作弊”的方法是通过最小化共享数据来减少线程交互。这是一种优秀的方法，隐式的用于“ 无状态（stateless）”的中间层程序和网页服务器中。由于多个客户端请求可以同时到达，服务端方法就必须是线程安全的。无状态设计（因可伸缩性（scalability）好而流行）在本质上限制了交互的可能性，因为类并不需要持久化请求之间的数据。线程交互仅限于静态字段，比如在内存中缓存通用数据，或者提供认证和审计这样的基础服务时需要考虑。 实现线程安全的最后一种方式是使用自动锁机制（automatic locking regime）。如果继承 ContextBoundObject 类并使用 Synchronization 特性，.NET Framework 就可以实现这种机制。当该对象上的方法或属性被调用时，一个对象范围（object-wide）的锁就会自动作用于整个方法或属性的调用。尽管这样降低了实现线程安全的负担，但是也有它的问题：它很可能造成死锁、降低并发度并引起并非有意的重入。正是由于这些原因，手动加锁通常是更好的选择（直到有更好用的自动锁机制出现）。 3.1线程安全与 .NET Framework 类型锁可以用来将线程不安全的代码转换为线程安全的代码。.NET Framework 就是一个好例子：几乎所有的非基本类型的实例成员都不是线程安全的（对于比只读访问更高的需求），然而如果对指定对象的所有访问都通过锁进行保护，它们就可以被用于多线程代码中。例如，两个线程同时向同一个List中添加对象，然后枚举它： 12345678910111213141516171819class ThreadSafe&#123; static List &lt;string&gt; _list = new List &lt;string&gt;(); static void Main() &#123; new Thread (AddItem).Start(); new Thread (AddItem).Start(); &#125; static void AddItem() &#123; lock (_list) _list.Add (\"Item \" + _list.Count); string[] items; lock (_list) items = _list.ToArray(); foreach (string s in items) Console.WriteLine (s); &#125;&#125; 在这个例子中，我们使用_list对象本身来加锁。如果有两个关联的List，就需要选择一个公共对象来加锁（可以使用其中一个List对象，然而更好的方式是使用一个独立的字段）。 枚举 .NET 的集合也不是线程安全的，因为如果在枚举的过程中集合被修改则会抛出异常。在这个例子中，我们并没有将整个枚举过程加锁，而是首先将其中的对象复制到一个数组中。如果我们要进行的枚举可能很耗时，那么可以通过上述方式避免过长时间锁定。（另一种解决方案是使用读写锁（reader / writer lock）） 对线程安全的对象加锁有时也需要对线程安全的对象加锁，为了举例说明，假设 Framework 的List类是线程安全的，我们要给它添加一个条目： 1if (!_list.Contains (newItem)) _list.Add (newItem); 无论List本身是否线程安全，上面的语句都不是线程安全的！为了防止if条件判断执行后，在实际添加条目之前，被其它线程抢占修改了_list，整个if所包含的代码都需要封装在一个锁中。并且在所有要修改_list的地方都要使用这个锁。例如，下面的语句也需要封装在相同的锁中： 1_list.Clear(); 这也是为了确保了它不会在前面语句的执行过程中抢先执行。换句话说，我们不得不像对于非线程安全的集合一样锁定线程安全的集合（这使得对于List类是线程安全的假设变得多余）。 在高并发的环境下，对集合的访问加锁可能会产生大量阻塞，为此 Framework 4.0 提供了线程安全的队列、栈和字典。 静态成员将对对象的访问封装在一个自定义锁中的方式，只有当所有参与并发的线程都知道并使用这个锁时才能起作用。然而如果需要加锁的逻辑有更大范围那就不是这么简单了。最糟糕的情况就是public类型中的静态成员。比如，我们假设DateTime结构体上的静态属性DateTime.Now不是线程安全的，即两个并发线程调用会导致错误的输出或是异常。使用外部加锁进行修正的唯一方法就是在调用DateTime.Now之前对类型本身加锁：lock(typeof(DateTime))。这仅适用于所有的程序员都接受这样做（这不太可能）。此外，对类型加锁也有其自身的问题。 因此，DateTime结构体的静态成员都经过细致的处理，来保证它是线程安全的。这在 .NET Framework 中是一个通用模式：静态成员是线程安全的，而实例成员则不是。编写类型让别人使用时，遵守这种模式就不会令别人感到困惑和遇到难以解决的线程安全问题。换句话说，保证静态成员的线程安全，就不会妨碍你的类型的使用者实现线程安全。 静态方法的线程安全是必须由明确的编码实现的，不是说把方法写成静态的就能自动实现线程安全！ 只读线程安全使类型对于并发只读访问是线程安全的会很有益，这意味着使用者可以避免使用排它锁。许多 .NET Framework 类型都遵循这一原则：例如集合对于并发读是线程安全的。 自己遵循这一愿则也很简单：如果我们希望一个类型对于并发只读访问是线程安全的，那么不要在使用者期望是只读的方法内修改字段（也不要加锁后修改）。例如，在集合的ToArray()方法的实现中，也许会从压紧（compacting）集合的内部结构开始。然而，这会导致使用者认为是只读的操作并非线程安全。 只读线程安全也是枚举器与可枚举类型分离的原因之一：两个线程可以在一个集合上同时进行枚举，因为它们会分别获得单独的枚举器。 如果缺乏文档，在认为一个方法是只读前一定要谨慎。一个很好的例子是Random类：当调用Random.Next()时，它会更新私有的种子（seed）值。因此，或者对Random类的使用加锁，或者每个线程使用单独的实例。 3.2应用服务器中的线程安全应用服务器需要使用多线程来处理多个客户端的同时请求。WCF、ASP.NET 以及 Web Services 应用都是隐式多线程的。使用 TCP 或 HTTP 之类网络通道的远程（Remoting）服务应用程序也是如此。这意味着服务端编程必须考虑线程安全，考虑在处理客户端请求的线程间是否存在交互的可能。幸运的是，这种交互的可能性不大，一般服务端类要不然是无状态的（无字段），要不然就有为每个客户端或每个请求创建单独对象实例的激活模型。交互通常仅在静态字段上出现，有时是用于在内存中缓存数据库数据来提高性能。 例如，有一个查询数据库的RetrieveUser方法： 12// User 是一个自定义类型，包含用户数据的字段internal User RetrieveUser (int id) &#123; ... &#125; 如果对这个方法的调用很频繁，可以通过在一个静态Dictionary中缓存查询结果来提高性能。下边是一个考虑了线程安全的方案： 1234567891011121314151617static class UserCache&#123; static Dictionary &lt;int, User&gt; _users = new Dictionary &lt;int, User&gt;(); internal static User GetUser (int id) &#123; User u = null; lock (_users) if (_users.TryGetValue (id, out u)) return u; u = RetrieveUser (id); // 从数据库获取数据 lock (_users) _users [id] = u; return u; &#125;&#125; 至少必须要在读取和更新字典时加锁来保证线程安全。在这个例子中，在加锁的便捷和性能之间进行了平衡。我们的设计略有一些效率问题：如果两个线程同时使用未缓存过数据的id调用这个方法，RetrieveUser就可能被调用两次，并且其中一次对字典的更新是不必要的。对整个方法加锁可以避免这一问题，但会导致更糟的效率：整个缓存在调用RetrieveUser的期间都会被加锁，在这段时间内，其它需要这样获取用户信息的线程都会被阻塞。 3.3富客户端应用与线程亲和（译者注：这里的 thread affinity 译为线程亲和，是指 UI 控件与线程的一种“绑定”关系，而不是通常理解中的线程与 CPU 核心的绑定关系。） WPF 与 Windows Forms 库都遵循基于线程亲和的模型。尽管它们有各自的实现，但是原理非常相似。 富客户端的构成主要基于DependencyObject（WPF 中）或是Control（Windows Forms 中）。这些对象具有线程亲和性（thread affinity），意思是只有创建它们的线程才能访问其成员。违反这一原则会引起不可预料的行为，或是抛出异常。 这样的好处是访问 UI 对象时并不需要加锁。而坏处是，如果希望调用在另一线程 Y 上创建的对象 X 的成员，就必须将请求封送（marshal）到线程 Y 。通过下列方法显式实现： WPF 中：在其Dispatcher对象上调用Invoke或BeginInvoke。 Windows Forms 中：调用Control对象上的Invoke或BeginInvoke。 Invoke和BeginInvoke都接受一个委托，代表我们希望在目标控件上运行的的方法。Invoke是同步工作的：调用方在封送的委托执行完成前会被阻塞；BeginInvoke是异步工作的：调用方立即返回，封送请求被加入队列（使用与处理键盘、鼠标、定时器事件相同的消息队列）。 假定窗体包含一个名为txtMessage的文本框，我们希望使用一个工作线程更新其内容，下面是 WPF 的示例： 1234567891011121314151617181920public partial class MyWindow : Window&#123; public MyWindow() &#123; InitializeComponent(); new Thread (Work).Start(); &#125; void Work() &#123; Thread.Sleep (5000); // 模拟耗时任务 UpdateMessage (\"The answer\"); &#125; void UpdateMessage (string message) &#123; Action action = () =&gt; txtMessage.Text = message; Dispatcher.Invoke (action); &#125;&#125; Windows Forms 的代码类似，所不同的是我们调用Form的Invoke方法： 12345void UpdateMessage (string message)&#123; Action action = () =&gt; txtMessage.Text = message; this.Invoke (action);&#125; Framework 提供了两个构造来简化这个过程： BackgroundWorker 任务延续（Task continuations） 工作线程 vs UI 线程我们可以认为富客户端应用程序中有两种不同的线程类别：UI 线程和工作线程。UI 线程创建（并“占有”） UI 元素，工作线程则不会；工作线程通常执行长时间任务，例如获取数据。 大多数的富客户端应用只有一个 UI 线程（它也是应用程序的主线程），它再去根据需要创建工作线程，可以直接创建或者使用BackgroundWorker。这些工作线程可以将代码封送回主 UI 线程来更新控件或报告工作进度。 那么，应用程序何时会需要多个 UI 线程呢？主要的应用场景是：如果应用具有多个顶级窗口，每个顶级窗口都是被称为单文档界面（Single Document Interface，SDI）的程序，例如 Microsoft Word。每个 SDI 窗口通常会在任务栏上显示为独立的应用程序，并且与其它的 SDI 窗口在功能上基本隔离。通过为每一个这样的窗口设置独立的 UI 线程，可以使应用程序有更好的响应。 3.4不可变对象不可变对象的状态不能被修改，无论通过外部还是内部。不可变对象的字段通常被声明为只读的，并且在构造过程中就会被初始化好。 不变性（immutability ）是函数式编程的一个标志：不是修改对象，而是使用不同的属性创建一个新的对象。LINQ 就遵循这种模式。不变性在多线程中也很有价值，它可以通过消除（或是最小化）写入的可能来避免共享可写状态的问题。 使用不可变对象的一个模式是：封装一组相关的字段来最小化锁定的时长。下面的例子中，假设有两个字段： 12int _percentComplete;string _statusMessage; 我们希望对其进行原子的读 / 写操作。除了加锁之外，也可以定义如下的不可变类： 12345678910111213class ProgressStatus // 代表某活动进度&#123; public readonly int PercentComplete; public readonly string StatusMessage; // 这个类可能还有其它很多字段... public ProgressStatus (int percentComplete, string statusMessage) &#123; PercentComplete = percentComplete; StatusMessage = statusMessage; &#125;&#125; 然后，我们可以定义一个该类型的字段，以及一个用于加锁的对象： 12readonly object _statusLocker = new object();ProgressStatus _status; 现在，我们就可以读 / 写该类型的值，而仅需要为一次赋值加锁： 1234var status = new ProgressStatus (50, \"Working on it\");// 想象一下我们曾经在这要处理多少个字段 ...// ...lock (_statusLocker) _status = status; // 非常短暂的锁 要读取该对象，首先获取该对象的一个副本（在锁内），然后就可以读取其值而不需要继续占有锁： 12345ProgressStatus statusCopy;lock (_locker ProgressStatus) statusCopy = _status; // 也是一个短暂的锁int pc = statusCopy.PercentComplete;string msg = statusCopy.StatusMessage;// ... （译者注：上面代码有误，lock中应该是_statusLocker。这里的statusCopy也不是真正的副本，而仅仅相当于_status的别名，这么做是为了通过刷新处理器缓存，获取_status当前的一致状态。） 技术上讲，最后两行代码的线程安全，是因为之前的lock进行了隐式的内存屏障（memory barrier）。 需要注意的是，这种无锁（译者注：这里不是说完全没有用到锁，而是指锁非常短暂）的方法可以避免一组相关字段出现不一致的情况。但它无法阻止后续的操作修改数据，因此，通常需要使用锁。在第 5 部分中，将会看到使用不变性来简化多线程的更多示例，包括PLINQ。 可以根据先前的值安全的创建一个新的ProgressStatus对象（例如：在其上可以“增加”PercentComplete的值），而仅需锁定一行代码。实际上不使用锁都可以，我们可以显式使用内存屏障、Interlocked.CompareExchange还有自旋等待。这种高级技术将在稍后的并行编程中讲解。 4使用事件等待句柄进行信号同步（译者注：signal / signalling 直译是信号 / 发信号，一般在通讯领域用于控制的信号称为信令，但是计算机领域一般还是称之为信号。这里的 signaling 指使用信号进行线程同步，翻译成信号或者信号同步。） 事件等待句柄（event wait handle）用于信号同步。信号同步就是一个线程进行等待，直到它收到其它线程的通知的过程。事件等待句柄是最简单的信号构造，与 C# 的事件（译者注：指基于event关键字的事件模式）无关。它们有三个成员：AutoResetEvent、ManualResetEvent以及CountdownEvent( Framework 4.0 中加入)。前两个的功能基本都是在它们的基类EventWaitHandle上实现的。 信号构造比较 构造 用途 跨进程 开销* AutoResetEvent 使线程在收到其它线程信号时解除阻塞一次 ** 1000ns ManualResetEvent 使线程在收到其它线程信号时解除阻塞，并且不继续阻塞直到被复位 ** 1000ns ManualResetEventSlim（Framework 4.0 中加入） - 40ns CountdownEvent（Framework 4.0 中加入） 使线程在收到预定数量的信号时解除阻塞 - 40ns Barrier（Framework 4.0 中加入） 实现线程执行屏障 - 80ns Wait 和 Pulse 使线程阻塞，直到自定义条件被满足 - 120ns每个Pulse * 时间代表在同一线程上进行发信号并等待（假设没有阻塞）的开销，在 Intel Core i7 860 上测得。 4.1AutoResetEventAutoResetEvent就像验票闸机：插入一张票，就只允许一个人通过。类名字里的 “ auto “ 是指打开的闸门可以自动关闭，或着说在有人通过后 “reset （复位）”。在闸机处调用WaitOne方法（等待这 “one（一个）” 闸机打开），线程就会进入等待或者说阻塞。票的插入则通过调用Set方法。如果有多个线程调用WaitOne，便会在闸机前排队（与锁同样，由于操作系统的差异，这个等待队列的先入先出顺序有时可能被破坏）。票可以来自任意线程，换句话说，任何能够访问这个AutoResetEvent对象的（非阻塞）线程都可以调用Set方法来放行一个被阻塞的线程。 有两种方式可以创建AutoResetEvent对象，第一种是通过构造方法： 1var auto = new AutoResetEvent (false); （如果传递ture给构造方法则相当于在创建后立即调用Set方法。） 第二种方式是像下边的代码这样创建AutoResetEvent： 1var auto = new EventWaitHandle (false, EventResetMode.AutoReset); 在接下来的例子中，一个线程开始等待直到收到另一个线程的信号。 1234567891011121314151617class BasicWaitHandle&#123; static EventWaitHandle _waitHandle = new AutoResetEvent (false); static void Main() &#123; new Thread (Waiter).Start(); Thread.Sleep (1000); // 暂停 1 秒 _waitHandle.Set(); // 唤醒 Waiter &#125; static void Waiter() &#123; Console.WriteLine (\"Waiting...\"); _waitHandle.WaitOne(); // 等待通知 Console.WriteLine (\"Notified\"); &#125; 输出结果： 1Waiting... (pause) Notified. 如果在没有线程等待的时候调用Set，该事件等待句柄会保持“打开”状态直到有线程调用WaitOne。这个行为可以帮助避免一个前往闸机的线程和一个正在插入票的线程之间的配合问题（“糟糕，票早插入了 1 微秒，真不幸，你要永远等下去了！”）。然而，在一个没有任何线程在等待的闸机上反复调用Set并不会允许一堆线程通过：仅仅允许下一个通过，多出来的票被“浪费”了。 在AutoResetEvent上调用Reset可以关闭闸机（应该是开启状态的），这个调用不会等待或阻塞。 WaitOne接受一个可选的timeout参数，如果等待不是由于收到了信号，而是超时结束则返回false。 调用WaitOne并给定一个为 0 的超时时间，可以用来测试等待句柄是否是“打开”的，并且不会阻塞调用方。但是要记住，如果AutoResetEvent是打开的则会复位（关闭）它。 销毁等待句柄（译者注：这里把 dispose 翻译为销毁。） 一旦等待句柄使用完成，可以调用它的Close方法来释放操作系统资源。或者，也可以简单地丢弃所有对等待句柄的引用，让垃圾回收器在稍后处理它（等待句柄实现了销毁模式，会在析构方法中调用Close）。这是少数几个能被接受的（有争论）依赖这种备用机制的场景之一，因为等待句柄对操作系统而言是轻量级资源（异步委托（asynchronous delegates）就是这样来释放其IAsyncResult的等待句柄的 ）。 等待句柄在应用程序域被卸载时会自动地释放。 双向信号我们设定一种场景：主线程需要连续向工作线程发 3 次信号。如果主线程只是在等待句柄上快速的多次调用Set，第 2 个和第 3 个信号可能会丢失，这是由于工作线程可能要花时间去处理每个信号。 解决方案是：主线程需要在发信号前等待工作线程就绪。这可以再用一个AutoResetEvent做到，例如： 12345678910111213141516171819202122232425262728293031323334353637class TwoWaySignaling&#123; static EventWaitHandle _ready = new AutoResetEvent (false); static EventWaitHandle _go = new AutoResetEvent (false); static readonly object _locker = new object(); static string _message; static void Main() &#123; new Thread (Work).Start(); _ready.WaitOne(); // 首先等待工作线程就绪 lock (_locker) _message = \"ooo\"; _go.Set(); // 通知工作线程执行 _ready.WaitOne(); lock (_locker) _message = \"ahhh\"; // 给工作线程其它信息 _go.Set(); _ready.WaitOne(); lock (_locker) _message = null; // 发信号通知工作线程退出 _go.Set(); &#125; static void Work() &#123; while (true) &#123; _ready.Set(); // 表示我们准备好了 _go.WaitOne(); // 等待开始 lock (_locker) &#123; if (_message == null) return; // 优雅地退出 Console.WriteLine (_message); &#125; &#125; &#125;&#125; 输出结果： 12oooahhh 这里我们使用了一个为null的消息来指示工作线程结束。对于无限运行（译者注：指类似这里的while (true)方式无限循环）的线程，退出机制是非常重要的！ 生产者 / 消费者队列生产者 / 消费者队列是一个在多线程中常见的需求，它是这样工作的： 建立一个队列，用于描述需要执行的工作项，或需要处理的数据。 当有任务需要执行时，把它加入队列中，这样调用方就可以继续处理其它事情。 一个或多个工作线程在后台工作，它们从队列中取出工作项并执行。 这种模型的好处是，可以精确控制工作线程的数量，使你能够限制 CPU 和其它资源的消耗。比如，如果任务执行密集的磁盘 I/O 操作，可以仅使用一个工作线程来执行工作，这样能够避免操作系统和其它应用出现饥饿。其它类型的应用也许就可以使用 20 个工作线程。也可以在队列生命周期内动态添加和移除工作线程。CLR 的线程池本身就是一种生产者 / 消费者队列。 生产者 / 消费者队列一般只是存放需要任务处理的数据项，例如数据项可能是文件名，而任务是加密这些文件。 下边的例子，使用一个AutoResetEvent发信号给工作线程，工作线程在所有任务都已完成时（或者说队列为空时）会处于等待状态。通过加入null任务来通知工作线程结束： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Threading;using System.Collections.Generic;class ProducerConsumerQueue : IDisposable&#123; EventWaitHandle _wh = new AutoResetEvent (false); Thread _worker; readonly object _locker = new object(); Queue&lt;string&gt; _tasks = new Queue&lt;string&gt;(); public ProducerConsumerQueue() &#123; _worker = new Thread (Work); _worker.Start(); &#125; public void EnqueueTask (string task) &#123; lock (_locker) _tasks.Enqueue (task); _wh.Set(); &#125; public void Dispose() &#123; EnqueueTask (null); // 通知消费者退出 _worker.Join(); // 等待消费者线程完成执行 _wh.Close(); // 释放所有系统资源 &#125; void Work() &#123; while (true) &#123; string task = null; lock (_locker) if (_tasks.Count &gt; 0) &#123; task = _tasks.Dequeue(); if (task == null) return; &#125; if (task != null) &#123; Console.WriteLine (\"Performing task: \" + task); Thread.Sleep (1000); // 模拟执行工作... &#125; else _wh.WaitOne(); // 没有任务了，等待信号 &#125; &#125;&#125; 为保证线程安全，我们使用了一个锁来保护对Queue&lt;string&gt;的访问。在Dispose方法中，我们也显式关闭了等待句柄，因为在程序生命周期中，有可能会创建和销毁许多这个类的实例。 下边是测试这个队列的主方法： 123456789101112static void Main()&#123; using (ProducerConsumerQueue q = new ProducerConsumerQueue()) &#123; q.EnqueueTask (\"Hello\"); for (int i = 0; i &lt; 10; i++) q.EnqueueTask (\"Say \" + i); q.EnqueueTask (\"Goodbye!\"); &#125; // 使用 using 语句结束时会调用 q 的 Dispose 方法 // 该方法向队列中插入一个 null 的任务，并等待消费者完成退出。&#125; 输出结果： 12345678Performing task: HelloPerforming task: Say 1Performing task: Say 2Performing task: Say 3......Performing task: Say 9Goodbye! Framework 4.0 提供了一个新的类型BlockingCollection，它实现了生产者 / 消费者队列的功能。 前面我们自己写的生产者 / 消费者队列还是有价值的，它不仅仅为了举例说明AutoResetEvent和线程安全，也是更多其它复杂构造的基础。例如，如果想要实现有界阻塞队列（bounded blocking queue）（可以限制队列中任务的个数），并且希望支持取消（和移除）队列中工作项，我们的代码就是一个很好的起点。之后在讨论Wait 和 Pulse时会让这个的生产者 / 消费者队列的例子更进一步。 4.2ManualResetEventManualResetEvent就像一个普通的门。调用Set方法打开门，允许任意数量的线程调用WaitOne方法来通过。调用Reset方法关闭门。如果线程在一个关闭的门上调用WaitOne方法将会被阻塞，当门下次打开时，会被立即放行。除这些不同以外，ManualResetEvent就和AutoResetEvent差不多了。 与AutoResetEvent类似，可以使用两种方式构造ManualResetEvent: 12var manual1 = new ManualResetEvent (false);var manual2 = new EventWaitHandle (false, EventResetMode.ManualReset); 从 Framework 4.0 开始，提供了另一个版本的ManualResetEvent，名为ManualResetEventSlim。后者为短等待时间做了优化，它提供了进行一定次数迭代自旋的能力，也实现了一种更有效的管理机制，允许通过CancellationToken取消Wait等待。但它不能用于跨进程的信号同步。ManualResetEventSlim不是WaitHandle的子类，但它提供一个WaitHandle的属性，会返回一个基于WaitHandle的对象（使用它的性能和一般的等待句柄相同）。 信号构造与性能对于AutoResetEvent和ManualResetEvent，使用它们等待或者发信号需要大概 1 微秒时间（假设没有阻塞）。 ManualResetEventSlim和CountdownEvent在等待时间很短的情况下可以比上面两个快 50 倍。这是因为它们不依赖操作系统，并能择机使用自旋构造。 然而大多数情况下，信号构造自身的开销并不会造成瓶颈，所以很少需要去考虑。高度并发的场景是个例外，我们将在第 5 部分进行讨论。 ManualResetEvent在需要让一个线程解除其它多个线程的阻塞时有用。如果是相反的需求，可以使用CountdownEvent。 4.3CountdownEventCountdownEvent 可以让你等待 1 个以上的线程。这个类型是 Framework 4.0 加入的，并且是一个高效的纯托管实现。 如果在使用较早版本的 .NET Framework，也不是没有办法。稍后我们会介绍如何使用Wait 和 Pulse来实现CountdownEvent。 使用CountdownEvent时，需要指定一个计数器数值，也就是你希望等待的线程数量： 1var countdown = new CountdownEvent (3); // 初始计数为 3 调用Signal方法会将计数减 1，调用Wait会阻塞直到计数为 0。例如： 123456789101112131415161718static CountdownEvent _countdown = new CountdownEvent (3);static void Main()&#123; new Thread (SaySomething).Start (\"I am thread 1\"); new Thread (SaySomething).Start (\"I am thread 2\"); new Thread (SaySomething).Start (\"I am thread 3\"); _countdown.Wait(); // 阻塞直到收到 3 次信号 Console.WriteLine (\"All threads have finished speaking!\");&#125;static void SaySomething (object thing)&#123; Thread.Sleep (1000); Console.WriteLine (thing); _countdown.Signal();&#125; 有时通过使用结构化并行（structured parallelism）构造会比CountdownEvent更容易解决问题。我们将在第 5 部分来说明（PLINQ 和 Parallel类）。 调用AddCount，可以增加CountdownEvent的计数。然而，如果计数已经为 0，就会抛出一个异常：是无法通过调用AddCount来复位（unsignal）的。为避免异常，可以用TryAddCount替代，它在当前计数为 0 时会返回false。 想要复位，可以调用Reset：把构造复位到初始状态，计数恢复原值。 像ManualResetEventSlim一样，CountdownEvent也提供WaitHandle属性，可以在其它类或方法希望得到一个基于WaitHandle的对象时使用。 4.4创建跨进程的 EventWaitHandleEventWaitHandle的构造方法允许以命名的方式进行创建，这样它就可以跨进程使用。名称就是一个字符串，可以随意起名，但是注意不要和别人的命名冲突！如果名字在计算机上已存在，你就会获取一个它对应的EventWaitHandle的引用，否则操作系统会创建一个新的。例如： 12EventWaitHandle wh = new EventWaitHandle (false, EventResetMode.AutoReset, \"MyCompany.MyApp.SomeName\"); 如果两个应用程序分别执行这个代码，它们就可以进行信号同步：这个等待句柄可以在跨这两个进程内的所有线程中使用。 4.5等待句柄和线程池如果你的应用有很多线程，这些线程大部分时间都在阻塞，那么可以通过调用ThreadPool.RegisterWaitForSingleObject来减少资源消耗。这个方法接受一个委托，它会在向等待句柄发信号时执行。当处于等待状态时，它不会浪费线程资源： 123456789101112131415161718static ManualResetEvent _starter = new ManualResetEvent (false);public static void Main()&#123; RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject (_starter, Go, \"Some Data\", -1, true); Thread.Sleep (5000); Console.WriteLine (\"Signaling worker...\"); _starter.Set(); Console.ReadLine(); reg.Unregister (_starter); // 完成后的清理&#125;public static void Go (object data, bool timedOut)&#123; Console.WriteLine (\"Started - \" + data); // 执行任务 ....&#125; 输出结果： 123(5 second delay)Signaling worker...Started - Some Data 当向等待句柄发信号时（或者已超时），委托会在一个线程池线程运行。 除等待句柄和委托外，RegisterWaitForSingleObject还接受一个“黑盒”对象，它会被传递给委托的目标方法（像ParameterizedThreadStart一样）；还有一个以毫秒为单位的超时时间（-1 代表没有超时时间）；和一个布尔值用来设置请求是一次性的还是可重复的。 RegisterWaitForSingleObject在需要处理很多并发请求的应用服务器中非常有用。假如你需要在ManualResetEvent上阻塞，调用WaitOne就可以了： 12345void AppServerMethod()&#123; _wh.WaitOne(); // ... 继续执行&#125; 如果 100 个客户端调用这个方法，就会有 100 个服务端线程被浪费在阻塞上。把_wh.WaitOne换成RegisterWaitForSingleObject可以让方法立即返回，就不会浪费线程资源： 1234567891011void AppServerMethod&#123; RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject (_wh, Resume, null, -1, true); // ...&#125;static void Resume (object data, bool timedOut)&#123; // ... 继续执行&#125; 传递给Resume的data对象可以用来传递和暂存一些瞬态数据。 4.6WaitAny、WaitAll 和 SignalAndWait除了Set、WaitOne和Reset方法外，在WaitHandle类上还有一些静态方法用来解决更复杂的同步问题。 WaitAny、WaitAll和SignalAndWait方法可以向多个等待句柄发信号和进行等待操作。等待句柄可以是不同的类型（包括Mutex和Semaphore，因为它们都派生自抽象类WaitHandle）。对于ManualResetEventSlim和CountdownEvent，也可以通过它们的WaitHandle属性来让这些方法使用。 WaitAll和SignalAndWait与旧有的 COM 架构有古怪的联系：这些方法要求调用方必须在多线程套间（multithreaded apartment）中，这个模式最不适合交互操作。比如 WPF 或 Windows 应用程序的主线程就不能在这种模式下操作剪贴板。我们稍后会讨论到它们的替代方案。 WaitHandle.WaitAny等待一组等待句柄中任意一个，WaitHandle.WaitAll等待给定的所有等待句柄。这个等待是原子的，就是说如果在等待两个AutoResetEvent： WaitAny当任意一个事件处于“打开”状态时就能结束等待。 WaitAll当两个事件同时处于“打开”状态时才能结束等待。 （译者注：见前文，AutoResetEvent在被Set时，如果没有线程在等待，会保持“打开”状态，直到有线程等待它，会放行一个线程，并“关闭”或者说“复位”。这里用WaitAny等待两个AutoResetEvent，那么它只会触发其中一个的复位，另一个如果也被Set，会继续保持“打开”；而如果是WaitAll，则必须两个都处于“打开”状态才能结束等待，同时触发两个事件的复位。） SignalAndWait会调用一个WaitHandle的Set方法，然后调用另一个WaitHandle的WaitOne方法。在向第一个句柄发信号后，会（让当前线程）跳到第二个句柄的等待队列的最前位置。你可以把它看作是“交换”两个信号，在一对EventWaitHandle上调用这个方法来设定两个线程的会合点（rendezvous），或者说是让它们在某一个时间点“相遇”。不管是AutoResetEvent还是ManualResetEvent都可以用来实现这个技巧。第一个线程执行： 1WaitHandle.SignalAndWait (wh1, wh2); 而第二个线程相反： 1WaitHandle.SignalAndWait (wh2, wh1); WaitAll 和 SignalAndWait 的替代方案WaitAll和SignalAndWait不能运行在单线程套间（single-threaded apartment）中。幸运的是，还有替代方案。对于SignalAndWait，其实很少需要它的插队机制：例如在上边的会合例子中，如果等待句柄完全只是为了会合使用，那么就可以在第一个句柄上调用Set，然后在第二个句柄上调用WaitOne。在Barrier类中，我们将探索实现线程会合的另外一个方法。 对于WaitAll，有时可以使用Parallel 类的 Invoke 方法来替代，这个我们将在第 5 部分讨论。（我们也会讨论Task和任务延续（continuations），以及如何使用TaskFactory的ContinueWhenAny作为WaitAny的替代。） 对于其它情况，答案是使用底层的方法来解决所有信号同步问题：见Wait 和 Pulse。 5同步上下文（译者注：这里的同步上下文（synchronization context）并不是指System.Threading.SynchronizationContext类。而是指 CLR 的自动锁机制中的同步域或者说加锁的范围。） 对于手动锁定，另一种实现方案是使用声明方式（declaratively）来锁定。通过从ContextBoundObject类派生并添加Synchronization特性，可以指示 CLR 自动加锁。例如： 12345678910111213141516171819202122232425using System;using System.Threading;using System.Runtime.Remoting.Contexts;[Synchronization]public class AutoLock : ContextBoundObject&#123; public void Demo() &#123; Console.Write (\"Start...\"); Thread.Sleep (1000); // 这里我们无法抢占 Console.WriteLine (\"end\"); // 感谢自动锁 &#125;&#125;public class Test&#123; public static void Main() &#123; AutoLock safeInstance = new AutoLock(); new Thread (safeInstance.Demo).Start(); new Thread (safeInstance.Demo).Start(); safeInstance.Demo(); //并发调用 Demo 3 次 &#125;&#125; 输出结果： 123Start... endStart... endStart... end CLR 确保了同一时刻只有一个线程可以执行 safeInstance中的代码。它通过创建了一个同步对象，并在每次调用safeInstance的方法和属性时进行锁定来实现。锁的作用范围，在这里是指safeInstance对象，被称为同步上下文（synchronization context）。 那么，它是如何工作的呢？一个线索是Synchronization特性的命名空间：System.Runtime.Remoting.Contexts。ContextBoundObject可以被认为是一个“远程（remote）”对象，这意味着所有方法的调用都是会被拦截。为了实现这种拦截，当我们实例化AutoLock时，CLR 自动返回了一个具有相同方法和属性的AutoLock的代理对象，它扮演着中间人角色。自动锁定就是在中间人上进行的。总的来说，这种拦截会在每次方法调用时增加大概 1 微秒的开销。 自动同步不能用于保护静态成员，也不能用于非派生自 ContextBoundObject的类。（例如：Windows Forms 窗体） 锁在内部以相同的方式运作，可以期待下面的例子与之前的有一样的结果： 1234567891011121314151617181920212223[Synchronization]public class AutoLock : ContextBoundObject&#123; public void Demo() &#123; Console.Write (\"Start...\"); Thread.Sleep (1000); Console.WriteLine (\"end\"); &#125; public void Test() &#123; new Thread (Demo).Start(); new Thread (Demo).Start(); new Thread (Demo).Start(); Console.ReadLine(); &#125; public static void Main() &#123; new AutoLock().Test(); &#125;&#125; （注意我们偷偷加了Console.ReadLine语句。）因为这个类的对象在同一时间只有一个线程可以执行代码，三个新线程将阻塞在Demo方法处，直到Test 方法完成，也就是要等待ReadLine完成。因此只有在按了回车键之后，才会得到和之前一样的结果。这种线程安全的重型武器足以阻碍所有类内部的多线程！ 此外，我们仍未解决之前描述的一个问题：如果AutoLock是一个集合类，如果在其它类中执行下面的代码，那么仍然需要加锁： 1if (safeInstance.Count &gt; 0) safeInstance.RemoveAt (0); 除非执行这段代码的类本身也是一个同步的ContextBoundObject！ 同步上下文的作用域可以扩展到超过单一对象的范围。默认情况下，如果一个同步对象在另一个类中被实例化，它们会共享同一个同步上下文（换言之，就是一个巨大的锁！）。这个行为可以通过在Synchronization特性构造方法中使用一个整型标识来改变，可以使用下列SynchronizationAttribute类中定义的常量之一： 常量 作用 NOT_SUPPORTED 相当于不使用Synchronized特性 SUPPORTED 如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则保持非同步状态 REQUIRED（默认值） 如果在另一个同步对象中被实例化，则加入已存在的同步上下文，否则创建新的同步上下文 REQUIRES_NEW 始终创建新的同步上下文 所以如果SynchronizedA在SynchronizedB中被实例化，而SynchronizedB使用下面这种声明的话，它们就有各自的同步上下文： 12[Synchronization (SynchronizationAttribute.REQUIRES_NEW)]public class SynchronizedB : ContextBoundObject &#123; // ... 越大的同步上下文越容易管理，但是并发的可能性就越低。另一方面，分离的同步上下文则容易造成死锁，例如： 1234567891011121314151617181920[Synchronization]public class Deadlock : ContextBoundObject&#123; public Deadlock Other; public void Demo() &#123; Thread.Sleep (1000); Other.Hello(); &#125; void Hello() &#123; Console.WriteLine (\"hello\"); &#125;&#125;public class Test&#123; static void Main() &#123; Deadlock dead1 = new Deadlock(); Deadlock dead2 = new Deadlock(); dead1.Other = dead2; dead2.Other = dead1; new Thread (dead1.Demo).Start(); dead2.Demo(); &#125;&#125; 因为两个Deadlock的实例都是在Test中创建的，而Test是非同步类，所以这两个实例会拥有它自己的同步上下文，因此有它自己的锁。当它们互相调用的时候，用不了多久就会死锁（确切的说是一秒！）。如果Deadlock和 Test是由不同的开发团队写的，这个问题会藏的很深。别指望负责Test的团队能意识到他们犯了什么错，更别指望能知道如何解决了。而对于显式的加锁，死锁的原因通常更容易被发现。 5.1重入（译者注：在单线程场景下，方法没有退出前自身再被调用也是重入，比如显式的递归调用，或者隐式的通过消息队列机制等等，这种重入和作者讨论的多线程场景下的重入并不是完全相同的概念。） 线程安全方法有时也被称为可重入的（reentrant），因为它可能在执行中途被抢占，然后在另外的线程再被调用也不会有问题。在一般意义上，线程安全和可重入是同义词或者是密切相关的。 然而，在自动锁机制下，重入有另一个更危险的潜在问题。如果Synchronization特性的reentrant参数为true： 1[Synchronization(true)] 那么在执行离开上下文时，同步上下文的锁会被临时释放。在之前的例子中，这可以防止死锁的发生，当然是符合我们期望的。但是，一个副作用是，在过渡期间，任何线程都可以自由的调用原对象上的任何方法（重新进入（re-entering）同步上下文），这会导致多线程编程异常复杂，应该极力避免它。这就是可重入的问题。 因为[Synchronization(true)]作用于类上，就导致了类中所有会离开同步上下文的方法调用都会带来可重入的副作用问题。 虽然可重入可能是危险的，但有些时候几乎没有其它选择。例如，在一个同步类内部实现了多线程，方法是通过委托把逻辑交给运行在其它同步上下文中的工作线程。如果没有重入，那么工作线程就可能会导致彼此之间或是原线程的阻塞。 这凸显了自动同步的一个基本缺点：范围过大的锁定作用域将制造出巨大的麻烦：死锁、可重入以及降低并发度。这使得手动锁定在任何场景都显得更为合适，而并不仅仅只在简单的场景下。 原文：http://www.albahari.com/threading/part2.aspx翻译：https://blog.gkarch.com/threading/part2.html","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://luox78.github.io/tags/thread/"}]},{"title":"初识JavaScript03","slug":"JavaScript03","date":"2017-12-31T11:50:33.903Z","updated":"2018-01-02T12:02:22.286Z","comments":true,"path":"2017/12/31/JavaScript03/","link":"","permalink":"https://luox78.github.io/2017/12/31/JavaScript03/","excerpt":"Array对象 js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组 赋值","text":"Array对象 js中的数组相当于C#中的集合，数组，哈希表集合体，是个动态数组 赋值 123456789101112131415//1var arr = new Array(3); arr[0] = 0; arr[1] = 1; arr[2] = 2; alert(arr);//0,1,2 arr[3] = 3;//0,1,2,3 alert(arr); //2 for(var i=0;i&lt;5;i++)&#123; arr[i]=i; &#125; //3 var arr=[1,2,3,\"string\"]; var arr=new Array(1,2,3,\"string\"); Json(键值对)12345var arr=&#123;\"gender\":\"male\",\"name\":\"luox78\",\"age\":18&#125;;for(var key in arr)&#123; alert(key+arr[key]); //取值的另一种方式 arr.key&#125; 原型 相当于C#拓展方法 注意：不能跨script标签使用 123456//简易的邮箱判断String.prototype.checkEmail=function()&#123; return this.indexOf(\"@\")&gt;0?true:false;&#125;;var str=\"111@163.com\";alert(str.checkEmail());//true; DOM DOM document object model 为什么要有dom为了更方便的操作html。DOM就是把Html页面模拟成一个对象，就像XDocument一样，把Xml模拟成了一个对象，提供了操作各个节点的方法，直接调用就可以了。 window，document对象 window代表浏览器整个窗口，alert等操作只能用window操作(window可以省略) document代表整个页面，只能操作页面元素 ，及内置方法 1234window.alert(\"hello\");var n=90;window.alert(window.n);//90document.getElementById('btn').id; 但通过window获取元素时会碰到一个问题，就是元素嵌套必须一层一层访问，如访问form中的buttonwindow.form1.btn.id，此时应该使用document对象简化操作,document.getElementById(&#39;btn&#39;).id document演示1234567//当click时先弹出body area 然后才是html body 涉及事件冒泡document.body.onmousedown=function()&#123; alert(\"body area\");&#125;document.onmousedown=function()&#123; alert(\"html area\");&#125; window常见方法 window.alert(&#39;大家好!&#39;);//弹出警告对话框 window.confirm(&#39;确定要删除吗？&#39;);//确定、取消对话框，返回true或false; 123456789101112&lt;body&gt; &lt;input type=\"button\" id=\"btn3\"/&gt;&lt;/body&gt;&lt;script&gt; document.getElementById(\"btn3\").onclick= function() &#123; if (window.confirm(\"Are you sure to delete?\")) &#123; alert(\"delete success\"); &#125; else &#123; alert(\"delete failed\"); &#125; &#125;&lt;/script&gt; window.navigate(url);//将网页重新导航到url,只支持IE、Opera11.6,建议使用window.location.href=&#39;url&#39;;//支持大多数浏览器 123456window.onload = function() &#123; window.navigate(\"https://luox78.github.io\"); &#125;//基本上都不行window.onload = function () &#123; window.location.href = \"https://luox78.github.io\"; &#125;//推荐使用 window.setInterval(function,delay)每个delay ms执行一次 setTimeout(function,delay)只会执行一次，clearTimeout(setId)是为了清理占用的内存 1234567891011//botton value自增例子&lt;script&gt; var num = parseInt(document.getElementById(\"btn\").value); var setId = setInterval(function () &#123; document.getElementById(\"btn\").value = num++; &#125;, 1); document.getElementById(\"btn\").onclick= function() &#123; clearInterval(setId);//计时器一旦被销毁不能再创建 &#125;&lt;/script&gt; 事件 跟C#中事件，委托差不多 注意点： 事件=函数名，等于给事件赋值不会调用 事件=函数名（），会执行一次函数，这种赋值其实并不正确，事件应该不能等于函数返回值 &lt;body&gt;中 123456&lt;body&gt; &lt;input type=\"button\" id=\"btn\"/&gt; &lt;input type=\"button\" onclick=\"f1();\" /&gt; &lt;input type=\"button\" onclick=f1 /&gt; &lt;input type=\"button\" id=\"btn2\" value=\"change method\"/&gt;&lt;/body&gt; onclick=f1;的意思就是说onclick触发的方法就是f1. onclick=“f1()”的意思就是说onclick触发的方法里调用了f1 &lt;script&gt;中 12345678910111213&lt;script&gt; function f1() &#123; alert(\"f1\"); &#125; function f3() &#123; alert(\"f3\"); &#125; document.getElementById(\"btn\").onclick = f1; document.getElementById(\"btn2\").onclick = function() &#123; document.getElementById(\"btn\").onclick = f3; alert(\"change completed\"); &#125;&lt;/script&gt; body、document对象的事件 window.onload 网页加载完毕时触发，浏览器是一边下载文档、一边解析执行，可能会出现JavaScript执行时需要操作某个元素，这个元素还没有加载，如果这样就要把操作的代码放到body的onload事件中，或者可以把JavaScript放到元素之后。元素的onload事件是元素自己加载完毕时触发，body onload才是全部加载完成 window.控件Id（不建议使用),document.getElementById(“控件Id”);(推荐) onunload（页面卸载后触发） 网页关闭（或者离开）后触发。//刷新页面的时候、关闭选项卡的时候（多个选项卡） onbeforeunload（页面卸载前触发） 在网页准备关闭（或者离开）前触发。//注意浏览器缓存 &lt;bodyonbeforeunload=“return ‘真的要放弃发帖退出吗?’; ”&gt;。显示的文字随浏览器版本而有差异。// =“window.event.returnValue=‘’只兼容IE 除了属性之外，当然还有通用的HTML元素的事件：onclick（单击）、ondblclick（双击）、onkeydown（按键按下）、onkeypress（点击按键）、onkeyup（按键释放）、onmousedown（鼠标按下）、onmousemove（鼠标移动）、onmouseout（鼠标离开元素范围）、onmouseover（鼠标移动到元素范围）、onmouseup（鼠标按键释放）、oncontextmenu（在浏览器中单击鼠标右键显示”右键菜单”时触发）等。 window对象事件,属性 window.location window.location.href=‘’;//重新导航到新页面,可以取值，也可以赋值。 window.location.reload();//刷新当前页 window.event 123456789&lt;script&gt; document.getElementById(\"dv\").onmousedown= function() &#123; if (window.event.shiftKey) &#123; alert(\"you have pressed the shift\"); &#125; else &#123; alert(\"only mouse click\"); &#125; &#125;&lt;/script&gt; clientX、clientY发生事件时鼠标在客户区域的坐标(指显示html区域)； screenX、screenY发生事件时鼠标在屏幕上的坐标； offsetX、offsetY发生事件时鼠标相对于事件源（比如点击按钮时触发onclick）的坐标。当页面中有&lt;!DOCTYPE（文档定义）时，对offsetX和offsetY单击时的解析不同(使用onmousedown的时候与onclick测试结果不同)（单击按钮中文字的时候。） (window.event.returnValue)returnValue属性，如果将returnValue设置为false，就会取消默认事件的处理。在超链接的onclick里面禁止访问href的页面。在表单校验的时候禁止提交表单到服务器，防止错误数据提交给服务器、防止页面刷新。(onsubmit=&quot;window.event.returnValue=false;&quot;) •window.event.returnValue不兼容火狐浏览器 •FireFox:e. preventDefault();取消事件的默认动作。 •直接写return false;IE、FF、Chrome都可以。 window.event.button，发生事件时鼠标按键，IE:1为左键，2为右键，4中滑轮,3左右键同时按下//要测试event.button的值的时候，请在onmousedown事件中测试 ​ window.screen对象，获取屏幕的信息 1234window.onload= function() &#123; alert(screen.width); alert(screen.height); &#125; clipboardData 对象，对粘贴板的操作 onpaste,oncopy事件 12345678910&lt;script&gt; document.body.oncopy = function () &#123; alert(\"forbid copy\"); return false; &#125; document.body.onpaste= function() &#123; alert(\"forbid paste\"); return false; &#125;&lt;/script&gt; window.clipboardData.getData``window.clipboardData.setData已弃用，新的粘贴复制方法下面介绍 ​ js实现各种复制到剪贴板的方法一、实现点击按钮，复制文本框中的的内容 12345678&lt;script type=\"text/javascript\"&gt; function copyUrl2() &#123; var Url2 = document.getElementById(\"biao1\"); Url2.select(); // 选择对象 document.execCommand(\"Copy\"); // 执行浏览器复制命令 alert(\"已复制好，可贴粘。\"); &#125;&lt;/script&gt; 二、点击文本框时，复制文本框里面的内容 123456789&lt;input onclick=\"oCopy(this)\" value=\"你好.要copy的内容!\"&gt;&lt;script language=\"javascript\"&gt; function oCopy(obj) &#123; obj.select(); js = obj.createTextRange(); js.execCommand(\"Copy\") alert(\"复制成功!\"); &#125;&lt;/script&gt; 三、复制文本框或者隐藏域中的内容 12345678910111213141516&lt;script language=\"javascript\"&gt; function CopyUrl(target) &#123; target.value = myimg.value; target.select(); js = myimg.createTextRange(); js.execCommand(\"Copy\"); alert(\"复制成功!\"); &#125; function AddImg(target) &#123; target.value = \"[IMG]\" + myimg.value + \"[/ img]\"; target.select(); js = target.createTextRange(); js.execCommand(\"Copy\"); alert(\"复制成功!\"); &#125;&lt;/script&gt; 四、复制 span 标记中的内容 123456789101112&lt;script type=\"text/javascript\"&gt; function copyText(obj) &#123; var rng = document.body.createTextRange(); rng.moveToElementText(obj); rng.scrollIntoView(); rng.select(); rng.execCommand(\"Copy\"); rng.collapse(false); alert(\"复制成功!\"); &#125;&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"初识JavaScript02","slug":"JavaScript02","date":"2017-12-28T13:39:52.479Z","updated":"2017-12-31T14:26:24.140Z","comments":true,"path":"2017/12/28/JavaScript02/","link":"","permalink":"https://luox78.github.io/2017/12/28/JavaScript02/","excerpt":"js中的事件1 通过调用方法名或在“”内部写2 通过id，使用document.getElementById实现事件","text":"js中的事件1 通过调用方法名或在“”内部写2 通过id，使用document.getElementById实现事件 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;input id=\"btn\" type=\"button\" value=\"show time\" onclick=\"alert(new Date().toLocaleString());\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"show time\" onclick=\"f1();\" /&gt; &lt;input id=\"btn3\" type=\"button\" value=\"show time\" /&gt; &lt;a href=\"http://www.baidu.com\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"#\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"javascript:void(0);\" onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a onclick=\"alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt; &lt;a href=\"javascript:alert(new Date().toLocaleString());\"&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; //alert(new Date().toLocaleString()); function f1() &#123; alert(new Date().toLocaleDateString()); &#125; document.getElementById('btn3').onclick = function f2() &#123; alert(new Date().toLocaleDateString()); &#125; //script 写在上面要加一个窗体以加载事件以防止报错 window.onload = function () &#123; document.getElementById('btn3').onclick = function f2() &#123; alert(new Date().toLocaleDateString()); &#125; &#125;&lt;/script&gt; js调试1 直接在vs中点调试，下断点2 直接在浏览器中调试，按f12-调试 js中的函数1 JavaScript中声明函数的方式：（无需声明返回值类型） 1234567function add(i1, i2) &#123; return i1 + i2; //如果不写return返回的是undefined &#125;int add(int i1,int i2)//C#写法 2 不需要声明返回值类型、参数类型。函数定义以function开头。 1234567var r = add(1, 2);alert(r);r = add(\"你好\", \"tom\");alert(r); 3 JavaScript中不像C#中那样要求所有路径都有返回值，没有返回值就是undefined。 4 易错：自定义函数名不要和js内置、dom内置方法重名，比如selectAll、focus等函数名不要用。//不要与系统函数重名。(在单击事件中调用自己定义的focus方法，有问题。与系统的focus()方法重名了) 注意点1 js方法小写开头 2 js中定义名字的方法没有返回值接受到的是undefined 3 js不支持方法重载，只认最后一个 12345678function add(n1,n2) &#123; return n1 + n2; &#125; function add(n1, n2, n3) &#123; return n1 + n2 + n3; &#125; alert(add(1, 2));//NaN,此时调用的三个参数的add，n3位undefined，导致最后结果为NaN 12345678function add(n1, n2, n3) &#123; return n1 + n2 + n3; &#125; function add(n1, n2) &#123; return n1 + n2; &#125; alert(add(1, 2, 3));//3 通过arguments实现传入多个值123456789function add() &#123; var sum = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum; &#125; alert(add(10, 20, 30));//60 4 return写成return {Name:’yzk’,Age:18};而不要写成： 12345return&#123; Name:’yzk’, Age:18&#125; 原因是js会在语句末尾自动增加”分号”，如果将大括号另起一行，则return语句后自动增加“分号”后，返回值就变成了undefined了。 5 12345var x = 10;function add(n) &#123; n = n + 1; return n &#125;alert(add(x));//4 js搜索的是整个页面的方法，当出现重名的方法，js会使用最后一个（一般是同一个script标签中，涉及加载问题）function add(n) &#123; n = n + 3; return n; &#125;alert(add(x));//4 匿名函数 为了解决方法名冲突（主要是导入文件） 1 写法一 123456//js为动态类型，只有运行时才知道方法有没有返回值，所以f此时代表的是方法 var f = function (n) &#123; return n + 1; &#125; var n = f(10); alert(n);//11 2 写法二 1234//跟第一种一个意思，没有接受方法而已(function(n) &#123; return n + 1; &#125;)(10); 3 写法三 创建一个方法对象，参数传入：方法的参数和方法体，浏览器解析成正常方法所以效率低，不推荐 12var m = new Function(\"m\", \"n\", \"return m+n\");alert(m(10, 20)); js的闭包 定义：在一定函数里面再定义一个函数，•内部函数函数能访问外部函数作用域范围内的变量，这时这个内部函数就叫做闭包。 无论这个内部函数在哪里被调用都能访问的到外部函数作用域中的那些变量。12345678910function f1() &#123; var n = 100; function f2() &#123; alert(n); &#125; return f2(); &#125; var res = f1(); res(); 闭包的目的： ​ * 通过闭包实现访问闭包外方法的局部变量（解决在匿名函数中调用局部变量相关的问题） ​ * 这样使得局部变量一直保存在内存中，模拟面向对象 闭包如何实现的： ​ * 通过作用域链（使用变量先搜索自己作用域里面的数，没有再往上搜索）​ 闭包模拟面向对象 闭包获取数据会长时间占用内存，尽量减少使用js中利用函数可以模拟面向对象123456789101112131415&lt;script&gt; //类名首字母大写以示区分 function Person()&#123; &#125; var per=new Person(); per.name=\"luox78\"; per.age=18; per.say=function ()&#123; alert(\"hello\"); &#125; alert(per.name); per.say();&lt;/script&gt; 123456789&lt;script&gt; function Person(name)&#123; this.name=name; &#125; var per=new Person(\"luo78\"); //访问里面变量的两种方法 alert(per.name); alert(per[\"name\"]);&lt;/script&gt; js里面string的常用方法length 返回字符串长度charAt(index) 返回index位置的字符split(&quot;分隔符&quot;,limit) 多个分隔符使用正则表达式，limit代表返回个数js中数组可以直接显示，中间是逗号隔开1234var str = \"1|2|3|4#6\";alert(str.split(\"|\"));//1,2,3,4//js中split使用正则，且使用直接//转义特殊字符alert(str.split(\\☆|#\\)); substr(startindex,len) 返回截取start位置后len长度的字符串123var str=\"luox78\";alert(str.substr(2));//ox78alert(str.substr(2,2));//ox substring(startindex,stopindex) 返回截取start位置到stop位置的字符串1alert(str.substring(0,3));//luo toUpperCase() toLowerCase() 返回大写，小写match() replace() search() 后面dom部分涉及indexOf(&quot;str&quot;,position) 返回str的索引位置， str指想找的字符串，position指想找的第几个","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"C#中的多线程 - 01基础知识","slug":"CS_Thread01","date":"2017-12-28T12:50:03.698Z","updated":"2017-12-31T12:44:41.774Z","comments":true,"path":"2017/12/28/CS_Thread01/","link":"","permalink":"https://luox78.github.io/2017/12/28/CS_Thread01/","excerpt":"1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子：","text":"1简介及概念C# 支持通过多线程并行执行代码，线程有其独立的执行路径，能够与其它线程同时执行。 一个 C# 客户端程序（Console 命令行、WPF 以及 Windows Forms）开始于一个单线程，这个线程（也称为“主线程”）是由 CLR 和操作系统自动创建的，并且也可以再创建其它线程。以下是一个简单的使用多线程的例子： 所有示例都假定已经引用了以下命名空间： 12using System;using System.Threading; 12345678910111213141516class ThreadTest&#123; static void Main() &#123; Thread t = new Thread (WriteY); // 创建新线程 t.Start(); // 启动新线程，执行WriteY() // 同时，在主线程做其它事情 for (int i = 0; i &lt; 1000; i++) Console.Write (\"x\"); &#125; static void WriteY() &#123; for (int i = 0; i &lt; 1000; i++) Console.Write (\"y\"); &#125;&#125; 输出结果： 1234xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx... 主线程创建了一个新线程t来不断打印字母 “ y “，与此同时，主线程在不停打印字母 “ x “。 线程一旦启动，线程的IsAlive属性值就会为true，直到线程结束。当传递给Thread的构造方法的委托执行完成时，线程就会结束。一旦结束，该线程不能再重新启动。 CLR 为每个线程分配各自独立的栈空间，因此局部变量是独立的。在下面的例子中，我们定义一个拥有局部变量的方法，然后在主线程和新创建的线程中同时执行该方法。 1234567891011static void Main()&#123; new Thread (Go).Start(); // 在新线程执行Go() Go(); // 在主线程执行Go()&#125;static void Go()&#123; // 定义和使用局部变量 - 'cycles' for (int cycles = 0; cycles &lt; 5; cycles++) Console.Write ('?');&#125; 输出结果：?????????? 变量cycles的副本是分别在各自的栈中创建的，因此才会输出 10 个问号。 线程可以通过对同一对象的引用来共享数据。例如： 1234567891011121314151617class ThreadTest&#123; bool done; static void Main() &#123; ThreadTest tt = new ThreadTest(); // 创建一个公共的实例 new Thread (tt.Go).Start(); tt.Go(); &#125; // 注意： Go现在是一个实例方法 void Go() &#123; if (!done) &#123; done = true; Console.WriteLine (\"Done\"); &#125; &#125;&#125; 由于两个线程是调用了同一个的ThreadTest实例上的Go()，它们共享了done字段，因此输出结果是一次 “ Done “，而不是两次。 输出结果：Done 静态字段提供了另一种在线程间共享数据的方式，以下是一个静态的done字段的例子： 123456789101112131415class ThreadTest&#123; static bool done; // 静态字段在所有线程中共享 static void Main() &#123; new Thread (Go).Start(); Go(); &#125; static void Go() &#123; if (!done) &#123; done = true; Console.WriteLine (\"Done\"); &#125; &#125;&#125; 以上两个例子引出了一个关键概念[线程安全（thread safety）]。上述两个例子的输出实际上是不确定的：” Done “ 有可能会被打印两次。如果在Go方法里调换指令的顺序，” Done “ 被打印两次的几率会大幅提高： 1234static void Go()&#123; if (!done) &#123; Console.WriteLine (\"Done\"); done = true; &#125;&#125; 输出结果： 12DoneDone (很可能!) 这个问题是因为一个线程对if中的语句估值的时候，另一个线程正在执行WriteLine语句，这时done还没有被设置为true。 修复这个问题需要在读写公共字段时，获得一个[排它锁（互斥锁，exclusive lock ）]。C# 提供了[lock]来达到这个目的： 12345678910111213141516171819class ThreadSafe&#123; static bool done; static readonly object locker = new object(); static void Main() &#123; new Thread (Go).Start(); Go(); &#125; static void Go() &#123; lock (locker) &#123; if (!done) &#123; Console.WriteLine (\"Done\"); done = true; &#125; &#125; &#125;&#125; 当两个线程同时争夺一个锁的时候（例子中的locker），一个线程等待，或者说[阻塞]，直到锁变为可用。这样就确保了在同一时刻只有一个线程能进入临界区（critical section，不允许并发执行的代码），所以 “ Done “ 只被打印了一次。像这种用来避免在多线程下的不确定性的方式被称为[线程安全（thread-safe）]。 在线程间共享数据是造成多线程复杂、难以定位的错误的主要原因。尽管这通常是必须的，但应该尽可能保持简单。 一个线程被阻塞时，不会消耗 CPU 资源。 1.1Join 和 Sleep可以通过调用Join方法来等待另一个线程结束，例如： 123456789101112static void Main()&#123; Thread t = new Thread (Go); t.Start(); t.Join(); Console.WriteLine (\"Thread t has ended!\");&#125;static void Go()&#123; for (int i = 0; i &lt; 1000; i++) Console.Write (\"y\");&#125; 输出 “ y “ 1,000 次之后，紧接着会输出 “ Thread t has ended! “。当调用Join时可以使用一个超时参数，以毫秒或是TimeSpan形式。如果线程正常结束则返回true，如果超时则返回false。 Thread.Sleep会将当前的线程阻塞一段时间： 12Thread.Sleep (TimeSpan.FromHours (1)); // 阻塞 1小时Thread.Sleep (500); // 阻塞 500 毫秒 当使用Sleep或Join等待时，线程是[阻塞（blocked）]状态，因此不会消耗 CPU 资源。 Thread.Sleep(0)会立即释放当前的时间片，将 CPU 资源出让给其它线程。Framework 4.0 新的Thread.Yield()方法与其相同，除了它只会出让给运行在相同处理器核心上的其它线程。 Sleep(0)和Yield在调整代码性能时偶尔有用，它也是一个很好的诊断工具，可以用于找出[线程安全（thread safety）]的问题。如果在你代码的任意位置插入Thread.Yield()会影响到程序，基本可以确定存在 bug。 1.2线程是如何工作的线程在内部由一个线程调度器（thread scheduler）管理，一般 CLR 会把这个任务交给操作系统完成。线程调度器确保所有活动的线程能够分配到适当的执行时间，并且保证那些处于等待或阻塞状态（例如，等待排它锁或者用户输入）的线程不消耗CPU时间。 在单核计算机上，线程调度器会进行时间切片（time-slicing），快速的在活动线程中切换执行。在 Windows 操作系统上，一个时间片通常在十几毫秒（译者注：默认 15.625ms），远大于 CPU 在线程间进行上下文切换的开销（通常在几微秒区间）。 在多核计算机上，多线程的实现是混合了时间切片和真实的并发，不同的线程同时运行在不同的 CPU 核心上。几乎可以肯定仍然会使用到时间切片，因为操作系统除了要调度其它的应用，还需要调度自身的线程。 线程的执行由于外部因素（比如时间切片）被中断称为被抢占（preempted）。在大多数情况下，线程无法控制其在何时及在什么代码处被抢占。 1.3线程 vs 进程好比多个进程并行在计算机上执行，多个线程是在一个进程中并行执行。进程是完全隔离的，而线程是在一定程度上隔离。一般的，线程与运行在相同程序中的其它线程共享堆内存。这就是线程为何有用的部分原因，一个线程可以在后台获取数据，而另一个线程可以同时显示已获取到的数据。 1.4线程的使用与误用多线程有许多用处，下面是通常的应用场景： 维持用户界面的响应 使用工作线程并行运行时间消耗大的任务，这样主UI线程就仍然可以响应键盘、鼠标的事件。 有效利用 CPU 多线程在一个线程等待其它计算机或硬件设备响应时非常有用。当一个线程在执行任务时被阻塞，其它线程就可以利用这个空闲出来的CPU核心。 并行计算 在多核心或多处理器的计算机上，计算密集型的代码如果通过分治策略（divide-and-conquer，见[第 5 部分]）将工作量分摊到多个线程，就可以提高计算速度。 推测执行（speculative execution） 在多核心的计算机上，有时可以通过推测之后需要被执行的工作，提前执行它们来提高性能。[LINQPad**]就使用了这个技术来加速新查询的创建。另一种方式就是可以多线程并行运行解决相同问题的不同算法，因为预先不知道哪个算法更好，这样做就可以尽早获得结果。 允许同时处理请求 在服务端，客户端请求可能同时到达，因此需要并行处理（如果你使用 ASP.NET、WCF、Web Services 或者 Remoting，.NET Framework 会自动创建线程）。这在客户端同样有用，例如处理 P2P 网络连接，或是处理来自用户的多个请求。 如果使用了 ASP.NET 和 WCF 之类的技术，可能[不会注意到多线程被使用]，除非是访问共享数据时（比如通过静态字段共享数据）。如果没有正确的[加锁]，就[可能产生线程安全问题]。 多线程同样也会带来缺点，最大的问题是它提高了程序的复杂度。使用多个线程本身并不复杂，复杂的是线程间的交互（一般是通过共享数据）。无论线程间的交互是否有意为之，都会带来较长的开发周期，以及带来间歇的、难以重现的 bug。因此，最好保证线程间的交互尽量少，并坚持简单和已被证明的多线程交互设计。这篇文章主要就是关于如何处理这种复杂的问题，如果能够移除线程间交互，那会轻松许多。 一个好的策略是把多线程逻辑使用可重用的类封装，以便于独立的检验和测试。.NET Framework 提供了许多高层的线程构造，之后会讲到。 当频繁地调度和切换线程时（并且如果活动线程数量大于 CPU 核心数），多线程会增加资源和 CPU 的开销，线程的创建和销毁也会增加开销。多线程并不总是能提升程序的运行速度，如果使用不当，反而可能降低速度。 例如，当需要进行大量的磁盘 I/O 时，几个工作线程顺序执行可能会比 10 个线程同时执行要快。（在[使用 Wait 和 Pulse 进行同步]中，将会描述如何实现 [生产者 / 消费者队列]，它提供了上述功能。） 2创建和启动线程像我们在简介中看到的那样，使用Thread类的构造方法来创建线程，通过传递ThreadStart委托来指明线程从哪里开始运行，下面是ThreadStart委托的定义： 1public delegate void ThreadStart(); 调用Start方法后，线程开始执行，直到它所执行的方法返回后，线程终止。下面这个例子使用完整的 C# 语法创建TheadStart委托： 1234567891011121314class ThreadTest&#123; static void Main() &#123; Thread t = new Thread (new ThreadStart (Go)); t.Start(); // 在新线程运行 GO() Go(); // 同时在主线程运行 GO() &#125; static void Go() &#123; Console.WriteLine (\"hello!\"); &#125;&#125; 在这个例子中，线程t执行Go()方法，几乎同时主线程也执行Go()方法，结果将打印两个 hello。 线程也可以使用更简洁的语法创建，使用方法组（method group），让 C# 编译器推断ThreadStart委托类型： 1Thread t = new Thread (Go); // 无需显式使用 ThreadStart 另一个快捷的方式是使用 lambda 表达式或者匿名方法： 12345static void Main()&#123; Thread t = new Thread ( () =&gt; Console.WriteLine (\"Hello!\") ); t.Start();&#125; 2.1向线程传递数据向一个线程的目标方法传递参数最简单的方式是使用 lambda 表达式调用目标方法，在表达式内指定参数: 12345678910static void Main()&#123; Thread t = new Thread ( () =&gt; Print (\"Hello from t!\") ); t.Start();&#125;static void Print (string message)&#123; Console.WriteLine (message);&#125; 使用这种方式，可以向方法传递任意数量的参数。甚至可以将整个实现封装为一个多语句的 lambda 表达式： 12345new Thread (() =&gt;&#123; Console.WriteLine (\"I'm running on another thread!\"); Console.WriteLine (\"This is so easy!\");&#125;).Start(); 在 C# 2.0 中，也可以很容易的使用匿名方法来进行相同的操作： 1234new Thread (delegate()&#123; ...&#125;).Start(); 另一个方法是向Thread的Start方法传递参数： 1234567891011static void Main()&#123; Thread t = new Thread (Print); t.Start (\"Hello from t!\");&#125;static void Print (object messageObj)&#123; string message = (string) messageObj; // 需要强制类型转换 Console.WriteLine (message);&#125; 可以这样是因为Thread的构造方法通过重载来接受两个委托中的任意一个： 12public delegate void ThreadStart();public delegate void ParameterizedThreadStart (object obj); ParameterizedThreadStart的限制是它只接受一个参数。并且由于它是object类型，通常需要类型转换。 Lambda 表达式与被捕获变量如我们所见，lambda 表达式是向线程传递数据的最强大的方法。然而必须小心，不要在启动线程之后误修改被捕获变量（captured variables）。例如，考虑下面的例子： 12for (int i = 0; i &lt; 10; i++) new Thread (() =&gt; Console.Write (i)).Start(); 输出结果是不确定的！可能是这样0223557799。 问题在于变量i在整个循环中指向相同的内存地址。所以，每一个线程在调用Console.Write时，都在使用这个值在运行时会被改变的变量！ 类似的问题在[C# 4.0 in a Nutshell**]的第 8 章的 “Captured Variables” 有描述。这个问题与多线程没什么关系，而是和 C# 的捕获变量的规则有关（在for和foreach的场景下有时不是很理想）。 解决方法就是使用临时变量，如下所示： 12345for (int i = 0; i &lt; 10; i++)&#123; int temp = i; new Thread (() =&gt; Console.Write (temp)).Start();&#125; 变量temp对于每一个循环迭代是局部的。所以，每一个线程会捕获一个不同的内存地址，从而不会产生问题。我们可以使用更为简单的代码来演示前面的问题： 12345678string text = \"t1\";Thread t1 = new Thread ( () =&gt; Console.WriteLine (text) );text = \"t2\";Thread t2 = new Thread ( () =&gt; Console.WriteLine (text) );t1.Start();t2.Start(); 因为两个lambda表达式捕获了相同的text变量，t2会被打印两次： 12t2t2 2.2线程命名每一个线程都有一个 Name 属性，我们可以设置它以便于调试。这在 Visual Studio 中非常有用，因为线程的名字会显示在线程窗口（Threads Window）与调试位置（Debug Location）工具栏上。线程的名字只能设置一次，以后尝试修改会抛出异常。 静态的Thread.CurrentThread属性会返回当前执行的线程。在下面的例子中，我们设置主线程的名字： 12345678910111213141516class ThreadNaming&#123; static void Main() &#123; Thread.CurrentThread.Name = \"main\"; Thread worker = new Thread (Go); worker.Name = \"worker\"; worker.Start(); Go(); &#125; static void Go() &#123; Console.WriteLine (\"Hello from \" + Thread.CurrentThread.Name); &#125;&#125; 2.3前台与后台线程默认情况下，显式创建的线程都是前台线程（foreground threads）。只要有一个前台线程在运行，程序就可以保持存活，而后台线程（background threads）并不能保持程序存活。当一个程序中所有前台线程停止运行时，仍在运行的所有后台线程会被强制终止。 线程的前台/后台状态与它的优先级和执行时间的分配无关。 可以通过线程的IsBackground属性来查询或修改线程的前后台状态。如下面的例子： 123456789class PriorityTest&#123; static void Main (string[] args) &#123; Thread worker = new Thread ( () =&gt; Console.ReadLine() ); if (args.Length &gt; 0) worker.IsBackground = true; worker.Start(); &#125;&#125; 如果这个程序以无参数的形式运行，工作线程会默认为前台，并在ReadLine时等待用户输入回车。此时主线程退出，但是程序仍然在运行，因为有一个前台线程依然存活。 相反，如果给Main()传递了参数，工作线程设置为后台状态，当主线程结束时，程序几乎立即退出（终止ReadLine需要一咪咪时间）。 当进程以这种方式结束时，后台线程执行栈中所有finally块就会被避开。如果程序依赖finally（或是using）块来执行清理工作，例如释放资源或是删除临时文件，就可能会产生问题。为了避免这种问题，在退出程序时可以显式的等待这些后台线程结束。有两种方法可以实现： 如果是自己创建的线程，在线程上调用[Join](方法。 如果是使用[线程池线程]，使用[事件等待句柄]。 在任一种情况下，都应指定一个超时时间，从而可以放弃由于某种原因而无法正常结束的线程。这是后备的退出策略：我们希望程序最后可以关闭，而不是让用户去开任务管理器(╯-_-)╯╧══╧ 如果用户使用任务管理器强行终止了 .NET 进程，所有线程都会被当作后台线程一般丢弃。这是通过观察得出的结论，并不是通过文档，而且可能会因为 CLR 和操作系统的版本不同而有不同的行为。 前台线程不需要这种处理，但是必须小心避免会使线程无法结束的 bug。程序无法正常退出的一个很有可能的原因就是仍有前台线程存在。 2.4线程优先级线程的Priority属性决定了相对于操作系统中的其它活动线程，它可以获得多少执行时间。线程优先级的取值如下： 1enum ThreadPriority &#123; Lowest, BelowNormal, Normal, AboveNormal, Highest &#125; 只有当多个线程同时活动时，线程优先级才有意义。 在提升线程优先级前请三思，这可能会导致其它线程的资源饥饿（resource starvation，译者注：指没有分配到足够的CPU时间来运行）等问题。 提升线程的优先级是无法使其能够处理实时任务的，因为它还受到程序进程优先级的影响。要进行实时任务，必须同时使用System.Diagnostics中的Process类来提升进程的优先级（记得这不是我告诉你的）： 12using (Process p = Process.GetCurrentProcess()) p.PriorityClass = ProcessPriorityClass.High; ProcessPriorityClass.High实际上就是一个略低于最高优先级Realtime的级别。将一个进程的优先级设置为Realtime是通知操作系统，我们绝不希望该进程将 CPU 时间出让给其它进程。如果你的程序误入一个无限循环，会发现甚至是操作系统也被锁住了，就只好去按电源按钮了o(&gt;_&lt;)o 正是由于这一原因，High 通常是实时程序的最好选择。 如果实时程序拥有用户界面，提升进程的优先级会导致大量的 CPU 时间被用于屏幕更新，这会降低整台机器的速度（特别是当 UI 很复杂时）。降低主线程的优先级，并提升进程的优先级可以保证需要进行实时任务的工作线程不会被屏幕重绘所抢占。但是这依然没有解决其它程序的CPU时间饥饿的问题，因为操作系统依然为这个进程分配了大量 CPU 资源。 理想的解决方案是分离 UI 线程和实时工作线程，使用两个进程分别运行。这样就可以分别设置各自的进程优先级，彼此之间通过 Remoting 或是内存映射文件进行通信。内存映射文件十分适用于这一任务，在C# 4.0 in a Nutshell**的第 14 和 25 章会讲到。 即使是提升了进程优先级，托管环境在处理强实时需求时仍然有限制。除了自动垃圾回收带来的延迟，操作系统也不能够完全满足实时任务的需要，即便是非托管的程序也是如此。最好的解决办法还是使用独立的硬件或者专门的实时平台。 2.5异常处理当线程开始运行后，其创建代码所在的try / catch / finally块与该线程不再有任何关系。考虑下面的程序： 1234567891011121314public static void Main()&#123; try &#123; new Thread (Go).Start(); &#125; catch (Exception ex) &#123; // 永远执行不到这里 Console.WriteLine (\"Exception!\"); &#125;&#125;static void Go() &#123; throw null; &#125; // 产生 NullReferenceException 异常 这个例子中的try / catch语句是无效的，而新创建的线程将会遇到一个未处理的NullReferenceException。因为主线程直接跳过catch。 修改方法是将异常处理移到Go方法中： 12345678910111213141516171819public static void Main()&#123; new Thread (Go).Start();&#125;static void Go()&#123; try &#123; // ... throw null; // 异常会在下面被捕获 // ... &#125; catch (Exception ex) &#123; // 一般会记录异常， 和/或通知其它线程我们遇到问题了 // ... &#125;&#125; 在生产环境的程序中，所有线程的入口方法处都应该有一个异常处理器，就如同在主线程所做的那样（一般可能是在执行栈上靠近入口的地方）。未处理的异常会使得整个程序停止运行，弹出一个难看的对话框。 在写异常处理块的时候，最好不要忽略错误。一般应该记录异常详细信息，然后可以弹出一个对话框让用户可以选择是否自动把这些信息提交到你的服务器。最后应该关闭程序，因为很可能错误已经破坏的程序的状态。然而这么做会导致用户丢失当前的工作，比如打开的文档。 WPF 和 Windows Forms 应用中的“全局”异常处理事件（Application.DispatcherUnhandledException和Application.ThreadException）只会在主UI线程有未处理的异常时触发。对于工作线程上的异常仍然需要手动处理。 AppDomain.CurrentDomain.UnhandledException会对所有未处理的异常触发，但是它不提供阻止程序退出的办法。 然而在某些情况下，可以不必处理工作线程上的异常，因为 .NET Framework 会为你处理。这些会在接下来的内容中讲到： [异步委托] [BackgroundWorker] [任务并行库（TPL）] 3线程池 当启动一个线程时，会有几百毫秒的时间花费在准备一些额外的资源上，例如一个新的私有局部变量栈这样的事情。每个线程会占用（默认情况下）1MB 内存。线程池（thread pool）可以通过共享与回收线程来减轻这些开销，允许多线程应用在很小的粒度上而没有性能损失。在多核心处理器以分治（divide-and-conquer）的风格执行计算密集代码时将会十分有用。 线程池会限制其同时运行的工作线程总数。太多的活动线程会加重操作系统的管理负担，也会降低 CPU 缓存的效果。一旦达到数量限制，任务就会进行排队，等待一个任务完成后才会启动另一个。这使得程序任意并发成为可能，例如 web 服务器。（异步方法模式（asynchronous method pattern）是进一步高效利用线程池的高级技术，我们在C# 4.0 in a Nutshell**的 23 章来讲）。 有多种方法可以使用线程池： 通过[任务并行库（TPL）]（Framework 4.0 中加入） 调用[ThreadPool.QueueUserWorkItem] 通过[异步委托] 通过[BackgroundWorker] 以下构造会间接使用线程池： WCF、Remoting、ASP.NET 和 ASMX 网络服务应用 [System.Timers.Timer]和 [System.Threading.Timer] .NET Framework 中名字以 Async 结尾的方法，例如WebClient上的方法（使用[基于事件的异步模式，EAP]），和大部分BeginXXX方法（异步编程模型模式，APM） PLINQ 任务并行库（Task Parallel Library，TPL）与 PLINQ 足够强大并面向高层，即使使用线程池并不重要，也应该使用它们来辅助多线程。我们会在[第 5 部分]中进行更详细的讨论。现在，简单看一下如何使用[Task]类作为在线程池线程上运行委托的简单方法。 在使用线程池线程时有几点需要小心： 无法设置线程池线程的Name属性，这会令调试更为困难（当然，调试时也可以在 Visual Studio 的线程窗口中给线程附加备注）。 线程池线程永远是[后台线程]（一般不是问题）。 [阻塞]线程池线程可能会在程序早期带来额外的延迟，除非调用了ThreadPool.SetMinThreads（见[优化线程池]）。 可以改变线程池线程的[优先级]，当它用完后返回线程池时会被恢复到默认状态。 可以通过Thread.CurrentThread.IsThreadPoolThread属性来查询当前是否运行在线程池线程上。 3.1通过 TPL 使用线程池可以很容易的使用任务并行库（Task Parallel Library，TPL）中的[Task]类来使用线程池。 Task类在 Framework 4.0 时被加入：如果你熟悉旧式的构造，可以将非泛型的Task类看作[ThreadPool.QueueUserWorkItem]的替代，而泛型的Task&lt;TResult&gt;看作[异步委托]的替代。比起旧式的构造，新式的构造会更快速，更方便，并且更灵活。 要使用非泛型的Task类，调用Task.Factory.StartNew，并传递目标方法的委托： 123456789static void Main() // Task 类在 System.Threading.Tasks 命名空间中&#123; Task.Factory.StartNew (Go);&#125;static void Go()&#123; Console.WriteLine (\"Hello from the thread pool!\");&#125; Task.Factory.StartNew返回一个Task对象，可以用来监视任务，例如通过调用Wait)方法来等待其结束。 当调用Task的[Wait方法]时，所有未处理的异常会在宿主线程被重新抛出。（如果不调用Wait而是丢弃不管，未处理的异常会[像普通的线程那样]结束程序。（译者注：在 .NET 4.5 中，为了支持基于async / await的异步模式，Task中这种“未观察”的异常默认会被忽略，而不会导致程序结束。 泛型的Task&lt;TResult&gt;类是非泛型Task的子类。它可以使你在其完成执行后得到一个返回值。在下面的例子中，我们使用Task&lt;TResult&gt;来下载一个网页： 12345678910111213141516171819static void Main()&#123; // 启动 task： Task&lt;string&gt; task = Task.Factory.StartNew&lt;string&gt; ( () =&gt; DownloadString (\"http://www.gkarch.com\") ); // 执行其它工作，它会和 task 并行执行： RunSomeOtherMethod(); // 通过 Result 属性获取返回值： // 如果仍在执行中, 当前进程会阻塞等待直到 task 结束： string result = task.Result;&#125;static string DownloadString (string uri)&#123; using (var wc = new System.Net.WebClient()) return wc.DownloadString (uri);&#125; （这里的&lt;string&gt; 类型参数是为了示例的清晰，它可以被省略，让编译器推断。） 查询task的Result属性时，未处理的异常会被封装在[AggregateException]中自动重新抛出。然而，如果没有查询Result属性（并且也没有调用Wait），未处理的异常会令程序结束。 TPL 具有更多的特性，非常适合于利用多核处理器。关于 TPL 的讨论我们在[第 5 部分]中继续。 3.2不通过 TPL 使用线程池如果是使用 .NET Framework 4.0 以前的版本，则不能使用任务并行库。你必须通过一种旧的构造使用线程池：ThreadPool.QueueUserWorkItem与异步委托。这两者之间的不同在于异步委托可以让你从线程中返回数据，同时异步委托还可以将异常封送回调用方。 QueueUserWorkItem要使用QueueUserWorkItem，仅需要使用希望在线程池线程上运行的委托来调用该方法： 1234567891011static void Main()&#123; ThreadPool.QueueUserWorkItem (Go); ThreadPool.QueueUserWorkItem (Go, 123); Console.ReadLine();&#125;static void Go (object data) // 第一次调用时 data 为 null&#123; Console.WriteLine (\"Hello from the thread pool! \" + data);&#125; 输出结果： 12Hello from the thread pool!Hello from the thread pool! 123 目标方法Go，必须接受单一一个object参数（来满足WaitCallback委托）。这提供了一种向方法传递数据的便捷方式，就像ParameterizedThreadStart一样。与Task不同，QueueUserWorkItem并不会返回一个对象来帮助我们在后续管理其执行。并且，你必须在目标代码中显式处理异常，未处理的异常会[令程序结束] 异步委托ThreadPool.QueueUserWorkItem并没有提供在线程执行结束之后从线程中返回值的简单机制。异步委托调用（asynchronous delegate invocations ）解决了这一问题，可以允许双向传递任意数量的参数。而且，异步委托上的未处理异常可以方便的原线程上重新抛出（更确切的说，在调用EndInvoke的线程上），所以它们不需要显式处理。 不要混淆异步委托和异步方法（asynchronous methods ，以 Begin 或 End 开始的方法，比如File.BeginRead/File.EndRead）。异步方法表面上看使用了相似的方式，但是其实是为了解决更困难的问题。我们在C# 4.0 in a Nutshell**的第 23 章中描述。 下面是如何通过异步委托启动一个工作线程： 创建目标方法的委托（通常是一个Func类型的委托）。 在该委托上调用BeginInvoke，保存其IAsyncResult类型的返回值。 BeginInvokde会立即返回。当线程池线程正在工作时，你可以执行其它的动作。 当需要结果时，在委托上调用EndInvoke，传递所保存的IAsyncResult对象。 接下来的例子中，我们使用异步委托调用来和主线程中并行运行一个返回字行串长度的简单方法： 123456789101112static void Main()&#123; Func&lt;string, int&gt; method = Work; IAsyncResult cookie = method.BeginInvoke (\"test\", null, null); // // 这里可以并行执行其它任务 // int result = method.EndInvoke (cookie); Console.WriteLine (\"String length is: \" + result);&#125;static int Work (string s) &#123; return s.Length; &#125; EndInvoke会做三件事： 如果异步委托还没有结束，它会等待异步委托完成执行。 它会接收返回值（也包括ref和out方式的参数）。 它会向调用线程抛出未处理的异常。 如果使用异步委托调用的方法没有返回值，技术上你仍然需要调用EndInvoke。在实践中，这里存在争论，因为不调用EndInvoke也不会有什么损失。然而如果你选择不调用它，就需要考虑目标方法中的异常处理来避免错误无法察觉。 （译者注：MSDN文档**中明确写了 “无论您使用何种方法，都要调用 EndInvoke 来完成异步调用。”，所以最好不要偷懒。） 当调用BeginInvoke时也可以指定一个回调委托。这是一个在完成时会被自动调用的、接受IAsyncResult对象的方法。这样可以在后面的代码中“忘记”异步委托，但是需要在回调方法里做点其它工作： 12345678910111213141516static void Main()&#123; Func&lt;string, int&gt; method = Work; method.BeginInvoke (\"test\", Done, method); // ... //&#125;static int Work (string s) &#123; return s.Length; &#125;static void Done (IAsyncResult cookie)&#123; var target = (Func&lt;string, int&gt;) cookie.AsyncState; int result = target.EndInvoke (cookie); Console.WriteLine (\"String length is: \" + result);&#125; BeginInvoke的最后一个参数是一个用户状态对象，用于设置IAsyncResult的AsyncState属性。它可以是需要的任何东西，在这个例子中，我们用它向回调方法传递method委托，这样才能够在它上面调用EndInvoke。 3.3优化线程池线程池初始时其池内只有一个线程。随着任务的分配，线程池管理器就会向池内“注入”新线程来满足工作负荷的需要，直到最大数量的限制。在足够的非活动时间之后，线程池管理器在认为“回收”一些线程能够带来更好的吞吐量时进行线程回收。 可以通过调用ThreadPool.SetMaxThreads方法来设置线程池可以创建的线程上限；默认如下： Framework 4.0，32位环境下：1023 Framework 4.0，64位环境下：32768 Framework 3.5：每个核心 250 Framework 2.0：每个核心 25 （这些数字可能根据硬件和操作系统不同而有差异。）数量这么多是因为要确定[阻塞]（等待一些条件，比如远程计算机的相应）的线程的条件是否被满足。 也可以通过ThreadPool.SetMinThreads设置线程数量下限。下限的作用比较奇妙：它是一种高级的优化技术，用来指示线程池管理器在达到下限之前不要延迟线程的分配。当存在[阻塞]线程时，提高下限可以改善程序并发性。 默认下限数量是 CPU 核心数，也就是能充分利用 CPU 的最小数值。在服务器环境下（比如 IIS 中的 ASP.NET），下限数量一般要高的多，差不多 50 或者更高。 最小线程数量是如何起作用的？ 将线程池的最小线程数设置为 x 并不是立即创建至少 x 个线程，而是线程会根据需要来创建。这个数值是指示线程池管理器当需要的时候，立即 创建 x 个线程。那么问题是为什么线程池在其它情况下会延迟创建线程？ 答案是为了防止短生命周期的任务导致线程数量短暂高峰，使程序的内存足迹（memory footprint）快速膨胀。为了描述这个问题，考虑在一个 4 核的计算机上运行一个客户端程序，它一次发起了 40 个任务请求。如果每个任务都是一个 10ms 的计算，假设它们平均分配在 4 个核心上，总共的开销就是 100ms 多。理想情况下，我们希望这 40 个任务运行在 4 个线程上： 如果线程数量更少，就无法充分利用 4 个核心。 如果线程数量更多，会浪费内存和 CPU 时间去创建不必要的线程。 线程池就是以这种方式工作的。让线程数量和 CPU 核心数量匹配，就能够既保持小的内存足迹，又不损失性能。当然这也需要线程都能被充分使用（在这个例子中满足该条件）。 但是，现在来假设任务不是进行 10ms 的计算，而是请求互联网，使用半秒钟等待响应，此时本地 CPU 是空闲状态。线程池管理器的线程经济策略（译者注：指上面说的线程数量匹配核心数）这时就不灵了，应该创建更多的线程，让所有的请求同时进行。 幸运的是，线程池管理器还有一个后备方案。如果在半秒内没有能够响应请求队列，就会再创建一个新的线程，以此类推，直到线程数量上限。 半秒的等待时间是一把双刃剑。一方面它意味着一次性的短暂任务不会使程序快速消耗不必要的40MB（或者更多）的内存。另一方面，在线程池线程被阻塞时，比如在请求数据库或者调用WebClient.DownloadFile，就进行不必要的等待。因为这种原因，你可以通过调用SetMinThreads来让线程池管理器在分配最初的 x 个线程时不要等待，例如： 1ThreadPool.SetMinThreads (50, 50); （第二个参数是表示多少个线程分配给 I/O 完成端口（I/O completion ports，IOCP），来被APM使用，这会在C# 4.0 in a Nutshell** 的第 23 章描述。） 最小线程数量的默认值是 CPU 核心数。 总结：面对长时间等待的线程，因为这些线程只占时间，并不需要cpu计算，所以线程池管理器之前的平分策略就出现了问题，由此引入半秒等待机制，一旦此线程运行时间超过半秒就直接开启新的线程给新任务。但半秒等待机制还是存在利弊，利是防止很多线程的同时开启一下子占用大量内存，弊是必须等待半秒线程管理器才会开启新线程导致时间浪费，此时设置最小线程数量显得尤为重要，可以有效的防止等待，也不会占用很多内存（根据你自己的设置）","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://luox78.github.io/tags/thread/"}]},{"title":"初识JavaScript01","slug":"JavaScript01","date":"2017-12-27T12:55:09.751Z","updated":"2018-01-01T11:38:56.825Z","comments":true,"path":"2017/12/27/JavaScript01/","link":"","permalink":"https://luox78.github.io/2017/12/27/JavaScript01/","excerpt":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt;","text":"js作用域123456789101112&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; &#125; //js没有块级作用域 alert(i); //10 function f1(parameters) &#123; var n = 1; &#125; //因为页面一开始加载并不会执行f1方法 //alert(n); undefined&lt;/script&gt; 默认如果直接在script标签中定义变量，则属于“全局作用域范围”(全局执行环境)，即属于window对象。1 . 全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源2 . 一个页面中的多个script标签中的变量可以互相访问。3 . JS有垃圾回收机制，会定时对可释放资源的变量回收。将变量设置为null则表示可以被回收了。 123456789&lt;script&gt; function name(parameters) &#123; var i = 0; i++; alert(i); &#125; //方法无返回值，会返回undefined alert(name());&lt;/script&gt; 1234567&lt;script&gt; var i = 1;&lt;/script&gt;&lt;script&gt; //全局作用域范围的变量直到网页关闭或浏览器关闭时才释放资源 alert(i);//1&lt;/script&gt; 方法内部不使用var定义的变量相当于全局变量1234567891011&lt;script&gt; function f1(parameters) &#123; i = 100; //var i = 100; &#125;&lt;/script&gt;&lt;script&gt; f1(); alert(i);//100 //alert(i);使用未定义&lt;/script&gt; switchjs中switch中的判断是严格判断就是全等于（===）123456789101112&lt;script&gt; var i = 90; switch (i) &#123; case 90: alert(\"number\"); break; case \"90\": alert(\"string\"); break; default: &#125;&lt;/script&gt; js类型转换注意点： 1 Number（）将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN 2 String（）转换不成功返回undefined， toString（）报错 3 Boolean（）转换当为0或为空（值为空或者null）时返回false，其余返回true1234567891011121314151617181920&lt;script&gt; alert(parseInt(\"90\")); //90 alert(parseInt(\"90aaaaaaaaaa\")); //90 alert(parseInt(\"aaaaaa\")); //NaN alert(parseInt(111, 2)); //代表给定一个二进制的数111输出十进制 alert(parseFloat(10.111)); //10.111 alert(Number(\"40addd\")); //将任意值转换成数字 如果该字符串不能完全转换为整型，则返回NaN //alert(isNaN(\"aaa\")); //true var str; alert(String(str)); //undefined alert(str.toString()); //报错 //boolean var b1 = Boolean(\"\"); //false - 空字符串 var b2 = Boolean(\"hello\"); //true - 非空字符串 var b1 = Boolean(50); //true - 非零数字 var b1 = Boolean(null); //false – null var b1 = Boolean(0); //false - 零 var b1 = Boolean(new object()); //true - 对象 &lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://luox78.github.io/categories/JavaScript/"}],"tags":[{"name":"jsfoundation","slug":"jsfoundation","permalink":"https://luox78.github.io/tags/jsfoundation/"}]},{"title":"LINQ","slug":"Ten_LINQ_Myth","date":"2017-12-26T14:34:53.555Z","updated":"2018-01-01T11:38:28.505Z","comments":true,"path":"2017/12/26/Ten_LINQ_Myth/","link":"","permalink":"https://luox78.github.io/2017/12/26/Ten_LINQ_Myth/","excerpt":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3);","text":"1 All LINQ queries must start with the ‘var’ keyword. In fact, the very purpose of the ‘var’ keyword is to start a LINQ query!123456string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); //is precisely equivalent to:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;IEnumerable&lt;string&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; 3); 2 All LINQ queries must use query syntax. lambda syntax query syntax 12345678//Here's an example of lambda syntax:string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = people.Where (p =&gt; p.Length &gt; 3); Here's the same thing expressed in query syntax://string[] people = new [] &#123; \"Tom\", \"Dick\", \"Harry\" &#125;;var filteredPeople = from p in people where p.Length &gt; 3 select p; 3 To retrieve all customers from the customer table, you must perform a query similar to the following:12345678910111213141516171819The expression:from c in db.Customers select c is a frivolous query! You can simply go:db.CustomersSimilarly, the following LINQ to XML query:var xe = from e in myXDocument.Descendants (\"phone\") select e;can be simplified to:var xe = myXDocument.Descendants (\"phone\");And this:Customer customer = (from c in db.Customers where c.ID == 123 select c) .Single();can be simplified to:Customer customer = db.Customers.Single (c =&gt; c.ID == 123); 4 A LINQ to SQL or EF query will be executed in one round-trip only if the query was built in a single step.LINQ follows a lazy evaluation model, which means queries execute not when constructed, but when enumerated. This means you can build up a query in as many steps as you like, and it won’t actually hit the server until you eventually start consuming the results. For instance, the following query retrieves the names of all customers whose name starts with the letter ‘A’, and who have made at least two purchases. We build this query in three steps:123456var query = db.Customers.Where (c =&gt; c.Name.StartsWith (\"A\"));query = query.Where (c =&gt; c.Purchases.Count() &gt;= 2);var result = query.Select (c =&gt; c.Name);foreach (string name in result) // Only now is the query executed! Console.WriteLine (name); 5 Because SQL emits flat result sets, LINQ queries must be structured to emit flat result sets, too.For example, if you want to retrieve the names of customers in the state of WA along with all their purchases, you can simply do the following:1234567from c in db.Customerswhere c.State == \"WA\"select new&#123; c.Name, c.Purchases // An EntitySet (collection)&#125; The hierarchical result from this query is much easier to work with than a flat result set! We can achieve the same result without association properties as follows:1234567from c in db.Customerswhere c.State == \"WA\"select new&#123; c.Name, Purchases = db.Purchases.Where (p =&gt; p.CustomerID == c.ID)&#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"LINQ","slug":"LINQ","permalink":"https://luox78.github.io/tags/LINQ/"}]},{"title":"C#6 特性","slug":"CS6","date":"2017-12-26T12:27:56.003Z","updated":"2018-01-01T11:37:40.958Z","comments":true,"path":"2017/12/26/CS6/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS6/","excerpt":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符","text":"字符串拼接12var Name = &quot;Jack&quot;; var results = $&quot;Hello &#123;Name&#125;&quot;; ## 空操作符 空操作符 ( ?. )123456if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0) &#123; Console.WriteLine(user.Project.Tasks.First().Name); &#125; //现在Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 注意： 上面的代码虽然可以让我们少些很多代码，而且也减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常，那么使用这个特性反而隐藏了Bug NameOf利用nameof减少手写带来的错误 12345Person p;if(p == null)&#123; throw new Exception(\"nameof(Person)\"); &#125; 表达式方法体1private static string SayHello() =&gt; \"Hello World\"; 自动属性初始化器1234567891011121314151617181920//以前public class Person &#123; public int Age &#123; get; set; &#125; public Person() &#123; Age = 100; &#125; &#125; //现在public class Person &#123; public int Age &#123; get; private set; &#125; &#125; //同时增加了只读属性初始化public class Person &#123; public int Age &#123; get; &#125; = 100; &#125; Index 初始化器1234567var names = new Dictionary&lt;int, string&gt; &#123; [1] = \"Jack\", [2] = \"Alex\", [3] = \"Eric\", [4] = \"Jo\" &#125;; using 静态类的方法可以使用 static using123456789101112using System; using static System.Math; namespace CSharp6NewFeatures &#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(Log10(5)+PI); &#125; &#125; &#125;","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"C#7 特性","slug":"CS7","date":"2017-12-25T16:01:58.230Z","updated":"2017-12-27T15:15:16.885Z","comments":true,"path":"2017/12/26/CS7/","link":"","permalink":"https://luox78.github.io/2017/12/26/CS7/","excerpt":"本地方法（Local functions）有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 （local function）： 123456789101112public int Fibonacci(int x) &#123; if (x &lt; 0) throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x)); return Fib(x).current; (int current, int previous) Fib(int i) &#123; if (i == 0) return (1, 0); var (p, pp) = Fib(i - 1); return (p + pp, p); &#125; &#125;","text":"本地方法（Local functions）有时一个辅助函数只在某个使用到它的函数中有用。现在你可以在其他函数体内将这类函数定义为 （local function）： 123456789101112public int Fibonacci(int x) &#123; if (x &lt; 0) throw new ArgumentException(&quot;Less negativity please!&quot;, nameof(x)); return Fib(x).current; (int current, int previous) Fib(int i) &#123; if (i == 0) return (1, 0); var (p, pp) = Fib(i - 1); return (p + pp, p); &#125; &#125; 元组（Tuples）我们经常希望能从一个方法中返回一个以上的结果。旧版本的 C#中的选项远远达不到令人满意的程度： Out 参数： 使用起来很笨拙（哪怕你使用了上面所述的改进），并且无法在 async 方法中使用。 System.Tuple&lt;…&gt; 返回类型： 用起来很啰嗦，并且需要分配一个元组对象。 自定义每个方法的传输类型： 需要用一大堆代码来实现一个类，而目的仅仅是临时打包几个变量。 通过动态类型返回匿名类： 性能有瓶颈，且没有静态类型检查。 为了在这方面做得更好，C# 7.0 加入了元组类型（tuple types）和元组字面量（tupleliterals）： 12345(string, string, string) LookupName(long id) // 元组返回类型 &#123; // 从数据储存中取出第一个、中间和最后一个数据 return (first, middle, last); // 元组字面量 &#125; 这种方法现在会很有效率地返回三个字符串，包装成一个元组值中的元素。 方法的调用者将会收到一个元组，并可以分别访问各个元素： 123var names = LookupName(id); WriteLine($&quot;found &#123;names.Item1&#125;&#123;names.Item3&#125;.&quot;); Item1等是元组元素的默认名称，并且总是可用的。但是这样描述性不是非常好，因此你可以选择性地使用另一种更好的方法： 123456(string first, string middle, string last)LookupName(long id) // 元组元素拥有了名称 //现在元组的接收者可以使用更具描述性的名字了： var names = LookupName(id); WriteLine($&quot;found &#123;names.first&#125;&#123;names.last&#125;.&quot;); //你也可以直接在元组字面量中指定元素名称： return (first: first, middle: middle,last: last); // 在字面量中命名元组元素 通常来说你可以无视名字而将元组类型互相转换：只要每个元素之间是可转换的（assignable），元组类型即可自由地互相转换。 元组是值类型，它们的元素是简单的公共、可修改的字段。它们具有值相等性，意味着如果两个元组间每个元素两两相等（且拥有相同的哈希值）则两个元组相等（且拥有相同的哈希值）。 这使得元组在多返回值之外的许多场景也很有用。例如，如果你需要一个拥有多个键的字典，使用一个元组作为你的键，一切都会正常运行。如果你需要一个每个位置有多个值的列表，使用元组吧，诸如搜索列表这样的功能将会正确的工作。","categories":[{"name":"C#","slug":"C","permalink":"https://luox78.github.io/categories/C/"}],"tags":[{"name":"C#特性","slug":"C-特性","permalink":"https://luox78.github.io/tags/C-特性/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-25T13:51:57.623Z","updated":"2017-12-27T15:14:33.446Z","comments":true,"path":"2017/12/25/hello-world/","link":"","permalink":"https://luox78.github.io/2017/12/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}